<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客内容归档和英文博客</title>
    <url>/202111/%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E5%BD%92%E6%A1%A3%E5%92%8C%E8%8B%B1%E6%96%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<div class="note info">
    从2019年开始尝试搭建自己的博客，到现在已经本科毕业。这三年的时间虽然没有坚持更新博客，但是一直在坚持记录。无论是理论知识的学习、Debug的记录，还是读书健身笔记和感慨万千时的随笔，他们都散落在各种在线笔记软件和手机的备忘录中。<br />
    随着时间的推移，我对博客的认识也发生了很多变化。“记录”对我来说仍然具有非常大的意义，但是“博客”最重要的价值不应该是“记录”，而是“分享”——传递有价值的信息。我把平时的日常生活和学习经历记录在各种笔记中，过一段时间再去回顾和整理，选取其中有价值的东西去分享。<br />
    过去的一年再次参加了美赛，加入了几个和区块链有关的项目，也完成了不少专利和论文。更多的时间忙于运用知识，以需求为导向迫使自己进行广泛而不深刻的学习。对我来说真正有价值的输入变少了，输出和表达的欲望也降低了很多。<br />
    我在原先的博客域名之下又建立了一个英文博客<a href="blog.crocodilezs.top/eysblog_en/">BLOG-EN</a>，旨在整理自己过去一年经历的各种项目。同时也将原博客中的内容进行整理归档，便于自己和访客的查阅。<br />
</div>

<span id="more"></span>
<h1 id="课程设计与实验"><a href="#课程设计与实验" class="headerlink" title="课程设计与实验"></a>课程设计与实验</h1><p><a href="/201911/Linux开发环境及应用作业%2020191031/" itemprop="url"> Linux文本处理作业 </a> &emsp;&emsp; <a href="/categories/操作系统/" itemprop="url"> 《30天自制操作系统》实验合辑 </a> &emsp;&emsp;<a href="/201909/周宇洋_「学生宿舍管理系统」实验报告/" itemprop="url"> 学生宿舍管理系统Python开发 </a> &emsp;&emsp;<a href="/201911/KNN与Naive_Bayes代码实现/" itemprop="url"> KNN和朴素贝叶斯的代码实现 </a> &emsp;&emsp;<a href="/201911/Price_Suggestion_Chanllenge/" itemprop="url"> 商品价格预测挑战 </a> &emsp;&emsp;<a href="/201911/Fisher算法&SVM&K-Means及其优化/" itemprop="url"> Fisher算法 &amp; SVM &amp; K-Means的实现和优化 </a> &emsp;&emsp;<a href="/201910/FINDS算法和ID3算法/" itemprop="url"> FINDS算法和ID3算法 </a> &emsp;&emsp;<a href="/201904/插入排序归并排序和快速排序/" itemprop="url"> 算法设计之排序 </a> &emsp;&emsp;<a href="/201904/循环赛赛程安排/" itemprop="url"> 算法设计之循环赛赛程安排 </a> &emsp;&emsp;</p>
<h1 id="展示和汇报"><a href="#展示和汇报" class="headerlink" title="展示和汇报"></a>展示和汇报</h1><p><a href="/201904/基于链接内容的社区发现（一）/" itemprop="url"> 基于链接内容的社区发现（一） </a> &emsp;&emsp;<a href="/201904/基于链接内容的社区发现（二）/" itemprop="url"> 基于链接内容的社区发现（二） </a> &emsp;&emsp;</p>
<h1 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h1><p><a href="/201904/爬虫入门（一）/" itemprop="url"> 爬虫入门 </a>  &emsp;&emsp;  <a href="/201904/第一行代码学习笔记（1）/" itemprop="url"> 《第一行代码》学习笔记1 </a>  &emsp;&emsp;  <a href="/201904/第一行代码学习笔记（2）/" itemprop="url"> 《第一行代码》学习笔记2 </a> &emsp;&emsp;<a href="/201909/数据库系统原理学习笔记（2）/" itemprop="url"> 数据库关系模式 </a> &emsp;&emsp;<a href="/201909/数据科学导论学习笔记（5）/" itemprop="url"> 数据预处理 </a> &emsp;&emsp;<a href="/201908/「迁移学习简明手册」学习笔记（1）/" itemprop="url"> 《迁移学习简明手册》学习笔记 </a> &emsp;&emsp;<a href="/201909/实验室苦逼搬砖暑假生活纪实/" itemprop="url"> 用户对齐（实验室搬砖纪实） </a> &emsp;&emsp;<a href="/202002/支持向量机算法的介绍及数学推导/" itemprop="url"> 支持向量机算法数学推导 </a> &emsp;&emsp;</p>
<h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><p><a href="/202005/《苏东坡传》摘录/" itemprop="url"> 《苏东坡传》 </a> &emsp;&emsp; <a href="/202002/祭亡妻程氏文/" itemprop="url"> 《祭亡妻程氏文》 </a> &emsp;&emsp; <a href="/202002/极简欧洲史/" itemprop="url"> 《极简欧洲史》 </a> </p>
]]></content>
  </entry>
  <entry>
    <title>支持向量机算法（Support Vector Machine Alg）的介绍及数学推导</title>
    <url>/202002/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E7%AE%97%E6%B3%95%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<div class="note info">
    🌟上个学期周文安老师教我们专业的机器学习课程，在讲每一个算法的时候老师都会强调数学推导的重要性。<br />
    她希望大家能够不仅仅会调库，还能明白算法最底层的原理，并且能够自己推导。然而上学期我在数学推导这里一直在划水😖，没有理解透各种推导过程，所以趁着寒假在家里比较有时间，把机器学习部分算法的数学推导部分补全。<br />
    <br />
    🌟SVM算法的证明用到了求解对偶问题的思想，石川老师在课上也说过这个算法的证明过程非常🕺“漂亮”🚶‍♂️。所以数学推导这一系列我决定从SVM开始。<br />
</div>

<p>在学期中我也有尝试手推过一次 <code>SVM</code>，但是并不是很理解，<strong>尤其是几何间隔、函数间隔和对偶问题等概念都没有理解，而这些概念对于推导过程都十分重要。</strong>现在的这篇文章将会展开得更详细。<br>这是上学期的文章👉<a href="https://blog.crocodilezs.top/201911/Fisher%E7%AE%97%E6%B3%95&amp;SVM&amp;K-Means%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/#more">SVM优化对偶问题的详细推导过程</a></p>
<p>文章的大致思路是 <code>SVM</code> 的介绍、推导过程中的基本概念介绍、数学推导。我会把问题描述到最容易理解。参考资料主要有李航老师的《统计学习方法》、<a href="https://www.coursera.org/learn/machine-learning?">吴恩达老师的机器学习课程</a>、<a href="https://scikit-learn.org/stable/modules/svm.html">python scikit learn的官方文档</a>和上个学期的课件。</p>
<span id="more"></span>
<h1 id="支持向量机介绍"><a href="#支持向量机介绍" class="headerlink" title="支持向量机介绍"></a>支持向量机介绍</h1><blockquote>
<p>支持向量机（support vector machines, <code>SVM</code>）是一种二分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机，支持向量机还包括核技巧，这使它成为实质上的非线性分类器。（关于“间隔”、“核技巧”的介绍在下文中会讲）</p>
</blockquote>
<h2 id="支持向量机的应用"><a href="#支持向量机的应用" class="headerlink" title="支持向量机的应用"></a>支持向量机的应用</h2><blockquote>
<p>Support vector machines (SVMs) are a set of supervised learning methods used for classification, regression and outliers detection.</p>
</blockquote>
<p>译：支持向量机是一种监督学习算法，可以用于分类问题、回归问题和异常点识别问题。</p>
<h2 id="直观理解支持向量机"><a href="#直观理解支持向量机" class="headerlink" title="直观理解支持向量机"></a>直观理解支持向量机</h2><p><a href="https://sm.ms/image/AU3tYprag8ckDGl" target="_blank"><img src="https://i.loli.net/2020/02/10/AU3tYprag8ckDGl.jpg" alt="pic0" width="350" height="350" ></a></p>
<p>假设在一个二分类问题中，我们的样例中有四个正例和五个反例（其中正例由圆形表示，反例由叉表示），如 <code>pic0</code> 所示。  </p>
<p>现在我们想通过一条直线将正例和反例区分开。显而易见，能够实现分类的有无数条直线，图中我们给出了三条分类直线：<code>l1</code>、<code>l2</code>、<code>l3</code>，如 <code>pic1</code> 所示。</p>
<p><a href="https://sm.ms/image/MHhx6BwTSzrQqZL" target="_blank"><img src="https://i.loli.net/2020/02/10/MHhx6BwTSzrQqZL.jpg" alt="pic1" width="350" height="350" ></a></p>
<p>然而，这三条直线的分类能力并不相同。假设我们再向训练样例中添加两个正样例（在 <code>pic2</code> 中用绿色的圆点表示），此时我们可以发现，直线 <code>l1</code> 和直线 <code>l3</code> 失去了完美的分类能力，因为它们没法将新加入的样例成功分类。</p>
<p>由此我们可以看出，<code>l2</code> 的分类能力比 <code>l1</code> 和 <code>l3</code> 的分类能力更强。<strong>而支持向量机算法就是去寻找所有直线中分类最强的那一条直线。</strong>在后面的推导过程中，我们也会证明：在这样的线性可分问题中，分类能力最强的直线（也就是“超平面”，后面会介绍）<strong>有且仅有一条</strong>。</p>
<p><a href="https://sm.ms/image/KpYh7ZNoMQCXDAH" target="_blank"><img src="https://i.loli.net/2020/02/10/KpYh7ZNoMQCXDAH.jpg" alt="pic2" width="350" height="350" ></a></p>
<h2 id="支持向量机的优势和劣势"><a href="#支持向量机的优势和劣势" class="headerlink" title="支持向量机的优势和劣势"></a>支持向量机的优势和劣势</h2><p>了解 <code>SVM</code> 的优势能够帮助我们在合适的问题中选择合适的算法。  </p>
<p><em>在看过后面算法的推导过程之后，会对支持向量机的优势和劣势有更深刻的了解。</em>  </p>
<h3 id="支持向量机的优势"><a href="#支持向量机的优势" class="headerlink" title="支持向量机的优势"></a>支持向量机的优势</h3><ol>
<li>Effective in high dimensional spaces.<em>在高维空间中比较容易使用。</em></li>
<li>Still effective in cases where number of dimensions is greater than the number of samples. <em>当样本特征数比样本数更多的时候，支持向量机仍然可以用。</em></li>
<li>Uses a subset of training points in the decision function (called support vectors), so it is also memory efficient.<em>仅仅用到了训练集中的部分样例（即支持向量），所以会节省内存空间。</em></li>
<li>Versatile: different Kernel functions can be specified for the decision function. Common kernels are provided, but it is also possible to specify custom kernels.<em>不同的核函数决定不同的决策函数。在python的scikit learn库中提供了普遍使用的核函数，当然我们也可以自定义核函数。</em></li>
</ol>
<h3 id="支持向量机的劣势"><a href="#支持向量机的劣势" class="headerlink" title="支持向量机的劣势"></a>支持向量机的劣势</h3><ol>
<li>If the number of features is much greater than the number of samples, avoid over-fitting in choosing Kernel functions and regularization term is crucial.<em>当样本特征数比样本数多的时候要注意防止过拟合，这个时候核函数的选择至关重要。</em></li>
<li>SVMs do not directly provide probability estimates, these are calculated using an expensive five-fold cross-validation (see Scores and probabilities, below).<em>sklearn包并不直接提供概率评估，是通过代价很大的五折交叉运算来实现的。</em></li>
</ol>
<h2 id="支持向量机的分类"><a href="#支持向量机的分类" class="headerlink" title="支持向量机的分类"></a>支持向量机的分类</h2><ol>
<li><p><strong>线性可分支持向量机（linear support vector machine in linearly separable case）</strong><br>通过硬间隔最大化（hard margin maximization）学习一个线性的分类器，又称为硬间隔支持向量机。</p>
</li>
<li><p><strong>线性支持向量机（linear support vector machine）</strong><br>当训练数据近似可分时，通过软间隔最大化（soft margin maximization）形成线性不可分支持向量机，简称为线性支持向量机</p>
</li>
<li><p><strong>非线性支持向量机（non-linear support vector machine）</strong><br>当训练数据集线性不可分时，通过使用核技巧以及软间隔最大化来学习非线性支持向量机。</p>
</li>
</ol>
<h1 id="相关定义和方法介绍"><a href="#相关定义和方法介绍" class="headerlink" title="相关定义和方法介绍"></a>相关定义和方法介绍</h1><h2 id="L0-L1-L2范数"><a href="#L0-L1-L2范数" class="headerlink" title="L0, L1, L2范数"></a><code>L0</code>, <code>L1</code>, <code>L2</code>范数</h2><p>直观地说，</p>
<ol>
<li><code>L0</code>范数：$||x||<em>0 := \sum</em>{i = 1}^n x^0$ 即<strong>向量中所有非零元素的个数</strong>；</li>
<li><code>L1</code>范数：$||x||<em>1 := \sum</em>{i = 1}^n |x|$  即<strong>向量中所有元素绝对值的和</strong>；</li>
<li><code>L2</code>范数：$||x||<em>2 := \sqrt{\sum</em>{i = 1}^n x^2}$ 即<strong>欧几里得（Euclidean）范数</strong>；</li>
</ol>
<p>范数是一个函数，其赋予某个向量空间（或矩阵）中的每个向量以长度或大小。对于零向量，另其长度为零。<br>直观的说，向量或矩阵的范数越大，则我们可以说这个向量或矩阵也就越大。有时范数有很多更为常见的叫法，如绝对值其实便是一维向量空间中实数或复数的范数，而Euclidean距离也是一种范数。</p>
<p><strong>p范数（p-norm）的表达公式</strong>：</p>
<script type="math/tex; mode=display">||x||_p := (\sum_{i = 1}^n x^p)^{\frac{1}{p}}</script><h2 id="函数间隔和几何间隔"><a href="#函数间隔和几何间隔" class="headerlink" title="函数间隔和几何间隔"></a>函数间隔和几何间隔</h2><p>首先在这里补充<strong>超平面</strong>的概念，<strong>超平面</strong>即分离不同类样本的分界面，在二维空间中的超平面就是线。</p>
<p>我们回到最开始的二分类问题，如<code>pic3</code>所示。<br><a href="https://sm.ms/image/PrVZwIlm2voCKHU" target="_blank"><img src="https://i.loli.net/2020/02/12/PrVZwIlm2voCKHU.png" alt="几何间隔示意图" width="350" height="350"></a></p>
<p>假设我们用直线 $l_2$ 对样例进行划分，图中的横轴表示样例的第一个属性$x^{(1)}$ ，纵轴表示样例的第二个属性 $x^{(2)}$。图中的点 $m_1(x_1^{(1)}, x_1^{(2)})$ 和 $m_2(x_2^{(1)}, x_2^{(2)})$ 都被划分为正类。一般来说，一个点距离超平面的远近可以表示分类预测确信程度，距离超平面越远的点确信程度越高，这个从直观上也比较容易理解。  </p>
<p>假设图中 $l_2$ 的方程确定为 $w_1x^{(1)} + w_2x^{(2)} + b = 0$ ，通过点到直线的距离公式$d = \frac{|w_1x^{(1)} + w_2x^{(2)} + b|}{\sqrt{w_1^2 + w_2^2}}$ 我们可以求得 $m_1$ 和 $m_2$ 到超平面的距离，以此来评判这些点分类的确信程度。这里的 $d$ 就被我们称为<strong>几何间隔</strong>。  </p>
<p>但如果我们仅仅想比较点 $m_1$ 和 $m_2$ 确信程度的大小，我们可以仅用距离公式的分子：$d’ = |w_1x^{(1)} + w_2x^{(2)} + b|$ 进行比较，因为同一条直线分类的点的分母都是相同的。这里的 $d’$ 我们称为<strong>函数间隔</strong>。 $d’$ 在图中的几何意义表示如下图所示：</p>
<p><a href="https://sm.ms/image/4m8PjYT2iS9rsf3" target="_blank"><img src="https://i.loli.net/2020/02/12/4m8PjYT2iS9rsf3.jpg" alt="函数间隔示意图" width="350" height="350"></a></p>
<p>一般来说，在超平面 $w·x+b=0$ 确定的情况下，$|w·x+b|$ 能够相对地表示点$x$距离超平面的远近，而 $w·x+b$ 的符号与类标记 $y$ 的符号是否一致能够表示分类是否正确。（在这里 $y$ 表示样本的标签）所以可以用$\widehat{\gamma_i} =  y_i(w·x_i+b)$ 来表示点 $m_i$ 分类的正确性及确信度，这就是样本的函数间隔的概念。</p>
<p>定义超平面 $(w, b)$ 关于训练数据集 $T$ 的函数间隔为超平面$(w, b)$ 关于 $T$ 中所有样本点$(x_i, y_i)$ 的函数间隔的最小值，即：</p>
<script type="math/tex; mode=display">\widehat\gamma = min_{i=1,...,N}\widehat{\gamma_i}</script><p>函数间隔可以表示分类预测的正确性和及确信度。但是选择分离超平面时，只有函数间隔还不够。因为只要成比例地改变$w$和$b$，例如将它们改为$2w$和$2b$，超平面并没有改变，但函数的间隔却变为原来的两倍。这一事实启示我们，可以对分离超平面的法向量$w$加某些约束，如规范化，$||w||=1$，使得间隔是确定的。这是函数间隔成为几何间隔（geometric margin）。</p>
<p><strong>定义（几何间隔）</strong></p>
<p>对于给定的训练数据集$T$和超平面$(w, b)$ ，定义超平面$(w,b)$ 关于样本点$(x_i, y_i)$ 的几何间隔为</p>
<script type="math/tex; mode=display">\gamma_i = y_i(\frac{w}{||w||}·x_i+\frac{b}{||w||})</script><p>定义超平面$(w,b)$ 关于训练数据集$T$ 的几何间隔为超平面$(w, b)$ 关于 $T$ 中所有样本点$(x_i, y_i)$的几何间隔最小值，即：</p>
<script type="math/tex; mode=display">\gamma=min_{i=1,...,N}\gamma_i</script><h2 id="拉格朗日对偶性"><a href="#拉格朗日对偶性" class="headerlink" title="拉格朗日对偶性"></a>拉格朗日对偶性</h2><p>首先举例直观理解，求解 $min<em>xmax</em>{\alpha, \beta} L(x, \alpha, \beta)$ 和求解 $max_{\alpha, \beta}min_x L(x, \alpha, \beta)$ 是对偶问题。前者是极小极大问题，后者是极大极小问题。</p>
<p>在约束优化问题中，常常利用拉格朗日对偶性（Lagrange duality）将原始问题转换为对偶问题，<strong>通过对偶问题而得到原始问题的解</strong>。该方法应用在许多统计学习方法中，例如，最大熵模型与支持向量机。这里简要叙述拉格朗日对偶性的主要概念和结果。</p>
<h3 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h3><p>假设$f(x)$, $c_i(x)$, $h_j(x)$  是定义在 $R^n$ 的连续可微函数。考虑约束最优化问题：</p>
<script type="math/tex; mode=display">min_{x \in R^n} f(x) \tag {C.1}</script><script type="math/tex; mode=display">s.t. c_i(x) \leq 0, i = 1, 2, ..., k \tag {C.2}</script><script type="math/tex; mode=display">h_j(x)=0, j=1,2,...,l \tag {C.3}</script><p>称此最优化问题为原始最优化问题或原始问题。</p>
<p>首先引进广义拉格朗日函数（generalized Lagrange function）</p>
<script type="math/tex; mode=display">L(x, \alpha, \beta) = f(x)+\sum_{i=0}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x) \tag {C.4}</script><p>这里，$x=(x^{(1)}, x^{(2)}, …, x^{(3)})^T \in R^n$ ，$\alpha_i, \beta_j$ 是拉格朗日乘子，$\alpha \geq 0$。考虑 $x$ 的函数：</p>
<script type="math/tex; mode=display">\theta_P(x) = max_{\alpha,\beta:\alpha_i \geq 0} L(x, \alpha, \beta) \tag {C.5}</script><p>这里，下标 $P$ 表示原始问题。</p>
<p>假设给定某个$x$。如果 $x$ 违反原始问题的约束条件，即存在某个 $i$ 使得 $c_i(x) &gt; 0$ 或者存在某个 $j$ 使得 $h_j(x) \neq 0$，那么就有</p>
<script type="math/tex; mode=display">\theta_P(x) = max_{\alpha, \beta:\alpha_i \geq 0} [f(x)+\sum_{i=0}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x)]=+ \infty \tag {C.6}</script><p>因为若某个 $i$ 使约束 $c_i(x) &gt; 0$ ，则可令 $\alpha_i \rightarrow + \infty $ ，若某个 $j$ 使 $h_j(x) \neq 0$，则可令 $\beta_j$ 使 $\beta_jh_j(x) \rightarrow + \infty$  ，而将其余各 $\alpha_i$， $\beta_j$ 均取为0.</p>
<p>相反地，如果 $x$ 满足约束条件$(C.2)$ 和$(C.3)$ ，此时 $\theta_P(x)=f(x)$.</p>
<p>所以，如果考虑极小化问题</p>
<script type="math/tex; mode=display">min_x\theta_P(x) = min_x max_{\alpha, \beta:\alpha_i \geq 0} L(x, \alpha, \beta)</script><p>$min<em>x max</em>{\alpha, \beta:\alpha_i \geq 0} L(x, \alpha, \beta)$ 称为广义拉格朗日函数的极小极大问题。</p>
<p>为了方便，定义原始问题的最优值</p>
<script type="math/tex; mode=display">p* = min_x\theta_P(x)</script><h3 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h3><script type="math/tex; mode=display">\theta_D(x) = min_{x} L(x, \alpha, \beta) \tag {C.8}</script><p>再考虑极大化 $\theta<em>D(x) = min</em>{x} L(x, \alpha, \beta)$ ，即</p>
<script type="math/tex; mode=display">max_{\alpha, \beta:\alpha_i \geq 0}\theta_D(\alpha, \beta) = max_{\alpha, \beta:\alpha_i \geq 0}min_{x} L(x, \alpha, \beta) \tag {C.9}</script><p>问题 $max<em>{\alpha, \beta:\alpha_i \geq 0}min</em>{x} L(x, \alpha, \beta)$ 称为广义拉格朗日函数的极大极小问题。</p>
<p>可以将广义拉格朗日定理函数的极大极小问题表示为约束最优化问题：</p>
<script type="math/tex; mode=display">max_{\alpha, \beta}\theta_D(\alpha, \beta) = max_{\alpha, \beta}min_{x} L(x, \alpha, \beta)</script><script type="math/tex; mode=display">s.t. \alpha_i \geq 0, i=1, 2,...,k</script><p>称为原始问题的对偶问题，定义对偶问题的最优值：</p>
<script type="math/tex; mode=display">d^* = max_{\alpha, \beta:\alpha_i \geq 0} \tag {C.10}</script><h3 id="原始问题和对偶问题的关系"><a href="#原始问题和对偶问题的关系" class="headerlink" title="原始问题和对偶问题的关系"></a>原始问题和对偶问题的关系</h3><p>这里只给出了定理，证明略去。</p>
<p><strong>定理C.1</strong>  </p>
<p>若原始问题和对偶问题都有最优值，则</p>
<script type="math/tex; mode=display">d^* = max_{\alpha, \beta : \alpha_i \geq 0} min_x L(x, \alpha, \beta) \leq min_x max_{\alpha, \beta:\alpha_i \geq 0} L(x, \alpha, \beta) = p^* \tag {C.11}</script><p><strong>推论C.1</strong>  </p>
<p>设 $x^<em>$ 和 $\alpha^</em>$ ， $\beta^<em>$ 分别是原始问题和对偶问题的可行解，并且 $d^</em> = p^<em>$ ，则 $x^</em>$ 和 $\alpha^<em>, \beta^</em>$ 分别是原始问题和对偶问题的最优解。</p>
<p><strong>定理C.2</strong></p>
<p>假设函数 $f(x)$ 和 $c_i(x)$ 是凸函数，$h_j(x)$ 是仿射函数；并且假设不等式约束$c_i(x)$ 是严格可行的，即存在 $x$ ，对所有$i$有$c_i(x) &lt;0$，则存在 $x^\ast , \alpha^\ast ,  \beta^\ast $ ，使 $x^\ast$ 是原始问题的解，$\alpha^\ast$ , $\beta^\ast$ 是对偶问题的解，并且</p>
<script type="math/tex; mode=display">p^* = d^* = L(x^*, \alpha^*, \beta^*) \tag {C.12}</script><p><strong>定理C.3</strong></p>
<p>假设函数 $f(x)$ 和 $c_i(x)$ 是凸函数，$h_j(x)$ 是仿射函数；并且假设不等式约束$c_i(x)$ 是严格可行的，则 $ x^\ast $ 和 $\alpha^\ast, \beta^\ast$ 分别是原始问题和对偶问题的解的充分必要条件是 $x^\ast, \alpha^\ast, \beta^\ast$ 满足下面的 <code>Karush-Kuhn-Trucker(KKT)</code> 条件：</p>
<script type="math/tex; mode=display">\triangledown_xL(x^*, \alpha^*, \beta^*)=0 \tag {C.13}</script><script type="math/tex; mode=display">\alpha_i^*c_i(x^*)=0,i=1,2,...,k \tag {C.14}</script><script type="math/tex; mode=display">c_i(x) \leq 0, i=1,2,...,k \tag {C.15}</script><script type="math/tex; mode=display">\alpha_i^* \geq ,i=1,2,...,k \tag {C.16}</script><script type="math/tex; mode=display">h_j(x^*)=0,j=1,2,...,l \tag {C.17}</script><p>特别指出，式$(C.24)$ 称为 <code>KKT</code> 的对偶互补条件。由此条件可知：若 $\alpha_i^<em> &gt;0$ ， 则 $c_i(x^</em>)=0$。</p>
<p>简单的总结一下这一小节：<strong>在某些条件下，原始问题和对偶问题的解相同，我们可以通过求解对偶问题的解来解决原问题。</strong></p>
<h2 id="核技巧"><a href="#核技巧" class="headerlink" title="核技巧"></a>核技巧</h2><p> 核技巧我们可以通过一张图来理解：<br> <img src="https://i.loli.net/2020/02/13/4rjnEpbuylieSIs.jpg" alt="pic5"></p>
<p> <strong>核函数是二元函数，输入是映射之前的两个向量，其输出等价于两个向量映射之后的内积。</strong></p>
<p>下面这个链接里有关于核函数更详细的描述：</p>
<p><a href="https://zhuanlan.zhihu.com/p/47541349?utm_source=qq&amp;utm_medium=social&amp;utm_oi=809760155267903488">关于核函数</a></p>
<h1 id="支持向量机数学推导"><a href="#支持向量机数学推导" class="headerlink" title="支持向量机数学推导"></a>支持向量机数学推导</h1><p>关于支持向量机的推导，重点还是在<strong>线性可分支持向量机</strong>这里。在明白了线性可分支持向量机的推导之后，线性支持向量机仅仅是在此基础上加了一个软间隔，非线性支持向量机是加上了核技巧。  </p>
<div class="note warning">
注意，在看下面的推导过程之前，请务必保证理解了上面的函数间隔和几何间隔、对偶问题等概念。
</div>

<h2 id="线性可分支持向量机"><a href="#线性可分支持向量机" class="headerlink" title="线性可分支持向量机"></a>线性可分支持向量机</h2><p><strong>支持向量机</strong>学习的<strong>基本想法</strong>是求解<strong>能够正确划分数据集</strong>并且<strong>几何间隔最大</strong>的分离超平面。这里的间隔最大化又称<strong>硬间隔最大化</strong>（与后面讨论的软间隔最大化相对应）。</p>
<div class="info">
    间隔最大化的直观理解：<br />
    对训练数据集找到几何间隔最大的超平面意味着以充分大的确信度对训练数据进行分类。也就是说，不仅将正负实例点分开，而且对最难分的实例点（离超平面最近的点）也有足够大的确信度将它们分开。这样的超平面应该对未知的新实例有很好的分类预测能力。
</div>

<h3 id="最大间隔算法"><a href="#最大间隔算法" class="headerlink" title="最大间隔算法"></a>最大间隔算法</h3><p>我们的目标是求解一个几何间隔最大的分离超平面，可以表示为下面的约束最优化问题：</p>
<script type="math/tex; mode=display">max_{w,b} \gamma \tag {1.1}</script><script type="math/tex; mode=display">y_i(\frac{w}{||w||}·x_i+\frac{b}{||w||}) \geq \gamma,i=1,2,...,N \tag {1.2}</script><p>考虑到几何间隔和函数间隔的关系（$\gamma$ 表示几何间隔，$\widehat{\gamma}$ 表示函数间隔），可以将这个问题改写为：</p>
<script type="math/tex; mode=display">max_{w,b} \gamma</script><script type="math/tex; mode=display">s.t. y_i(w·x_i+b) \geq \widehat{\gamma},i=1,2,...,N</script><p>函数间隔$\widehat{\gamma}$ 的取值并不影响最优化问题的解。事实上，假设将$w$ 和 $b$ 按比例改编为 $\lambda w$ 和 $\lambda b$ ，这时函数间隔成为 $\lambda \widehat{\gamma}$ ，函数间隔的这一改变对等式约束没有影响，对目标函数的优化也没有影响。</p>
<p>这样，我们可以取$\widehat{\gamma} =1$ ，带入到上面的式子，同时我们注意到最大化$\frac{1}{||w||}$ 和最小化 $\frac{1}{2}||w||^2$ 是等价的，于是约束规划问题可以转换成如下的形式：</p>
<p>$min_{w,b} \frac{1}{2}||w||^2 \tag {1.3}$</p>
<script type="math/tex; mode=display">s.t.y_i(w·x_i+b)-1 \geq 0,i=1,2,...,N \tag {1.4}</script><p>综上，我们得到了线性可分的<strong>支持向量机算法</strong>——<strong>最大间隔法</strong>，在后文中我们会对这个算法进行求解。</p>
<hr>
<p><strong>算法（线性可分支持向量机学习算法）：</strong></p>
<ul>
<li>输入：线性可分训练数据集 $T={(x_1,y_1),(x_2,y_2),…,(x_N,y_N)}$，其中，$x_i \in X =R^n,y_i \in Y ={-1, +1},i=1,2,…,N$;</li>
<li>输出：最大间隔分离超平面和分类决策函数</li>
</ul>
<p>（1） 构造并求解约束最优化问题：</p>
<script type="math/tex; mode=display">min_{w,b} \frac{1}{2}||w||^2</script><script type="math/tex; mode=display">s.t. y_i(w_i ·x+b)-1 \geq 0,i=1,2,...,N</script><p>求得最优解$w^<em>,b^</em>$。</p>
<p>（2） 由此得到分类超平面啊：</p>
<script type="math/tex; mode=display">w^* · x+b^*=0</script><p>分类决策函数</p>
<script type="math/tex; mode=display">f(x)=sign(w^*·x+b^*)</script><h3 id="算法求解"><a href="#算法求解" class="headerlink" title="算法求解"></a>算法求解</h3><h2 id="线性支持向量机"><a href="#线性支持向量机" class="headerlink" title="线性支持向量机"></a>线性支持向量机</h2><h2 id="非线性支持向量机"><a href="#非线性支持向量机" class="headerlink" title="非线性支持向量机"></a>非线性支持向量机</h2><h1 id="归纳和总结"><a href="#归纳和总结" class="headerlink" title="归纳和总结"></a>归纳和总结</h1>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>SVM</tag>
        <tag>算法推导</tag>
      </tags>
  </entry>
  <entry>
    <title>写于10月15日——博客正式对外开放之际</title>
    <url>/201909/%E5%86%99%E4%BA%8E%E5%8D%9A%E5%AE%A2%E6%AD%A3%E5%BC%8F%E5%AF%B9%E5%A4%96%E5%BC%80%E6%94%BE%E4%B9%8B%E9%99%85/</url>
    <content><![CDATA[<p><img src="https://s2.ax1x.com/2019/10/15/KPwEYd.jpg" alt=""></p>
<p>If you can quite, then quite.<br /><br>If you can’t quite, you’re a writer.</p>
<div style="text-align:right">——R.A.Salvatore</div>

<span id="more"></span>
<p>经过四个月的磨叽，新的博客基本已经完善。<a href="www.crocodilezs.top">鳄鱼先生的水族馆</a><br>本来想着把原先<code>wordpress</code>博客的文章慢慢搬过来再向大家开放博客，但是仔细看看自己原来的那些文章，要么是没什么深度的书评和影评，要么是平淡的流水账。  </p>
<p>但是讲真话，看到自己以前的文字觉得很有成就感，因为那些文章的信息量虽然没那么高、有很多无意义的情绪宣泄，但是里面都有很有意思的闪光点，自己大一大二还真是一个有些自负的天马行空少年。如果这个学期还有时间，就把自己曾经的一些想法整理一下发到博客上来。  </p>
<p>下面就记录一下自己接触博客这个圈子以来的一些感触。</p>
<h1 id="我为什么要写博客？"><a href="#我为什么要写博客？" class="headerlink" title="我为什么要写博客？"></a>我为什么要写博客？</h1><p>表达自己的方式有太多了，微信朋友圈、微信公众平台、QQ空间、微博、知乎、百度贴吧…<br>但是我逐渐发现两个非常严重的问题，其一、这些社交平台上的原创信息都太多了，把自己的想法和感触发布出去真的就是石沉大海，少有人能注意到自己的想法，即使看到了，能让大家留下印象真的非常困难（微信公众平台最明显，随着微信公众平台的门槛降低，“写的比看的多”真的成为了现实）这是消息爆炸的必然结果，随着时间的累积，互联网上文字的平均价值一定会逐渐减少。<br>其二、即使在自己很有存在感的朋友圈和空间，发布的内容也只是自己即时的感慨和供大家取乐的段子，这些东西能够极大地满足我的虚荣心，也记录下了自己很多美好的瞬间。但是在这些平台发布一些长篇大论，就少有人阅读也很难引发深刻的共鸣。  </p>
<p><b>自己的文字越来越浮躁、信息量越来越低，最终在2017年12月，我开始接触博客。</b>  </p>
<p>博客对于我来说就像是信息海洋里属于自己的象牙舟——任缘分流，最后还回港口。</p>
<p>老狼就是一个不会被时间改变的人，你应该庆幸身边有这样的人。<br /><br>我是那种随时跟着时代改变的，但是如果你身边都是这样的人，大家都是弄潮儿，最后就不知道随波逐流到哪儿去了。<br /><br>那你身边有这么一个人呢，你在哪儿弄潮也好，还是劈波斩浪也好，你老能看见他。<br />你会知道，“哦，这个地方是我们出发的地方，这个地方是我们还要回去的地方。”</p>
<div style="text-align:right">——高晓松</div>


<h1 id="搭建博客的历史"><a href="#搭建博客的历史" class="headerlink" title="搭建博客的历史"></a>搭建博客的历史</h1><p>大一的时候根本不懂任何技术，经知乎大佬们安利最终决定自己买服务器用<code>wordpress</code>进行傻瓜操作。<br>买域名主机一气呵成，按照教程搭建好了自己的博客。<br><code>wordpress</code>也确实对小白很友好了，但是它有一个很严重的问题——慢，还有一个致命的问题——莫名其妙地自己的博客就会打不开。<br><code>wordpress</code>有很棒的地方比如说操作简单、文章可以带密码（有些文章只开放给特定人群），当然缺点就是可定制性太低了，博文内部的插件很少很少，不想现在的’hexo’<code>NeXT</code>主题非常灵活。<br>最终，在我又一次打不开自己博客的时候，我选择了放弃<code>wordpress</code>，放弃自己买的主机，准备转战其他的地方。</p>
<p><b>博客中国、博客大巴</b>这些老牌BSP（Blog Service Provider）已经半死不活了。博客园、CSDN的博客技术性又太强了。当时的我始终逃避自己码代码，虽然对<code>hexo</code>早有耳闻，但是总感觉技术性太强一直不愿尝试。<br>最后找到了一个发布轻博文的地方——网易lofter，然而lofter现在的用户流量也大不如前。无奈，我最终还是选择了<code>hexo</code>+<code>github</code>。现在真的可以说是真香了。  </p>
<p>搭建的过程真的非常非常艰辛，从六月份一直到现在，花了不知道多少时间和多少精力，从<code>git</code>的使用到前端的学习，从<code>markdown</code>进阶到<code>next</code>博文内嵌的插件，每一项都学的我要疯掉。最困难的就是<code>next</code>主题更新的速度太快，根本找不到什么新版本的指导教程，只能自己一点一点摸索，借鉴别人的博客。最终才把自己的主题写好。期间受到过很多大佬的博客的启发：  </p>
<ul>
<li><p>内容方面<br><a href="https://www.cnfeat.com/">陈素封的博客</a>：陈素封老师是我搭建博客期间最佩服的博主，他的文章信息量极大，让我获益匪浅。</p>
</li>
<li><p>技术方面<br><a href="https://bestzuo.cn/">Sanarous的博客</a>：最好看的主题没有之一，我的博客的博文字体和配色基本都是借鉴这位大佬的。他的博客搭建系列对我的技术和审美的提升都非常大。他的博客也是我见过的最优秀的博客。  </p>
</li>
</ul>
<p>下面的博客各有可取之处，在搭建的过程中也给了我莫大的帮助：</p>
<p><a href="https://lruihao.cn/">李瑞豪的博客</a><br><a href="https://asdfv1929.github.io/">asdfv1929’s blog</a><br><a href="https://xian6ge.cn/">贤柳阁</a><br><a href="https://yfzhou.coding.me/">Felix</a>：这个主题真的让人眼前一亮<br><a href="https://www.zhyong.cn/">YouForever</a><br><a href="https://linchao1002.github.io">Linchao’s Blog</a></p>
<h1 id="我的生活"><a href="#我的生活" class="headerlink" title="我的生活"></a>我的生活</h1><p>博客搭建的具体过程已经忘得差不多了，也不想再费尽心思地回想和记录。<br>目前自己博客的定位当然不会是一个单纯的技术博客，平时也会post自己的学习笔记、健身记录、书影观后感、游记、摄影和随笔。<br>可以说这是自己的一个个人品牌吧，在接下来的日子里要不断地完善。<br>陈素封老师在自己地一篇文章中提到过写博客的意义：</p>
<ol>
<li>提供持续学习的动力</li>
<li>积累更多的知识</li>
<li>提高将事情讲清楚的能力</li>
<li>分享带来的连锁反应</li>
<li>帮你找到志同道合的人</li>
<li>记录成长</li>
<li>培养持续做一件事的能力</li>
<li>讨论反思</li>
<li>搜寻你意想不到的东西</li>
<li>一个人在做一件属于自己的事</li>
<li>互联网的身份识别</li>
</ol>
<p>以上意义对我来说，最重要的应该是1、5、10、11，还有就是让自己沉淀下来，能够去把信息碎片整合、归纳、扩展，形成自己独树一帜的观点。这些是博客对于我的意义。</p>
<div style='display: none'>
我现在的日程轨迹自己也非常地满意：
晚上十一点开始清理滴答清单的每日Checklist，然后为第二天安排任务。滴答清单的具体使用方法参考了课程《跟邹小强学用滴答清单》，课程在网易云课堂上应该有。滴答清单我用了快半年了，这是我目前接触的最完美的时间管理类app，我需要的功能它全部都有，而且有产品自己的对时间管理的一些想法。“收集箱”的存在对我有很大的帮助。  
下面是我每晚的checklist：

<div class="note info">
    1. 信息门户<br />
    2. 北邮人论坛十大<br />
    3. 清理阅读清单<br />
    4. qq官方通知群<br />
    5. 清理滴答清单<br />
    6. 整理知识碎片<br />
    7. 计算机院公众号
</div>

<p>每日的打卡清单包括：</p>
<div class="note success">
    1. 查看今天花了多少钱<br />
    2. 健身（z1.2.3.5.6）<br />
    3. 坚持记录<br />
    4. 阅读<br />
    5. 不发脾气<br />
    6. 背单词<br />
    7. 吃早餐<br />
    8. 喝水
</div>

<p>每日的咨询获得包括：36氪、澎湃新闻、部分微信公众号、网易云课堂、北邮人论坛<br>收集的app：<b>pocket</b>（很优秀的app！）<br>晚上记录的app：<b>卡片日记</b>（记录app里界面我最喜欢的了，每天记录的时候心情最重要，所以日记软件的颜值要求应该是最高的~）<br>然后有时间的时候再根据卡片日记里的想法形成长篇大论发到博客。<br>&lt;/div&gt;</p>
<p>然而、然而、最近课程真的太忙了啊！专业分流就跟转专业了一样，前两年学的东西和现在的专业都脱轨了啊！<br>这几天累的不行，也好久都没写博客了。</p>
<p>今天写的这一篇的内容一定还有太多不完善的地方，日后再慢慢细化吧。</p>
]]></content>
      <categories>
        <category>参省乎己</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>实验室苦逼搬砖暑假生活纪实</title>
    <url>/201909/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E8%8B%A6%E9%80%BC%E6%90%AC%E7%A0%96%E6%9A%91%E5%81%87%E7%94%9F%E6%B4%BB%E7%BA%AA%E5%AE%9E/</url>
    <content><![CDATA[<div class="note primary">
    记录一下自己暑假在实验室做的一些事情和收获吧。<br />
    虽然进步很小很缓慢，但总归是有的。
</div>

<h1 id="7月13日"><a href="#7月13日" class="headerlink" title="7月13日"></a>7月13日</h1><ol>
<li><p>关于论文的主要内容，学长进行了讲解：<br /><br> <strong>任务目标：</strong>通过迁移学习实现用户对齐问题，并将对齐结果与其他的用户对其方法进行比较：其中的方法包括“监督类型的”和“非监督类型的”，最终论文里要将我们的方法与其他至少三四种方法进行比较。</p>
 <span id="more"></span>
</li>
<li><p>下面的时间应该做到：<br> 0）熟悉各数据集，每个数据集经过哪个函数变成什么样子？<br> <code>myspace</code>文件夹中，<code>.node</code>文件前一个数字表示结点标号，后面的表示用户名。<br> <code>.edges</code>文件每一行的两个数字表示边连接的两个节点。<br> <code>aminer.tar.gz</code>,<code>flicker.tar.gz</code>,<code>lastfm.tar.gz</code>,<code>linkedin.tar,gz</code>,<code>livejournal.tar.gz</code>这五个压缩包都是上面形式的点和边<br> <code>aminer-linkedin.map.raw</code>文件，将<code>aminer.tar.gz</code>文件中的结点映射到<code>linkedin</code>上  </p>
<p> 1）<code>DRNE</code>（将图表示矩阵转化成向量）<br> 转化成的向量是什么格式？它是怎样表示矩阵的？它的输入和输出是怎样的？</p>
<p> 2）<code>wGAN</code>的一个变种函数（生成相应的对齐结果）<br> 它的输入和输出是怎样的？</p>
</li>
</ol>
<h1 id="7月14日"><a href="#7月14日" class="headerlink" title="7月14日"></a>7月14日</h1><p>非常艰难的一天，<code>DRNE</code>作者的<code>readme</code>文档写错了，指令是错误的，我第一次接触这个看不懂debug信息，学长也没发现。最后发邮件问原作者才知道<code>readme</code>中把<code>\</code>打成了<code>/</code>🤬<br>这一件事情花了我三天的时间，一开始以为自己的环境没搭建好，安装了各种库，利用<code>anaconda</code>创造了许多环境测试，我哭了。</p>
<ol>
<li><p>关于安装<code>tensorflow</code>的方法：<br> <a href="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/1-2-install/">莫凡Python</a><br> <a href="https://www.cnblogs.com/lvsling/p/8672404.html">ling’s bolg</a></p>
<p> <a href="https://www.jianshu.com/p/28e2ae6fbd75">安装时遇到的问题</a></p>
</li>
<li><p>上面这些乱七八糟的都不如直接<code>pip install</code>，觉得慢的话换成清华镜像资源<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a></p>
</li>
</ol>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/">pypi镜像使用帮助</a></p>
<h1 id="7月15日"><a href="#7月15日" class="headerlink" title="7月15日"></a>7月15日</h1><div class="note primary">
    学长又分配了两个任务，第一个是判断图是否为连通图。 <br /> 
    其实要是只有几个点倒简单，但是仅仅接触了一点`Python`就要写个几千点判断连通图的程序，我想到的第一点是效率会非常低。。。最后这个代码学长亲自写了。
</div>

<p>这里顺带复习了一下数据结构的东西</p>
<ol>
<li>邻接矩阵与邻接表<br> <a href="https://www.cnblogs.com/icode-girl/p/5273209.html">邻接矩阵</a></li>
<li>边表<br> 边集表，图的储存结构之一。边表由表头结点和表结点两部分组成，图中每个顶点均对应一个存储在数组中的表头结点。<br> 边表存储了以点为起点的边的信息，邻接表存储了以点为出发点的点的信息。 </li>
<li>edgelist边表中每行有两个数，表示这两个结点之间有边</li>
<li>python nx.has_path(G, source, target)用来判断是否为连通图</li>
<li>networkx库查阅资料：<br><a href="https://www.cnblogs.com/kaituorensheng/p/5423131.html">network资料</a><br>NetworkX是一个用Python语言开发的图论与复杂网络建模工具，内置了常用的图与复杂网络分析算法，可以方便的进行复杂网络数据分析、仿真建模等工作。networkx支持创建简单无向图、有向图和多重图（multigraph）；内置许多标准的图论算法，节点可为任意数据；支持任意的边值维度，功能丰富，简单易用。<br><a href="https://networkx.github.io/documentation/stable/tutorial.html">network官方文档</a>  </li>
</ol>
<p>发现文档里举的例子都是自己输入的个别的点，我可以先研究一下DRNE的代码，从里面得到一些有用的内容。</p>
<p>代码看不懂的地方，首先就是embedding：<br><a href="https://blog.csdn.net/songyunli1111/article/details/85100616">关于embedding</a></p>
<h1 id="7月16日"><a href="#7月16日" class="headerlink" title="7月16日"></a>7月16日</h1><ol>
<li>CONSNET数据集：<br> deepwalk-master先不用，做对比算法的<br> DRNE-master 用来做embedding的<br> GAN用来生成模型  </li>
<li>关于anaconda的使用：<br> Anaconda是一个方便的python包管理和环境管理软件，一般用来配置不同的项目环境。<br> 我们常常会遇到这样的情况，正在做的项目A和项目B分别基于python2和python3，而第电脑只能安装一个环境，这个时候Anaconda就派上了用场，它可以创建多个互不干扰的环境，分别运行不同版本的软件包，以达到兼容的目的。<br> Anaconda通过管理工具包、开发环境、Python版本，大大简化了你的工作流程。不仅可以方便地安装、更新、卸载工具包，而且安装时能自动安装相应的依赖包，同时还能使用不同的虚拟环境隔离不同要求的项目。<br> <a href="https://www.jianshu.com/p/742dc4d8f4c5">Anaconda入门</a></li>
</ol>
<h1 id="7月17日"><a href="#7月17日" class="headerlink" title="7月17日"></a>7月17日</h1><div class="note success">
    conda有一点好处是，如果你需要安装一个包，系统将自动检查这个包需要的前置包并且安装，比如你要安装TensorFlow，而TensorFlow会用到很多像前置包像pandas、matiplot等，如果你在单纯的python下没有安装pandas等包就直接安装TensorFlow，那么和有可能无法使用，而使用conda安装TensorFlow将会询问你并自动帮你把缺少的前置包安装好
</div>

<ol>
<li><p>使用anaconda先创建一个用于drne的环境<br> <img src="https://s2.ax1x.com/2019/09/28/u1d88U.png" alt=""><br> 安装以上环境<br> 其中添加的资源库都没有tensorflow == 1.2.0<br> 按照提示 </p>
 <blockquote><p>To search for alternate channels that may provide the conda package you’re looking for, navigate to <a href="https://anaconda.org">https://anaconda.org</a> and use the search bar at the top of the page.</p>
</blockquote>
<p> 去官网搜索资源即可下载</p>
<p> 环境安装完成</p>
</li>
<li><p>anaconda跑不出来，先学习anaconda的使用方法：<br> <a href="https://www.jianshu.com/p/eaee1fadc1e9">anaconda1</a></p>
<p> <a href="https://i.xdc.at/2017/08/13/add-anaconda-prompt-to-context-menu-of-explorer/">anaconda2</a></p>
<p> <a href="https://blog.csdn.net/c20081052/article/details/88839479">anaconda3</a></p>
</li>
</ol>
<h1 id="7月19日"><a href="#7月19日" class="headerlink" title="7月19日"></a>7月19日</h1><p>继续研究network库</p>
<h1 id="7月21日"><a href="#7月21日" class="headerlink" title="7月21日"></a>7月21日</h1><p>研读networkx的文档，在后面处理相关问题的时候会简单很多。<br>在学习图的过程中，遇到的问题：<br><img src="https://s2.ax1x.com/2019/09/28/u1wzTI.png" alt=""><br><img src="https://s2.ax1x.com/2019/09/28/u1wx0A.png" alt=""></p>
<p>最后一行输出，我记得莫凡python里有讲这个，关于迭代器的东西，然后搜索了一下，继续进行学习：<br><a href="https://blog.csdn.net/u014028063/article/details/80572234">Python迭代器</a></p>
<p><strong>任务：</strong><br>写一个可以将ground truth抽样的函数，给定一个列表，例如[0.3， 0.5， 0.7]，<br>0.3表示在groundtruth里面随机抽样30%，并生成名为new-gt-0.3.txt的文件，列表长度为多少，就生成多少个这样的文件。</p>
<h1 id="7月22日"><a href="#7月22日" class="headerlink" title="7月22日"></a>7月22日</h1><p>readme文档中AcrossNetworkEmbeddingData文件夹里的文件和实际文件夹里的不一样，是否有问题？</p>
<p>anchor users 定位用户</p>
<h1 id="7月23日"><a href="#7月23日" class="headerlink" title="7月23日"></a>7月23日</h1><p>读学长写的：</p>
<ol>
<li><p>连通图代码<br>numpy.zeros<br><a href="https://blog.csdn.net/qq_28618765/article/details/78085457">https://blog.csdn.net/qq_28618765/article/details/78085457</a></p>
</li>
<li><p>抽样代码<br>自己完成：数据转换代码<br>python open函数的参数<br><a href="https://www.runoob.com/python/python-func-open.html">https://www.runoob.com/python/python-func-open.html</a></p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/qq_33254870/article/details/81668297">https://blog.csdn.net/qq_33254870/article/details/81668297</a></p>
<p><a href="https://cloud.tencent.com/developer/ask/172682">https://cloud.tencent.com/developer/ask/172682</a></p>
<font color="FF0000">一定要系统地学一下python！要不然什么都不会，写起来效率太低了！！</font>

<p>怎样用csvreader读入用tab分隔的文件——直接用\t</p>
<p><a href="https://www.runoob.com/python/att-list-len.html">https://www.runoob.com/python/att-list-len.html</a></p>
<p>for while if后面都要有冒号</p>
<p>python的‘和’符号是 and</p>
<p>关于newline参数</p>
<h1 id="7月24日"><a href="#7月24日" class="headerlink" title="7月24日"></a>7月24日</h1><div class="note danger">
    把trans_result打成了tranns_result，出现问题，，，，，
    python也没有报错，还好自己发现了
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span>(i &lt; <span class="built_in">len</span>(trans_result)):</span><br><span class="line">		<span class="comment"># print(&quot;Delete process...&quot;)</span></span><br><span class="line">		<span class="keyword">if</span>(trans_result[i][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">or</span> trans_result[i][<span class="number">1</span>] == <span class="number">0</span>):</span><br><span class="line">			trans_result = np.delete(trans_result, i, axis = <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">else</span>:<span class="comment">#！！！！注意这里的else！！！否则会出错</span></span><br><span class="line">			i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><center>❤️ 🧡 💛 💚 💙 💜 </center></p>
<p><center>中间几天帮张老师查项目资料来着——关于“认知计算”和“意图推理”</center></p>
<h1 id="7月31日"><a href="#7月31日" class="headerlink" title="7月31日"></a>7月31日</h1><p>如何调出eclipse左边文件栏<br><a href="https://jingyan.baidu.com/article/a24b33cd3af41119ff002b7a.html"></a></p>
<p>anaconda prompt 切换到e盘：<br><a href="https://blog.csdn.net/c20081052/article/details/88839479"></a></p>
<p>drne配适自己的代码：<br>activate for_drne<br>e:</p>
<h1 id="8月4日"><a href="#8月4日" class="headerlink" title="8月4日"></a>8月4日</h1><p>coursera视频无法播放<br><a href="https://blog.csdn.net/qq_39521554/article/details/79039548">https://blog.csdn.net/qq_39521554/article/details/79039548</a></p>
<p>欧式距离</p>
<p><a href="https://www.cnblogs.com/kimkat/p/9938475.html">https://www.cnblogs.com/kimkat/p/9938475.html</a></p>
<p>测试程序（把程序拆成几小部分）</p>
<ol>
<li>np.linalg.norm(vec1 - vec2)</li>
<li>读入部分，怎样读出来两个向量</li>
</ol>
<p>python cookbook 真的能学到很多东西！！<br>挺有用！</p>
<p><a href="https://zhidao.baidu.com/question/115008008.html">https://zhidao.baidu.com/question/115008008.html</a></p>
<p><a href="https://www.cnblogs.com/bakari/p/4807847.html">https://www.cnblogs.com/bakari/p/4807847.html</a></p>
<h1 id="8月5日"><a href="#8月5日" class="headerlink" title="8月5日"></a>8月5日</h1><ol>
<li><p>查数据类型：<br><a href="https://www.cnblogs.com/carlber/p/9362584.html">https://www.cnblogs.com/carlber/p/9362584.html</a></p>
</li>
<li><p>列表最后有一个逗号，就会多出来一个空元素<br><a href="https://www.cnblogs.com/lostme/articles/8857083.html">https://www.cnblogs.com/lostme/articles/8857083.html</a></p>
</li>
<li><p>operands could not be broadcast together with shapes (2,) (250,)<br><a href="https://blog.csdn.net/Odyssues_lee/article/details/85244735">https://blog.csdn.net/Odyssues_lee/article/details/85244735</a></p>
</li>
<li><p>运行map（）后，报：map object at 0x02629E50解决方法与原因分析​​​​​​​<br><a href="https://blog.csdn.net/weixin_40807247/article/details/82797378">https://blog.csdn.net/weixin_40807247/article/details/82797378</a></p>
</li>
</ol>
<p><a href="https://www.cnblogs.com/hwd9654/p/5707920.html">https://www.cnblogs.com/hwd9654/p/5707920.html</a></p>
<ol>
<li><p>从字符串中提取数字：<br><a href="https://www.cnblogs.com/dancesir/p/11021829.html">https://www.cnblogs.com/dancesir/p/11021829.html</a></p>
</li>
<li><p>python中，“<filter object at 0x028A2050>”是什么意思？怎么解决？<br><a href="https://zhidao.baidu.com/question/329317296.html">https://zhidao.baidu.com/question/329317296.html</a></p>
</li>
<li><p>数据格式要求很严格：<br>3   2<br>5  4<br>7  6<br>9  7<br>tab和x个空格不一样</p>
</li>
<li><p>输出百分比：<br><a href="https://blog.csdn.net/u013553529/article/details/78567696">https://blog.csdn.net/u013553529/article/details/78567696</a></p>
</li>
</ol>
<h1 id="8月7日"><a href="#8月7日" class="headerlink" title="8月7日"></a>8月7日</h1><p>博客搭建<br><a href="https://blog.csdn.net/fangquan1980/article/details/80648171">https://blog.csdn.net/fangquan1980/article/details/80648171</a></p>
<p><a href="https://blog.csdn.net/zyupupup/article/details/85098366">https://blog.csdn.net/zyupupup/article/details/85098366</a></p>
<p><a href="https://blog.csdn.net/weixin_42419856/article/details/81141546">https://blog.csdn.net/weixin_42419856/article/details/81141546</a></p>
<p><a href="https://blog.csdn.net/lvsehaiyang1993/article/details/80881433">https://blog.csdn.net/lvsehaiyang1993/article/details/80881433</a></p>
<p><a href="http://zhangchunlei.com/blog/2014/12/01/modify-a-record-of-my-website-dns/">http://zhangchunlei.com/blog/2014/12/01/modify-a-record-of-my-website-dns/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On a Windows machine, you&#x27;ll want to run nslookup your-domain.com and ensure that the output does not include any of the deprecated IP addresses (207.97.227.XXX, 204.232.175.XX, or 199.27.73.XXX).</span><br><span class="line">If you&#x27;re on a Mac or Linux machine, simply paste this command into a terminal window, replacing your-domain.com with, your site&#x27;s domain. dig your-domain.com | grep -E &#x27;(207.97.227.245|204.232.175.78|199.27.73.133)&#x27; || echo &quot;OK&quot;. If you see the word &quot;OK&quot;, you&#x27;re all set.</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/a1023182899/article/details/77461567">https://blog.csdn.net/a1023182899/article/details/77461567</a></p>
<h1 id="8月8日"><a href="#8月8日" class="headerlink" title="8月8日"></a>8月8日</h1><p><a href="https://www.v2ex.com/amp/t/465570">https://www.v2ex.com/amp/t/465570</a></p>
<p>LINE（PALE中）<br>GAN<br>画圈</p>
<h1 id="8月11日"><a href="#8月11日" class="headerlink" title="8月11日"></a>8月11日</h1><p>xlrd模块：<br><a href="https://www.cnblogs.com/insane-Mr-Li/p/9092619.html">https://www.cnblogs.com/insane-Mr-Li/p/9092619.html</a></p>
<h1 id="8月13日"><a href="#8月13日" class="headerlink" title="8月13日"></a>8月13日</h1><ol>
<li><p>random.choices<br><a href="https://blog.csdn.net/lcqin111/article/details/83504029">https://blog.csdn.net/lcqin111/article/details/83504029</a></p>
</li>
<li><p>Cannot feed value of shape (256, 255) for Tensor ‘Placeholder:0’, which has shape ‘(?, 256)’<br><a href="http://www.mamicode.com/info-detail-2346029.html">http://www.mamicode.com/info-detail-2346029.html</a></p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4000</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------------training---------DDDDDD----------EPOCH：&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;-----------------------&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        mm = np.reshape(random.choices(f_d, f_g, k=<span class="number">256</span>))</span><br><span class="line">        nn = np.reshape(random.choices(t_d, t_g, k=<span class="number">256</span>))</span><br><span class="line">        rms_train1, loss1 = sess.run([model.rms_train_op1, model.loss_d], feed_dict=&#123;model.s: np.array(random.choices(f_d, f_g, k=<span class="number">256</span>)), model.t: np.array(random.choices(t_d, t_g, k=<span class="number">256</span>))&#125;)</span><br><span class="line">        <span class="keyword">for</span> every <span class="keyword">in</span> model.clip:</span><br><span class="line">            sess.run(every)</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>7.13<br>了解任务详情<br /></p>
<p>7.14<br>装相应的环境，跑DRNE，发现了文档的错误<br>DRNE在命令行窗口运行。<br>输入：edgelist<br>输出：.npy（需要再写程序转换为embedding）<br /></p>
<p>7.15<br>想要完成任务：判断是否为连通图<br>结果就是不行，，<br /></p>
<p>7.16<br>还在为DRNE的无脑错误 debug<br /></p>
<p>7.17<br>学习了anaconda的使用，还在跑DRNE，，<br /></p>
<p>7.18<br>DRNE，，<br /></p>
<p>7.19<br>完成一个可以将ground truth抽样的函数，例如[0.3, 0.5, 0.7]<br /></p>
<p>7.21<br>学习关于图的内容，不敢下手自己写代码<br /></p>
<p>7.22<br>开始跑IONE（java）<br /></p>
<p>7.23<br>数据转换代码，将cosnet数据集中的用户名转换成结点号<br /></p>
<p>7.24<br>删去edges里面没有在groundtruth中出现的记录，以此来缩小数据集<br /></p>
<p>7.25<br>用学长改过的代码跑ione<br /></p>
<p>7.31<br>用anaconda环境跑DRNE<br /></p>
<p>8.4<br>写计算距离，画圈的代码<br /></p>
<p>8.5<br>计算距离的代码，注意数据格式<br /></p>
<p>8.7<br>博客搭建<br /></p>
<p>8.8<br>跑PALE中的LINE，尝试WGAN<br /></p>
<p>8.11<br>跑学长改过的WGAN<br /></p>
<p>8.11<br>跑学长改过的WGAN完成，DRNE结果的npy转成txt<br /></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>迁移学习</tag>
        <tag>Anaconda</tag>
        <tag>DRNE</tag>
        <tag>IONE</tag>
        <tag>WGAN</tag>
        <tag>PALE</tag>
      </tags>
  </entry>
  <entry>
    <title>KNN与Naive_Bayes代码实现</title>
    <url>/201911/KNN%E4%B8%8ENaive_Bayes%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="KNN与Naive-Bayes代码实现"><a href="#KNN与Naive-Bayes代码实现" class="headerlink" title="KNN与Naive_Bayes代码实现"></a>KNN与Naive_Bayes代码实现</h1><h2 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h2><p>采用Python实现分类算法：</p>
<ul>
<li>不得借助现成的工具包调库，例如SKlearn</li>
<li>至少实现k-近邻，朴素贝叶斯，逻辑回归，决策树与支持向量机中的其中一个算法。k-临近，朴素贝叶斯相对较简单，逻辑回归，决策树与支持向量机相对较难。</li>
<li>对breast cancer数据集调用编写的函数进行分类演示。</li>
<li>能力强的可以多实现几种算法</li>
</ul>
<span id="more"></span>
<h2 id="算法实现——kNN"><a href="#算法实现——kNN" class="headerlink" title="算法实现——kNN"></a>算法实现——kNN</h2><p>利用breast_cancer中的数据，实现kNN算法。  </p>
<ol>
<li>导入数据集，并分为训练集和测试集</li>
<li>实现kNN算法<ul>
<li>对每一个测试集中的实例，计算它距离训练集中的点的距离</li>
<li>根据选定的k值，选择距离最近的k个点数量更多的“标签”</li>
</ul>
</li>
<li>算法效果测试，测试算法的精确度，和SKlearn提供的kNN算法进行比较。</li>
</ol>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> neighbors</span><br><span class="line"></span><br><span class="line">datasets = datasets.load_breast_cancer()</span><br><span class="line">X = datasets.data;</span><br><span class="line">y = datasets.target;</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.3</span>, random_state = <span class="number">0</span>)</span><br><span class="line">k = <span class="number">5</span></span><br><span class="line"><span class="comment"># print(datasets.DESCR)</span></span><br><span class="line"><span class="comment"># malignant - 0, benign - 1</span></span><br><span class="line">y_predict = []</span><br></pre></td></tr></table></figure>
<h3 id="kNN算法实现"><a href="#kNN算法实现" class="headerlink" title="kNN算法实现"></a>kNN算法实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knn</span>(<span class="params">X_train, y_train, X_test, y_predict</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    对测试集的数据进行预测，得到的结果与y_test比较。用欧式距离进行计算。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> test_data <span class="keyword">in</span> X_test:</span><br><span class="line">        first_k_instance = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X_train)):</span><br><span class="line">            distance = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> attributes_no <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X_train[<span class="number">0</span>])):</span><br><span class="line">                distance += (test_data[attributes_no] - X_train[i][attributes_no]) ** <span class="number">2</span></span><br><span class="line">            Euclid_distance = distance ** <span class="number">0.5</span></span><br><span class="line">            <span class="comment">#print(Euclid_distance)</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; k:</span><br><span class="line">                first_k_instance.append((i, Euclid_distance))</span><br><span class="line">            <span class="keyword">elif</span> Euclid_distance &lt; first_k_instance[k-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                first_k_instance[k-<span class="number">1</span>] = (i, Euclid_distance)</span><br><span class="line">            first_k_instance = <span class="built_in">sorted</span>(first_k_instance, key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>]) </span><br><span class="line">            <span class="comment">#print(first_k_instance)</span></span><br><span class="line">        <span class="comment"># 现在得到了距离测试点最近的k个点，用多数表决器来判断测试点是良性还是恶性</span></span><br><span class="line">        benign = <span class="number">0</span></span><br><span class="line">        malignant = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> instance <span class="keyword">in</span> first_k_instance:</span><br><span class="line">            <span class="keyword">if</span> y_train[instance[<span class="number">0</span>]] == <span class="number">0</span>:</span><br><span class="line">                malignant += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                benign += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> malignant &gt;= benign:</span><br><span class="line">            y_predict.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y_predict.append(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="精确度计算函数"><a href="#精确度计算函数" class="headerlink" title="精确度计算函数"></a>精确度计算函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">y_predict, y_test</span>):</span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_predict)):</span><br><span class="line">        <span class="keyword">if</span> y_predict[i] == y_test[i]:</span><br><span class="line">            correct += <span class="number">1</span></span><br><span class="line">    accuracy_rate = correct / <span class="built_in">len</span>(y_predict)</span><br><span class="line">    <span class="keyword">return</span> correct, accuracy_rate</span><br></pre></td></tr></table></figure>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    knn(X_train, y_train, X_test, y_predict)</span><br><span class="line">    correct, accuracy_rate = accuracy(y_predict, y_test)</span><br><span class="line">    <span class="built_in">print</span>(y_predict)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kNN模型测试集预测的准确率为：%.3f&quot;</span> % accuracy_rate);</span><br><span class="line">    KNN = neighbors.KNeighborsClassifier(n_neighbors = <span class="number">5</span>)</span><br><span class="line">    KNN.fit(X_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sklearn库中kNN模型预测的准确率为：%.3f&quot;</span> % KNN.score(X_test, y_test));</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<pre><code>[0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1]
kNN模型测试集预测的准确率为：0.947
sklearn库中kNN模型预测的准确率为：0.947
</code></pre><p>通过实验结果可以发现，我们实现的kNN与SKlearn中提供的kNN效果一致。<br>我们可以通过设置k的值和转换寻找相似样本的策略（将欧式距离替换为匹配系数或Jaccard等），进一步优化精确度。</p>
<h2 id="算法实现——Naive-Bayes"><a href="#算法实现——Naive-Bayes" class="headerlink" title="算法实现——Naive_Bayes"></a>算法实现——Naive_Bayes</h2><p>利用breast_cancer中的数据，实现Naive_Bayes算法。  </p>
<ol>
<li>导入数据集，并分为训练集和测试集</li>
<li>实现Naive Bayes算法<ul>
<li>把连续的属性划分区间，计算正例和反例落在每个属性的每个区间的个数</li>
<li>计算概率值，预测测试集的标签</li>
</ul>
</li>
<li>算法效果测试，测试算法的精确度，和SKlearn提供的Naive Bayes算法进行比较。</li>
</ol>
<h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><h3 id="导入数据-1"><a href="#导入数据-1" class="headerlink" title="导入数据"></a>导入数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load datasets</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> naive_bayes</span><br><span class="line"></span><br><span class="line">datasets = datasets.load_breast_cancer()</span><br><span class="line">X = datasets.data;</span><br><span class="line">y = datasets.target;</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.3</span>, random_state = <span class="number">0</span>)</span><br><span class="line"><span class="comment">#print(datasets.DESCR)</span></span><br><span class="line"><span class="comment">#malignant - 0, benign - 1</span></span><br><span class="line">y_predict = []</span><br></pre></td></tr></table></figure>
<p>由于30个属性全部都是连续值，我们使用朴素贝叶斯的时候需要将属性的值的范围分为几个区间，计算实例落在该区间的概率。这里每个属性我都以平均值作为间隔来划分区间。<br><img src="2-1.jpg" alt=""></p>
<h3 id="对每个连续的属性划分区间并统计个数"><a href="#对每个连续的属性划分区间并统计个数" class="headerlink" title="对每个连续的属性划分区间并统计个数"></a>对每个连续的属性划分区间并统计个数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">distribution</span>(<span class="params">X_train, y_train</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    先把区间分好，然后再计算概率。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#===============区间划分====================#</span></span><br><span class="line">    attributes_max_min_mean = []</span><br><span class="line">    <span class="comment"># 记录所有属性的最大值、最小值和平均值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X_train[<span class="number">0</span>])):</span><br><span class="line">        <span class="comment">#属性循环</span></span><br><span class="line">        <span class="comment">#section = [max, min, mean]</span></span><br><span class="line">        section = [X_train[<span class="number">0</span>][i], X_train[<span class="number">0</span>][i], <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> instance <span class="keyword">in</span> X_train:</span><br><span class="line">            <span class="comment">#训练样例循环</span></span><br><span class="line">            <span class="keyword">if</span> instance[i] &gt; section[<span class="number">0</span>]:</span><br><span class="line">                section[<span class="number">0</span>] = instance[i]</span><br><span class="line">            <span class="keyword">if</span> instance[i] &lt; section[<span class="number">1</span>]:</span><br><span class="line">                section[<span class="number">1</span>] = instance[i]</span><br><span class="line">            section[<span class="number">2</span>] += instance[i]</span><br><span class="line">        section[<span class="number">2</span>] /= <span class="built_in">len</span>(X_train)</span><br><span class="line">        attributes_max_min_mean.append(section)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#=========计算每个属性落在每个区间的样例个数=========#</span></span><br><span class="line">    instance_distribution = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X_train[<span class="number">0</span>])):</span><br><span class="line">        <span class="comment">#属性循环</span></span><br><span class="line">        smaller_benign = <span class="number">0</span></span><br><span class="line">        larger_benign = <span class="number">0</span></span><br><span class="line">        smaller_malignant = <span class="number">0</span></span><br><span class="line">        larger_malignant = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X_train)):</span><br><span class="line">            <span class="comment">#训练样例循环</span></span><br><span class="line">            <span class="keyword">if</span> X_train[j][i] &gt; attributes_max_min_mean[i][<span class="number">2</span>]:</span><br><span class="line">                <span class="keyword">if</span> y_train[j] == <span class="number">1</span>:</span><br><span class="line">                    larger_benign += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    larger_malignant +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> y_train[j] == <span class="number">1</span>:</span><br><span class="line">                smaller_benign += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                smaller_malignant += <span class="number">1</span>   </span><br><span class="line">        instance_distribution.append([smaller_benign, larger_benign, smaller_malignant, larger_malignant])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> instance_distribution, attributes_max_min_mean</span><br></pre></td></tr></table></figure>
<h3 id="实现朴素贝叶斯"><a href="#实现朴素贝叶斯" class="headerlink" title="实现朴素贝叶斯"></a>实现朴素贝叶斯</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Naive_Bayes</span>(<span class="params">X_test, y_predict, instance_distribution,attributes_max_min_mean</span>):</span><br><span class="line">    <span class="keyword">for</span> test_data <span class="keyword">in</span> X_test:</span><br><span class="line">        <span class="comment">#测试样例循环</span></span><br><span class="line">        <span class="comment">#训练集中良性和恶性肿瘤的数量</span></span><br><span class="line">        malignant = instance_distribution[<span class="number">0</span>][<span class="number">2</span>] + instance_distribution[<span class="number">0</span>][<span class="number">3</span>]</span><br><span class="line">        benign = instance_distribution[<span class="number">0</span>][<span class="number">0</span>] + instance_distribution[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="comment">#概率初始化，下面计算每个属性的概率</span></span><br><span class="line">        p_xc0 = <span class="number">1</span></span><br><span class="line">        p_xc1 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X_train[<span class="number">0</span>])):</span><br><span class="line">            <span class="comment"># 属性循环</span></span><br><span class="line">            <span class="keyword">if</span> test_data[i] &gt; attributes_max_min_mean[i][<span class="number">2</span>]:</span><br><span class="line">                p_xc0 *= instance_distribution[i][<span class="number">3</span>] / malignant</span><br><span class="line">                p_xc1 *= instance_distribution[i][<span class="number">1</span>] / benign</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p_xc0 *= instance_distribution[i][<span class="number">2</span>] / malignant</span><br><span class="line">                p_xc1 *= instance_distribution[i][<span class="number">0</span>] / benign</span><br><span class="line">        p0 = p_xc0 * malignant / (malignant + benign)</span><br><span class="line">        p1 = p_xc1 * benign / (malignant + benign)</span><br><span class="line">        <span class="keyword">if</span> p0 &gt; p1:</span><br><span class="line">            y_predict.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y_predict.append(<span class="number">1</span>)      </span><br></pre></td></tr></table></figure>
<h3 id="计算精确度"><a href="#计算精确度" class="headerlink" title="计算精确度"></a>计算精确度</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">y_predict, y_test</span>):</span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_predict)):</span><br><span class="line">        <span class="keyword">if</span> y_predict[i] == y_test[i]:</span><br><span class="line">            correct += <span class="number">1</span></span><br><span class="line">    accuracy_rate = correct / <span class="built_in">len</span>(y_predict)</span><br><span class="line">    <span class="keyword">return</span> correct, accuracy_rate</span><br></pre></td></tr></table></figure>
<h3 id="主函数-1"><a href="#主函数-1" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    instance_distribution, attributes_max_min_mean = distribution(X_train, y_train)</span><br><span class="line">    Naive_Bayes(X_test, y_predict, instance_distribution, attributes_max_min_mean)</span><br><span class="line">    correct, accuracy_rate = accuracy(y_predict, y_test)</span><br><span class="line">    <span class="built_in">print</span>(y_predict)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Naive Bayes模型测试集预测的准确率为：%.3f&quot;</span> % accuracy_rate);</span><br><span class="line">    bayes = naive_bayes.GaussianNB()</span><br><span class="line">    bayes.fit(X_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sklearn库中Naive Bayes模型预测的准确率为：%.3f&quot;</span> % bayes.score(X_test, y_test));</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<pre><code>[0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1]
Naive Bayes模型测试集预测的准确率为：0.930
sklearn库中Naive Bayes模型预测的准确率为：0.924
</code></pre><p>通过实验结果可以发现，我们实现的朴素贝叶斯比SKlearn提供的朴素贝叶斯效果更好。<br>我们可以通过尝试各属性不同的区间划分，进一步优化精确度。而SKlearn提供的朴素贝叶斯效果不好的原因可能就是将连续值转换为离散值的区间划分没有做好。</p>
]]></content>
      <categories>
        <category>数据科学导论</category>
      </categories>
  </entry>
  <entry>
    <title>《苏东坡传》摘录</title>
    <url>/202005/%E3%80%8A%E8%8B%8F%E4%B8%9C%E5%9D%A1%E4%BC%A0%E3%80%8B%E6%91%98%E5%BD%95/</url>
    <content><![CDATA[<p>今年五月份读完的这本书，暑假开始的时候决定把读书笔记和读后感整理放在博客上。关于《苏东坡传》的文章一共有两篇，这是第一篇，内容为读书时的摘录。第二篇如下：  </p>
<p>人生到处知何似， 应似飞鸿踏雪泥， 泥上偶然留指爪， 鸿飞那复计东西。</p>
<p>拿西洋作家为例，李白可以媲美雪莱或拜伦，是一个燃烧自己展现出瞬间壮景的文学彗星。杜甫就象米尔顿，是一个热心的哲学家和老好人，以贴切、渊博的古典比喻写出了丰富的作品。苏东坡永远年轻。他性格比较象萨克莱，政治和诗词的盛名则象雨果，同时又具有约翰生博士那份动人的本质。不知怎么约翰生博士的痛风病直到今天还叫我们感动，米尔顿的瞎眼却不尽然。如果约翰生同时又兼有甘斯伯劳的特色，而且象波普用诗词批评政治，又象史维夫特吃过那么多苦而没有史维夫特的尖酸味儿，我们就能找出一个英国的类比了。苏东坡的道精神由于遭受许多困难而更醇美，却没有变酸。今天我们爱他，只因为他吃苦吃得太多了。</p>
<p>苏东坡在面对痛苦时展现出了超常的淡然，他像是一个已经预知了自己一生的人。我最爱他的地方是他面对所有事情的坦诚。  </p>
<p>今年五月份读完的这本书，暑假开始的时候决定把读书笔记和读后感整理放在博客上。关于《苏东坡传》的文章一共有两篇，这是第一篇，内容为读书时的摘录。第二篇如下：</p>
<span id="more"></span>
<hr>
<p>我们可以检视一幕幕已经终了的情节，眼见许多事情因外在事变和内在性格的必然性而自然发展。  </p>
<p>王安石热衷社会改革，自然觉得任何手段都没有错，甚至不惜清除异己。神圣的目标向来是最危险的。<strong>一旦目标神圣化，实行的手段必然日渐卑鄙。</strong>这种发展趋势逃不过苏东坡敏锐的心灵，甚至有点违背他的幽默感。他的行径和王安石不合；彼此的冲突决定了他一生的经历，也决定了宋朝的命运。  </p>
<p>“文章如精金美玉”，苏东坡写信给谢民师说，“市有定价，非人所能以口舌贵贱也”。</p>
<p><strong>构成永恒特质的“真诚性”</strong>究竟是什么呢？苏东坡清清楚楚表达了他对写作和文体的意见。“大略如行云流水。初无定质。但常行于所当行，常止于不可不止。文理自然，姿态横生。孔子曰，言之不文，行之不远。又曰，词达而已矣，夫言止于达意，则疑若不文，是大不然。求物之妙，如系风捕影，能使是物了然于心者，盖千万人而不一遇也。而况能使了然于口与手乎。是之谓词达。词至于能达，则文不可胜用矣。杨雄好为艰深之词。以文浅易之说，若正言之，则人人知之矣。此正所谓雕虫篆刻者。”苏东坡为文体下定义，正好贴切地描述了他自己写文章的过程，动笔收笔都象“行云流水”，揭露出文章和修辞的一切奥秘。什么时候进行，什么时候结束都没有一定的规矩。<strong>如果作家的思绪很美，只要他能忠实、诚恳、妥当表达，魅力和美感自然存在。</strong>这些不是硬放人作品的东西，词达而造成的单纯、自然和某一种自由感正是好文章的秘诀。这些特质具备了，文体不虚浮空洞，就可以写出真诚的文学作品。  </p>
<p>“生平最快乐的时刻”，有一天苏东坡对他的朋友说，“就是写作时笔端能表达一切思想的脉络。我自忖道‘人间自乐莫过于此’”。  </p>
<p>他曾一度坚称，给人快慰的力量便是文学本身的报酬。  </p>
<p>当时有一位作家说，文士不怕刑罚，不爱晋升，也不贪生怕死，只怕欧阳修的意见。欧阳修对一位同事说，“读苏东坡的信，我全身喜极流汗。我应当退隐，使这个青年出人头地。”想想这句话对苏东坡有多大的影响!  </p>
<p>日月何促促， 尘世苦局束。  </p>
<p>我简直想说，苏东坡的精神代表“火”，他一生和水灾、旱灾奋斗，每到一地就忙着修建供水系统、水运系统和水井。火的象征很恰当，因为他活力充沛；换句话说，他的脾气和一生都象烈焰，到处给人生机和温暖，也一路烧毁了某些东西。</p>
<p><em>我没有懂作者这里说的烧毁的是什么东西</em>  </p>
<p>人生到处知何似， 应似飞鸿踏雪泥， 泥上偶然留指爪， 鸿飞那复计东西。 这是东坡的佳作之一，飞鸿象征人类的精神。事实上这本书所写的苏东坡生来事略只是一个伟大心灵偶尔留下的足迹，真正的苏东坡是一个幻鸟般的灵魂，说不定今天还在星宿间梦游呢。  </p>
<p>她要他当心那些表现太露骨的泛泛之交，以及他根据“世间无恶人”理论而交上的朋友。他的麻烦就出在这儿；他无法看出别人的错处。他太太对他说：“当心那些朋友。太快建立的友情不会长久的。”东坡承认，她的话总是应验，我想她这方面的智慧是来自中国<strong>“君子之交淡如水”的古训——没有令人兴奋的味道，却永远不会生厌。</strong>诚挚的友情从来不表现太多。真正的好友不常写信，因为全心信任彼此的友谊，根本不必写。分别几年又重逢，友情依然如故。   </p>
<p>坑上架着一个小木板桥，百英尺下有激流飞过，四周是直立的峡谷。章惇自己很勇敢，对苏轼一鞠躬，他走过木板桥，在对面峭壁上留几个字。苏东坡拒绝了，章惇独自过桥，泰然自若。他拢拢长袍，抓住一根吊索，沿峭壁到溪流对岸写了六个字：“苏轼章惇来游”。然后若无其事走回来。苏东坡拍拍朋友的背说，“有一天你会杀人。” “为什么？”章惇问道。 苏东坡答道，“能将自己性命玩弄于股掌之上，也就能杀人。”苏东坡的预言到底对不对，我们以后就知道了。  </p>
<p>这不是中国第一次试行国家资本主义，却是最后的一次。在中国四千年的历史中，曾四度试行极权主义、国家资本主义、社会主义，以及剧烈的社会革命，每一次都惨败而终。最成功的是法家商鞍的右派极权主义，他的理论由兴建长城的秦始皇（公元前三世纪）有效推行。早期法家理论最重要的两大原则就是教战与重农。两者其实是同一回事，因为商鞍相信农夫是最好的军人，所有中产阶级的商人和贸易家都该尽量受到压制。大家都知道，根据这一教条而建立发展的强大军事系统使秦国统一了全中国；但是此一政治理论刚遍行全国，不到几年就完全崩溃。  </p>
<p>王安石的怪习惯是不是伪装，我们无法断定；<strong>不过一个人的行为如果太过份，大家难免怀疑他有自我宣传的意味。</strong>  </p>
<p>王安石说，他宁愿谈谈尧舜的贤臣。“在上等人才眼中，诸葛亮根本不值得一提。” 诸葛亮的政治天才在于一步步走向既定的目标，这位急功自信的财政鬼才觉得很不对胃口。  </p>
<p>好官知道这些贷款对人民不利，确定他们付不出本利会下狱坐牢。他们遵守政府的明文规定，宣布贷款完全出于“自愿”，心中打算有一天会因“阻碍新政”而丢官。  </p>
<p>王安石认为，控制文人的思想更属必要。他和古代的王莽，近代的希特勒一样，具有“一个国家、一个信仰、一个领袖”的信念〔他像希特勒，遭到反对就大发雷霆；现代精神病学家可以把他列为妄想狂。  </p>
<p>无论古今中外，人民爱不爱某一政权唯有等这个专制政府失势才能判断。  </p>
<p>郑侠终日站在宫门边，看到成群难民由东北逃来，挤满京师的街道。郑侠知道图画比言辞更有力，就把这些可怜的农民画下来，献给皇上。有一张画描写难民饥寒交迫，在大风雨中流浪。另一张描写半裸的男女正在吃草根树皮，还有人拴着铁链搬砖负柴来缴税。皇帝看到这些图画，不禁掉下泪来，精采的献图——我们以后会谈到——加上一颗彗星出现。圣山发生土崩，皇帝终于废除了许多“新法”。  </p>
<p>司马光学问和品德都冠绝当代，从头到尾为原则而争。他和王安石代表相反的政策立场。  </p>
<p>过了两个月老相富弼辞职，临行警告说，<strong>治斗争总是好人输，奸小一定会爬到高位。因为好人争原则，坏人争权利，最后双方都各得其所，好人去职，坏人留下来。</strong>他预言这样下去国家不久就会陷入纷乱。</p>
<p>苏东坡的九千字“上皇帝书”非常重要，可以代表他的政治哲学，也显出他个人的脾气和文风，充满机智、学问和大无畏的勇气。义愤的争论夹着冷静、简明的推理。有时候沮丧、严苛、挑剔、直爽无比；有时候却徐徐辩论，引经（孔孟）据典，引史例来支持他的理论。内容巧妙、诚挚、有力，对世事满怀激动和悲哀。  </p>
<p>苏东坡认为，好政府要靠异议的健全作用来维持。民主就根据各党异议的原则而存在。我相信苏东坡若生在现代，一定反对联合国安理会的否决权，认为不民主。他知道盘古开天以来，没有两个人看法完全一样，除了民主就是专制。我从来没有发现一个反对民主的人在家、在国、在世界政局上不是暴君。  </p>
<p>若使言无不同，意无不合，更唱迭和，何者非贤。  </p>
<p>孔子曾说，人应该“驱郑声，远佞人”。有一天王安石和惠卿谈话，他弟弟安国在外面吹笛子。宰相对弟弟大叫说，“你能不能驱郑声？”他弟弟回答说，“你能不能远佞人？”  </p>
<p>两兄弟政治观点始终相同，立场也一致，但是性格却完全不一样。子由性安稳，实事求是，保守，不爱多说话；东坡性豪放，开朗，多嘴多舌，天真而不计一切后果。朋友同伴都觉得子由很可靠，东坡开朗的天才，他的嘲弄和恶作剧却常常使人害怕。  </p>
<p>苏东坡最大的缺点就是喜欢在宾客面前或者作品中坦白说出他的想法，十分不利。子由十分了解他的哥哥。子由把手放在他的嘴上，叫他从此沉默些，后来东坡出狱，子由也曾做过同样的暗示。  </p>
<p>风中飞蓬正是苏东坡一生最好的象征，从此他就成为政治风暴中的海燕，直到老死从未在一个地方住过三年以上。  </p>
<p>这里是他的第二故乡，不只因为此地有美丽的山丘、森林、湖泊、大海、热闹的市街和壮观的寺庙，也因为当地人民都很喜欢他，他度过了这一生中最幸福的日子。居民有南方人快乐的天性，有诗歌有美人，他们敬爱这位年轻的名诗人，欣赏他冲动、热情和无忧无虑的个性。美景启发了他的灵感，此外柔婉的魅力更抚慰了他的心灵。杭州赢得他的青睐，他也赢得杭州人民的爱戴。他担任杭州通判（助理官员），没有机会为人民多尽力，但是诗人的身份已经足够了；他被捕的时候，杭州人纷纷在街上设龛拜祭，替他解灾。他走了以后，南国的美景和温情一直令他魂牵梦系。他知道他会回来，十八年后他再度回来当太守，对本城建树极多，在杭州人心目中留下了不朽的回忆，大家都说他是杭州人。在他死后千年的今天。你走上西湖，登上孤山岛或凤山，或者在湖滨的一家饭店喝茶，你会听到杭州本籍的店主一再提到“苏东坡——苏东坡。”你若点明东坡是四川人，他可不高兴。咦，他认为苏东坡生在那儿，除了京师从来没到过别的地方哩!  </p>
<p>苏东坡几乎相信他前生曾住在这儿。他自己的诗词和同代人的杂记都有记载。有一天他拜访寿星院，一进大门就觉得景物很熟悉。他告诉同伴，他知道有九十二级石阶通向忏堂。结果完全正确。他还向同伴描述后殿的建筑、庭院和木石。我们不必相信这些转生的故事，不过社会若相信神鬼和轮回，总有很多这一类的说法，就象鬼故事，没有人能证明是真是假。  </p>
<p>游这些山往往要一整天，他常在傍晚回来，街灯都亮了。穿过灯火通明、人潮汹涌的小河塘夜市，他往往半醉才回家，想起一些诗句然后又忘掉一些： 睡眼忽惊矍， 繁灯闹河塘。 <strong>市人拍手笑， 状如失林莺。</strong> 始悟山野姿， 异趣难自强。 人生安为笑， 吾策殊未良。  </p>
<p>这些家船都精雕细琢，船头有笕嘴。湖上还有其它船只专卖食品给游客。有人卖栗子、瓜子、莲藕、甜食、炸鸡和海鲜。有人专供茶水。有些船上载着艺人，照例贴近游客的小船，为大家表演歌唱、杂耍，并供应吊索和其他射猎的游戏。他们身边就是澄蓝的湖水，周长十英里左右。远处白云栖在山顶上，山峰若隐若现。云霞使山峰千变万化，多采多姿，山峰给云霞一个栖息的所在。有时候天冷欲雪，雾气盖满山脚。隔着雾气，游人可以看见零零落落的的亭台楼阁，瞥见远山模糊的棱线。睛天湖水清爽极了，水中鱼儿历历可数，苏东坡曾以两行愉快的诗句描写船夫的黄头巾与青山的背景相映照，画面十分动人： 映山黄帽螭头舫， 夹道青烟鹊尾炉。  </p>
<p>他常常借一张和尚的躺椅，搬到附近竹林中；完全卸下官吏的尊严，脱下衣衫，赤身露体睡午觉。小和尚用敬畏的眼光偷看这位大学者，看到了别人无权一窥的场向。他看见——也许是自以为看见——苏东坡背上有七粒黑痣，排列的方位很象北斗七星。老和尚说，可见他是天廷派下来的神灵，暂时在人间作客而已  </p>
<p><strong>苏东坡眼中感官的生活和灵性的生活是同一回事，以诗意哲学化的人生观看来并没有什么冲突。有了诗，他热爱今生，不可能变成禁欲的和尚。有了哲学，他十分明智，也不会沉沦在“魔鬼”手中。他不会弃绝青山绿水，也不会弃绝美人、诗歌和酒肉。但是他有深度，不可能披上纨绔子弟肤浅、愤世嫉俗的外衣。</strong>  </p>
<p>苏东坡身为通判，有一次曾裁决一件与和尚有关的案子。灵隐寺有一位和尚名叫了然，常到红灯区走动，爱上一个名叫秀奴的少女。后来他床头金尽，衣衫槛楼，秀奴就不肯见他了。有一天晚上他喝醉酒又去找那个女孩，吃了闭门羹，就强闯进去，将她打死。于是他被控杀人。官吏审问他，发现他臂上刺了两行诗：“但愿生同极乐国，免教今世苦相思。”调查完毕，证物送到苏东坡手中。苏东坡忍不住写下这一首词： 这个秃奴，修行忒煞，云山顶上空持戒。只因迷恋玉楼人，鹑衣百结浑无奈。 毒手伤心，花容粉碎，色空空色今安在，臂间刺道苦相思，这回还了相思债。 和尚被送到刑场处决。  </p>
<p>苏太太聪明贤慧，不想用错方法，把丈夫逼到妓女怀中。此外她知道她丈夫是一个妻子或皇帝都无法阻挡的人，她采取明智的作风——充分信任他。  </p>
<p>苏东坡个性复杂多变，很难了解。他是大哲学家，不可能变成清教徒，但他又是儒家子弟，不可能变成酒鬼。<strong>他了解生命，珍惜生命，不会把时光完全浪费在醇酒美人身上。他是自然诗人，怀有特殊健全的神秘人生观，往往和自然的了解密切融合。我相信任何一个人和自然、四季、雨、雪、山、谷那么接近，接受它的治疗，一定不会心思闭塞，具有封闭的人生观。</strong>  </p>
<p>这是苏东坡最沮丧的时期，说也奇怪，诗人最悲哀的时候却写出了最好的作品。照中国的标准，他在这段期间达到诗词的成熟期。愤怒与尖酸都过去了，只留下满心安详与去意。  </p>
<p>韩琦和欧阳修已逝。富弼和范镇辞官归隐。司马光潜心著作。张方平沉迷酒杯，东坡的弟弟明哲保身，一句话也不说。东坡不够圆滑。<strong>一个人亲眼看到百性受苦，这只是该不该忘掉一切后果表达心中感慨的问题。也许他从来没有考虑过。</strong>  </p>
<p><strong>现在苏东坡很受欢迎，不仅因为他对抗洪水成功，也因为他亲身关切狱囚的健康和利益，当时很少太守这么做。他亲自去看犯人，第一次派狱医照顾病患。苏东坡指出，法律虽禁止地方官鞭死囚犯，对囚犯病死或失于照顾而死，却没有明文规定。囚犯也是百姓。他遂赢得囚犯亲友的感激。</strong>  </p>
<p><em>每一个人都是平等的。</em>  </p>
<p>套一句苏东坡自己的话，他始终如蝇在食，吐之乃已，到目前为止还平安无事。但是他“吐”一百次，终于被捉了。  </p>
<p>苏东坡笑着对他们说了一个故事： 真宗时代，皇帝四处探访隐居的大学者，有人推荐杨朴。杨朴不愿入京，却被押到朝中见皇帝。 “听说你会写诗”皇帝说。 “不，我不会。”杨朴想掩饰自己的才华，不愿从政。 “朋友们送你出来，有没有人写诗给你？”皇帝又问。 “没有，”杨朴说，“只有臣妻写了一首。” “请问诗中写什么？”陛下问他。 于是杨朴把妻子送行的诗念给皇帝听。全诗如下： 更休落魄贪酒杯， 且莫猖狂爱咏诗。 今日捉将官里去， 这回断送老头皮。 苏太太听到这个故事，热泪盈眶，却忍不住笑出来。这个故事出现在东坡的笔记中，不知道是不是他临时杜撰的。  </p>
<p><em>幽默</em>  </p>
<p>外在的工作与责任隐藏了一个人的本性。去掉这些时势和传统的陷阱，真我就出现了。<strong>苏东坡回到百姓群中，有如水里的海豹；在陆地上摇鳍摆尾的海豹只是半只海豹而已。</strong>  </p>
<p>解放的生活使他的心灵产生蜕变，又反映到作品中。刻薄的讽刺、尖锐的笔锋、一切激情与愤怒都过去了，代之而起的是光辉、温暖、亲切、宽容的幽默感，绝对醇美，完全成熟。<strong>哲学的价值就是教人笑自己。就我所知，动物只有猩猩会笑，但是我相信只有人才会笑自己。</strong>不知道这能不能称为神祗的笑容。希腊诸神充满人性的错误和缺点，他们一定常常有机会自嘲一番；但是基督教的上帝或天使太完美了，不可能这样做。把这种自嘲的特色称为堕落人类独一的美德，该算是一大恭维吧。  </p>
<p>任何情况下，幸福都是一种秘密。但是研究苏东坡的作品，就不难探出他幸福的奥秘了。   这位慷慨的天才对世人的贡献远超过他从世上收取的一切，他到处捕捉诗意的片刻，化为永恒，使我们大家都充实不少。  </p>
<p>归去来兮，吾归何处……人生底事，来往如梭，待闲看秋风，洛水清波，好在堂前细柳，应念我莫剪柔柯。仍传语江南父老，时与晒鱼蓑。  </p>
<p><strong>到了南京，苏东坡去看王安石，后者现在已是疲惫的病老头了。他们一起谈诗论佛。双方都是大诗人，佛家弟子，有不少话可说。传说有一次两人比诗，同韵同题，苏东坡赢了。王安石中途放弃。谈话中苏东坡不免责备王安石招来战祸，迫害学者。</strong>  </p>
<p>事实上，奢华的日子和简朴的日子在幸福方面倒没有什么差别。只有不配作高官的人才羡慕高官的荣宠。通常不想作官的人为当局一心争取，想作官的人却又不够资格。一旦“官愿”满足了，做大官的乐趣不见得胜过成功的铁匠。  </p>
<p>乐事可慕，苦事可畏，皆是未至时心尔。及苦乐既至，以身履之。求畏慕者初不可得况，既过之后复有何物。  </p>
<p>当时的知识分子只有两条路可走，不是做官就是自甘淡泊——淡泊通常代表贫穷。当然人可以以潜心学术，得到永远的声名；但是对许多人来说，不朽的声名就算有把握，也只是空腹的自我安慰罢了。  </p>
<p>这些年来苏东坡不断在策论中说，“独立思考”和“公正无私”是好大臣的重要条件。但是独立思考和意见公正却是党人最讨厌的。  </p>
<p><strong>诗、书、画最主要的材料就是两种液体：酒和墨；他们有上好美酒，上好名墨，还有最好的毛笔和最珍贵的纸张。</strong>  </p>
<p>把中国书法当做一种抽象画，也许最能解释其中的特性。中国书法和抽象画的问题其实非常相似。判断中国书法的好坏，批评家完全不管文字的意思，只把它视为抽象的构图。它是抽象画，因为它并不描绘任何可辨的物体，与一般绘画不同。中国字是由线条所构成，线条组合千变万化，书法就是把这些字完美凑出来，而且要和同一行、同一页的其它字体相配合。中国字是由最复杂的成份所构成，不免呈现一切构图的问题，包括轴线、轮廓、组织、对比、平衡、比例等等，尤其注重整体的统一概念。 一切艺术的问题都是节奏的问题，无论绘画、雕刻或音乐都是一样。既然美感就是动感，每一种形式都有隐含的韵律。就连建筑方面亦然，哥德式的教堂仿佛在沉思。美学上甚至可以用“冲”、“扫”、“粗鲁”等人格的形容词，这些都是韵律的观念。  </p>
<p>这种动作的韵律美观念改变了一切技术家对线条、质量、表面、构图和材料的看法。若属于力学而非静态的美，一切全是平衡的直线画，像工程师的蓝图一般，那就不值得考虑了。相反的艺术家必须寻找扭曲不平的树枝线条，只因为弯曲扭转才能显出生命和运动。这种不平均的线条我们很容易看出生命和动作，其中敏感的压力、休止和扫动以及树枝偶然的哗啦声都仔细保存下来。国画和书法可以说有一项基本原则，除非必要——譬如画书桌和茶几——千万别用均衡的线条。构图的概念也变了。中国艺术家绝不以静态的安排、线面的对比为满足，因为这些线面都是死的。画家因此强调活线条，这是国画技巧和其它绘画的一大差别。  </p>
<p>为了培养活线条的基础，书法家便回头观察大自然。自然的线条总让人想起动作，变化永无止尽。善跑的灵堤猎犬结实光滑，自有一种美姿；而爱尔兰小诜多毛矮胖，又另是一番风味。我们可以欣赏小鹿的灵巧，同时又爱慕狮掌强大的肌力。小鹿身材优美，不仅因为轮廓匀称，也因为它让人想起跳跃的动作，狮掌优美则因为让人想起飞扑，就是这种飞扑和跳跃的功能使线条具有活生生的协调感。若追求这种韵律美，我们可以欣赏大象庞然的身躯，小蛇扭曲的张力，甚至长颈鹿枯瘦笨拙的动作。所以自然的韵律永远充满机能，只因为线条和轮廓都是生长过程的结果，具有一定的作用。借自然丰富的韵律，才能极度锻炼我们的鉴赏眼光。中国书法家挥笔时想模仿的就是这种自然的律动，也只有最敏感的画笔才能模摹出来。有些笔触稳定而圆熟，令人想起狮掌的威力；有些令人想起马足的肌力，节骨分明。有些想表现明快的清爽感，字体有肩、有腰、有支架，正如完美的女性，或者像中国批评家所说的“如美人鬓带鲜花”。有些想效法枯藤难摹的雅姿，末端形成温文安定的小卷，用几片细叶加以平衡。别忘枯藤的平衡最完美，因为末端弯曲的角度和形状要看藤蔓整个的重量——茎株的支持点和残叶在哪一边而定。  </p>
<p>在八大山人的鱼鸟或石涛的兰花中也许更能看出印象派艺术的极端例证。无论画鱼画鸡画鸟，八大山人的画可以说是用最少线条、最少墨汁来表现最多的韵味。大艺术家只花几分钟，迅速泼墨完成一张鱼、马或人像图；不是成功就是失败，万一失败他就把纸条揉成一团，丢入字纸篓中，从头来起。  </p>
<p>我前面已说过，在位党和反对党也没有明确的权责。多数党统治的机能并不存在。于是政治游戏便成为个人之间的斗争，比西方更剧烈。<strong>但是东西方的政治规则完全一样：爬到顶端的一定是庸才。</strong>  </p>
<p>第一，好政客要会说一大堆话，却不透露任何消息。好官决不肯定什么，只用否定。只要学会“无可奉告”、“你说得对”等至理名言，好官就可以无往而不利。第二、他应该施惠于朋友。第三、他应该小心不得罪人。一个人如果不随便说话，爱用文雅、细柔、愉快的低语，又很喜欢施小惠给人家，他就算不位极人臣，也不会失势。他到死都有官做。  </p>
<p>苏东坡逃避政治，政治却在追逐他。他和司马光政见不合——<strong>独立的心灵永远不会完全一致</strong>——但是他到京师半年，司马光就去世了。苏东坡陷入显赫遭忌的地位。  </p>
<p>他维护意见不一的原则。信中指出，<strong>“若上之所可，不问其是非，下亦可之。上之所否，不问其曲直，下亦否之”</strong>，对国家并没有好处。君主和大臣应该互相提供意见，如果百官唯唯诺诺，就变成孔子所谓“足以丧邦”的跟屁虫了。  </p>
<p>当时政府最大的间题——中国每一朝代都是如此——就是冗官充斥。文人太多，官位太少，在“学而优则仕”的中国社会成为经常存在的弊端。除非现在能改变此一观念，否则教育普及就能把国家拖垮。我们要如何提供四亿五千万知识分子的官位呢？如果公职制度严格遵行，用人惟才，则考中的人数自然有限，素质也会提高。但是苏东坡时代已盛行亲族主义。  </p>
<p>事实上他已决心离开朝廷。他说君子如麟凤难求，小人<strong>“易进如蛆蝇，腥膻所聚，瞬息千万”</strong>。  </p>
<p>“聚蚊成雷，积羽成舟，寡不胜众也”。  </p>
<p>苏东坡对于这种零碎、没有组织的救病工作并不满意，他由政府基金拨出两千缗，自己又捐了五十两金子，在城中心众安桥建了一座公立医院。就我所知，这个“安乐坊”是中国最早的公立医院。三年内曾医过一千个病人，主管医院的道士由政府赠以紫袍和金钱。后来医院搬到湖边，改名“安济坊”，苏东坡离开后还继续看病。  </p>
<p>太后死前十天，范纯仁和苏子由等六位大臣进去看她。 “我大概无法复原了，”太后说，“不能长期看着你们。你们要尽力侍候小皇帝。” 大臣即将告退，太后指名要范纯仁留下来。于是哲宗叫别人退开，只剩范纯仁和吕大防。 朝中传闻太后谋反，要立自己的儿子为帝，太后问道，“皇上年幼，神宗托老身治国。九年里你们可曾看我特别照顾高家？” “没有，”吕大防说，“太后未曾厚待娘家，一切以邦国为重。” “正是如此，”太后含泪说，“所以老身临死才见不到自己的儿子和女儿。”她并没有派儿子在京师做官。 “太后必能康复，”吕大防说，“请听医生的劝告。您现在不该说这些事情。” “不，”太后说，“今天当你们的面，我要对皇上说几句话。我知道我死后很多大臣会愚弄他。孙子，你该当心。”她转向吕大防和范纯仁说：“我觉得老身死后，你们还是辞官归隐吧，小皇帝会用新人。” 她问侍从宫中有没有请大臣吃饭，她对吕大防和范纯仁说：“现在去用餐吧。明年此日，请记得老身。”  </p>
<p>一个王朝的悲剧在于皇后们有必要接连生出善良、聪明、能干的儿子、孙子和曾孙，皇室才能长保权位——这是生物学上人类从来没有听过的不保险假设。天才不生天才，迟早贤明的君主会生出邪恶、昏庸的后代。  </p>
<p>中国历史上若有一个时期可以称得上残暴与混乱的时代，那就是蔡京手下的政府了。他替皇帝建设精美的乐园，在中国历史中写下最可怕的一页，因为皇家乐园也用不着国人付出那么多悲惨的代价呀。园中每一块异石，每一朵奇花都曾牺牲几条人命。读到徽宗和大臣们赞美这个花园、假山、清溪、异石的诗句，我们不禁脊骨发冷，感受到中国文学史上从未有过的悲剧。悲剧在于作者并不知道这些。  </p>
<p>章惇劝皇帝挖司马光的坟墓，打烂棺材，鞭尸示众，以警告所有不忠的臣民。在小皇帝心目中，司马光变成元祐时代奸诈、不忠、邪恶的象征。上朝的时候大家都表示赞成，只有许将不说话。小皇帝打量他，退朝后叫他留下来。  </p>
<p>他转念一想：<strong>“此间有什么歇不得处。由是心若挂钩之鱼忽得解脱。若人悟此，当恁么时也不妨熟歇。”</strong>  </p>
<p>他又恢复了自然的本性。他在广州曾买了一些檀香，现在他常关门静坐，享受奇特的异香，反省自己以往的错误。有时午后小睡一回，凉爽的江风吹进窗口，房顶的鸟鸦打断他的幽梦，他突然觉得自己卸下一切责任。他看到大江的光影射入他房中。真美，他暗自说，美得像清空的明月。他不懂为什么有人喜欢云中的翳月。他觉得晴空是光明磊落的象征。  </p>
<p>苏东坡写过一篇酒颂。就是不解杯中乐趣的人读到他描写半痴半醉的幸福状态也会为之入迷： “浊醪有妙理赋 酒勿嫌浊，人当取醇。失忧心于昨梦，信妙理之疑神……仔人之生，以酒为命。常因既醉之适，人识此心之正。稻米无知，岂解穷理。麴栗有毒，安能发性，乃知神物之自然，盖与天工而相并。得时行道，我则师齐相之饮醇。远害全身，我则学徐公之中圣。湛若秋露，穆如春风。疑宿云之解驳，漏朝日之暾红。初体栗之失去，旋眼花之扫空……兀尔坐忘，浩然天纵。如如不动而体无碍，了了常知而心不用。座中客满。惟忧百種之空。身后名轻，但觉一杯之重。今夫明月之珠，不可以襦，夜光之璧，不可以哺。刍肉饱我而不我觉，布帛袄我而不我娱。惟此君独游万物之表，盖天下不可一日而无。在醉常醒，孰是狂人之乐。得意忘味，始知至道之腴。”  </p>
<p>她是虔诚的佛教徒，临死还念着《金刚经》的一道偈/jié/语： <strong>一切有为法， 如梦幻泡影。 如露亦如电， 应作如是观。</strong> 根据她的遗嘱，苏东坡将她安葬在城西丰湖边的山脚上，靠近一座亭台和几间佛寺。墓后有山溪瀑布流入湖中。  </p>
<p>玉骨那愁瘴雾，冰肌自有仙风。海仙时遣探花丛，倒挂绿毛么凤。 素面常嫌粉污，洗妆不退唇红。高情已逐晓云空，不与梨花同梦。  </p>
<p>苏东坡自以为晚年可以定居惠州，没想到突然被贬到海外。新居落成两个月，移居海南岛的命令就来了。有人记载说，他写了两行诗描述他在春风中小睡，聆听屋后庙院钟声的情景。章惇读到这段诗，就说：“原来苏东坡那么惬意。”于是颁布了移居的命令。  </p>
<p>但是他不屈的灵魂和人生观不容许他失去生活的乐趣：“尚有此身付与造物者，听其运转流行坎止无不可者。故人知之，免忧热。”他写信给一位朋友说。  </p>
<p>“吾始至南海，环视天水无际，凄然伤之曰‘何时得出此岛也’。已而思之：天地在积水中，九洲在大浪海中，中国在少海中。有生孰不在岛者。譬如注水于地，小草浮其上，一蚁抱草叶求活，已而水干，遇他蚁而泣日‘不意尚能相见尔’。小蚁岂知瞬间竟得全哉？思及此事甚妙。与诸友人小饮后记之。” 苏东坡也许是倔强，也许是真的掌握了自己。至少他从未失去幽默感。  </p>
<p>苏东坡曾经对他弟弟说：“我上可以陪玉皇大帝，下可陪卑田院乞儿。在我眼中天下没有一个不是好人。”现在他和默默无闻的穷学者、农夫农妇交往。他和这些纯朴小民谈话不必有戒心，自由自在，最能表现自己。家里一天没有客人他就不自在，别人不来他就出去拜访邻居。和黄州时期一样，他与高官、平民、学者、农夫杂处。聊天总是他发言；他天生爱说话。但是他也希望别人开口。他带着海南种的大犬“乌嘴”到处闲逛。他和村民坐在槟榔树下，想畅谈一番。无知的穷农夫能对他说什么呢？农夫对这位大学者敬畏万分，“我们不知道要谈什么。”苏东坡说：“那就谈鬼吧，说几个鬼故事来听听。”对方会说他们没听过什么好的鬼故事，他说：“没关系，就谈你们听过的好了。”后来苏过告诉朋友，他父亲如果一天没看到客人，就好像有什么不对劲似的。  </p>
<p>小屋完成后的两年半期间，苏东坡过着无忧无虑却十分贫穷的生活。他有两位妙友，一个是替他转信的广州道士何德顺，另一位是四处游荡，送他食物、药物、米、泡菜、书本的小学者（吴复古）。  </p>
<p>他写了不少有关药草的笔记，我要特别谈谈荨麻治风湿的办法，荨麻含有荨麻素和黄体素，像毒藤似的，碰到皮肤就会肿痛。照他的说法，把荨麻敷在风湿起始的肿痛关节上，全身各处的酸痛都会停止。他还热烈信仰苍耳。苍耳到处都有，对人无害，不管吃多久怎么吃都可以（含有脂肪，少量树胶、维他命C1和耳醣）。他写下苍耳白粉碾制的办法，把叶灰用温火烧二十四小时就成了。白粉吃下去据说可以美化皮肤，“满肌如玉’。有些笔记谈到蔓菁、芦菔和苦荠，苏东坡称为‘葛天氏之遗民”的美食，价值高，味道又好吃。  </p>
<p>他请子由写序，在一封信中说：“然吾于渊明，岂独好其诗也哉。如其为人，实有感焉。”很多崇拜苏东坡的人也会这样说。  </p>
<p><strong>徽宗继位时，国家的命脉已经腐蚀削弱。有个性、有才华、有正义感的君子是文明社会的珍贵产物，需要长时间培养茁壮。司马光、欧阳修、范纯仁、吕公著的时代过去了，那一代的人已经分别下狱、流放、病死、老死或被杀。独立批评，勇敢思考写作的气氛已经僵化，整个政治生命都污染了。苏东坡师徒因言论而受罪，不愿意再入政坛，何况政风又对他们不利。皇帝一声命令，不可能马上有一群正直、博学、大无畏的学者出现朝中。己尝了八年权力滋味的大批政客更不可能放弃权位。</strong>  </p>
<p>显然神宗皇后和她婆婆一样，善于感受国家的利益，她们具有单纯的女性本能，会判断好人坏人。<strong>批评家和历史家迷恋优美的文辞和抽象的特征，善于研究某一时期深奥的问题和政策，却忘记我们看人最后总逃不过“好”、“坏”这两个形容词。总括一个人的事迹和个性，“好人”就是最高的赞美。苏东坡服侍的太后们似乎从来不管政府领袖的问题和政策。当然章惇是一个坚强果断的人。惠卿是雄辩家。蔡京生气勃勃、精明能干。但太后一概把他们归类成坏人。</strong>  </p>
<p>他本来想等福建大船，苦等不来，就随吴复古、苏过和爱犬（乌嘴）渡海，一行人到雷州去找秦观。吴复古又失去踪影。苏东坡和吴复古一生游遍全中国，不同的是苏东坡被别人的命令赶来赶去，吴复古却是自愿飘泊。追忆往事，苏东坡似乎恨不能和他的朋友交换际遇。那样一定快乐得多，也自由得多。  </p>
<p>他在广州受到热诚的招待。他到海南岛第二年，有人传说他死了。有一位朋友在宴席上开玩笑说： “我以为你死了。” 苏东坡说：“不错，我死了，在地府半路上碰到章惇，我又决定折回来。”  </p>
<p>大家庭有不少小孩和年轻的妇女，他们就乘船到南雄。<strong>没走多远，吴复古和一群和尚追上他们，陪老苏畅游了几天。然后吴复古突然病倒去世，一切都那么简单。苏东坡问他临终有什么交代。吴复古笑笑合上了眼睛。</strong>  </p>
<p>苏东坡最初和最终的乐趣都是写作。他把自己在南方所写的诗文拿给钱世雄看，眼睛闪闪发光，似乎忘记了一切。有时候他还能写短简和题跋，其中包括一篇桂酒颂，他知道好友会仔细珍藏，就把这篇文章送给钱世雄。  </p>
<p><strong>苏东坡缓缓低语：“西天也许存在，不过设法到那儿也没有用。”钱世雄站在旁边，就对他说：“尤其这个时候，你一定要试试看。”苏东坡最后一句话是“试就不对了”。那就是他的道家哲学，解脱在于自然而不自觉的善行。</strong>  </p>
<p>由尘世的标准来说，苏东坡的一生相当坎坷不幸。有一次孔子的门生问起两个为信念而饿死的古圣人。门生问孔子，伯夷叔齐死前有没有悔意。孔子说：“他们求仁而得仁，为什么要后悔呢？” 苏东坡今生的“浩然之气”己经用光。人生不过是性灵的生活，而性灵是控制人类事迹和个性的力量，与生俱来，只能靠生命和际遇和环境来表现。正如苏东坡的描写：<strong>“浩然之气不依形而立，不恃力而行，不待生而存，不随生而亡矣。故在天为星辰，在地为河岳，幽则为鬼神，而明则复为人。此理之常，无足怪者。”</strong>  </p>
<p><strong>读到苏东坡的生平，我们等于追察人类心智和性灵暂时显现在地球上的生命。苏东坡死了，他的名字只是一段回忆，但是他却为我们留下了他灵魂的欢欣和心智的乐趣，这些都是不可磨灭的宝藏。</strong></p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>苏东坡</tag>
      </tags>
  </entry>
  <entry>
    <title>《祭亡妻程氏文》 苏洵</title>
    <url>/202002/%E7%A5%AD%E4%BA%A1%E5%A6%BB%E7%A8%8B%E6%B0%8F%E6%96%87/</url>
    <content><![CDATA[<p>与子相好，相期百年。不知中道，弃我而先。</p>
<p>东坡刚考中准备做官的时候，他的母亲去世了，她临死还没有听到京师的好消息。《苏东坡传》中林语堂先生引了苏洵的《祭亡妻程氏文》的一段话：“我归旧庐，无不改移。魂兮未泯，不日来归。”</p>
<p>昨晚读到这里的时候有被触动。今天去找来了原文查词典把文章理顺了。</p>
<p>呜呼！与子相好，相期百年，不知中道，弃我而先。  </p>
<p>我徂京师，不远当还；嗟子之去，曾不须臾。子去不返，我怀永哀。反复求思，意子复回。  </p>
<p>人亦有言，死生短长，苟皆不欲，尔避谁当，我独悲子。  </p>
<p>生逢百殃，有子六人，今谁在堂？唯轼与辙，仅存不亡。咻呴抚摩，既冠既昏，教以学问，畏其无闻。昼夜孜孜，孰知子勤？  </p>
<p>提携东去，出门迟迟。今往不捷，后何以归？二子告我，母氏劳苦，今不汲汲，奈后将悔。大寒酷热，崎岖在外。亦既荐名，试于南宫。文字炜炜，叹惊群公。二子喜跃，我知母心，非官实好，要以文称。  </p>
<p>我今西归，有以藉口。故乡千里，期母寿考。归来空堂，哭不见人。伤心故物，感涕殷勤。  </p>
<p>嗟予老矣，四海一身。自子之逝，内失良朋。孤居终日，有过谁箴？  </p>
<p>昔予少年，游荡不学，子虽不言，耿耿不乐。我知子心，忧我泯没，感叹折节，以至今日！ 呜呼死矣！不可再得。  </p>
<p>安镇之乡，里名可龙，隶武阳县，在州北东。有蟠其丘，惟子之坟。凿为二室，期与子同。骨肉归土，魂无不之。我归旧庐，无不改移。魂兮未泯，不日来归。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
  </entry>
  <entry>
    <title>《极简欧洲史》读书笔记</title>
    <url>/202002/%E6%9E%81%E7%AE%80%E6%AC%A7%E6%B4%B2%E5%8F%B2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/11/EG6KiIgvJp5sq4m.png" alt=""></p>
<span id="more"></span>
<p>从2019年年底到2020年年初我一直在读的这本书——《极简欧洲史》，我应该不会向身边的人推荐这本书，因为这是一本比较枯燥的历史课本。唯一能让我对历史提起兴趣的描写性语言少之又少。在我读到大概三分之二的时候就想放弃，然而最后还是因为微职的读书小组坚持读下来了。这本书越往后节奏越快，到后面快要变成了流水账。不过通过这本书我也做了非常多的思考：像我这样对历史毫无兴趣的理科生还需不需要读历史？有没有更舒服的、更有趣地了解历史的方式？</p>
<blockquote>
<p>本书的内容原本是授课用的讲义，目的是让澳大利亚的大学生对欧洲历史有个初步的认识。但身为老师的我并不是从最前面开始，按部就班讲到最后。我的做法是先为学生很快地做个概论，再回头补充细节。<br>——《极简欧洲史》引言</p>
</blockquote>
<p>既然整本书都只是知识性的，那这本书的读书笔记应该是一份复习提纲。然而我并没有按照书的逻辑做摘录，而是仅仅把其中触动我的一些文字摘录了出来。现在回去看，这些摘录并不是关于“历史”的，而是关于“人”的。</p>
<blockquote>
<p>在雅典，死刑通常都是立刻执行，这次却往后推迟了，因为宗教庆典的关系。苏格拉底大可趁机潜逃，说不定那些官员还暗自希望他逃之夭夭，但他却拒绝逃跑。他问：“既然我不能永远活着，那又何必苟且偷生？活着不是目的，好好活着才是。我曾在雅典的法治下过着很好的生活，如今我已准备好接受惩罚。”直到最后一刻，他还是充满了哲学思辨。直到他的镣铐被取下，他还在发表高论，说痛苦和享乐只是一线之隔。<br>他被判处服毒芹汁自绝，必须在一日将尽时服下毒药，他的弟子求他晚点再喝，现在太阳还没下山呢！苏格拉底回复道，要是他这样偷生，自己看了都觉得荒谬，他平静地接过毒药一饮而尽，全无半点神伤，很快就药效发作而亡。</p>
<p>“他该受到什么报应，”鲁克丽丝说，“我交由你们决定。至于我，虽然失节非我之过，但我要接受自己的惩罚。失贞的女人应该得到什么报应，我绝不会首开避脱的先例。”话声甫落，她便从衣袍中掏出一把刀刺入心脏，应声倒下，就此香销玉殒。她的父亲和丈夫哀恸欲绝。两人只能呆立着无助地哭泣，但布鲁图斯拔出鲁克丽丝胸前染血的刀，举着它高喊：“我要对这位烈女的血发誓：在她被暴君蹧蹋之前，没有人比她更为贞洁，我也对上帝发誓，我要借助刀剑、烈火以及所有能让我更强大的东西，追捕骄傲者塔克文、邪恶的王后及其所有的子女，绝不让他们任何人再登上罗马的王座。”</p>
<p>拿破仑是启蒙运动之子，深信革命所揭橥的诸多原则，却不相信人民有权统治自己。自1789年之后，法国在这个志业上可说是节节落败，拿破仑的政见因此非常吸引人。他是独裁者中最有魅力的一个，他不准任何团体享有特权，所有国民一律得到平等对待，国家提供所有孩童受教育的机会，所有职务都要公开选才。他延揽各方人才进入政府，无论是保王派还是共和派，雅各宾恐怖政权的支持者还是反对者，完全不计较他们过去在革命中扮演的角色。他只交给他们一个使命：创立一个有理性、有秩序的政府体制。</p>
<p>你一定会喜欢这些平民百姓。他们很脏很臭，看来很不讨喜，因为他们一年到头无分寒暑地日夜操劳，形容憔悴、伤痕累累、营养不良、疾病缠身。那为什么你还会喜欢他们？<br>因为他们的命运很容易追踪；百年复百年，他们做的都是同样的事，几乎所有的人都在耕种。</p>
</blockquote>
<p>历史是枯燥的，但历史河流中的每个人都是鲜活的。我们可以通过面对死亡时平淡和毅然的苏格拉底去了解雅典的法庭；通过坚贞的鲁克莉丝了解罗马共和政体的开启；通过飒爽的拿破仑了解法国的革命。当我们从人的角度切入历史的时候，我们可以收获更多的共鸣。《中国的历史精神》里说“历史便即是人生”，因为历史确实是由无数的人生构成的。历史本身就是我们人生整个过往的经验。</p>
<p>当我发现人物对于历史的重要性之后，也明确了自己想要了解历史的一个更好的途径应该是人物传记。所以也从自己最喜欢的苏轼开始读《苏东坡传》，上一周的读书时间也比较开心，不仅仅是因为苏轼本身就是一个很有意思的人，林语堂的文风也比较轻松诙谐。苏轼身上的纯真相当感染人，也对我自己面对选择的态度有挺大的触动。希望这周能把《苏东坡传》读完吧。</p>
<p>以古为鉴，可知兴替；以人为鉴，可正德身。</p>
<div style="text-align:right">——唐太宗</div>


<!-- more -->]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>极简欧洲史</tag>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title>【2020.02.03 - 2020.02.09】 一周记录</title>
    <url>/202002/%E4%B8%80%E5%91%A8%E8%AE%B0%E5%BD%95week1/</url>
    <content><![CDATA[<p>一周记录图片<br><span id="more"></span></p>
<p><a href="https://sm.ms/image/YwJeVioaBI41MuK" target="_blank"><img src="https://i.loli.net/2020/02/10/YwJeVioaBI41MuK.jpg" alt="week1.jpg"></a></p>
]]></content>
      <categories>
        <category>一周记录</category>
      </categories>
  </entry>
  <entry>
    <title>数据预处理</title>
    <url>/201911/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>代码实现：（由于时间原因，这里忽略了各方法的参数的意义和方法）<br>4.1.3 数据可视化实例  </p>
<ol>
<li>显示各列名称</li>
<li>数据的快速统计汇总，包括平均数、最大最小点和分位点等</li>
<li>频度分布图</li>
<li>偏态和峰度</li>
<li>散点图 scatter plot</li>
<li>箱线图 box plot</li>
<li>相关矩阵 correlation matrix</li>
</ol>
<span id="more"></span>
<p>4.2.1 用Python进行缺失值处理</p>
<ol>
<li>创造缺失数据</li>
<li>查看缺失率</li>
<li>将缺失的行全部删去</li>
<li>使用均值填充缺失值</li>
</ol>
<p>4.2.3 异常值的检测和处理  </p>
<ol>
<li>计算平均值和标准差（计算均值）</li>
<li>绘制数据密度曲线</li>
<li>根据$3/sigma$原则检验异常值并剔除</li>
<li>使用箱线图查看数据分布</li>
<li>计算分位差</li>
<li>根据分位差的上下限筛选出异常值error，剔除异常值</li>
</ol>
<p>4.3.4 元组重复<br>如何使用卡方值，相关系数与协方差进行删除冗余与相关分析。</p>
<ol>
<li>选取两个属性计算卡方值，若两个数据完全相关，可以删掉一个属性来消除冗余。</li>
<li>选取两个属性计算协方差和相关系数，若发现两个属性存在相关性，但并不是完全相关，不能删除其中任何一个属性。</li>
</ol>
<p>4.4.2 维规约<br>PCA：又称K-L方法，搜索k个最能代表数据的n维正交向量，其中k&lt;=n。这样，原来的数据投影到一个小得多的空间上，实现维规约。<br>属性子集选择<br>这一节选择了Boston房价数据集，分别使用PCA方法和逐步向前选择的属性子集选择方法进行维规约。</p>
<p>4.5.2 规范化<br>把属性数据按比例缩放，使之落入一个小区间。  </p>
<ol>
<li>最大-最小规范化</li>
<li><code>Z-score</code>规范化</li>
<li>小数定标规范化</li>
</ol>
<p>4.5.3 离散化<br>通过把数值属性的原始值用区间标签或概念标签替换。这种方法可以自动地产生数据的概念分层，而概念分层允许在多个粒度层进行挖掘。</p>
]]></content>
      <categories>
        <category>数据科学导论</category>
      </categories>
      <tags>
        <tag>数据预处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Price Suggestion Chanllenge</title>
    <url>/201911/Price_Suggestion_Chanllenge/</url>
    <content><![CDATA[<h1 id="Price-Suggestion-Chanllenge"><a href="#Price-Suggestion-Chanllenge" class="headerlink" title="Price Suggestion Chanllenge"></a>Price Suggestion Chanllenge</h1><h2 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p>考虑到网上销售的产品数量，产品定价在规模上变得更加困难。服装有很强的季节性定价趋势，受品牌影响很大，而电子产品价格根据产品规格波动。如何根据以往信息进行合理定价，有效地帮助商家进行商品的销售是一个有意义的问题。</p>
<span id="more"></span>
<h3 id="分析目标"><a href="#分析目标" class="headerlink" title="分析目标"></a>分析目标</h3><p>通过给出的商品描述、商品类别和品牌信息，并结合训练数据中的商品价格来给新商品定价格。Eg ：<br><img src="image/1-1.png" alt=""></p>
<p>显然 <code>Versace</code> 的衣服价格上应该远高于美特斯邦威的衣服，并且在商品描述中，可以发现两者描述有细微差别。 </p>
<blockquote>
<p>本 project 旨在对文本信息进行分析，提取文本信息中重要信息，推导出和价格之间的潜在关系 </p>
</blockquote>
<h3 id="数据字段分析"><a href="#数据字段分析" class="headerlink" title="数据字段分析"></a>数据字段分析</h3><p><img src="image/1-2.png" alt=""></p>
<h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><ul>
<li><code>train.csv</code> 训练集 （含price）</li>
<li><code>test.csv</code> 测试集 (不含price) ; <code>label_test.csv</code> 测试集 中对应的 <code>price</code></li>
<li><code>f_test.csv</code> 最终的评价数据集 （不含 <code>price</code> ）</li>
</ul>
<h3 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h3><p>评价的使用的是 <code>Mean Squared Logarithmic Error</code>: 计算的方式如下</p>
<script type="math/tex; mode=display">MSLE = \cfrac{1}{n}\sum_{i=1}^n(log(p_i+1)-log(\alpha_i+1))^2</script><p>其中$n$代表测试集的样本数；$p_i$代表的是预测的商品价格值；$\alpha_i$代表实际的销售价格。</p>
<h3 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h3><p>提交的最后文件内容为：  </p>
<ul>
<li>最终代码文件（请写清楚使用了那些库，以及相应库的版本，可使用 <code>pip list</code> 命令查看版本，确保能顺利运行）</li>
<li>在 <code>f_test.csv</code>数据集上的结果</li>
<li>分析文档<br>请不要是简单的代码粘贴，加入分析过程<br>将你对于数据的理解记录下来，简单来说，缺失值处理这种基本操作<br>写出你的尝试的各种方法，为了解决rank太低的情况下分数太低<br>写一份同学负责哪一部分代码，每一部分没有区别，主要是为了给代码风格打分。  </li>
</ul>
<h3 id="提交结果文件格式"><a href="#提交结果文件格式" class="headerlink" title="提交结果文件格式"></a>提交结果文件格式</h3><ul>
<li>结果文件名为</li>
<li>提交格式<ul>
<li>第一行为 test_id \t price 的表头</li>
<li>接下来的每行为id \t predict_price</li>
</ul>
</li>
</ul>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p><em>这次实验难度很大，我们所有参考资料均在实验报告的末尾注明</em></p>
<h3 id="一、样例代码的学习"><a href="#一、样例代码的学习" class="headerlink" title="一、样例代码的学习"></a>一、样例代码的学习</h3><p>首先尝试了给出的样例代码，了解了解决这个问题的大致思路。解决这个价格预测问题的主要过程是：导入数据和数据探索、数据预处理、模型构建、价格预测和测评。</p>
<h4 id="导入数据和数据探索"><a href="#导入数据和数据探索" class="headerlink" title="导入数据和数据探索"></a>导入数据和数据探索</h4><p>导入数据和初步了解数据<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data = pd.read_csv(<span class="string">&#x27;../data/4/train.csv&#x27;</span>, sep=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">test_data = pd.read_csv(<span class="string">&#x27;../data/4/test.csv&#x27;</span>,sep=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">train_data.info()</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;</span><br><span class="line">RangeIndex: 300000 entries, 0 to 299999</span><br><span class="line">Data columns (total 8 columns):</span><br><span class="line">train_id             300000 non-null int64</span><br><span class="line">name                 300000 non-null object</span><br><span class="line">item_condition_id    300000 non-null int64</span><br><span class="line">category_name        298719 non-null object</span><br><span class="line">brand_name           171929 non-null object</span><br><span class="line">price                300000 non-null float64</span><br><span class="line">shipping             300000 non-null int64</span><br><span class="line">item_description     300000 non-null object</span><br><span class="line">dtypes: float64(1), int64(3), object(4)</span><br><span class="line">memory usage: 18.3+ MB</span><br></pre></td></tr></table></figure></p>
<h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><p>首先处理属性，训练数据首先要删去<code>price</code>，再去掉没有用处的 <code>train_id</code> 或者 <code>test_id</code>。通过观察上面的数据属性可知 <code>category_name</code> 和 <code>brand_name</code>有数据缺失，样例代码直接用 <code>missing</code>填充。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">featureProcessing</span>(<span class="params">df</span>):</span><br><span class="line">    <span class="comment"># delete the data that will not be used</span></span><br><span class="line">    df = df.drop([<span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;test_id&#x27;</span>, <span class="string">&#x27;train_id&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># deal with the missing value with a default value</span></span><br><span class="line">    df[<span class="string">&#x27;category_name&#x27;</span>] = df[<span class="string">&#x27;category_name&#x27;</span>].fillna(<span class="string">&#x27;missing&#x27;</span>).astype(<span class="built_in">str</span>)</span><br><span class="line">    df[<span class="string">&#x27;brand_name&#x27;</span>] = df[<span class="string">&#x27;brand_name&#x27;</span>].fillna(<span class="string">&#x27;missing&#x27;</span>).astype(<span class="built_in">str</span>)</span><br><span class="line">    df[<span class="string">&#x27;item_description&#x27;</span>] = df[<span class="string">&#x27;item_description&#x27;</span>].fillna(<span class="string">&#x27;No&#x27;</span>)</span><br><span class="line">    <span class="comment"># convert the data : int -&gt; str</span></span><br><span class="line">    df[<span class="string">&#x27;shipping&#x27;</span>] = df[<span class="string">&#x27;shipping&#x27;</span>].astype(<span class="built_in">str</span>)</span><br><span class="line">    df[<span class="string">&#x27;item_condition_id&#x27;</span>] = df[<span class="string">&#x27;item_condition_id&#x27;</span>].astype(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure></p>
<h4 id="模型构建"><a href="#模型构建" class="headerlink" title="模型构建"></a>模型构建</h4><p>首先做模型的输入，通过<code>CountVectorizer</code> 和 <code>TfidfVectorizer</code>生成词频的矩阵， <code>Tfidf</code> 的效果更优，因为考虑了各词在所有字段钟出现的次数，生成的词频矩阵是带有权重的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vectorizer = FeatureUnion([</span><br><span class="line">    (<span class="string">&#x27;name&#x27;</span>, CountVectorizer(ngram_range=(<span class="number">1</span>, <span class="number">2</span>), max_features=<span class="number">50000</span>, preprocessor=build_preprocessor_1(<span class="string">&#x27;name&#x27;</span>))),</span><br><span class="line">    (<span class="string">&#x27;category_name&#x27;</span>, CountVectorizer(token_pattern=<span class="string">&#x27;.+&#x27;</span>, preprocessor=build_preprocessor_1(<span class="string">&#x27;category_name&#x27;</span>))),</span><br><span class="line">    (<span class="string">&#x27;brand_name&#x27;</span>, CountVectorizer(token_pattern=<span class="string">&#x27;.+&#x27;</span>, preprocessor=build_preprocessor_1(<span class="string">&#x27;brand_name&#x27;</span>))),</span><br><span class="line">    (<span class="string">&#x27;shipping&#x27;</span>, CountVectorizer(token_pattern=<span class="string">&#x27;\d+&#x27;</span>, preprocessor=build_preprocessor_1(<span class="string">&#x27;shipping&#x27;</span>))),</span><br><span class="line">    (<span class="string">&#x27;item_condition_id&#x27;</span>, CountVectorizer(token_pattern=<span class="string">&#x27;\d+&#x27;</span>, preprocessor=build_preprocessor_1(<span class="string">&#x27;item_condition_id&#x27;</span>))),</span><br><span class="line">    (<span class="string">&#x27;item_description&#x27;</span>, TfidfVectorizer(ngram_range=(<span class="number">1</span>, <span class="number">3</span>),max_features=<span class="number">100000</span>, preprocessor=build_preprocessor_1(<span class="string">&#x27;item_description&#x27;</span>))),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>利用岭回归，实现价格预测。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ridgeClassify</span>(<span class="params">train_data, train_label</span>):</span><br><span class="line">    ridgeClf = Ridge(</span><br><span class="line">        solver=<span class="string">&#x27;auto&#x27;</span>,</span><br><span class="line">        fit_intercept=<span class="literal">True</span>,</span><br><span class="line">        alpha=<span class="number">0.5</span>,</span><br><span class="line">        max_iter=<span class="number">500</span>,</span><br><span class="line">        normalize=<span class="literal">False</span>,</span><br><span class="line">        tol=<span class="number">0.05</span>)</span><br><span class="line">    <span class="comment"># 训练</span></span><br><span class="line">    ridgeClf.fit(train_data, train_label)</span><br><span class="line">    <span class="keyword">return</span> ridgeClf</span><br></pre></td></tr></table></figure><br>通过对数据集的了解和对样例代码的学习，我们了解到优化这个问题的答案有三个角度可以入手：</p>
<ol>
<li>数据预处理：怎样处理缺失值？数据该怎样结合？</li>
<li>形成词频矩阵时进行优化：调整 <code>CountVectorizer</code> 和 <code>TfidfVectorizer</code> 的参数</li>
<li>模型的选择和优化：尝试岭回归之外的模型、调整模型参数。</li>
</ol>
<h3 id="二、尝试更多的模型"><a href="#二、尝试更多的模型" class="headerlink" title="二、尝试更多的模型"></a>二、尝试更多的模型</h3><p>在上面的样例代码中，利用岭回归模型得到的结果是3.01左右。经过之前课上的提示和网上的资料查找，我们准备再去尝试一下 <code>MLP</code>模型和 <code>Lgmb</code>模型。在粗略的尝试了两个模型之后我们决定进一步利用 <code>MLP</code> 进行下一步的优化。</p>
<h4 id="MLP"><a href="#MLP" class="headerlink" title="MLP"></a><code>MLP</code></h4><p><code>MLP</code> 模型的结果如下：<br><img src="image/2-2.png" alt=""></p>
<h4 id="LGBM"><a href="#LGBM" class="headerlink" title="LGBM"></a><code>LGBM</code></h4><p><code>Lgbm</code> 模型的结果如下：<br><img src="image/2-1.png" alt=""></p>
<h4 id="MLP-和-LGBM-结合"><a href="#MLP-和-LGBM-结合" class="headerlink" title="MLP 和 LGBM 结合"></a><code>MLP</code> 和 <code>LGBM</code> 结合</h4><ol>
<li>特征处理</li>
</ol>
<ul>
<li>导入数据集</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读文件</span></span><br><span class="line">   train = pd.read_csv(<span class="string">&#x27;data/train.csv&#x27;</span>, sep=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">   test = pd.read_csv(<span class="string">&#x27;data/test.csv&#x27;</span>, sep=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">   <span class="comment"># 训练数据和测试数据一起处理</span></span><br><span class="line">   df = pd.concat([train, test], axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>缺失值处理</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对缺失值进行处理</span></span><br><span class="line">   df[<span class="string">&#x27;category_name&#x27;</span>] = df[<span class="string">&#x27;category_name&#x27;</span>].fillna(<span class="string">&#x27;MISS&#x27;</span>).astype(<span class="built_in">str</span>)</span><br><span class="line">   df[<span class="string">&#x27;brand_name&#x27;</span>] = df[<span class="string">&#x27;brand_name&#x27;</span>].fillna(<span class="string">&#x27;missing&#x27;</span>).astype(<span class="built_in">str</span>)</span><br><span class="line">   df[<span class="string">&#x27;item_description&#x27;</span>] = df[<span class="string">&#x27;item_description&#x27;</span>].fillna(<span class="string">&#x27;No&#x27;</span>)</span><br><span class="line">   <span class="comment">#数据类型处理</span></span><br><span class="line">   df[<span class="string">&#x27;shipping&#x27;</span>] = df[<span class="string">&#x27;shipping&#x27;</span>].astype(<span class="built_in">str</span>)</span><br><span class="line">   df[<span class="string">&#x27;item_condition_id&#x27;</span>] = df[<span class="string">&#x27;item_condition_id&#x27;</span>].astype(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>特征向量化</li>
</ul>
<p>使用 <code>sklearn</code> 库中的 <code>CountVectorizer</code> 类将文本特征进行向量化处理，并使用 <code>FeatureUnion</code> 进行特征联合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vectorizer = FeatureUnion([</span><br><span class="line">        (<span class="string">&#x27;name&#x27;</span>, CountVectorizer(</span><br><span class="line">            ngram_range=(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">            max_features=<span class="number">100000</span>,</span><br><span class="line">            preprocessor=build_preprocessor(<span class="string">&#x27;name&#x27;</span>))),</span><br><span class="line">        (<span class="string">&#x27;category_name&#x27;</span>, CountVectorizer(</span><br><span class="line">            token_pattern=<span class="string">&#x27;.+&#x27;</span>,</span><br><span class="line">            preprocessor=build_preprocessor(<span class="string">&#x27;category_name&#x27;</span>))),</span><br><span class="line">        (<span class="string">&#x27;brand_name&#x27;</span>, CountVectorizer(</span><br><span class="line">            token_pattern=<span class="string">&#x27;.+&#x27;</span>,</span><br><span class="line">            preprocessor=build_preprocessor(<span class="string">&#x27;brand_name&#x27;</span>))),</span><br><span class="line">        (<span class="string">&#x27;shipping&#x27;</span>, CountVectorizer(</span><br><span class="line">            token_pattern=<span class="string">&#x27;\d+&#x27;</span>,</span><br><span class="line">            preprocessor=build_preprocessor(<span class="string">&#x27;shipping&#x27;</span>))),</span><br><span class="line">        (<span class="string">&#x27;item_condition_id&#x27;</span>, CountVectorizer(</span><br><span class="line">            token_pattern=<span class="string">&#x27;\d+&#x27;</span>,</span><br><span class="line">            preprocessor=build_preprocessor(<span class="string">&#x27;item_condition_id&#x27;</span>))),</span><br><span class="line">        (<span class="string">&#x27;item_description&#x27;</span>, TfidfVectorizer(</span><br><span class="line">            ngram_range=(<span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line">            max_features=<span class="number">200000</span>,</span><br><span class="line">            preprocessor=build_preprocessor(<span class="string">&#x27;item_description&#x27;</span>),</span><br><span class="line">            stop_words=<span class="string">&#x27;english&#x27;</span>)),</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure>
<ol>
<li>模型构建</li>
</ol>
<p>对特征分别使用岭回归模型，<code>Lgbm</code> 模型和 <code>mlp</code> 模型进行训练，在本地测试得到的解分别为3.01，3.00，0.26</p>
<ul>
<li>岭回归模型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ridge_classify</span>(<span class="params">train_data,train_label</span>):</span><br><span class="line">    <span class="comment">#模型</span></span><br><span class="line">    model = Ridge(</span><br><span class="line">            solver=<span class="string">&#x27;auto&#x27;</span>,</span><br><span class="line">            fit_intercept=<span class="literal">True</span>,</span><br><span class="line">            alpha=<span class="number">0.4</span>,</span><br><span class="line">            max_iter=<span class="number">100</span>,</span><br><span class="line">            normalize=<span class="literal">False</span>,</span><br><span class="line">            tol=<span class="number">0.05</span>)</span><br><span class="line">    <span class="comment">#训练</span></span><br><span class="line">    model.fit(train_data, train_label)</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>
<ul>
<li><code>lgbm</code>模型 </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lgbm_classify</span>(<span class="params">train_data,train_label</span>):</span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.75</span>,</span><br><span class="line">        <span class="string">&#x27;application&#x27;</span>: <span class="string">&#x27;regression&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="string">&#x27;num_leaves&#x27;</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="string">&#x27;verbosity&#x27;</span>: -<span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;metric&#x27;</span>: <span class="string">&#x27;RMSE&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    train_X, valid_X, train_y, valid_y = train_test_split(train_data, train_label, test_size=<span class="number">0.1</span>, random_state=<span class="number">144</span>)</span><br><span class="line">    d_train = lgb.Dataset(train_X, label=train_y)</span><br><span class="line">    d_valid = lgb.Dataset(valid_X, label=valid_y)</span><br><span class="line">    watchlist = [d_train, d_valid]</span><br><span class="line"></span><br><span class="line">    model = lgb.train(params, train_set=d_train, num_boost_round=<span class="number">2200</span>, valid_sets=watchlist, \</span><br><span class="line">                      early_stopping_rounds=<span class="number">50</span>, verbose_eval=<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mlp</code> 模型</li>
</ul>
<p><code>MLP</code> 模型由两个全连接层和一个dropout层组成，本质上就是一个多隐藏层的网络</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mlp_model</span>(<span class="params">train_data,train_label,row_train</span>):</span><br><span class="line">    model = Sequential()</span><br><span class="line">    <span class="comment"># 全连接层</span></span><br><span class="line">    model.add(Dense(<span class="number">64</span>, input_shape=(row_train,), activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    <span class="comment"># DropOut层</span></span><br><span class="line">    model.add(Dropout(<span class="number">0.4</span>))</span><br><span class="line">    <span class="comment"># 全连接层+分类器</span></span><br><span class="line">    model.add(Dense(<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mean_squared_logarithmic_error&#x27;</span>,</span><br><span class="line">                  optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">                  metrics=[<span class="string">&#x27;accuracy&#x27;</span>]</span><br><span class="line">                  )</span><br><span class="line"></span><br><span class="line">    model.fit(train_data, train_label,</span><br><span class="line">              batch_size=<span class="number">300</span>,</span><br><span class="line">              epochs=<span class="number">1</span>,</span><br><span class="line">              )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model.predict(X_test)</span><br></pre></td></tr></table></figure>
<h3 id="三、形成词频矩阵时进行优化"><a href="#三、形成词频矩阵时进行优化" class="headerlink" title="三、形成词频矩阵时进行优化"></a>三、形成词频矩阵时进行优化</h3><p>在样例代码中我们尝试了将所有 <code>CountVectorizer</code> 替换为 <code>TdidfVectorizer</code>，然后利用岭模型进行预测，但是结果并没有优化很多，仅仅到2.9而已。<br>在后面利用 <code>MLP</code>时完全舍弃了 <code>CountVectorizer</code> 只利用  <code>TdidfVectorizer</code>。</p>
<h3 id="四、优化数据预处理过程"><a href="#四、优化数据预处理过程" class="headerlink" title="四、优化数据预处理过程"></a>四、优化数据预处理过程</h3><p>我们对上面基本已经完善的 <code>MLP</code> 进行优化的方式是<strong>尝试不同特征的组合</strong>。</p>
<h4 id="数据属性分析（详见Price-Suggestion-Challenge1-ipynb）"><a href="#数据属性分析（详见Price-Suggestion-Challenge1-ipynb）" class="headerlink" title="数据属性分析（详见Price Suggestion Challenge1.ipynb）"></a>数据属性分析（详见<code>Price Suggestion Challenge1.ipynb</code>）</h4><p>首先对属性进行分析：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">item_condition_id    300000 non-null int64</span><br><span class="line">shipping             300000 non-null int64</span><br><span class="line"></span><br><span class="line">name                 300000 non-null object</span><br><span class="line">category_name        298719 non-null object</span><br><span class="line">brand_name           171929 non-null object</span><br><span class="line">item_description     300000 non-null object</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><code>item_condition_id</code> 和 <code>shipping</code> 直接作为输入考虑，而 <code>name</code>, <code>category_name</code>, <code>brand_name</code>, <code>item_description</code> 考虑不同的组合进行尝试。</p>
<p>在此之前，我们找到了一个数据可视化的实例教程，对数据的属性进行分析。<br>通过详细观察数据得到最优的输入组合：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train.head()</span><br></pre></td></tr></table></figure><br><img src="image/1-3.png" alt=""></p>
<ol>
<li><p><code>price</code><br>通过数据可视化后的观察我们得知为什么要对 <code>price</code> 做 <code>log1p</code> 处理，这样使 <code>price</code> 分布更优。<br><img src="image/1-4.png" alt=""></p>
</li>
<li><p><code>category_name</code><br>尝试对该属性进行拆分，分成各种子类并查看相应数据。<br><img src="image/1-5.png" alt=""></p>
</li>
<li><p><code>item_description</code><br><img src="image/1-6.png" alt=""></p>
</li>
</ol>
<h4 id="不同的输入组合"><a href="#不同的输入组合" class="headerlink" title="不同的输入组合"></a>不同的输入组合</h4><ol>
<li>在样例代码中只是简单地将各个属性结合在一起进行文本分析，即<code>name</code> + <code>item_condition_id</code> + <code>category_name</code> + <code>brand_name</code> + <code>shipping</code> + <code>item_description</code>（6个输入）</li>
<li>尝试<code>name</code>, <code>item_condition_id</code>, <code>shipping</code>,<code>category_name</code> + <code>item_description</code>, <code>brand_name</code>（5个输入）</li>
<li>尝试<code>name</code>, <code>item_condition_id</code>, <code>shipping</code>, <code>category_name</code> + <code>brand_name</code> + <code>item_description</code>（4个输入）</li>
<li>尝试<code>name</code>, <code>item_condition_id</code>, <code>shipping</code>, <code>name</code> + <code>category_name</code> + <code>brand_name</code> + <code>item_description</code>  （4个输入）</li>
</ol>
<p>四种组合作为输入的结果非常相近，除了组合1<code>MSLE</code>在0.4左右，组合2和3 在0.21 左右，组合4最终能跑到0.17左右。组合4实际上加大了<code>name</code>的权重，让最终结果更好。</p>
<h2 id="最终源码及实验结果"><a href="#最终源码及实验结果" class="headerlink" title="最终源码及实验结果"></a>最终源码及实验结果</h2><ol>
<li><p>数据预处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据处理</span></span><br><span class="line"><span class="comment"># 属性共有8个，删去price，train_id对结果没有影响。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_preprocess</span>(<span class="params">df</span>):</span><br><span class="line">    df[<span class="string">&#x27;name&#x27;</span>] = df[<span class="string">&#x27;name&#x27;</span>].fillna(<span class="string">&#x27;&#x27;</span>) + <span class="string">&#x27; &#x27;</span> + df[<span class="string">&#x27;brand_name&#x27;</span>].fillna(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    df[<span class="string">&#x27;text&#x27;</span>] = (df[<span class="string">&#x27;item_description&#x27;</span>].fillna(<span class="string">&#x27;&#x27;</span>) + <span class="string">&#x27; &#x27;</span> + df[<span class="string">&#x27;name&#x27;</span>] + <span class="string">&#x27; &#x27;</span> + df[<span class="string">&#x27;category_name&#x27;</span>].fillna(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> df[[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;text&#x27;</span>, <span class="string">&#x27;shipping&#x27;</span>, <span class="string">&#x27;item_condition_id&#x27;</span>]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fit_predict</span>(<span class="params">xs, y_train</span>):</span><br><span class="line">    X_train, X_test = xs</span><br><span class="line">    <span class="comment"># 配置tf.Session的运算方式，比如gpu运算或者cpu运算</span></span><br><span class="line">    config = tf.ConfigProto(</span><br><span class="line">        <span class="comment"># 设置多个操作并行运算的线程数</span></span><br><span class="line">        intra_op_parallelism_threads=<span class="number">1</span>, use_per_session_threads=<span class="number">1</span>, inter_op_parallelism_threads=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># Session提供了Operation执行和Tensor求值的环境。</span></span><br><span class="line">    <span class="keyword">with</span> tf.Session(graph=tf.Graph(), config=config) <span class="keyword">as</span> sess, timer(<span class="string">&#x27;fit_predict&#x27;</span>):</span><br><span class="line">        ks.backend.set_session(sess)</span><br><span class="line">        model_in = ks.Input(shape=(X_train.shape[<span class="number">1</span>],), dtype=<span class="string">&#x27;float32&#x27;</span>, sparse=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># ks.layers.Dense 表示输出空间的维度</span></span><br><span class="line">        <span class="comment"># Dense全连接层，相当于直接添加一层</span></span><br><span class="line">        <span class="comment"># activation 是按逐个元素计算的激活函数</span></span><br><span class="line">        out = ks.layers.Dense(<span class="number">192</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(model_in)</span><br><span class="line">        out = ks.layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(out)</span><br><span class="line">        out = ks.layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(out)</span><br><span class="line">        out = ks.layers.Dense(<span class="number">1</span>)(out)</span><br><span class="line">        model = ks.Model(model_in, out)</span><br><span class="line">        model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mean_squared_error&#x27;</span>, optimizer=ks.optimizers.Adam(lr=<span class="number">3e-3</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">with</span> timer(<span class="string">f&#x27;epoch <span class="subst">&#123;i + <span class="number">1</span>&#125;</span>&#x27;</span>):</span><br><span class="line">                model.fit(x=X_train, y=y_train, batch_size=<span class="number">2</span> ** (<span class="number">11</span> + i), epochs=<span class="number">1</span>, verbose=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> model.predict(X_test)[:, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>训练模型并预测结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    vectorizer = make_union(<span class="comment"># 把所有的transformers组装成一个FeatureUnion. n_jobs表示可以同时进行</span></span><br><span class="line">        <span class="comment"># FunctionTransformer 实现自定义转换，validate=False 时没有输入验证</span></span><br><span class="line">        <span class="comment"># TfidfVectorizer函数，仅考虑按照词频排列前max_feature位的词，token_pattern=&#x27;\w+&#x27;至少匹配一位的词</span></span><br><span class="line">        make_pipeline(FunctionTransformer(itemgetter(<span class="string">&#x27;name&#x27;</span>), validate=<span class="literal">False</span>), TfidfVectorizer(max_features=<span class="number">100000</span>, token_pattern=<span class="string">&#x27;\w+&#x27;</span>)),</span><br><span class="line">        make_pipeline(FunctionTransformer(itemgetter(<span class="string">&#x27;text&#x27;</span>), validate=<span class="literal">False</span>), TfidfVectorizer(max_features=<span class="number">100000</span>, token_pattern=<span class="string">&#x27;\w+&#x27;</span>)),</span><br><span class="line">        make_pipeline(FunctionTransformer(itemgetter([<span class="string">&#x27;shipping&#x27;</span>, <span class="string">&#x27;item_condition_id&#x27;</span>]), validate=<span class="literal">False</span>),</span><br><span class="line">                      FunctionTransformer(to_records, validate=<span class="literal">False</span>), DictVectorizer()),</span><br><span class="line">        n_jobs=<span class="number">4</span>)</span><br><span class="line">    <span class="comment"># StandardScaler()进行数据标准化。保存训练集中的参数（均值、方差）直接使用其对象转换测试集数据。</span></span><br><span class="line">    y_scaler = StandardScaler()</span><br><span class="line">    <span class="comment"># with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。</span></span><br><span class="line">    <span class="keyword">with</span> timer(<span class="string">&#x27;process train&#x27;</span>):</span><br><span class="line">        train = pd.read_csv(<span class="string">&#x27;train.csv&#x27;</span>, sep=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        test = pd.read_csv(<span class="string">&#x27;test.csv&#x27;</span>, sep=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="comment"># 删去&#x27;price&#x27;属性</span></span><br><span class="line">        train = train[train[<span class="string">&#x27;price&#x27;</span>] &gt; <span class="number">0</span>].reset_index(drop=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 将price数据进行标准化</span></span><br><span class="line">        y_train = y_scaler.fit_transform(np.log1p(train[<span class="string">&#x27;price&#x27;</span>].values.reshape(-<span class="number">1</span>, <span class="number">1</span>)))</span><br><span class="line">        X_train = vectorizer.fit_transform(data_preprocess(train)).astype(np.float32)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;X_train: <span class="subst">&#123;X_train.shape&#125;</span> of <span class="subst">&#123;X_train.dtype&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> timer(<span class="string">&#x27;process valid&#x27;</span>):</span><br><span class="line">        X_test = vectorizer.transform(data_preprocess(test)).astype(np.float32)</span><br><span class="line">    <span class="keyword">with</span> ThreadPool(processes=<span class="number">4</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        Xb_train, Xb_test = [x.astype(np.<span class="built_in">bool</span>).astype(np.float32) <span class="keyword">for</span> x <span class="keyword">in</span> [X_train, X_test]]</span><br><span class="line">        xs = [[Xb_train, Xb_test], [X_train, X_test]] * <span class="number">2</span></span><br><span class="line">        <span class="comment"># 预测模型</span></span><br><span class="line">        y_pred = np.mean(pool.<span class="built_in">map</span>(partial(fit_predict, y_train=y_train), xs), axis=<span class="number">0</span>)</span><br><span class="line">    y_pred = np.expm1(y_scaler.inverse_transform(y_pred.reshape(-<span class="number">1</span>, <span class="number">1</span>))[:, <span class="number">0</span>])</span><br><span class="line">    <span class="comment"># print(type(y_pred))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出预测结果到csv</span></span><br><span class="line">    test_id = np.array(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(y_pred)))</span><br><span class="line">    dataframe = pd.DataFrame(&#123;<span class="string">&#x27;test_id&#x27;</span>: test_id, <span class="string">&#x27;price&#x27;</span>: y_pred&#125;)</span><br><span class="line">    dataframe.to_csv(<span class="string">&quot;res.csv&quot;</span>, index=<span class="literal">False</span>, sep=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(&#x27;Valid MSLE: &#123;:.4f&#125;&#x27;.format(mean_squared_log_error(valid[&#x27;price&#x27;], y_pred)))</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最终实验结果达到了0.179。</p>
<h2 id="在MLP模型下的其他优化方向"><a href="#在MLP模型下的其他优化方向" class="headerlink" title="在MLP模型下的其他优化方向"></a>在<code>MLP</code>模型下的其他优化方向</h2><ol>
<li>可以观察到在<code>item_desciption</code> 的词云中，有诸如<code>shipping</code> 和<code>free</code>等词，这些词可能代表着免运费等含义，与<code>shipping</code>属性有一定的重复，将它作为特征词训练模型会造成干扰。</li>
<li>单个关键词可能包含的信息不全面，关键词之间可能有很大的关联。</li>
<li>在最终的模型中<code>MLP</code>采用了四层感知机，感知机的层数和每层的输入规模还可以做进一步调参。</li>
</ol>
<h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><p>这次实验的难度非常大，不知道从何入手。</p>
<p>在仔细研究了课程中给的样例代码和数据可视化分析的内容之后，对数据集和预测的方法都有了初步的了解。  </p>
<p>因为对<code>MLP</code>，<code>Lightgbm</code>等模型非常不熟悉，所以从输入的角度入手，在不同属性的组合之处进行尝试，得到了最终的较为优秀的结果。  </p>
<p>在之后的学习中应该更加深入地学习和了解模型，尽量能够自己独立完成创建模型，而不是修改其他已经写好的模型。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1].<a href="https://ahmedbesbes.com/how-to-mine-newsfeed-data-and-extract-interactive-insights-in-python.html">https://ahmedbesbes.com/how-to-mine-newsfeed-data-and-extract-interactive-insights-in-python.html</a></p>
<p>[2].  <a href="https://github.com/pjankiewicz/mercari-solution">https://github.com/pjankiewicz/mercari-solution</a></p>
<p>[3].<a href="https://www.kaggle.com/thykhuely/mercari-interactive-eda-topic-modelling">https://www.kaggle.com/thykhuely/mercari-interactive-eda-topic-modelling</a></p>
<p>[4].<a href="https://wklchris.github.io/Py3-pandas.html#统计信息dfdescribe-svalue_counts--unique">https://wklchris.github.io/Py3-pandas.html#%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AFdfdescribe-svalue_counts—unique</a></p>
<p>[5].<a href="https://zh.wikipedia.org/wiki/多层感知器">https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E5%99%A8</a></p>
<p>[6].<a href="https://blog.csdn.net/weixin_39807102/article/details/81912566">https://blog.csdn.net/weixin_39807102/article/details/81912566</a></p>
<p>[7].<a href="https://github.com/maiwen/NLP">https://github.com/maiwen/NLP</a></p>
<p>[8]. <a href="https://zh.wikipedia.org/wiki/正则表达式">https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F</a></p>
<p>[9].<a href="https://blog.csdn.net/u012609509/article/details/72911564">https://blog.csdn.net/u012609509/article/details/72911564</a></p>
<p>[10]. <a href="https://www.kaggle.com/tunguz/more-effective-ridge-lgbm-script-lb-0-44823">https://www.kaggle.com/tunguz/more-effective-ridge-lgbm-script-lb-0-44823</a></p>
<p>[11]. <a href="https://qiita.com/kazuhirokomoda/items/1e9b7ebcacf264b2d814">https://qiita.com/kazuhirokomoda/items/1e9b7ebcacf264b2d814</a></p>
<p>[12]. <a href="https://www.jianshu.com/p/c532424541ad">https://www.jianshu.com/p/c532424541ad</a></p>
<p>[13]. <a href="https://www.jiqizhixin.com/articles/2017-11-13-7">https://www.jiqizhixin.com/articles/2017-11-13-7</a></p>
]]></content>
      <categories>
        <category>数据科学导论</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux开发环境及应用作业1</title>
    <url>/201911/Linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8%E4%BD%9C%E4%B8%9A%2020191031/</url>
    <content><![CDATA[<h1 id="Linux开发环境及应用作业-20191031"><a href="#Linux开发环境及应用作业-20191031" class="headerlink" title="Linux开发环境及应用作业 20191031"></a><code>Linux</code>开发环境及应用作业 20191031</h1><h2 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h2><p>从因特网上搜索相关Web网页，处理网页<code>html</code>数据，从中提取出当前时间点北京各监测站的 PM2.5浓度，输出格式如下。要求：写出各个处 理步骤，并给出解释。<br>2018-03-15 13:00:00,海淀区万柳,73<br>2018-03-15 13:00:00,昌平镇,67<br>2018-03-15 13:00:00,奥体中心,66<br>2018-03-15 14:00:00,海淀区万柳,73<br>2018-03-15 14:00:00,昌平镇,73<br>2018-03-15 14:00:00,奥体中心,75</p>
<span id="more"></span>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="数据搜集"><a href="#数据搜集" class="headerlink" title="数据搜集"></a>数据搜集</h3><p>北京各监测站的<code>PM2.5</code>指数的数据来源网站：<a href="http://www.86pm25.com/city/beijing.html">http://www.86pm25.com/city/beijing.html</a><br><img src="https://s2.ax1x.com/2019/10/31/K5rmkV.jpg" alt=""></p>
<h3 id="数据整理及汇总"><a href="#数据整理及汇总" class="headerlink" title="数据整理及汇总"></a>数据整理及汇总</h3><p>先展示实现该操作的指令和最后的结果：<br><img src="https://s2.ax1x.com/2019/10/31/K5rl6J.jpg" alt=""><br><img src="https://s2.ax1x.com/2019/10/31/K5rQl4.jpg" alt=""><br><img src="https://s2.ax1x.com/2019/10/31/K5rJTx.jpg" alt=""></p>
<p>下面详细解释指令：</p>
<ol>
<li>首先利用<tr>标签把数据分成单独的行，<code>sed -e &#39;s/&lt;tr/\n&lt;tr/g&#39;</code></li>
<li>其次删掉html文件中的所有标签<code>-e &#39;s/&lt;[^&lt;&gt;]*&gt;/ /g</code>，把所有标签都换成了空格。</li>
<li>我先在html文件中寻找日期和时间，发现时间的那一行有“更新”的字样，于是建立awk文件，此时发现“更新”后面中文的冒号紧跟着日期，没发把日期分离开，于是先在中文冒号后面添加空格。顺便把日期和时间的格式改成标准的输出的格式。<code>-e &#39;s/：/： /g&#39; -e &#39;s/[年月]/-/g&#39; -e &#39;s/日//g -e &#39;s/时/:00:00/g&#39;</code><br><img src="https://s2.ax1x.com/2019/10/31/K5rrnA.jpg" alt=""></li>
<li>此时可以把时间和日期抽离出来了。在建立的awk文件中输入<code>/更新/ &#123;data = $2; time = $3&#125;</code></li>
<li>得到日期和时间 之后，我们去找监测站和pm2.5指数，发现在这些数据最后都有$m^3$单位在，于是在awk文件中添加<code>/m3/&#123;printf(&quot;%s %s,%s,%s\n&quot;,date, time, $1, $3);&#125;</code><br><img src="https://s2.ax1x.com/2019/10/31/K5rs0I.jpg" alt=""></li>
<li>最后把单位删掉，并输出到csv文件中即可。<code>awk -f flow.awk | sed -e &#39;s/[ug/m3]//g&#39; &gt; flow.csv</code></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>文本处理</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络作业报告</title>
    <url>/201911/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="神经网络作业报告"><a href="#神经网络作业报告" class="headerlink" title="神经网络作业报告"></a>神经网络作业报告</h1><p>[TOC]<br>本次作业部分源码的参考资料已注明</p>
<h2 id="一、实验要求"><a href="#一、实验要求" class="headerlink" title="一、实验要求"></a>一、实验要求</h2><ol>
<li>推导具有单隐层的神经网络的前向传播和反向传播算法，并进行编程（可以使用<code>sklearn</code>中的神经网络）。<ul>
<li>探讨10，30，100，300，1000，不同隐藏节点数对网络性能的影响。</li>
<li>探讨不同学习率和迭代次数对网络性能的影响。</li>
<li>改变数据的标准化方法，探讨对训练的影响。</li>
</ul>
</li>
<li>查阅资料说明什么是<code>Hebb</code>学习规则</li>
</ol>
<span id="more"></span>
<h2 id="二、推导单隐层神经网络的前向传播和反向传播算法"><a href="#二、推导单隐层神经网络的前向传播和反向传播算法" class="headerlink" title="二、推导单隐层神经网络的前向传播和反向传播算法"></a>二、推导单隐层神经网络的前向传播和反向传播算法</h2><p>参考资料：<a href="https://blog.csdn.net/Lucky_Go/article/details/89738286">https://blog.csdn.net/Lucky_Go/article/details/89738286</a><br><img src="image4\reduction1.jpg" alt=""><br><img src="image4\reduction2.jpg" alt=""><br><img src="image4\reduction3.jpg" alt=""><br><img src="image4\reduction4.jpg" alt=""></p>
<h2 id="三、算法实现"><a href="#三、算法实现" class="headerlink" title="三、算法实现"></a>三、算法实现</h2><p>参考资料：<a href="https://blog.csdn.net/zsx17/article/details/89342506">https://blog.csdn.net/zsx17/article/details/89342506</a></p>
<p>因为网上神经网络的代码基本都是用<code>tensorflow</code>实现的，这里是直接调库。在完成了作业的基本要求之后我也尝试了自己实现单隐层神经网络的代码（在实验报告的后部分）。</p>
<h3 id="1-载入数据"><a href="#1-载入数据" class="headerlink" title="1. 载入数据"></a>1. 载入数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、载入数据</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> tensorflow.examples.tutorials.mnist.input_data <span class="keyword">as</span> input_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取mnist数据</span></span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">&#x27;MNIST_data/&#x27;</span>, one_hot=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-建立模型"><a href="#2-建立模型" class="headerlink" title="2. 建立模型"></a>2. 建立模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2.建立模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.1 构建输入层</span></span><br><span class="line">x = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">784</span>], name=<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">y = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">10</span>], name=<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.2 构建隐藏层</span></span><br><span class="line"><span class="comment"># 隐藏层神经元数量(随意设置）</span></span><br><span class="line">H1_NN = <span class="number">256</span></span><br><span class="line"><span class="comment"># 权重</span></span><br><span class="line">W1 = tf.Variable(tf.random_normal([<span class="number">784</span>, H1_NN]))</span><br><span class="line"><span class="comment"># 偏置项</span></span><br><span class="line">b1 = tf.Variable(tf.zeros([H1_NN]))</span><br><span class="line"></span><br><span class="line">Y1 = tf.nn.relu(tf.matmul(x, W1) + b1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.3 构建输出层</span></span><br><span class="line">W2 = tf.Variable(tf.random_normal([H1_NN, <span class="number">10</span>]))</span><br><span class="line">b2 = tf.Variable(tf.zeros([<span class="number">10</span>]))</span><br><span class="line"></span><br><span class="line">forward = tf.matmul(Y1, W2) + b2</span><br><span class="line">pred = tf.nn.softmax(forward)</span><br></pre></td></tr></table></figure>
<h3 id="3-训练模型"><a href="#3-训练模型" class="headerlink" title="3. 训练模型"></a>3. 训练模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3.训练模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.1 定义损失函数</span></span><br><span class="line"><span class="comment"># tensorflow提供了下面的函数，用于避免log(0)值为Nan造成数据不稳定</span></span><br><span class="line">loss_function = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=forward, labels=y))</span><br><span class="line"><span class="comment"># # 交叉熵损失函数</span></span><br><span class="line"><span class="comment"># loss_function = tf.reduce_mean(-tf.reduce_sum(y*tf.log(pred), reduction_indices=1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.2 设置训练参数</span></span><br><span class="line">train_epochs = <span class="number">40</span>  <span class="comment"># 训练轮数</span></span><br><span class="line">batch_size = <span class="number">50</span>  <span class="comment"># 单次训练样本数(批次大小)</span></span><br><span class="line"><span class="comment"># 一轮训练的批次数</span></span><br><span class="line">total_batch = <span class="built_in">int</span>(mnist.train.num_examples / batch_size)</span><br><span class="line">display_step = <span class="number">1</span>  <span class="comment"># 显示粒数</span></span><br><span class="line">learning_rate = <span class="number">0.01</span>  <span class="comment"># 学习率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.2 选择优化器</span></span><br><span class="line">optimizer = tf.train.AdamOptimizer(learning_rate).minimize(loss_function)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.3定义准确率</span></span><br><span class="line">correct_prediction = tf.equal(tf.argmax(y, <span class="number">1</span>), tf.argmax(pred, <span class="number">1</span>))</span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.4 模型的训练</span></span><br><span class="line"><span class="comment"># 记录训练开始的时间</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">startTime = time()</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(train_epochs):</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> <span class="built_in">range</span>(total_batch):</span><br><span class="line">        <span class="comment"># 读取批次训练数据</span></span><br><span class="line">        xs, ys = mnist.train.next_batch(batch_size)</span><br><span class="line">        <span class="comment"># 执行批次训练</span></span><br><span class="line">        sess.run(optimizer, feed_dict=&#123;x: xs, y: ys&#125;)</span><br><span class="line">    <span class="comment"># 在total_batch批次数据训练完成后，使用验证数据计算误差和准确率，验证集不分批</span></span><br><span class="line">    loss, acc = sess.run([loss_function, accuracy], feed_dict=&#123;x: mnist.validation.images, y: mnist.validation.labels&#125;)</span><br><span class="line">    <span class="comment"># 打印训练过程中的详细信息</span></span><br><span class="line">    <span class="keyword">if</span> (epoch + <span class="number">1</span>) % display_step == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;训练轮次：&#x27;</span>, <span class="string">&#x27;%02d&#x27;</span> % (epoch + <span class="number">1</span>),</span><br><span class="line">              <span class="string">&#x27;损失：&#x27;</span>, <span class="string">&#x27;&#123;:.9f&#125;&#x27;</span>.<span class="built_in">format</span>(loss),</span><br><span class="line">              <span class="string">&#x27;准确率：&#x27;</span>, <span class="string">&#x27;&#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(acc))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;训练结束&#x27;</span>)</span><br><span class="line"><span class="comment"># 显示总运行时间</span></span><br><span class="line">duration = time() - startTime</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;总运行时间为：&quot;</span>, <span class="string">&quot;&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(duration))</span><br></pre></td></tr></table></figure>
<h3 id="4-模型评估"><a href="#4-模型评估" class="headerlink" title="4. 模型评估"></a>4. 模型评估</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4.评估模型</span></span><br><span class="line">accu_test = sess.run(accuracy,</span><br><span class="line">                     feed_dict=&#123;x: mnist.test.images, y: mnist.test.labels&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;测试集准确率：&#x27;</span>, accu_test)</span><br></pre></td></tr></table></figure>
<h3 id="5-应用模型"><a href="#5-应用模型" class="headerlink" title="5. 应用模型"></a>5. 应用模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 5.应用模型</span></span><br><span class="line">prediction_result = sess.run(tf.argmax(pred, <span class="number">1</span>), feed_dict=&#123;x: mnist.test.images&#125;)</span><br><span class="line"><span class="comment"># 查看预测结果的前10项</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;前10项的结果：&quot;</span>, prediction_result[<span class="number">0</span>:<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.1找出预测错误的样本</span></span><br><span class="line">compare_lists = prediction_result == np.argmax(mnist.test.labels, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(compare_lists)</span><br><span class="line">err_lists = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(compare_lists)) <span class="keyword">if</span> compare_lists[i] == <span class="literal">False</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;预测错误的图片：&#x27;</span>, err_lists)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;预测错误图片的总数：&#x27;</span>, <span class="built_in">len</span>(err_lists))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个输出错误分类的函数</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_predict_errs</span>(<span class="params">labels,  <span class="comment"># 标签列表</span></span></span><br><span class="line"><span class="params">                       prediction</span>):  <span class="comment"># 预测值列表</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    compare_lists = (prediction == np.argmax(labels, <span class="number">1</span>))</span><br><span class="line">    err_lists = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(compare_lists)) <span class="keyword">if</span> compare_lists[i] == <span class="literal">False</span>]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> err_lists:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;index=&#x27;</span> + <span class="built_in">str</span>(x) + <span class="string">&#x27;标签值=&#x27;</span>, np.argmax(labels[x]), <span class="string">&#x27;预测值=&#x27;</span>, prediction[x])</span><br><span class="line">        count = count + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;总计：&quot;</span> + <span class="built_in">str</span>(count))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print_predict_errs(labels=mnist.test.labels, prediction=prediction_result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_images_labels_prediction</span>(<span class="params">images,  <span class="comment"># 图像列表</span></span></span><br><span class="line"><span class="params">                                  labels,  <span class="comment"># 标签列表</span></span></span><br><span class="line"><span class="params">                                  predication,  <span class="comment"># 预测值列表</span></span></span><br><span class="line"><span class="params">                                  index,  <span class="comment"># 从第index个开始显示</span></span></span><br><span class="line"><span class="params">                                  num=<span class="number">10</span></span>):  <span class="comment"># 缺省一次显示10幅</span></span><br><span class="line">    fig = plt.gcf()  <span class="comment"># 获取当前图表，get current figure</span></span><br><span class="line">    fig.set_size_inches(<span class="number">10</span>, <span class="number">12</span>)  <span class="comment"># 设为英寸，1英寸=2.53厘米</span></span><br><span class="line">    <span class="keyword">if</span> num &gt; <span class="number">25</span>:</span><br><span class="line">        num = <span class="number">25</span>  <span class="comment"># 最多显示25个子图</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num):</span><br><span class="line">        ax = plt.subplot(<span class="number">5</span>, <span class="number">5</span>, i + <span class="number">1</span>)  <span class="comment"># 获取当前要处理的子图</span></span><br><span class="line">        <span class="comment"># 显示第index图像</span></span><br><span class="line">        ax.imshow(np.reshape(images[index], (<span class="number">28</span>, <span class="number">28</span>)), cmap=<span class="string">&#x27;binary&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建该图上显示的title</span></span><br><span class="line">        title = <span class="string">&#x27;label=&#x27;</span> + <span class="built_in">str</span>(np.argmax(labels[index]))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(predication) &gt; <span class="number">0</span>:</span><br><span class="line">            title += <span class="string">&quot;,predict=&quot;</span> + <span class="built_in">str</span>(predication[index])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 显示图上的title信息</span></span><br><span class="line">        ax.set_title(title, fontsize=<span class="number">10</span>)</span><br><span class="line">        ax.set_xticks([])  <span class="comment"># 不显示坐标轴</span></span><br><span class="line">        ax.set_yticks([])</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plot_images_labels_prediction(mnist.test.images,</span><br><span class="line">                              mnist.test.labels,</span><br><span class="line">                              prediction_result, <span class="number">10</span>, <span class="number">25</span>)</span><br><span class="line">plot_images_labels_prediction(mnist.test.images,</span><br><span class="line">                              mnist.test.labels,</span><br><span class="line">                              prediction_result, <span class="number">610</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<h3 id="6-结果展示"><a href="#6-结果展示" class="headerlink" title="6. 结果展示"></a>6. 结果展示</h3><p>上面的代码中隐层节点个数为256个，学习率为0.01，迭代次数为40次。训练结果如下：</p>
<p><img src="image4\256-0.01-40.jpg" alt=""></p>
<p>部分分类图像如下所示：</p>
<p><img src="image4\256-0.01-40-1.jpg" alt=""></p>
<p><img src="image4\256-0.01-40-2.jpg" alt=""></p>
<h2 id="四、算法调优"><a href="#四、算法调优" class="headerlink" title="四、算法调优"></a>四、算法调优</h2><p>在上面的模型中隐层结点数为256，学习率为0.01，迭代次数为40次。</p>
<p>下面分别从隐层节点数、学习率和迭代次数三个角度进行调优。</p>
<h3 id="1-隐层节点数"><a href="#1-隐层节点数" class="headerlink" title="1. 隐层节点数"></a>1. 隐层节点数</h3><p>将隐层节点数设为10，得到的结果如下图所示：</p>
<p><img src="image4\10-0.01-40.jpg" alt=""></p>
<p>将隐层节点设为30，100，300，1000的效果不再具体展示，效果如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">隐层节点个数</th>
<th style="text-align:center">总运行时间/s</th>
<th style="text-align:center">预测错误的图片数</th>
<th style="text-align:center">准确率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">46.29</td>
<td style="text-align:center">736</td>
<td style="text-align:center">0.9264</td>
</tr>
<tr>
<td style="text-align:center">30</td>
<td style="text-align:center">43.46</td>
<td style="text-align:center">528</td>
<td style="text-align:center">0.9472</td>
</tr>
<tr>
<td style="text-align:center">100</td>
<td style="text-align:center">59.06</td>
<td style="text-align:center">343</td>
<td style="text-align:center">0.9657</td>
</tr>
<tr>
<td style="text-align:center">256</td>
<td style="text-align:center">84.48</td>
<td style="text-align:center">249</td>
<td style="text-align:center">0.9751</td>
</tr>
<tr>
<td style="text-align:center">300</td>
<td style="text-align:center">76.64</td>
<td style="text-align:center">269</td>
<td style="text-align:center">0.9731</td>
</tr>
<tr>
<td style="text-align:center">1000</td>
<td style="text-align:center">302.27</td>
<td style="text-align:center">240</td>
<td style="text-align:center">0.976</td>
</tr>
</tbody>
</table>
</div>
<p>由表可知，准确率随着隐层节点个数的增加而增加，增加速率逐步减少。</p>
<h3 id="2-学习率"><a href="#2-学习率" class="headerlink" title="2. 学习率"></a>2. 学习率</h3><p>学习率分别为0.005，0.01， 0.02， 0.1，隐层节点数选择256，迭代次数选择40。分类结果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">学习率</th>
<th style="text-align:center">总运行时间/s</th>
<th style="text-align:center">预测错误的图片数</th>
<th style="text-align:center">准确率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0.005</td>
<td style="text-align:center">78.81</td>
<td style="text-align:center">231</td>
<td style="text-align:center">0.9769</td>
</tr>
<tr>
<td style="text-align:center">0.01</td>
<td style="text-align:center">84.48</td>
<td style="text-align:center">249</td>
<td style="text-align:center">0.9751</td>
</tr>
<tr>
<td style="text-align:center">0.02</td>
<td style="text-align:center">69.72</td>
<td style="text-align:center">446</td>
<td style="text-align:center">0.9554</td>
</tr>
<tr>
<td style="text-align:center">0.1</td>
<td style="text-align:center">73.87</td>
<td style="text-align:center">2561</td>
<td style="text-align:center">0.7439</td>
</tr>
</tbody>
</table>
</div>
<p>由表可知，准确率随着学习率的增加而降低。在学习率低于0.01时，图片分类的准确率提升的速率较小。</p>
<h3 id="3-迭代次数"><a href="#3-迭代次数" class="headerlink" title="3. 迭代次数"></a>3. 迭代次数</h3><p>迭代次数分别为20，40，100，隐层节点数选择256，学习率选择0.01。分类结果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">迭代次数</th>
<th style="text-align:center">总运行时间/s</th>
<th style="text-align:center">预测错误的图片数</th>
<th style="text-align:center">准确率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">37.12</td>
<td style="text-align:center">307</td>
<td style="text-align:center">0.9693</td>
</tr>
<tr>
<td style="text-align:center">40</td>
<td style="text-align:center">84.48</td>
<td style="text-align:center">249</td>
<td style="text-align:center">0.9751</td>
</tr>
<tr>
<td style="text-align:center">100</td>
<td style="text-align:center">184.39</td>
<td style="text-align:center">239</td>
<td style="text-align:center">0.9761</td>
</tr>
</tbody>
</table>
</div>
<p>由表可知，迭代次数对总运行时间的影响率很大，准确率随着迭代次数的增加而增加，但对准确率起决定因素的还是隐层的节点个数以及学习率。</p>
<h3 id="4-改变数据标准化方法"><a href="#4-改变数据标准化方法" class="headerlink" title="4. 改变数据标准化方法"></a>4. 改变数据标准化方法</h3><h4 id="最大-最小规范化"><a href="#最大-最小规范化" class="headerlink" title="最大-最小规范化"></a>最大-最小规范化</h4><h4 id="Z-score规范化"><a href="#Z-score规范化" class="headerlink" title="Z-score规范化"></a><code>Z-score</code>规范化</h4><h2 id="五、Hebb学习规则"><a href="#五、Hebb学习规则" class="headerlink" title="五、Hebb学习规则"></a>五、<code>Hebb</code>学习规则</h2><p>参考资料：<a href="https://baike.baidu.com/item/Hebb学习规则/3061563?fr=aladdin">https://baike.baidu.com/item/Hebb%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%99/3061563?fr=aladdin</a></p>
<p><code>Hebb</code>学习规则是一个无监督学习规则，这种学习的结果是使网络能够提取训练集的统计特性，从而把输入信息按照它们的相似性程度划分为若干类。这一点与人类观察和认识世界的过程非常吻合，人类观察和认识世界在相当程度上就是在根据事物的统计特征进行分类。<code>Hebb</code>学习规则只根据神经元连接间的激活水平改变权值，因此这种方法又称为相关学习或并联学习。</p>
<p>无监督学习规则<br> 唐纳德·赫布（1904-1985）是加拿大著名生理心理学家。<code>Hebb</code>学习规则与“条件反射”机理一致，并且已经得到了神经细胞学说的证实。<br> 巴甫洛夫的条件反射实验：每次给狗喂食前都先响铃，时间一长，狗就会将铃声和食物联系起来。以后如果响铃但是不给食物，狗也会流口水。<br> 受该实验的启发，Hebb的理论认为在同一时间被激发的神经元间的联系会被强化。比如，铃声响时一个神经元被激发，在同一时间食物的出现会激发附近的另一个神经元，那么这两个神经元间的联系就会强化，从而记住这两个事物之间存在着联系。相反，如果两个神经元总是不能同步激发，那么它们间的联系将会越来越弱。<br> <code>Hebb</code>学习律可表示为：<br>$W<em>{ij}(t+1)=W</em>{ij}(t)+a⋅y<em>i⋅y_j$<br>$W</em>{ij}(t+1)=W_{ij}(t)+a⋅y_i⋅y_j$</p>
<p> 其中$W<em>{ij}$表示神经元$j$到神经元$i$的连接权，$y_i$与$y_j$表示两个神经元的输出，$a$是表示学习速率的常数，如果$y_i$与$y_j$同时被激活，即$y_i$与$y_j$同时为正，那么$W</em>{ij}$将增大。如果$y<em>i$被激活，而$y_j$处于抑制状态，即$y_i$为正$y_j$为负，那么$W</em>{ij}$将变小。</p>
<p><img src="https://images2015.cnblogs.com/blog/520787/201510/520787-20151021081107630-1544768706.png" alt=""></p>
<h2 id="六、-自己实现单隐层神经网络"><a href="#六、-自己实现单隐层神经网络" class="headerlink" title="六、 自己实现单隐层神经网络"></a>六、 自己实现单隐层神经网络</h2><p>参考资料：<a href="https://blog.csdn.net/hellozhxy/article/details/81055391">https://blog.csdn.net/hellozhxy/article/details/81055391</a></p>
<p>网络结构的函数定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">layer_sizes</span>(<span class="params">X, Y</span>):</span><br><span class="line">    n_x = X.shape[<span class="number">0</span>] <span class="comment"># size of input layer</span></span><br><span class="line">    n_h = <span class="number">4</span> <span class="comment"># size of hidden layer</span></span><br><span class="line">    n_y = Y.shape[<span class="number">0</span>] <span class="comment"># size of output layer</span></span><br><span class="line">    <span class="keyword">return</span> (n_x, n_h, n_y)</span><br></pre></td></tr></table></figure>
<p>参数初始化函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_parameters</span>(<span class="params">n_x, n_h, n_y</span>):</span><br><span class="line">    W1 = np.random.randn(n_h, n_x)*<span class="number">0.01</span></span><br><span class="line">    b1 = np.zeros((n_h, <span class="number">1</span>))</span><br><span class="line">    W2 = np.random.randn(n_y, n_h)*<span class="number">0.01</span></span><br><span class="line">    b2 = np.zeros((n_y, <span class="number">1</span>)) </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">assert</span> (W1.shape == (n_h, n_x))    </span><br><span class="line">    <span class="keyword">assert</span> (b1.shape == (n_h, <span class="number">1</span>))    </span><br><span class="line">    <span class="keyword">assert</span> (W2.shape == (n_y, n_h))    </span><br><span class="line">    <span class="keyword">assert</span> (b2.shape == (n_y, <span class="number">1</span>))</span><br><span class="line">    parameters = &#123;<span class="string">&quot;W1&quot;</span>: W1, </span><br><span class="line">                  <span class="string">&quot;b1&quot;</span>: b1,                 </span><br><span class="line">                  <span class="string">&quot;W2&quot;</span>: W2,                  </span><br><span class="line">                  <span class="string">&quot;b2&quot;</span>: b2&#125;   </span><br><span class="line">                   </span><br><span class="line">    <span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure>
<p>前向传播计算函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward_propagation</span>(<span class="params">X, parameters</span>):</span><br><span class="line">    <span class="comment"># Retrieve each parameter from the dictionary &quot;parameters&quot;</span></span><br><span class="line">    W1 = parameters[<span class="string">&#x27;W1&#x27;</span>]</span><br><span class="line">    b1 = parameters[<span class="string">&#x27;b1&#x27;</span>]</span><br><span class="line">    W2 = parameters[<span class="string">&#x27;W2&#x27;</span>]</span><br><span class="line">    b2 = parameters[<span class="string">&#x27;b2&#x27;</span>]    </span><br><span class="line">    <span class="comment"># Implement Forward Propagation to calculate A2 (probabilities)</span></span><br><span class="line">    Z1 = np.dot(W1, X) + b1</span><br><span class="line">    A1 = np.tanh(Z1)</span><br><span class="line">    Z2 = np.dot(W2, Z1) + b2</span><br><span class="line">    A2 = sigmoid(Z2)    </span><br><span class="line">    <span class="keyword">assert</span>(A2.shape == (<span class="number">1</span>, X.shape[<span class="number">1</span>]))</span><br><span class="line">    cache = &#123;<span class="string">&quot;Z1&quot;</span>: Z1,                   </span><br><span class="line">             <span class="string">&quot;A1&quot;</span>: A1,                   </span><br><span class="line">             <span class="string">&quot;Z2&quot;</span>: Z2,                  </span><br><span class="line">             <span class="string">&quot;A2&quot;</span>: A2&#125;    </span><br><span class="line">    <span class="keyword">return</span> A2, cache</span><br></pre></td></tr></table></figure>
<p>计算损失函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute_cost</span>(<span class="params">A2, Y, parameters</span>):</span><br><span class="line">    m = Y.shape[<span class="number">1</span>] <span class="comment"># number of example</span></span><br><span class="line">    <span class="comment"># Compute the cross-entropy cost</span></span><br><span class="line">    logprobs = np.multiply(np.log(A2),Y) + np.multiply(np.log(<span class="number">1</span>-A2), <span class="number">1</span>-Y)</span><br><span class="line">    cost = -<span class="number">1</span>/m * np.<span class="built_in">sum</span>(logprobs)</span><br><span class="line">    cost = np.squeeze(cost)     <span class="comment"># makes sure cost is the dimension we expect.</span></span><br><span class="line">    <span class="keyword">assert</span>(<span class="built_in">isinstance</span>(cost, <span class="built_in">float</span>))    </span><br><span class="line">    <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure>
<p>反向传播函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backward_propagation</span>(<span class="params">parameters, cache, X, Y</span>):</span><br><span class="line">    m = X.shape[<span class="number">1</span>]    </span><br><span class="line">    <span class="comment"># First, retrieve W1 and W2 from the dictionary &quot;parameters&quot;.</span></span><br><span class="line">    W1 = parameters[<span class="string">&#x27;W1&#x27;</span>]</span><br><span class="line">    W2 = parameters[<span class="string">&#x27;W2&#x27;</span>]    </span><br><span class="line">    <span class="comment"># Retrieve also A1 and A2 from dictionary &quot;cache&quot;.</span></span><br><span class="line">    A1 = cache[<span class="string">&#x27;A1&#x27;</span>]</span><br><span class="line">    A2 = cache[<span class="string">&#x27;A2&#x27;</span>]    </span><br><span class="line">    <span class="comment"># Backward propagation: calculate dW1, db1, dW2, db2. </span></span><br><span class="line">    dZ2 = A2-Y</span><br><span class="line">    dW2 = <span class="number">1</span>/m * np.dot(dZ2, A1.T)</span><br><span class="line">    db2 = <span class="number">1</span>/m * np.<span class="built_in">sum</span>(dZ2, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    dZ1 = np.dot(W2.T, dZ2)*(<span class="number">1</span>-np.power(A1, <span class="number">2</span>))</span><br><span class="line">    dW1 = <span class="number">1</span>/m * np.dot(dZ1, X.T)</span><br><span class="line">    db1 = <span class="number">1</span>/m * np.<span class="built_in">sum</span>(dZ1, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    grads = &#123;<span class="string">&quot;dW1&quot;</span>: dW1,</span><br><span class="line">             <span class="string">&quot;db1&quot;</span>: db1,                      </span><br><span class="line">             <span class="string">&quot;dW2&quot;</span>: dW2,             </span><br><span class="line">             <span class="string">&quot;db2&quot;</span>: db2&#125;   </span><br><span class="line">    <span class="keyword">return</span> grads</span><br></pre></td></tr></table></figure>
<p>权值更新函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update_parameters</span>(<span class="params">parameters, grads, learning_rate = <span class="number">1.2</span></span>):</span><br><span class="line">    <span class="comment"># Retrieve each parameter from the dictionary &quot;parameters&quot;</span></span><br><span class="line">    W1 = parameters[<span class="string">&#x27;W1&#x27;</span>]</span><br><span class="line">    b1 = parameters[<span class="string">&#x27;b1&#x27;</span>]</span><br><span class="line">    W2 = parameters[<span class="string">&#x27;W2&#x27;</span>]</span><br><span class="line">    b2 = parameters[<span class="string">&#x27;b2&#x27;</span>]    </span><br><span class="line">    <span class="comment"># Retrieve each gradient from the dictionary &quot;grads&quot;</span></span><br><span class="line">    dW1 = grads[<span class="string">&#x27;dW1&#x27;</span>]</span><br><span class="line">    db1 = grads[<span class="string">&#x27;db1&#x27;</span>]</span><br><span class="line">    dW2 = grads[<span class="string">&#x27;dW2&#x27;</span>]</span><br><span class="line">    db2 = grads[<span class="string">&#x27;db2&#x27;</span>]    </span><br><span class="line">    <span class="comment"># Update rule for each parameter</span></span><br><span class="line">    W1 -= dW1 * learning_rate</span><br><span class="line">    b1 -= db1 * learning_rate</span><br><span class="line">    W2 -= dW2 * learning_rate</span><br><span class="line">    b2 -= db2 * learning_rate</span><br><span class="line">    parameters = &#123;<span class="string">&quot;W1&quot;</span>: W1, </span><br><span class="line">                  <span class="string">&quot;b1&quot;</span>: b1,            </span><br><span class="line">                  <span class="string">&quot;W2&quot;</span>: W2,   </span><br><span class="line">                  <span class="string">&quot;b2&quot;</span>: b2&#125;    </span><br><span class="line">    <span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure>
<p>最终的神经网络模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nn_model</span>(<span class="params">X, Y, n_h, num_iterations = <span class="number">10000</span>, print_cost=<span class="literal">False</span></span>):</span><br><span class="line">    np.random.seed(<span class="number">3</span>)</span><br><span class="line">    n_x = layer_sizes(X, Y)[<span class="number">0</span>]</span><br><span class="line">    n_y = layer_sizes(X, Y)[<span class="number">2</span>]    </span><br><span class="line">    <span class="comment"># Initialize parameters, then retrieve W1, b1, W2, b2. Inputs: &quot;n_x, n_h, n_y&quot;. Outputs = &quot;W1, b1, W2, b2, parameters&quot;.</span></span><br><span class="line">    parameters = initialize_parameters(n_x, n_h, n_y)</span><br><span class="line">    W1 = parameters[<span class="string">&#x27;W1&#x27;</span>]</span><br><span class="line">    b1 = parameters[<span class="string">&#x27;b1&#x27;</span>]</span><br><span class="line">    W2 = parameters[<span class="string">&#x27;W2&#x27;</span>]</span><br><span class="line">    b2 = parameters[<span class="string">&#x27;b2&#x27;</span>]    </span><br><span class="line">    <span class="comment"># Loop (gradient descent)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_iterations):        </span><br><span class="line">    <span class="comment"># Forward propagation. Inputs: &quot;X, parameters&quot;. Outputs: &quot;A2, cache&quot;.</span></span><br><span class="line">        A2, cache = forward_propagation(X, parameters)        </span><br><span class="line">        <span class="comment"># Cost function. Inputs: &quot;A2, Y, parameters&quot;. Outputs: &quot;cost&quot;.</span></span><br><span class="line">        cost = compute_cost(A2, Y, parameters)        </span><br><span class="line">        <span class="comment"># Backpropagation. Inputs: &quot;parameters, cache, X, Y&quot;. Outputs: &quot;grads&quot;.</span></span><br><span class="line">        grads = backward_propagation(parameters, cache, X, Y)        </span><br><span class="line">        <span class="comment"># Gradient descent parameter update. Inputs: &quot;parameters, grads&quot;. Outputs: &quot;parameters&quot;.</span></span><br><span class="line">        parameters = update_parameters(parameters, grads, learning_rate=<span class="number">1.2</span>)        </span><br><span class="line">        <span class="comment"># Print the cost every 1000 iterations</span></span><br><span class="line">        <span class="keyword">if</span> print_cost <span class="keyword">and</span> i % <span class="number">1000</span> == <span class="number">0</span>:            </span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;Cost after iteration %i: %f&quot;</span> %(i, cost))    </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Finds算法和ID3算法</title>
    <url>/201910/FINDS%E7%AE%97%E6%B3%95%E5%92%8CID3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="FINDS-算法与-ID3-算法"><a href="#FINDS-算法与-ID3-算法" class="headerlink" title="FINDS 算法与 ID3 算法"></a>FINDS 算法与 ID3 算法</h1><h2 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h2><ol>
<li>实现<code>FINDS</code>算法</li>
<li>实现<code>ID3</code>算法</li>
</ol>
<ul>
<li>不要调库自己写。如果有能力可以继续用课件里的数据集测试两个算法（用天气的4条记录测试<code>FINDS</code>，用贷款的15条记录测试<code>ID3</code>）给出训练误差测试误差等；  </li>
<li>再有能力可以使用更大的数据集测试算法。</li>
</ul>
<span id="more"></span>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="FINDS算法"><a href="#FINDS算法" class="headerlink" title="FINDS算法"></a><code>FINDS</code>算法</h3><ol>
<li>目标：寻找极大特殊假设。</li>
<li>从假设集合H中最特殊的假设开始。在该假设不能正确地划分一个正例的时候将其进行一般化。算法如下：<br><img src="https://s2.ax1x.com/2019/10/22/K3ymOH.jpg" alt="算法流程"></li>
<li><code>FINDS</code>算法是一种利用<code>more-general-than</code>的偏序结构来搜索假设空间的方法，这一搜索沿着偏序链，从较特殊的假设逐渐演变为较一般的假设。</li>
<li>算法<code>Python</code>实现：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string"> Created on 2019/10/21 21:02</span></span><br><span class="line"><span class="string"> FINDS</span></span><br><span class="line"><span class="string"> @Author  : Zhouy</span></span><br><span class="line"><span class="string"> @Blog    : www.crocodilezs.top</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create dataset</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CreateDataset</span>():</span><br><span class="line">    dataset = [[<span class="string">&#x27;Sunny&#x27;</span>, <span class="string">&#x27;Warm&#x27;</span>, <span class="string">&#x27;Normal&#x27;</span>, <span class="string">&#x27;Strong&#x27;</span>, <span class="string">&#x27;Warm&#x27;</span>, <span class="string">&#x27;Same&#x27;</span>, <span class="string">&#x27;Yes&#x27;</span>],</span><br><span class="line">               [<span class="string">&#x27;Sunny&#x27;</span>, <span class="string">&#x27;Warm&#x27;</span>, <span class="string">&#x27;High&#x27;</span>, <span class="string">&#x27;Strong&#x27;</span>, <span class="string">&#x27;Warm&#x27;</span>, <span class="string">&#x27;Same&#x27;</span>, <span class="string">&#x27;Yes&#x27;</span>],</span><br><span class="line">               [<span class="string">&#x27;Rainy&#x27;</span>, <span class="string">&#x27;Cold&#x27;</span>, <span class="string">&#x27;High&#x27;</span>, <span class="string">&#x27;Strong&#x27;</span>, <span class="string">&#x27;Warm&#x27;</span>, <span class="string">&#x27;Change&#x27;</span>, <span class="string">&#x27;No&#x27;</span>],</span><br><span class="line">               [<span class="string">&#x27;Sunny&#x27;</span>, <span class="string">&#x27;Warm&#x27;</span>, <span class="string">&#x27;High&#x27;</span>, <span class="string">&#x27;Strong&#x27;</span>, <span class="string">&#x27;Cold&#x27;</span>, <span class="string">&#x27;Change&#x27;</span>, <span class="string">&#x27;Yes&#x27;</span>]]</span><br><span class="line">    labels = [<span class="string">&#x27;Sky&#x27;</span>, <span class="string">&#x27;Temp&#x27;</span>, <span class="string">&#x27;Humidity&#x27;</span>, <span class="string">&#x27;Wind&#x27;</span>, <span class="string">&#x27;Water&#x27;</span>, <span class="string">&#x27;Forest&#x27;</span>, <span class="string">&#x27;OutdoorSport&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> dataset, labels</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find one version space by using FINDS</span></span><br><span class="line"><span class="comment"># &#x27;/&#x27; means null, and &#x27;*&#x27; means generalization</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FINDS</span>(<span class="params">dataset</span>):</span><br><span class="line">    constraint = [<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;/&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> dataset:</span><br><span class="line">        <span class="keyword">if</span> item[-<span class="number">1</span>] == <span class="string">&#x27;Yes&#x27;</span>:</span><br><span class="line">            <span class="comment"># only go through positive instances</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(item)-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span>(item[i] != constraint[i] <span class="keyword">and</span> constraint[i] != <span class="string">&#x27;*&#x27;</span>):</span><br><span class="line">                    <span class="keyword">if</span>(constraint[i] == <span class="string">&#x27;/&#x27;</span>):</span><br><span class="line">                        constraint[i] = item[i]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        constraint[i] = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> constraint</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    dataset, labels = CreateDataset()</span><br><span class="line">    constraint = FINDS(dataset)</span><br><span class="line">    <span class="built_in">print</span>(constraint)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a><code>ID3</code>算法</h3><ol>
<li>决策树：决策树是一种常用的分类与回归方法。决策树的模型为树形结构，在针对分类问题时，实际上就是针对输入数据的各个特征对实例进行分类的过程，即通过树形结构的模型，在每一层级上对特征值进行判断，进而到达决策树叶子节点，即完成分类过程。<br><strong>决策树的本质是概念学习。</strong></li>
<li><p>信息熵（香浓熵）、条件熵和信息增益的概念</p>
<ul>
<li>信息量：一件事发生的概率越小，我们说它所蕴含的信息量越大。<br><img src="https://s2.ax1x.com/2019/10/22/K36VNq.jpg" alt="信息量"></li>
<li>信息熵：信息熵就是所有可能发生的事件的信息量的期望<br><img src="https://s2.ax1x.com/2019/10/22/K36EEn.jpg" alt="信息熵"></li>
<li>条件熵：表示在X给定条件下，Y的条件概率分布的熵对X的数学期望。<br>![条件熵(<a href="https://s2.ax1x.com/2019/10/22/K36FBj.jpg">https://s2.ax1x.com/2019/10/22/K36FBj.jpg</a>)</li>
<li>信息增益：当我们用另一个变量X对原变量Y分类后，原变量Y的不确定性就会减小了(即熵值减小)。而熵就是不确定性，不确定程度减少了多少其实就是信息增益。这就是信息增益的由来，所以信息增益定义如下：<br><img src="https://s2.ax1x.com/2019/10/22/K36kHs.jpg" alt="信息增益"></li>
</ul>
</li>
<li><p>算法’python’实现:<br>(用课件上的贷款数据集一直没法成功分类，于是参考了csdn博客的另一个数据集合代码)</p>
</li>
</ol>
<p><code>myTrees.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string"> Created on 2019/10/22 11:59</span></span><br><span class="line"><span class="string"> myTrees</span></span><br><span class="line"><span class="string"> @Author  : Zhouy</span></span><br><span class="line"><span class="string"> @Blog    : www.crocodilezs.top</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createDataSet</span>():</span><br><span class="line">    dataSet = [[<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;no&#x27;</span>]]</span><br><span class="line">    labels = [<span class="string">&#x27;no surfacing&#x27;</span>,<span class="string">&#x27;flippers&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> dataSet, labels</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多数表决器</span></span><br><span class="line"><span class="comment"># 列中相同值数量最多为结果</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">majorityCnt</span>(<span class="params">classList</span>):</span><br><span class="line">    classCounts = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> classList:</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">not</span> <span class="keyword">in</span> classCounts.keys()):</span><br><span class="line">            classCounts[value] = <span class="number">0</span></span><br><span class="line">        classCounts[value] += <span class="number">1</span></span><br><span class="line">    sortedClassCount = <span class="built_in">sorted</span>(classCounts.iteritems(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分数据集</span></span><br><span class="line"><span class="comment"># dataSet:原始数据集</span></span><br><span class="line"><span class="comment"># axis:进行分割的指定列索引</span></span><br><span class="line"><span class="comment"># value:指定列中的值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">splitDataSet</span>(<span class="params">dataSet, axis, value</span>):</span><br><span class="line">    retDataSet = []</span><br><span class="line">    <span class="keyword">for</span> featDataVal <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">if</span> featDataVal[axis] == value:</span><br><span class="line">            <span class="comment"># 下面两行去除某一项指定列的值，很巧妙有没有</span></span><br><span class="line">            reducedFeatVal = featDataVal[:axis]</span><br><span class="line">            reducedFeatVal.extend(featDataVal[axis + <span class="number">1</span>:])</span><br><span class="line">            retDataSet.append(reducedFeatVal)</span><br><span class="line">    <span class="keyword">return</span> retDataSet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算香农熵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calcShannonEnt</span>(<span class="params">dataSet</span>):</span><br><span class="line">    <span class="comment"># 数据集总项数</span></span><br><span class="line">    numEntries = <span class="built_in">len</span>(dataSet)</span><br><span class="line">    <span class="comment"># 标签计数对象初始化</span></span><br><span class="line">    labelCounts = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> featDataVal <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="comment"># 获取数据集每一项的最后一列的标签值</span></span><br><span class="line">        currentLabel = featDataVal[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 如果当前标签不在标签存储对象里，则初始化，然后计数</span></span><br><span class="line">        <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys():</span><br><span class="line">            labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">        labelCounts[currentLabel] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 熵初始化</span></span><br><span class="line">    shannonEnt = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># 遍历标签对象，求概率，计算熵</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts.keys():</span><br><span class="line">        prop = labelCounts[key] / <span class="built_in">float</span>(numEntries)</span><br><span class="line">        shannonEnt -= prop * log(prop, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> shannonEnt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选出最优特征列索引</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chooseBestFeatureToSplit</span>(<span class="params">dataSet</span>):</span><br><span class="line">    <span class="comment"># 计算特征个数，dataSet最后一列是标签属性，不是特征量</span></span><br><span class="line">    numFeatures = <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 计算初始数据香农熵</span></span><br><span class="line">    baseEntropy = calcShannonEnt(dataSet)</span><br><span class="line">    <span class="comment"># 初始化信息增益，最优划分特征列索引</span></span><br><span class="line">    bestInfoGain = <span class="number">0.0</span></span><br><span class="line">    bestFeatureIndex = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFeatures):</span><br><span class="line">        <span class="comment"># 获取每一列数据</span></span><br><span class="line">        featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">        <span class="comment"># 将每一列数据去重</span></span><br><span class="line">        uniqueVals = <span class="built_in">set</span>(featList)</span><br><span class="line">        newEntropy = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">            subDataSet = splitDataSet(dataSet, i, value)</span><br><span class="line">            <span class="comment"># 计算条件概率</span></span><br><span class="line">            prob = <span class="built_in">len</span>(subDataSet) / <span class="built_in">float</span>(<span class="built_in">len</span>(dataSet))</span><br><span class="line">            <span class="comment"># 计算条件熵</span></span><br><span class="line">            newEntropy += prob * calcShannonEnt(subDataSet)</span><br><span class="line">        <span class="comment"># 计算信息增益</span></span><br><span class="line">        infoGain = baseEntropy - newEntropy</span><br><span class="line">        <span class="keyword">if</span> (infoGain &gt; bestInfoGain):</span><br><span class="line">            bestInfoGain = infoGain</span><br><span class="line">            bestFeatureIndex = i</span><br><span class="line">    <span class="keyword">return</span> bestFeatureIndex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 决策树创建</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createTree</span>(<span class="params">dataSet, labels</span>):</span><br><span class="line">    <span class="comment"># 获取标签属性，dataSet最后一列，区别于labels标签名称</span></span><br><span class="line">    classList = [example[-<span class="number">1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    <span class="comment"># 树极端终止条件判断</span></span><br><span class="line">    <span class="comment"># 标签属性值全部相同，返回标签属性第一项值</span></span><br><span class="line">    <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == <span class="built_in">len</span>(classList):</span><br><span class="line">        <span class="keyword">return</span> classList[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 只有一个特征（1列）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> majorityCnt(classList)</span><br><span class="line">    <span class="comment"># 获取最优特征列索引</span></span><br><span class="line">    bestFeatureIndex = chooseBestFeatureToSplit(dataSet)</span><br><span class="line">    <span class="comment"># 获取最优索引对应的标签名称</span></span><br><span class="line">    bestFeatureLabel = labels[bestFeatureIndex]</span><br><span class="line">    <span class="comment"># 创建根节点</span></span><br><span class="line">    myTree = &#123;bestFeatureLabel: &#123;&#125;&#125;</span><br><span class="line">    <span class="comment"># 去除最优索引对应的标签名，使labels标签能正确遍历</span></span><br><span class="line">    <span class="keyword">del</span> (labels[bestFeatureIndex])</span><br><span class="line">    <span class="comment"># 获取最优列</span></span><br><span class="line">    bestFeature = [example[bestFeatureIndex] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    uniquesVals = <span class="built_in">set</span>(bestFeature)</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniquesVals:</span><br><span class="line">        <span class="comment"># 子标签名称集合</span></span><br><span class="line">        subLabels = labels[:]</span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        myTree[bestFeatureLabel][value] = createTree(splitDataSet(dataSet, bestFeatureIndex, value), subLabels)</span><br><span class="line">    <span class="keyword">return</span> myTree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取分类结果</span></span><br><span class="line"><span class="comment"># inputTree:决策树字典</span></span><br><span class="line"><span class="comment"># featLabels:标签列表</span></span><br><span class="line"><span class="comment"># testVec:测试向量  例如：简单实例下某一路径 [1,1]  =&gt; yes（树干值组合，从根结点到叶子节点）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify</span>(<span class="params">inputTree, featLabels, testVec</span>):</span><br><span class="line">    <span class="comment"># 获取根结点名称，将dict转化为list</span></span><br><span class="line">    firstSide = <span class="built_in">list</span>(inputTree.keys())</span><br><span class="line">    <span class="comment"># 根结点名称String类型</span></span><br><span class="line">    firstStr = firstSide[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 获取根结点对应的子节点</span></span><br><span class="line">    secondDict = inputTree[firstStr]</span><br><span class="line">    <span class="comment"># 获取根结点名称在标签列表中对应的索引</span></span><br><span class="line">    featIndex = featLabels.index(firstStr)</span><br><span class="line">    <span class="comment"># 由索引获取向量表中的对应值</span></span><br><span class="line">    key = testVec[featIndex]</span><br><span class="line">    <span class="comment"># 获取树干向量后的对象</span></span><br><span class="line">    valueOfFeat = secondDict[key]</span><br><span class="line">    <span class="comment"># 判断是子结点还是叶子节点：子结点就回调分类函数，叶子结点就是分类结果</span></span><br><span class="line">    <span class="comment"># if type(valueOfFeat).__name__==&#x27;dict&#x27;: 等价 if isinstance(valueOfFeat, dict):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(valueOfFeat, <span class="built_in">dict</span>):</span><br><span class="line">        classLabel = classify(valueOfFeat, featLabels, testVec)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        classLabel = valueOfFeat</span><br><span class="line">    <span class="keyword">return</span> classLabel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将决策树分类器存储在磁盘中，filename一般保存为txt格式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">storeTree</span>(<span class="params">inputTree, filename</span>):</span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line">    fw = <span class="built_in">open</span>(filename, <span class="string">&#x27;wb+&#x27;</span>)</span><br><span class="line">    pickle.dump(inputTree, fw)</span><br><span class="line">    fw.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将瓷盘中的对象加载出来，这里的filename就是上面函数中的txt文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grabTree</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line">    fr = <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> pickle.load(fr)</span><br></pre></td></tr></table></figure>
<p><code>treePlotter.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string"> Created on 2019/10/22 12:00</span></span><br><span class="line"><span class="string"> treePlotter</span></span><br><span class="line"><span class="string"> @Author  : Zhouy</span></span><br><span class="line"><span class="string"> @Blog    : www.crocodilezs.top</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">decisionNode = <span class="built_in">dict</span>(boxstyle=<span class="string">&quot;sawtooth&quot;</span>, fc=<span class="string">&quot;0.8&quot;</span>)</span><br><span class="line">leafNode = <span class="built_in">dict</span>(boxstyle=<span class="string">&quot;round4&quot;</span>, fc=<span class="string">&quot;0.8&quot;</span>)</span><br><span class="line">arrow_args = <span class="built_in">dict</span>(arrowstyle=<span class="string">&quot;&lt;-&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取树的叶子节点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getNumLeafs</span>(<span class="params">myTree</span>):</span><br><span class="line">    numLeafs = <span class="number">0</span></span><br><span class="line">    <span class="comment"># dict转化为list</span></span><br><span class="line">    firstSides = <span class="built_in">list</span>(myTree.keys())</span><br><span class="line">    firstStr = firstSides[<span class="number">0</span>]</span><br><span class="line">    secondDict = myTree[firstStr]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">        <span class="comment"># 判断是否是叶子节点（通过类型判断，子类不存在，则类型为str；子类存在，则为dict）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(secondDict[</span><br><span class="line">                    key]).__name__ == <span class="string">&#x27;dict&#x27;</span>:  <span class="comment"># test to see if the nodes are dictonaires, if not they are leaf nodes</span></span><br><span class="line">            numLeafs += getNumLeafs(secondDict[key])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            numLeafs += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> numLeafs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取树的层数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getTreeDepth</span>(<span class="params">myTree</span>):</span><br><span class="line">    maxDepth = <span class="number">0</span></span><br><span class="line">    <span class="comment"># dict转化为list</span></span><br><span class="line">    firstSides = <span class="built_in">list</span>(myTree.keys())</span><br><span class="line">    firstStr = firstSides[<span class="number">0</span>]</span><br><span class="line">    secondDict = myTree[firstStr]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(secondDict[</span><br><span class="line">                    key]).__name__ == <span class="string">&#x27;dict&#x27;</span>:  <span class="comment"># test to see if the nodes are dictonaires, if not they are leaf nodes</span></span><br><span class="line">            thisDepth = <span class="number">1</span> + getTreeDepth(secondDict[key])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            thisDepth = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> thisDepth &gt; maxDepth: maxDepth = thisDepth</span><br><span class="line">    <span class="keyword">return</span> maxDepth</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plotNode</span>(<span class="params">nodeTxt, centerPt, parentPt, nodeType</span>):</span><br><span class="line">    createPlot.ax1.annotate(nodeTxt, xy=parentPt, xycoords=<span class="string">&#x27;axes fraction&#x27;</span>,</span><br><span class="line">                            xytext=centerPt, textcoords=<span class="string">&#x27;axes fraction&#x27;</span>,</span><br><span class="line">                            va=<span class="string">&quot;center&quot;</span>, ha=<span class="string">&quot;center&quot;</span>, bbox=nodeType, arrowprops=arrow_args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plotMidText</span>(<span class="params">cntrPt, parentPt, txtString</span>):</span><br><span class="line">    xMid = (parentPt[<span class="number">0</span>] - cntrPt[<span class="number">0</span>]) / <span class="number">2.0</span> + cntrPt[<span class="number">0</span>]</span><br><span class="line">    yMid = (parentPt[<span class="number">1</span>] - cntrPt[<span class="number">1</span>]) / <span class="number">2.0</span> + cntrPt[<span class="number">1</span>]</span><br><span class="line">    createPlot.ax1.text(xMid, yMid, txtString, va=<span class="string">&quot;center&quot;</span>, ha=<span class="string">&quot;center&quot;</span>, rotation=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plotTree</span>(<span class="params">myTree, parentPt, nodeTxt</span>):  <span class="comment"># if the first key tells you what feat was split on</span></span><br><span class="line">    numLeafs = getNumLeafs(myTree)  <span class="comment"># this determines the x width of this tree</span></span><br><span class="line">    depth = getTreeDepth(myTree)</span><br><span class="line">    firstSides = <span class="built_in">list</span>(myTree.keys())</span><br><span class="line">    firstStr = firstSides[<span class="number">0</span>]  <span class="comment"># the text label for this node should be this</span></span><br><span class="line">    cntrPt = (plotTree.xOff + (<span class="number">1.0</span> + <span class="built_in">float</span>(numLeafs)) / <span class="number">2.0</span> / plotTree.totalW, plotTree.yOff)</span><br><span class="line">    plotMidText(cntrPt, parentPt, nodeTxt)</span><br><span class="line">    plotNode(firstStr, cntrPt, parentPt, decisionNode)</span><br><span class="line">    secondDict = myTree[firstStr]</span><br><span class="line">    plotTree.yOff = plotTree.yOff - <span class="number">1.0</span> / plotTree.totalD</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(secondDict[</span><br><span class="line">                    key]).__name__ == <span class="string">&#x27;dict&#x27;</span>:  <span class="comment"># test to see if the nodes are dictonaires, if not they are leaf nodes</span></span><br><span class="line">            plotTree(secondDict[key], cntrPt, <span class="built_in">str</span>(key))  <span class="comment"># recursion</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># it&#x27;s a leaf node print the leaf node</span></span><br><span class="line">            plotTree.xOff = plotTree.xOff + <span class="number">1.0</span> / plotTree.totalW</span><br><span class="line">            plotNode(secondDict[key], (plotTree.xOff, plotTree.yOff), cntrPt, leafNode)</span><br><span class="line">            plotMidText((plotTree.xOff, plotTree.yOff), cntrPt, <span class="built_in">str</span>(key))</span><br><span class="line">    plotTree.yOff = plotTree.yOff + <span class="number">1.0</span> / plotTree.totalD</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># if you do get a dictonary you know it&#x27;s a tree, and the first element will be another dict</span></span><br><span class="line"><span class="comment"># 绘制决策树</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createPlot</span>(<span class="params">inTree</span>):</span><br><span class="line">    fig = plt.figure(<span class="number">1</span>, facecolor=<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">    fig.clf()</span><br><span class="line">    axprops = <span class="built_in">dict</span>(xticks=[], yticks=[])</span><br><span class="line">    createPlot.ax1 = plt.subplot(<span class="number">111</span>, frameon=<span class="literal">False</span>, **axprops)  <span class="comment"># no ticks</span></span><br><span class="line">    <span class="comment"># createPlot.ax1 = plt.subplot(111, frameon=False) #ticks for demo puropses</span></span><br><span class="line">    plotTree.totalW = <span class="built_in">float</span>(getNumLeafs(inTree))</span><br><span class="line">    plotTree.totalD = <span class="built_in">float</span>(getTreeDepth(inTree))</span><br><span class="line">    plotTree.xOff = -<span class="number">0.5</span> / plotTree.totalW</span><br><span class="line">    plotTree.yOff = <span class="number">1.0</span></span><br><span class="line">    plotTree(inTree, (<span class="number">0.5</span>, <span class="number">1.0</span>), <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制树的根节点和叶子节点（根节点形状：长方形，叶子节点：椭圆形）</span></span><br><span class="line"><span class="comment"># def createPlot():</span></span><br><span class="line"><span class="comment">#    fig = plt.figure(1, facecolor=&#x27;white&#x27;)</span></span><br><span class="line"><span class="comment">#    fig.clf()</span></span><br><span class="line"><span class="comment">#    createPlot.ax1 = plt.subplot(111, frameon=False) #ticks for demo puropses</span></span><br><span class="line"><span class="comment">#    plotNode(&#x27;a decision node&#x27;, (0.5, 0.1), (0.1, 0.5), decisionNode)</span></span><br><span class="line"><span class="comment">#    plotNode(&#x27;a leaf node&#x27;, (0.8, 0.1), (0.3, 0.8), leafNode)</span></span><br><span class="line"><span class="comment">#    plt.show()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">retrieveTree</span>(<span class="params">i</span>):</span><br><span class="line">    listOfTrees = [&#123;<span class="string">&#x27;no surfacing&#x27;</span>: &#123;<span class="number">0</span>: <span class="string">&#x27;no&#x27;</span>, <span class="number">1</span>: &#123;<span class="string">&#x27;flippers&#x27;</span>: &#123;<span class="number">0</span>: <span class="string">&#x27;no&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;yes&#x27;</span>&#125;&#125;&#125;&#125;,</span><br><span class="line">                   &#123;<span class="string">&#x27;no surfacing&#x27;</span>: &#123;<span class="number">0</span>: <span class="string">&#x27;no&#x27;</span>, <span class="number">1</span>: &#123;<span class="string">&#x27;flippers&#x27;</span>: &#123;<span class="number">0</span>: &#123;<span class="string">&#x27;head&#x27;</span>: &#123;<span class="number">0</span>: <span class="string">&#x27;no&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;yes&#x27;</span>&#125;&#125;, <span class="number">1</span>: <span class="string">&#x27;no&#x27;</span>&#125;&#125;&#125;&#125;</span><br><span class="line">                   ]</span><br><span class="line">    <span class="keyword">return</span> listOfTrees[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># thisTree = retrieveTree(0)</span></span><br><span class="line"><span class="comment"># createPlot(thisTree)</span></span><br><span class="line"><span class="comment"># createPlot()</span></span><br><span class="line"><span class="comment"># myTree = retrieveTree(0)</span></span><br><span class="line"><span class="comment"># numLeafs =getNumLeafs(myTree)</span></span><br><span class="line"><span class="comment"># treeDepth =getTreeDepth(myTree)</span></span><br><span class="line"><span class="comment"># print(u&quot;叶子节点数目：%d&quot;% numLeafs)</span></span><br><span class="line"><span class="comment"># print(u&quot;树深度：%d&quot;%treeDepth)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>testTrees_3.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string"> Created on 2019/10/22 12:00</span></span><br><span class="line"><span class="string"> testTrees_3</span></span><br><span class="line"><span class="string"> @Author  : Zhouy</span></span><br><span class="line"><span class="string"> @Blog    : www.crocodilezs.top</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> myTrees <span class="keyword">as</span> mt</span><br><span class="line"><span class="keyword">import</span> treePlotter <span class="keyword">as</span> tp</span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">dataSet, labels = mt.createDataSet()</span><br><span class="line"><span class="comment">#copy函数：新开辟一块内存，然后将list的所有值复制到新开辟的内存中</span></span><br><span class="line">labels1 = labels.copy()</span><br><span class="line"><span class="comment">#createTree函数中将labels1的值改变了，所以在分类测试时不能用labels1</span></span><br><span class="line">myTree = mt.createTree(dataSet,labels1)</span><br><span class="line"><span class="comment">#保存树到本地</span></span><br><span class="line">mt.storeTree(myTree,<span class="string">&#x27;myTree.txt&#x27;</span>)</span><br><span class="line"><span class="comment">#在本地磁盘获取树</span></span><br><span class="line">myTree = mt.grabTree(<span class="string">&#x27;myTree.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">u&quot;决策树结构：%s&quot;</span>%myTree)</span><br><span class="line"><span class="comment">#绘制决策树</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">u&quot;绘制决策树：&quot;</span>)</span><br><span class="line">tp.createPlot(myTree)</span><br><span class="line">numLeafs =tp.getNumLeafs(myTree)</span><br><span class="line">treeDepth =tp.getTreeDepth(myTree)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">u&quot;叶子节点数目：%d&quot;</span>% numLeafs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">u&quot;树深度：%d&quot;</span>%treeDepth)</span><br><span class="line"><span class="comment">#测试分类 简单样本数据3列</span></span><br><span class="line">labelResult =mt.classify(myTree,labels,[<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">u&quot;[1,1] 测试结果为：%s&quot;</span>%labelResult)</span><br><span class="line">labelResult =mt.classify(myTree,labels,[<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">u&quot;[1,0] 测试结果为：%s&quot;</span>%labelResult)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>FindS</tag>
        <tag>ID3</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统基础实验一、Linux环境和GCC工具链</title>
    <url>/201910/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
    <content><![CDATA[<h1 id="Linux操作系统概述和实验环境介绍"><a href="#Linux操作系统概述和实验环境介绍" class="headerlink" title="Linux操作系统概述和实验环境介绍"></a><code>Linux</code>操作系统概述和实验环境介绍</h1><h2 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h2><p><code>OS</code>是管理和控制计算机硬件与软件资源的计算机程序，是直接在“裸机”上的最基本的系统软件。</p>
<h2 id="Linux的应用"><a href="#Linux的应用" class="headerlink" title="Linux的应用"></a><code>Linux</code>的应用</h2><ol>
<li>服务器端：Linux非常稳定，特别适合大型企业生产环境。</li>
<li>作为网络平台的后端服务器被使用。</li>
<li>作为应用服务器、数据库服务器被使用：解决海量数据、高并发的问题；</li>
<li>作为嵌入式操作系统被使用：智能控制、自动化、物联网等领域。</li>
</ol>
<span id="more"></span>
<h2 id="Linux历史"><a href="#Linux历史" class="headerlink" title="Linux历史"></a><code>Linux</code>历史</h2><p>追溯到<code>UNIX</code><br>简单地说，<code>Linux</code>是对<code>UNIX</code>的重新实现。世界各地的<code>Linux</code>开发人员借鉴了<code>UNIX</code>的技术和用户界面，并且融入了很多独创的技术。<code>Linux</code>不属于<code>BSD</code>和<code>AT&amp;T</code>风格的<code>UNIX</code>中的任何一种。因此，严格来说，<code>Linux</code>是有别于<code>UNIX</code>的另一种操作系统。</p>
<h2 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a><code>Linux</code>简介</h2><p><code>Linux</code>发现行版本举例：<code>Ubuntu</code>、<code>redhat</code></p>
<h2 id="操作系统的三个部分"><a href="#操作系统的三个部分" class="headerlink" title="操作系统的三个部分"></a>操作系统的三个部分</h2><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><p>操作系统五大管理功能一般都由操作系统内核负责。</p>
<h3 id="外壳"><a href="#外壳" class="headerlink" title="外壳"></a>外壳</h3><ul>
<li>外壳程序负责接收用户操作，提供与 用户的交互界面。</li>
<li>一般操作系统提供给用户的界面主要有两种：文本界面、<code>GUI</code>图形界面。<h3 id="管理工具和附属软件"><a href="#管理工具和附属软件" class="headerlink" title="管理工具和附属软件"></a>管理工具和附属软件</h3></li>
</ul>
<h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><ol>
<li><code>CPU</code>的控制与管理：处理器管理</li>
<li>内存的分配与管理：存储器管理</li>
<li>外部设备的控制与管理：设备管理</li>
<li>文件管理</li>
<li>作业管理和控制：用户接口</li>
</ol>
<h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a><code>Shell</code></h2><ol>
<li>外壳程序对用户的输入命令进行解释，为用户提供一种通过操作系统使用计算机的操作环境。</li>
<li><code>Windows</code>的图形界面，由一个成为<code>Explorer</code>的模块解释用户的输入。</li>
<li>如<code>DOS</code>的命令行界面，<code>Command.com</code>是对命令输入进行解释的外壳程序(<code>Linux</code>的<code>Shell</code>)</li>
<li>Shell命令：从命令行输入语句，每输入一次就能得到一次响应，这些语句就是<code>shell</code>命令。</li>
<li><code>Shell</code>程序：又称<code>Shell</code>脚本。（把一系列的<code>shell</code>命令，按照一定的语法规则和控制结构，组织在一个文件中，然后由内核来一条接一条地解释和执行这些命令，这个文件就是shell程序，类似<code>DOS</code>/<code>Winsows</code>中的。bat批处理文件。）</li>
<li>[username@computername ~]$<br>user name为当前用户名，computername 为当前计算机名 ，$表示当前用户是一般用户。 <h2 id="ssh-secure-shell"><a href="#ssh-secure-shell" class="headerlink" title="ssh secure shell"></a><code>ssh</code> secure shell</h2>把<code>Linux</code>终端搬到<code>Windows</code>下，连接到BUPT1.<h2 id="Shell常用命令"><a href="#Shell常用命令" class="headerlink" title="Shell常用命令"></a><code>Shell</code>常用命令</h2><h3 id="目录操作命令"><a href="#目录操作命令" class="headerlink" title="目录操作命令"></a>目录操作命令</h3>目录操作命令能够对当前的目录进行查看、创建、删除，以及显示当前工作目录和改变当前目录等操作。</li>
</ol>
<div note="class info">
    1. /etc - 系统所需的重要配置和管理文件<br />
    2. /dev - 存放device file（装置文件）<br />
    3. /boot - 存放系统激活的相关文件，不可任意删除。<br />
    4. /home - 登陆用户的主目录<br />
    5. /lib - 存放系统激活时需要的系统函数库<br />
    6. /usr/lib - 存放一些应用程序的共享函数库<br />
    7. /mnt - 系统默认的挂载点(mount point)
    8. /proc - 虚拟文件系统，不占用硬盘空间，目录下的文件均放置于内存中<br />
    9. /root - 系统管理用户root的主目录<br />
    10. /bin - 存放一些系统启动时所需的普通程序和系统程序<br />
    11. /tmp - 存放临时文件
    12. /var - 存放被系统修改过的数据。
</div>

<p>常用的目录操作命令包括：</p>
<ol>
<li>pwd 打印当前工作目录</li>
<li>cd 改变当前所在目录</li>
<li>ls 查看当前目录下的内容</li>
<li>dir 类似ls命令</li>
<li>mkdir 创建目录</li>
<li>rmdir 删除空目录</li>
</ol>
<h3 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h3><ul>
<li>在命令行环境下对文件进行操作将比在图形环境下操作文件更加快捷和高效</li>
<li>文件操作主要包括：搜索文件、复制和移动文件、删除文件以及合并文件内容</li>
</ul>
<p>常用文件操作命令：  </p>
<ul>
<li><code>cat</code>  </li>
<li><code>more</code>  </li>
<li><code>less</code>  </li>
<li><code>head</code></li>
<li><code>tail</code></li>
<li><code>cp</code></li>
<li><code>mv</code></li>
<li><code>rm</code></li>
<li><code>find</code></li>
<li><code>touch</code></li>
<li><code>ln</code></li>
</ul>
<h3 id="使用帮助命令"><a href="#使用帮助命令" class="headerlink" title="使用帮助命令"></a>使用帮助命令</h3><ol>
<li><code>man 命令名</code> </li>
<li><code>whatis 命令名</code>  </li>
<li><code>help 命令名</code>：适用于部分命令</li>
</ol>
<h2 id="Vi编辑器"><a href="#Vi编辑器" class="headerlink" title="Vi编辑器"></a>Vi编辑器</h2><h3 id="Vi简介"><a href="#Vi简介" class="headerlink" title="Vi简介"></a><code>Vi</code>简介</h3><ul>
<li><code>Vi</code>编辑器是<code>Visual interface</code>的简称，它可以执行输出、删除、查找、替换、块操作等众多文本操作</li>
<li><code>Vi</code>不是一个排版程序，只是一个文本编辑程序。</li>
<li>是全屏幕文本编辑器，没有菜单，只有命令。</li>
</ul>
<h3 id="Vi的基本概念"><a href="#Vi的基本概念" class="headerlink" title="Vi的基本概念"></a><code>Vi</code>的基本概念</h3><ol>
<li>命令行模式（command mode）<br>控制屏幕光标的移动、字符、字或行的删除、移动复制某区段及进入<code>Insert mode</code>下，或者到<code>last line mode</code>。</li>
<li>插入模式（Insert mode）<br>只有在<code>Insert mode</code>下，才可以做文字输入，按ESC键可回到命令行模式。</li>
<li>底行模式(last line mode)<br>将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号。</li>
</ol>
<div class="note info">
    $ vi test.txt<br />
    即可进入vi（打开或新建文件）
</div>

<p>操作：</p>
<ol>
<li>命令行模式 —-&gt;(i)  插入模式</li>
<li>插入模式  —-&gt;（ESC）  命令行模式</li>
<li>如果处于「插入模式」，就只能一直输入文字，如果发现输错了字想用光标往回移动将该字删除，就得先回到「命令行模式」</li>
<li>在「命令行模式」下，按下：进入底行模式<br><code>: w filename</code><br><code>: wq</code><br><code>: q!</code></li>
</ol>
<h2 id="GCC工具链"><a href="#GCC工具链" class="headerlink" title="GCC工具链"></a><code>GCC</code>工具链</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol>
<li><code>GCC</code>编译器能将<code>C</code>和<code>C++</code>语言源程序、汇编程序编译、链接成可执行文件。</li>
<li>使用<code>GCC</code>编译器时，编译过程可以被细分为四个阶段：<ul>
<li>预处理(Pre-Processing)</li>
<li>编译(Compiling)</li>
<li>汇编(Assembling)</li>
<li>链接(Linking)</li>
</ul>
</li>
</ol>
<h3 id="GDB的概述"><a href="#GDB的概述" class="headerlink" title="GDB的概述"></a><code>GDB</code>的概述</h3><p><code>GDB</code>是一款GNU开发组织并发布的UNIX/Linux下的程序调试工具。它使你能够在程序运行时观察程序的内部结构和内存的使用情况。以下是<code>GDB</code>提供的一些功能：</p>
<ol>
<li>监视程序中变量的值</li>
<li>设置断点以使程序在指定的代码行上停止运行</li>
<li>能逐行执行代码</li>
</ol>
<h2 id="Objdump简介"><a href="#Objdump简介" class="headerlink" title="Objdump简介"></a><code>Objdump</code>简介</h2><p><code>Objdump</code>是以一种可阅读的格式让你更多地了解二进制文件可能带有地附加信息。<br>对于想进一步了解系统地程序员，这个命令没有没有更多意义，对于想进一步了解系统的程序员，应该掌握这种工具，至少你可以自己写写<code>shellcode</code>了，或者看看人家给的<code>exploit</code>中的<code>shellcode</code>是什么东西。<br><strong>把C语言源代码编译链接生成的可执行程序反汇编后得到对应的汇编代码，可以帮助我们理解C语言和汇编语言之间的对应关系。非常有助于深入理解C语言</strong></p>
<div class="note warning">
    至此，已经完成了计算机系统基础第一次实验的理论部分，其中有太多的东西还需要自己去实践、接下来开始实验！
</div>]]></content>
      <categories>
        <category>计算机系统基础</category>
      </categories>
  </entry>
  <entry>
    <title>CS229-机器学习-吴恩达（一）</title>
    <url>/201910/CS229-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="1-1-Welcome-to-machine-learning"><a href="#1-1-Welcome-to-machine-learning" class="headerlink" title="1-1 Welcome to machine learning!"></a>1-1 Welcome to machine learning!</h1><ol>
<li>Machine learning is the science of getting computers to learn without being explicitly programmed.  </li>
<li>Machine Learning Honor Code</li>
</ol>
<h1 id="1-2-Welcome"><a href="#1-2-Welcome" class="headerlink" title="1-2 Welcome"></a>1-2 Welcome</h1><p>machine Learning</p>
<pre><code>- Grew out of work in AI
- New capability for computers
</code></pre><p>Exmaple:</p>
<pre><code>- Database mining
Large datasets from growth of automation/web.
E.g. Web click data, medical records, biology, engineering
- Applicaitons can&#39;t program by hand.
E.g., Autonomous helicopter, handwriting recognition, most of Natural Language Processing(NLP), Computer Vision.
- Self customizing programs
E.g., Amazon, Netflix product recommendations
- Understanding human learning(brain, real AI).
</code></pre><h1 id="1-3-What-is-machine-learning"><a href="#1-3-What-is-machine-learning" class="headerlink" title="1-3 What is machine learning?"></a>1-3 What is machine learning?</h1><p>To know what is machine learning and give u a sense of when u want to use machine learning.  </p>
<h2 id="Machine-learning-defination"><a href="#Machine-learning-defination" class="headerlink" title="Machine learning defination"></a>Machine learning defination</h2><ol>
<li>Arthur Samuel(1959). Machine Learning: Field of study that gives computers the ability to learn without being explicitly programmed.</li>
<li>Tom Mitchell(1998) Well-posed Learning Problem: A computer Program is said to learn from experience $E$ with respect to some task $T$ and some performance measure $P$, if its performance on $T$ as measured by $P$ improves with experience $E$. </li>
</ol>
<h2 id="Machine-learning-algorithms"><a href="#Machine-learning-algorithms" class="headerlink" title="Machine learning algorithms"></a>Machine learning algorithms</h2><ul>
<li>Supervised learning</li>
<li>Unsupervised learning</li>
</ul>
<p>Others: Reinforcement learning(强化学习), recommender systems(推荐系统).</p>
<p>Also talk about <strong>practical advice</strong> for applying learning algorithms.</p>
<h1 id="1-4-Supevised-learning"><a href="#1-4-Supevised-learning" class="headerlink" title="1-4 Supevised learning"></a>1-4 Supevised learning</h1><p>Supervised learning:<br>“right answers” given.  </p>
<ol>
<li>Regression: Predict continuous valued output.(Used: house price)</li>
<li>Classification: Discrete valued output(0 or 1)(Used: Breast cancer)</li>
</ol>
<p><strong>How do you deal with an infinite number of features, and how do you even store an infinite number of things on the computer?</strong><br>SVM will be a neat mathematical trick that will allow a computer to deal with an infinite number of features.</p>
<h1 id="1-5-Unsupervised-Learning"><a href="#1-5-Unsupervised-Learning" class="headerlink" title="1-5 Unsupervised Learning"></a>1-5 Unsupervised Learning</h1><p>Data does not have any labels.<br>Used: </p>
<ol>
<li>Google News.(Cluster the news of the same topic)  </li>
<li>DNA microarray data.</li>
<li>Organize large computer clusters.</li>
<li>Social network analysis</li>
<li>Market segmentation</li>
<li>Astronomical data analysis(how galaxies are formed.)</li>
</ol>
<p>Clustering is just one type of Unsupervised Learning.</p>
<h2 id="Cocktail-Party-problem"><a href="#Cocktail-Party-problem" class="headerlink" title="Cocktail Party problem"></a>Cocktail Party problem</h2><p>recognize and separate the audio.<br><strong>when you use the right programming enviroment, many learning algorithms can be really shot programs.</strong>  </p>
<p><strong>If you use Octave as your learning tool and as your prorotyping tool(原型工具), it will let you learn and prototype learning algorithms much quickly.</strong></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>Fisher算法&amp;SVM&amp;K-Means及其优化</title>
    <url>/201911/Fisher%E7%AE%97%E6%B3%95&amp;SVM&amp;K-Means%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Fisher算法-amp-SVM-amp-K-Means及其优化"><a href="#Fisher算法-amp-SVM-amp-K-Means及其优化" class="headerlink" title="Fisher算法&amp;SVM&amp;K-Means及其优化"></a>Fisher算法&amp;SVM&amp;K-Means及其优化</h1><p>部分源码的参考资料已注明</p>
<h2 id="fisher算法及其实现"><a href="#fisher算法及其实现" class="headerlink" title="fisher算法及其实现"></a><code>fisher</code>算法及其实现</h2><ol>
<li>请实现<code>fisher</code>算法，并采用自己随机生成2类数据（每类100个）的方式，验证自己的算法。<br><a href="https://blog.csdn.net/pengjian444/article/details/71138003">参考资料:https://blog.csdn.net/pengjian444/article/details/71138003</a></li>
</ol>
<span id="more"></span>
<h3 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_multilabel_classification</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x, y = make_multilabel_classification(n_samples=<span class="number">200</span>, n_features=<span class="number">2</span>,</span><br><span class="line">                                      n_labels=<span class="number">1</span>, n_classes=<span class="number">1</span>,</span><br><span class="line">                                      random_state=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据类别分类</span></span><br><span class="line">index1 = np.array([index <span class="keyword">for</span> (index, value) <span class="keyword">in</span> <span class="built_in">enumerate</span>(y) <span class="keyword">if</span> value == <span class="number">0</span>])  <span class="comment"># 获取类别1的indexs</span></span><br><span class="line">index2 = np.array([index <span class="keyword">for</span> (index, value) <span class="keyword">in</span> <span class="built_in">enumerate</span>(y) <span class="keyword">if</span> value == <span class="number">1</span>])  <span class="comment"># 获取类别2的indexs</span></span><br><span class="line"></span><br><span class="line">c_1 = x[index1]   <span class="comment"># 类别1的所有数据(x1, x2) in X_1</span></span><br><span class="line">c_2 = x[index2]  <span class="comment"># 类别2的所有数据(x1, x2) in X_2</span></span><br></pre></td></tr></table></figure>
<p><a href="http://lijiancheng0614.github.io/scikit-learn/modules/generated/sklearn.datasets.make_multilabel_classification.html#sklearn.datasets.make_multilabel_classification">make_multilabel_classification方法参数说明</a><br><code>n_samples</code>:样本的数量。<br><code>n_features</code>：样本的特征，这里是在二维平面中的点，所以为2.<br><code>n_labels</code>：每个实例的平均标签数。<br><code>n_classes</code>：分类问题的分类数。<br><code>random_state</code>：设置随机数种子，保证每次产生相同的数据。</p>
<p><a href="https://www.runoob.com/python/python-func-enumerate.html">enumerate()函数说明</a><br><code>enumerate()</code>函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p>
<h3 id="fisher算法实现"><a href="#fisher算法实现" class="headerlink" title="fisher算法实现"></a>fisher算法实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cal_cov_and_avg</span>(<span class="params">samples</span>):</span><br><span class="line">    u1 = np.mean(samples, axis=<span class="number">0</span>)</span><br><span class="line">    cov_m = np.zeros((samples.shape[<span class="number">1</span>], samples.shape[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> samples:</span><br><span class="line">        t = s - u1</span><br><span class="line">        cov_m += t * t.reshape(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> cov_m, u1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fisher</span>(<span class="params">c_1, c_2</span>):</span><br><span class="line">    cov_1, u1 = cal_cov_and_avg(c_1)</span><br><span class="line">    cov_2, u2 = cal_cov_and_avg(c_2)</span><br><span class="line">    s_w = cov_1 + cov_2</span><br><span class="line">    u, s, v = np.linalg.svd(s_w)  <span class="comment"># 奇异值分解</span></span><br><span class="line">    s_w_inv = np.dot(np.dot(v.T, np.linalg.inv(np.diag(s))), u.T)</span><br><span class="line">    <span class="keyword">return</span> np.dot(s_w_inv, u1 - u2)</span><br></pre></td></tr></table></figure>
<p><code>np.mean</code>：计算制定轴上的平均值。<br><code>np.zeros</code>：给定形状和类型确定的数组，并用0填充。</p>
<h3 id="判定类别"><a href="#判定类别" class="headerlink" title="判定类别"></a>判定类别</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">judge</span>(<span class="params">sample, w, c_1, c_2</span>):</span><br><span class="line">    u1 = np.mean(c_1, axis=<span class="number">0</span>)</span><br><span class="line">    u2 = np.mean(c_2, axis=<span class="number">0</span>)</span><br><span class="line">    center_1 = np.dot(w.T, u1)</span><br><span class="line">    center_2 = np.dot(w.T, u2)</span><br><span class="line">    pos = np.dot(w.T, sample)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(pos - center_1) &lt; <span class="built_in">abs</span>(pos - center_2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w = fisher(c_1, c_2)  <span class="comment"># 调用函数，得到参数w</span></span><br><span class="line">out = judge(c_1[<span class="number">1</span>], w, c_1, c_2)   <span class="comment"># 判断所属的类别</span></span><br><span class="line"><span class="comment"># print(out)</span></span><br></pre></td></tr></table></figure>
<h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.scatter(c_1[:, <span class="number">0</span>], c_1[:, <span class="number">1</span>], c=<span class="string">&#x27;#99CC99&#x27;</span>)</span><br><span class="line">plt.scatter(c_2[:, <span class="number">0</span>], c_2[:, <span class="number">1</span>], c=<span class="string">&#x27;#FFCC00&#x27;</span>)</span><br><span class="line">line_x = np.arange(<span class="built_in">min</span>(np.<span class="built_in">min</span>(c_1[:, <span class="number">0</span>]), np.<span class="built_in">min</span>(c_2[:, <span class="number">0</span>])),</span><br><span class="line">                   <span class="built_in">max</span>(np.<span class="built_in">max</span>(c_1[:, <span class="number">0</span>]), np.<span class="built_in">max</span>(c_2[:, <span class="number">0</span>])),</span><br><span class="line">                   step=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">line_y = - (w[<span class="number">0</span>] * line_x) / w[<span class="number">1</span>]</span><br><span class="line">plt.plot(line_x, line_y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<pre><code>&lt;Figure size 640x480 with 1 Axes&gt;
</code></pre><h2 id="SVM优化对偶问题的详细推导过程"><a href="#SVM优化对偶问题的详细推导过程" class="headerlink" title="SVM优化对偶问题的详细推导过程"></a><code>SVM</code>优化对偶问题的详细推导过程</h2><ol>
<li>请给出<code>SVM</code>优化对偶问题的详细推导过程；并给出只有2维特征情况下的，对偶问题的优化求解过程（可以采用<code>lagrange</code>方法，也可以采用其他方法。）<br><a href="https://zhuanlan.zhihu.com/p/49331510">参考资料：https://zhuanlan.zhihu.com/p/49331510</a>  </li>
</ol>
<p><img src="https://s2.ax1x.com/2019/10/08/uWyoX4.png" alt=""><br><img src="https://s2.ax1x.com/2019/10/08/uWy4pT.png" alt=""><br><img src="https://s2.ax1x.com/2019/10/08/uWyIcF.png" alt=""><br><img src="https://s2.ax1x.com/2019/10/08/uWy51U.png" alt=""><br><img src="https://s2.ax1x.com/2019/10/08/uWyfhV.png" alt=""></p>
<h2 id="SVM算法的实现"><a href="#SVM算法的实现" class="headerlink" title="SVM算法的实现"></a><code>SVM</code>算法的实现</h2><ol>
<li>请实现<code>SVM</code>算法；并采用自己随机生成2类线性可分数据（每类100个）的方式验证自己的算法。<br><a href="https://www.jb51.net/article/131580.htm">参考资料：https://www.jb51.net/article/131580.htm</a></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line">  </span><br><span class="line">np.random.seed(<span class="number">0</span>) </span><br><span class="line">x = np.r_[np.random.randn(<span class="number">100</span>,<span class="number">2</span>)-[<span class="number">2</span>,<span class="number">2</span>],np.random.randn(<span class="number">100</span>,<span class="number">2</span>)+[<span class="number">2</span>,<span class="number">2</span>]] <span class="comment">#正态分布来产生数字,20行2列*2 </span></span><br><span class="line">y = [<span class="number">0</span>]*<span class="number">100</span>+[<span class="number">1</span>]*<span class="number">100</span> <span class="comment">#100个class0，100个class1 </span></span><br><span class="line">  </span><br><span class="line">clf = svm.SVC(kernel=<span class="string">&#x27;linear&#x27;</span>) </span><br><span class="line">clf.fit(x,y) </span><br><span class="line">  </span><br><span class="line">w = clf.coef_[<span class="number">0</span>] <span class="comment">#获取w </span></span><br><span class="line">a = -w[<span class="number">0</span>]/w[<span class="number">1</span>] <span class="comment">#斜率 </span></span><br><span class="line"><span class="comment">#画图划线 </span></span><br><span class="line">xx = np.linspace(-<span class="number">5</span>,<span class="number">5</span>) <span class="comment">#(-5,5)之间x的值 </span></span><br><span class="line">yy = a*xx-(clf.intercept_[<span class="number">0</span>])/w[<span class="number">1</span>] <span class="comment">#xx带入y，截距 </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#画出与点相切的线 </span></span><br><span class="line">b = clf.support_vectors_[<span class="number">0</span>] </span><br><span class="line">yy_down = a*xx+(b[<span class="number">1</span>]-a*b[<span class="number">0</span>]) </span><br><span class="line">b = clf.support_vectors_[-<span class="number">1</span>] </span><br><span class="line">yy_up = a*xx+(b[<span class="number">1</span>]-a*b[<span class="number">0</span>]) </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;W:&quot;</span>,w) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a:&quot;</span>,a) </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;support_vectors_:&quot;</span>,clf.support_vectors_) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;clf.coef_:&quot;</span>,clf.coef_) </span><br><span class="line">  </span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">4</span>)) </span><br><span class="line">plt.plot(xx,yy) </span><br><span class="line">plt.plot(xx,yy_down) </span><br><span class="line">plt.plot(xx,yy_up) </span><br><span class="line">plt.scatter(clf.support_vectors_[:,<span class="number">0</span>],clf.support_vectors_[:,<span class="number">1</span>],s=<span class="number">80</span>) </span><br><span class="line">plt.scatter(x[:,<span class="number">0</span>],x[:,<span class="number">1</span>],c=y,cmap=plt.cm.Paired) <span class="comment">#[:，0]列切片，第0列 </span></span><br><span class="line">  </span><br><span class="line">plt.axis(<span class="string">&#x27;tight&#x27;</span>) </span><br><span class="line">  </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<pre><code>W: [0.95070185 1.15607502]
a: -0.8223530762163854
support_vectors_: [[-0.51174781 -0.10411082]
 [ 0.16323595 -0.66347205]
 [ 2.39904635 -0.77259276]
 [ 0.66574153  0.65328249]
 [-0.25556423  0.97749316]]
clf.coef_: [[0.95070185 1.15607502]]
</code></pre><p><img src="output_12_1.png" alt="png"></p>
<h2 id="k-means算法的实现"><a href="#k-means算法的实现" class="headerlink" title="k-means算法的实现"></a><code>k-means</code>算法的实现</h2><ol>
<li>请实现<code>k-means</code>的算法；并采用自己随机生成3类数据（每类100个）的方式，验证自己的算法。<br><a href="https://cloud.tencent.com/developer/article/1465020">参考资料1:https://cloud.tencent.com/developer/article/1465020</a><br><a href="https://blog.csdn.net/weixin_42029738/article/details/81978038">参考资料2:https://blog.csdn.net/weixin_42029738/article/details/81978038</a>  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    K-Means clustering algorithms</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(__doc__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> MiniBatchKMeans, KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances_argmin</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_blobs</span><br><span class="line"></span><br><span class="line"><span class="comment"># #############################################################################</span></span><br><span class="line"><span class="comment"># Generate sample data</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">45</span></span><br><span class="line">centers = [[<span class="number">1</span>, <span class="number">1</span>], [-<span class="number">1</span>, -<span class="number">1</span>], [<span class="number">1</span>, -<span class="number">1</span>]] <span class="comment"># 初始化3个中心</span></span><br><span class="line">n_clusters = <span class="built_in">len</span>(centers) <span class="comment"># 聚类的数目为3</span></span><br><span class="line"><span class="comment"># 产生10000组二维数据，以上面三个点为中心，以(-10,10)为边界，数据集的标准差是0.7</span></span><br><span class="line">X, labels_true = make_blobs(n_samples=<span class="number">10000</span>, centers=centers, cluster_std=<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># #############################################################################</span></span><br><span class="line"><span class="comment"># Compute clustering with Means</span></span><br><span class="line"></span><br><span class="line">k_means = KMeans(init=<span class="string">&#x27;k-means++&#x27;</span>, n_clusters=<span class="number">3</span>, n_init=<span class="number">10</span>)</span><br><span class="line">t0 = time.time()</span><br><span class="line">k_means.fit(X)</span><br><span class="line"><span class="comment"># 使用k-means对300组数据集训练算法的时间消耗</span></span><br><span class="line">t_batch = time.time() - t0</span><br><span class="line"></span><br><span class="line"><span class="comment"># #############################################################################</span></span><br><span class="line"><span class="comment"># Plot result</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">8</span>, <span class="number">3</span>))</span><br><span class="line">fig.subplots_adjust(left=<span class="number">0.02</span>, right=<span class="number">0.98</span>, bottom=<span class="number">0.05</span>, top=<span class="number">0.9</span>)</span><br><span class="line">colors = [<span class="string">&#x27;#4EACC5&#x27;</span>, <span class="string">&#x27;#FF9C34&#x27;</span>, <span class="string">&#x27;#4E9A06&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># We want to have the same colors for the same cluster from the</span></span><br><span class="line"><span class="comment"># MiniBatchKMeans and the KMeans algorithm. Let&#x27;s pair the cluster centers per</span></span><br><span class="line"><span class="comment"># closest one.</span></span><br><span class="line">k_means_cluster_centers = np.sort(k_means.cluster_centers_, axis=<span class="number">0</span>)</span><br><span class="line">k_means_labels = pairwise_distances_argmin(X, k_means_cluster_centers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># KMeans</span></span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> k, col <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(n_clusters), colors):</span><br><span class="line">    my_members = k_means_labels == k</span><br><span class="line">    cluster_center = k_means_cluster_centers[k]</span><br><span class="line">    ax.plot(X[my_members, <span class="number">0</span>], X[my_members, <span class="number">1</span>], <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">            markerfacecolor=col, marker=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    ax.plot(cluster_center[<span class="number">0</span>], cluster_center[<span class="number">1</span>], <span class="string">&#x27;o&#x27;</span>, markerfacecolor=col,</span><br><span class="line">            markeredgecolor=<span class="string">&#x27;k&#x27;</span>, markersize=<span class="number">6</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;KMeans&#x27;</span>)</span><br><span class="line">ax.set_xticks(())</span><br><span class="line">ax.set_yticks(())</span><br><span class="line">plt.text(-<span class="number">3.5</span>, <span class="number">1.8</span>,  <span class="string">&#x27;train time: %.2fs\ninertia: %f&#x27;</span> % (</span><br><span class="line">    t_batch, k_means.inertia_))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<pre><code>    K-Means clustering algorithms
</code></pre><p><img src="output_14_1.png" alt="png"></p>
<h2 id="k-means算法的改进"><a href="#k-means算法的改进" class="headerlink" title="k-means算法的改进"></a><code>k-means</code>算法的改进</h2><ol>
<li>请给出三种<code>k-means</code>算法在大数据量时的改进方法，并分析改进的结果。<br>改进方法包括：<ol>
<li><code>k-means++</code>（改变中心点的选取方法）</li>
<li><code>elkan K-Means</code>（减少不必要的距离计算）</li>
<li><code>ISODATA</code>算法（在运行过程中根据实际情况调整聚类中心数k）</li>
<li><code>Mini Batch k-means</code>算法（采用部分样本，舍弃一些精确度大大加快收敛速度）</li>
</ol>
</li>
</ol>
<p>其中1和4改进方法给出了源码和对比。</p>
<h3 id="k-means-（改变中心点的选择方法）"><a href="#k-means-（改变中心点的选择方法）" class="headerlink" title="k-means++（改变中心点的选择方法）"></a><code>k-means++</code>（改变中心点的选择方法）</h3><p><a href="https://blog.csdn.net/github_39261590/article/details/76910689">参考资料1:https://blog.csdn.net/github_39261590/article/details/76910689</a><br><a href="https://www.cnblogs.com/yszd/p/9672885.html">参考资料2:https://www.cnblogs.com/yszd/p/9672885.html</a><br><code>k-means++</code>算法选择初始seeds的基本思想就是：<strong>初始的聚类中心之间的相互距离要尽可能的远。</strong>  </p>
<p>算法步骤：</p>
<ol>
<li>从输入的数据点集合中随机选择一个点作为第一个聚类中心</li>
<li>对于数据集中的每一个点x，计算它与最近聚类中心(指已选择的聚类中心)的距离D(x)</li>
<li>选择一个新的数据点作为新的聚类中心，选择的原则是：D(x)较大的点，被选取作为聚类中心的概率较大</li>
<li>重复2和3直到k个聚类中心被选出来</li>
<li>利用这k个初始的聚类中心来运行标准的k-means算法</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> sklearn.datasets <span class="keyword">as</span> ds</span><br><span class="line"><span class="keyword">import</span> matplotlib.colors</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> MiniBatchKMeans</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">expand</span>(<span class="params">a, b</span>):</span><br><span class="line">    d = (b - a) * <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">return</span> a-b, b+d</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    N = <span class="number">400</span></span><br><span class="line">    centers = <span class="number">4</span></span><br><span class="line">    data, y = ds.make_blobs(N, n_features=<span class="number">2</span>, centers=centers, random_state=<span class="number">2</span>)</span><br><span class="line">    data2, y2 = ds.make_blobs(N, n_features=<span class="number">2</span>, centers=centers, cluster_std=(<span class="number">1</span>, <span class="number">2.5</span>, <span class="number">0.5</span>, <span class="number">2</span>), random_state=<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 按行拼接numpy数组</span></span><br><span class="line">    data3 = np.vstack((data[y == <span class="number">0</span>][:], data[y == <span class="number">1</span>][:<span class="number">50</span>], data[y == <span class="number">2</span>][:<span class="number">20</span>], data[y == <span class="number">3</span>][:<span class="number">5</span>]))</span><br><span class="line">    y3 = np.array([<span class="number">0</span>] * <span class="number">100</span> + [<span class="number">1</span>] * <span class="number">50</span> + [<span class="number">2</span>] * <span class="number">20</span> + [<span class="number">3</span>] * <span class="number">5</span>)</span><br><span class="line">    cls = KMeans(n_clusters=<span class="number">4</span>, init=<span class="string">&#x27;k-means++&#x27;</span>)</span><br><span class="line">    y_hat = cls.fit_predict(data)</span><br><span class="line">    y2_hat = cls.fit_predict(data2)</span><br><span class="line">    y3_hat = cls.fit_predict(data3)</span><br><span class="line">    </span><br><span class="line">    m = np.array(((<span class="number">1</span>, <span class="number">1</span>),(<span class="number">1</span>, <span class="number">3</span>)))</span><br><span class="line">    data_r = data.dot(m)</span><br><span class="line">    y_r_hat = cls.fit_predict(data_r)</span><br><span class="line">    </span><br><span class="line">    matplotlib.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">u&#x27;SimHei&#x27;</span>]</span><br><span class="line">    matplotlib.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line">    cm = matplotlib.colors.ListedColormap(<span class="built_in">list</span>(<span class="string">&#x27;rgbm&#x27;</span>))</span><br><span class="line">    plt.figure(figsize=(<span class="number">9</span>, <span class="number">10</span>), facecolor=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    plt.subplot(<span class="number">421</span>)</span><br><span class="line">    plt.title(<span class="string">u&#x27;原始数据&#x27;</span>)</span><br><span class="line">    plt.scatter(data[:, <span class="number">0</span>], data[:, <span class="number">1</span>], c=y, s=<span class="number">30</span>, cmap=cm, edgecolors=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">    x1_min, x2_min = np.<span class="built_in">min</span>(data, axis=<span class="number">0</span>)</span><br><span class="line">    x1_max, x2_max = np.<span class="built_in">max</span>(data, axis=<span class="number">0</span>)</span><br><span class="line">    x1_min, x1_max = expand(x1_min, x1_max)</span><br><span class="line">    x2_min, x2_max = expand(x2_min, x2_max)</span><br><span class="line">    plt.xlim((x1_min, x1_max))</span><br><span class="line">    plt.ylim((x2_min, x2_max))</span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">422</span>)</span><br><span class="line">    plt.title(<span class="string">u&#x27;KMeans++聚类&#x27;</span>)</span><br><span class="line">    plt.scatter(data[:, <span class="number">0</span>], data[:, <span class="number">1</span>], c=y_hat, s=<span class="number">30</span>, cmap=cm, edgecolors=<span class="string">&#x27;none&#x27;</span>)    </span><br><span class="line">    plt.xlim((x1_min, x1_max))</span><br><span class="line">    plt.ylim((x2_min, x2_max))</span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><img src="output_16_0.png" alt="png"></p>
<h3 id="elkan-k-means算法"><a href="#elkan-k-means算法" class="headerlink" title="elkan k-means算法"></a><code>elkan k-means</code>算法</h3><p><a href="https://blog.csdn.net/u014465639/article/details/71342072">参考资料:https://blog.csdn.net/u014465639/article/details/71342072</a><br><code>elkan K-Means</code>利用了两边之和大于等于第三边,以及两边之差小于第三边的三角形性质，来减少距离的计算。<br>第一种规律是对于一个样本点和两个质心。如果我们预先计算出了这两个质心之间的距离，则如果计算发现,我们立即就可以知道。此时我们不需要再计算,也就是说省了一步距离计算。<br>第二种规律是对于一个样本点和两个质心。我们可以得到。这个从三角形的性质也很容易得到。<br>利用上边的两个规律，elkan K-Means比起传统的K-Means迭代速度有很大的提高。但是如果我们的样本的特征是稀疏的，有缺失值的话，这个方法就不使用了，此时某些距离无法计算，则不能使用该算法。  </p>
<h3 id="ISODATA算法"><a href="#ISODATA算法" class="headerlink" title="ISODATA算法"></a><code>ISODATA</code>算法</h3><p><a href="https://blog.csdn.net/houston11235/article/details/8511379">参考资料1:https://blog.csdn.net/houston11235/article/details/8511379</a><br><a href="https://www.cnblogs.com/huadongw/p/4101422.html">参考资料2:https://www.cnblogs.com/huadongw/p/4101422.html</a><br>k-means 的一个缺点就是必须指定聚类的个数，这个有些时候并不太行得通。于是就要求最好这个类别的个数也可以改变，这就形成了 isodata 方法，通过设定一些类别分裂和合并的条件，在聚类的过程中自动增减类别的数目。当然这也带来了一个问题，就是这个条件有时候并不那么好给出。当然 isodata 在很多情况下还是可以得到比较靠谱的结果。  </p>
<h3 id="Mini-Batch-k-means（用一部分样本做传统的k-means，舍弃一部分精确度大大提高收敛速度）"><a href="#Mini-Batch-k-means（用一部分样本做传统的k-means，舍弃一部分精确度大大提高收敛速度）" class="headerlink" title="Mini Batch k-means（用一部分样本做传统的k-means，舍弃一部分精确度大大提高收敛速度）"></a><code>Mini Batch k-means</code>（用一部分样本做传统的k-means，舍弃一部分精确度大大提高收敛速度）</h3><p><a href="https://cloud.tencent.com/developer/article/1465020">参考资料1:https://cloud.tencent.com/developer/article/1465020</a><br>Mini Batch KMeans算法是一种能<strong>尽量保持聚类准确性下但能大幅度降低计算时间的聚类模型</strong>，采用小批量的数据子集减少计算时间，同时仍试图优化目标函数，这里所谓的Mini Batch是指每次训练算法时随机抽取的数据子集，采用这些随机选取的数据进行训练，大大的减少了计算的时间，减少的KMeans算法的收敛时间，但要比标准算法略差一点，建议当样本量大于一万做聚类时，就需要考虑选用Mini Batch KMeans算法。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Comparison of the K-Means and MiniBatchKMeans clustering algorithms</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(__doc__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> MiniBatchKMeans, KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances_argmin</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_blobs</span><br><span class="line"></span><br><span class="line"><span class="comment"># #############################################################################</span></span><br><span class="line"><span class="comment"># Generate sample data</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">45</span></span><br><span class="line">centers = [[<span class="number">1</span>, <span class="number">1</span>], [-<span class="number">1</span>, -<span class="number">1</span>], [<span class="number">1</span>, -<span class="number">1</span>]] <span class="comment"># 初始化3个中心</span></span><br><span class="line">n_clusters = <span class="built_in">len</span>(centers) <span class="comment"># 聚类的数目为3</span></span><br><span class="line"><span class="comment"># 产生10000组二维数据，以上面三个点为中心，以(-10,10)为边界，数据集的标准差是0.7</span></span><br><span class="line">X, labels_true = make_blobs(n_samples=<span class="number">10000</span>, centers=centers, cluster_std=<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># #############################################################################</span></span><br><span class="line"><span class="comment"># Compute clustering with Means</span></span><br><span class="line"></span><br><span class="line">k_means = KMeans(init=<span class="string">&#x27;k-means++&#x27;</span>, n_clusters=<span class="number">3</span>, n_init=<span class="number">10</span>)</span><br><span class="line">t0 = time.time()</span><br><span class="line">k_means.fit(X)</span><br><span class="line"><span class="comment"># 使用k-means对300组数据集训练算法的时间消耗</span></span><br><span class="line">t_batch = time.time() - t0</span><br><span class="line"></span><br><span class="line"><span class="comment"># #############################################################################</span></span><br><span class="line"><span class="comment"># Compute clustering with MiniBatchKMeans</span></span><br><span class="line"></span><br><span class="line">mbk = MiniBatchKMeans(init=<span class="string">&#x27;k-means++&#x27;</span>, n_clusters=<span class="number">3</span>, batch_size=batch_size,</span><br><span class="line">                      n_init=<span class="number">10</span>, max_no_improvement=<span class="number">10</span>, verbose=<span class="number">0</span>)</span><br><span class="line">t0 = time.time()</span><br><span class="line">mbk.fit(X)</span><br><span class="line"><span class="comment"># 使用MiniBatchKMeans对300组数据集训练算法的时间消耗</span></span><br><span class="line">t_mini_batch = time.time() - t0</span><br><span class="line"></span><br><span class="line"><span class="comment"># #############################################################################</span></span><br><span class="line"><span class="comment"># Plot result</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">8</span>, <span class="number">3</span>))</span><br><span class="line">fig.subplots_adjust(left=<span class="number">0.02</span>, right=<span class="number">0.98</span>, bottom=<span class="number">0.05</span>, top=<span class="number">0.9</span>)</span><br><span class="line">colors = [<span class="string">&#x27;#4EACC5&#x27;</span>, <span class="string">&#x27;#FF9C34&#x27;</span>, <span class="string">&#x27;#4E9A06&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># We want to have the same colors for the same cluster from the</span></span><br><span class="line"><span class="comment"># MiniBatchKMeans and the KMeans algorithm. Let&#x27;s pair the cluster centers per</span></span><br><span class="line"><span class="comment"># closest one.</span></span><br><span class="line">k_means_cluster_centers = np.sort(k_means.cluster_centers_, axis=<span class="number">0</span>)</span><br><span class="line">mbk_means_cluster_centers = np.sort(mbk.cluster_centers_, axis=<span class="number">0</span>)</span><br><span class="line">k_means_labels = pairwise_distances_argmin(X, k_means_cluster_centers)</span><br><span class="line">mbk_means_labels = pairwise_distances_argmin(X, mbk_means_cluster_centers)</span><br><span class="line">order = pairwise_distances_argmin(k_means_cluster_centers,</span><br><span class="line">                                  mbk_means_cluster_centers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># KMeans</span></span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> k, col <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(n_clusters), colors):</span><br><span class="line">    my_members = k_means_labels == k</span><br><span class="line">    cluster_center = k_means_cluster_centers[k]</span><br><span class="line">    ax.plot(X[my_members, <span class="number">0</span>], X[my_members, <span class="number">1</span>], <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">            markerfacecolor=col, marker=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    ax.plot(cluster_center[<span class="number">0</span>], cluster_center[<span class="number">1</span>], <span class="string">&#x27;o&#x27;</span>, markerfacecolor=col,</span><br><span class="line">            markeredgecolor=<span class="string">&#x27;k&#x27;</span>, markersize=<span class="number">6</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;KMeans&#x27;</span>)</span><br><span class="line">ax.set_xticks(())</span><br><span class="line">ax.set_yticks(())</span><br><span class="line">plt.text(-<span class="number">3.5</span>, <span class="number">1.8</span>,  <span class="string">&#x27;train time: %.2fs\ninertia: %f&#x27;</span> % (</span><br><span class="line">    t_batch, k_means.inertia_))</span><br><span class="line"></span><br><span class="line"><span class="comment"># MiniBatchKMeans</span></span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> k, col <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(n_clusters), colors):</span><br><span class="line">    my_members = mbk_means_labels == order[k]</span><br><span class="line">    cluster_center = mbk_means_cluster_centers[order[k]]</span><br><span class="line">    ax.plot(X[my_members, <span class="number">0</span>], X[my_members, <span class="number">1</span>], <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">            markerfacecolor=col, marker=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    ax.plot(cluster_center[<span class="number">0</span>], cluster_center[<span class="number">1</span>], <span class="string">&#x27;o&#x27;</span>, markerfacecolor=col,</span><br><span class="line">            markeredgecolor=<span class="string">&#x27;k&#x27;</span>, markersize=<span class="number">6</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;MiniBatchKMeans&#x27;</span>)</span><br><span class="line">ax.set_xticks(())</span><br><span class="line">ax.set_yticks(())</span><br><span class="line">plt.text(-<span class="number">3.5</span>, <span class="number">1.8</span>, <span class="string">&#x27;train time: %.2fs\ninertia: %f&#x27;</span> %</span><br><span class="line">         (t_mini_batch, mbk.inertia_))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialise the different array to all False</span></span><br><span class="line">different = (mbk_means_labels == <span class="number">4</span>)</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n_clusters):</span><br><span class="line">    different += ((k_means_labels == k) != (mbk_means_labels == order[k]))</span><br><span class="line"></span><br><span class="line">identic = np.logical_not(different)</span><br><span class="line">ax.plot(X[identic, <span class="number">0</span>], X[identic, <span class="number">1</span>], <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">        markerfacecolor=<span class="string">&#x27;#bbbbbb&#x27;</span>, marker=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">ax.plot(X[different, <span class="number">0</span>], X[different, <span class="number">1</span>], <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">        markerfacecolor=<span class="string">&#x27;m&#x27;</span>, marker=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;Difference&#x27;</span>)</span><br><span class="line">ax.set_xticks(())</span><br><span class="line">ax.set_yticks(())</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<pre><code>    Comparison of the K-Means and MiniBatchKMeans clustering algorithms
</code></pre><p><img src="output_20_1.png" alt="png"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Fisher</tag>
        <tag>SVM</tag>
        <tag>K-Means</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux开发环境及其应用学习笔记（二）</title>
    <url>/201910/Linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%9C%BA%E5%99%A8%E5%BA%94%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Chap1-开始使用Linux"><a href="#Chap1-开始使用Linux" class="headerlink" title="Chap1 开始使用Linux"></a>Chap1 开始使用Linux</h1><h2 id="Linux发展过程"><a href="#Linux发展过程" class="headerlink" title="Linux发展过程"></a>Linux发展过程</h2><h2 id="系统登陆与退出"><a href="#系统登陆与退出" class="headerlink" title="系统登陆与退出"></a>系统登陆与退出</h2><h3 id="字符终端"><a href="#字符终端" class="headerlink" title="字符终端"></a>字符终端</h3><p> <code>UNIX</code>和<code>Linux</code>是多用户系统：主机连接多台字符终端，字符终端作为交互式输入输出设备。</p>
 <span id="more"></span>
<h3 id="终端的组成"><a href="#终端的组成" class="headerlink" title="终端的组成"></a>终端的组成</h3><ul>
<li>键盘</li>
<li>屏幕</li>
<li>RS232串口</li>
</ul>
<h3 id="主机与终端的连接"><a href="#主机与终端的连接" class="headerlink" title="主机与终端的连接"></a>主机与终端的连接</h3><p>主机中的串口卡（硬件）引出多个RS232串口。每个RS232接口通过电缆连接一台终端。<br><code>RS232</code>是一个通信标准，现在仍在使用。</p>
<h3 id="终端与主机的功能分工"><a href="#终端与主机的功能分工" class="headerlink" title="终端与主机的功能分工"></a>终端与主机的功能分工</h3><ol>
<li>终端：主机的输入和输出设备。<br>终端通过电缆把用户的按键信息送到主机，把主机发来的信息在屏幕上显示。</li>
<li>主机：程序和数据的存储及处理。<br>数据及程序存放在主机的硬盘上，程序的运行也都由主机内的CPU占用主机内存来完成。</li>
</ol>
<h3 id="行律与驱动程序"><a href="#行律与驱动程序" class="headerlink" title="行律与驱动程序"></a>行律与驱动程序</h3><ol>
<li>驱动程序：不同的硬件需要不同的驱动程序，驱动程序也是与行律模块的接口。把行律送上来的字节流，沿着通信线路发上去。</li>
<li>行律的作用<ul>
<li>一行内字符的缓冲、回显与编辑，直到按下回车键</li>
<li>数据加工，比如说把\n转化成\r\n</li>
<li>将<kbd>Ctrl</kbd> + <kbd>C</kbd> 转换为终止进程运行的信号</li>
</ul>
</li>
</ol>
<div class="note info">
    主机和终端的通信实际上没有“删除”（\b），是利用\b + blankspace + \b 构成的，用blankspace替换了打错的地方，\b只控制了光标
</div>

<h3 id="终端转义序列"><a href="#终端转义序列" class="headerlink" title="终端转义序列"></a>终端转义序列</h3><ol>
<li>转义字符：ASCII码1B（十进制27，八进制033）</li>
<li>主机发往终端方向数据中的转义序列的功能<ul>
<li>控制光标位置、字符颜色、字符大小等等</li>
<li>选择终端的字符集</li>
<li>控制终端上的打印机、刷卡机、磁条机、密码键盘</li>
</ul>
</li>
</ol>
<h3 id="终端类型"><a href="#终端类型" class="headerlink" title="终端类型"></a>终端类型</h3><ul>
<li>每一种终端都会有对应的一系列转义序列，不同的终端转义序列可能不同，因此我们把终端分成不同的类型，例如<code>ansi</code>,<code>vt100</code>,<code>vt220</code>等。</li>
<li>主机根据终端类型，实现相应功能时发送对应的控制码；当终端类型设置不对时，可能一些全屏幕操作的软件运行失败。</li>
</ul>
<h3 id="主机和终端之间的流量控制"><a href="#主机和终端之间的流量控制" class="headerlink" title="主机和终端之间的流量控制"></a>主机和终端之间的流量控制</h3><ol>
<li>必要性<ul>
<li>终端的显示速度跟不上主机的发送速度；</li>
<li>主机送来的数据终端需要打印出来，但打印速度慢</li>
<li>主机送来的显示内容，需暂停显示，仔细分析</li>
<li>需要一种机制控制主机方向来的数据流量。</li>
</ul>
</li>
<li>两种流控方法<ul>
<li>硬件方式：RS232接口的CTS信号线</li>
<li>软件方式：利用流控字符<code>Xon</code>和<code>Xoff</code></li>
</ul>
</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/10/17/KEWCIH.jpg" alt="利用Xon和Xoff流量控制的方式"></p>
<h3 id="仿真终端和虚拟终端"><a href="#仿真终端和虚拟终端" class="headerlink" title="仿真终端和虚拟终端"></a>仿真终端和虚拟终端</h3><ol>
<li>仿真终端<br>PC机串口，运行终端仿真软件来仿真终端。仿真的内容包括实现终端的转义码序列功能。</li>
<li>虚拟终端<br>UNIX主机和PC机通过网络相连，客户端运行telnet，服务器端运行telnetd，成为UNIX的一个基于TCP通信的虚拟终端。</li>
</ol>
<p>由于<code>telnet</code>不安全，现在都使用更加安全的终端，在<code>TCP</code>链接上加密和压缩数据，如Windows客户端软件<code>SecureCRT</code>或者<code>Putty</code></p>
<h2 id="用户登录和练级手册的查询"><a href="#用户登录和练级手册的查询" class="headerlink" title="用户登录和练级手册的查询"></a>用户登录和练级手册的查询</h2><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><h3 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h3><p>登陆shell：一般是bash，也可以选其他shell，其他系统程序等等。</p>
<ul>
<li>登陆成功后出现shell提示符：<ul>
<li><code>$</code> Bourne Shell系列（sh, ksh, bash）</li>
<li><code>#</code> 当前用户为超级用户</li>
</ul>
</li>
<li>出现shell提示符后就可以输入系统命令（注意：英文字母大小写敏感！）</li>
</ul>
<h3 id="基本的Linux命令"><a href="#基本的Linux命令" class="headerlink" title="基本的Linux命令"></a>基本的Linux命令</h3><ol>
<li>man 查阅手册<br>取自manual<br>分页器：q-退出； 空格-下一页； 上下箭头-上移下移<br>章节：1. 命令； 2. 系统调用； 3. 库函数； 5. 配置文件  </li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux开发环境及其应用学习笔记（一）</title>
    <url>/201910/Linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%9C%BA%E5%99%A8%E5%BA%94%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>Tips：  </p>
<ol>
<li>先修课：C语言、操作系统</li>
<li>上机实验：自己安装<code>VMware</code>虚拟机和<code>Ubuntu</code></li>
<li>成绩考核：平时成绩+上机作业（30%），期末考试（70%）</li>
</ol>
<span id="more"></span>
<h2 id="计算机系统的组成"><a href="#计算机系统的组成" class="headerlink" title="计算机系统的组成"></a>计算机系统的组成</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ol>
<li>主机<ul>
<li>CPU<ul>
<li>寄存器组</li>
<li>控制器</li>
<li>运算器</li>
<li><code>Cache</code></li>
<li><code>MMU</code></li>
</ul>
</li>
<li>内存<ul>
<li>ROM</li>
<li>RAM</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><ol>
<li>系统软件<ul>
<li>操作系统</li>
<li>编译器</li>
<li>数据库</li>
<li>网络软件</li>
</ul>
</li>
<li>应用软件</li>
</ol>
<div class="note primary">
    MMU<br />
    MMU是Memory Management Unit的缩写，中文名是内存管理单元，它是中央处理器（CPU）中用来管理虚拟存储器、物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权，多用户多进程操作系统。
</div>

<h2 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h2><ol>
<li>手工操作（电子管）  </li>
<li>单道批处理操作系统<br>问题：慢速的输入输出处理仍然由<code>CPU</code>完成，输入输出时，<code>CPU</code>处于等待状态。</li>
<li>多道批处理系统<br>提高了<code>CPU</code>的利用率，用户交互性差</li>
<li>分时系统  <ul>
<li>分时共享：多个程序分时共享<code>CPU</code>资源</li>
<li>按时间片分配：多个程序在<code>CPU</code>上执行的轮换时间</li>
</ul>
</li>
</ol>
<h2 id="多道程序需要的硬件支持：-中断与通道技术"><a href="#多道程序需要的硬件支持：-中断与通道技术" class="headerlink" title="多道程序需要的硬件支持： 中断与通道技术"></a>多道程序需要的硬件支持： 中断与通道技术</h2><ul>
<li>中断</li>
<li>通道：有专用的<code>I/O</code>处理器，控制<code>I/O</code>设备与内存间的数据传输，启动后独立于<code>CPU</code>运行，实现<code>CPU</code>与<code>I/O</code>的并行。<ul>
<li>DMA：直接内存存取<code>Direct Memory Access</code></li>
<li><code>CPM</code>通信处理器</li>
</ul>
</li>
</ul>
<h2 id="实现多道程序需要的硬件支持：内存管制"><a href="#实现多道程序需要的硬件支持：内存管制" class="headerlink" title="实现多道程序需要的硬件支持：内存管制"></a>实现多道程序需要的硬件支持：内存管制</h2><p>存储器管理单元<code>MMU</code></p>
<ul>
<li>多道程序的加载<br>程序采用虚拟地址，以保证多道同时运行的程序可以在内存中重定位（虚实地址转换）</li>
<li>内存保护<br>避免同时运行在内存中的程序互相影响（越界/越权）；<code>CPU</code>设置核心、用户态。</li>
</ul>
<h2 id="系统调用和系统命令"><a href="#系统调用和系统命令" class="headerlink" title="系统调用和系统命令"></a>系统调用和系统命令</h2><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>可以认为操作系统就是所有中断服务程序的集合，包括硬件中断和软件中断。</p>
<h3 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h3><p>操作系统自带的命令也是利用系统调用设计的应用程序，与普通的应用程序具有相同的地位。</p>
<h2 id="应用软件和设备驱动程序开发"><a href="#应用软件和设备驱动程序开发" class="headerlink" title="应用软件和设备驱动程序开发"></a>应用软件和设备驱动程序开发</h2><h3 id="应用软件开发SDK"><a href="#应用软件开发SDK" class="headerlink" title="应用软件开发SDK"></a>应用软件开发SDK</h3><h3 id="设备驱动程序开发DDK"><a href="#设备驱动程序开发DDK" class="headerlink" title="设备驱动程序开发DDK"></a>设备驱动程序开发DDK</h3><p>操作系统对设备进行分类，每类设备设计一种抽象的接口（包括多个函数）设备驱动程序操纵硬件，处理中断，提供这类设备接口规定的一组函数。<br>设备驱动程序工作在<code>CPU</code>特权级，驱动程序的<code>BUG</code>可能会导致整个系统崩溃。</p>
<h2 id="操作系统在计算机系统中的地位"><a href="#操作系统在计算机系统中的地位" class="headerlink" title="操作系统在计算机系统中的地位"></a>操作系统在计算机系统中的地位</h2><p><img src="https://s2.ax1x.com/2019/10/17/KAIAO0.jpg" alt="OS的地位">  </p>
<p><font color="FFF00">注意：</font>沙漏型生态</p>
<h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ol>
<li>Linux常用命令</li>
<li>shell脚本程序设计</li>
<li>系统调用</li>
<li>网络socket程序设计</li>
</ol>
<div class="note info">
    Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。
</div>

<p><img src="https://s2.ax1x.com/2019/10/17/KA7Vmt.jpg" alt=""></p>
<div class="note info">
    学习的过程中不知道UNIX和LINUX之间是什么关系，怎么好像一会儿在讲Lunix一会儿在讲UNIX？<br />
    ![UNIX和LINUX的历史](http://c.biancheng.net/view/707.html)
    Linux 是一个类似 Unix 的操作系统，Unix 要早于 Linux，Linux 的初衷就是要替代 UNIX，并在功能和用户体验上进行优化，所以 Linux 模仿了 UNIX（但并没有抄袭 UNIX 的源码），使得 Linux 在外观和交互上与 UNIX 非常类似。<br />
    <b>UNIX/Linux 系统可以粗糙地抽象为 3 个层次（所谓粗糙，就是不够细致、精准，但是便于初学者抓住重点理解）。底层是 UNIX/Linux 操作系统，即系统内核（Kernel）；中间层是 Shell 层，即命令解释层；高层则是应用层。</b>
    1) 内核层<br />
    内核层是 UNIX/Linux 系统的核心和基础，它直接附着在硬件平台之上，控制和管理系统内各种资源（硬件资源和软件资源），有效地组织进程的运行，从而扩展硬件的功能，提高资源的利用效率，为用户提供方便、高效、安全、可靠的应用环境。<br />
    2) Shell层<br />
    Shell 层是与用户直接交互的界面。用户可以在提示符下输入命令行，由 Shell 解释执行并输出相应结果或者有关信息，所以我们也把 Shell 称作命令解释器，利用系统提供的丰富命令可以快捷而简便地完成许多工作。<br />
    3) 应用层<br />
    应用层提供基于 X Window 协议的图形环境。X Window 协议定义了一个系统所必须具备的功能（就如同 TCP/IP 是一个协议，定义软件所应具备的功能），可系统能满足此协议及符合 X 协会其他的规范，便可称为 X Window。
</div>

<div class="note info">
    关于SecureCRT：<br />
    SecureCRT是一款支持SSH（SSH1和SSH2）的终端仿真程序，简单地说是Windows下登录UNIX或Linux服务器主机的软件。
</div>

<div class="note info">
    关于SSH：<br />
    安全外壳协议。Secure Shell的缩写。<br />
    SSH 为建立在应用层和传输层基础上的安全协议。SSH 是目前较可靠，<b>专为远程登录会话和其他网络服务提供安全性的协议。</b>利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。<br />
    SSH是由客户端和服务端的软件组成，服务端是一个守护进程(daemon)，它在后台运行并响应来自客户端的连接请求，客户端包含ssh程序以及像scp（远程拷贝）、slogin（远程登陆）、sftp（安全文件传输）等其它应用程序。
</div>

<div class="note info">
    Linux和Ubuntu是什么关系？<br />
    答：Ubuntu是世界上最流行的Linux发行版。<br />

    严格来讲，Linux这个词本身只表示Linux内核，但在实际上使用者已经习惯了用Linux来形容整个基于Linux内核并且使用GNU 工程各种工具和数据库的操作系统(也被称为GNU/Linux)。<br />

    基于这些组件的Linux软件被称为Linux发行版。<br />
    一个典型的Linux发行版包括GNU程序库和工具，命令行shell，图形界面包括：Linux内核，一的X Window系统和相应的桌面环境，如KDE或GNOME，并包含数千种从办公套件，编译器，文本编辑器到科学工具的应用软件。
</div>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据技术基础课堂笔记（4）</title>
    <url>/201909/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/</url>
    <content><![CDATA[<h2 id="hadoop存储格式"><a href="#hadoop存储格式" class="headerlink" title="hadoop存储格式"></a><code>hadoop</code>存储格式</h2><h1 id="行式存储格式"><a href="#行式存储格式" class="headerlink" title="行式存储格式"></a>行式存储格式</h1><h2 id="未压缩的Sequence-File"><a href="#未压缩的Sequence-File" class="headerlink" title="未压缩的Sequence File"></a>未压缩的<code>Sequence File</code></h2><p>通过设置同步的标记，把<code>key value</code>划分成块，当后面出错的时候只需要重传一个块。相当于debug时的断点。<br><code>record length</code>-<code>key length</code>-<code>key</code>-<code>value</code><br>block的结构要清楚。  </p>
<span id="more"></span>
<p><code>Sequence File</code>读写数据（略过）java写的</p>
<p>行式存储（2种）</p>
<ol>
<li>text file</li>
<li>二进制的key value 图片 视频 存 squence file</li>
<li>没有压缩</li>
<li>文件级别的压缩</li>
<li>block级别的压缩</li>
</ol>
<p>列式存储</p>
<p>ORC文件<br>Parquet文件<br>Carbondata文件：吸取了ORC和Parquet的优点</p>
<h1 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h1><p>数据的采集<br>数据的存储<br>hdfx<br>scale-up scale-out 十分重要<br>摩尔定律 晶体管会散热，一个processsor上能够集成多个core，从一个core到多个core就是从scale-up到scale-out集成的过程<br>当processor已经无法集成再多core的时候，可以利用多个processor，或者多个计算机（机群）这也是scale-out的策略<br>interact是一个问题。<br>随着技术的发展，当出现瓶颈的时候scale-out 的方式就是绕过瓶颈的思路。<br>又比如，笔记本电脑加硬盘，总能加到一定的限制，那么此时通过网络进行扩充</p>
<h2 id="文件级别和块级别的分布式文件系统"><a href="#文件级别和块级别的分布式文件系统" class="headerlink" title="文件级别和块级别的分布式文件系统"></a>文件级别和块级别的分布式文件系统</h2><h3 id="文件级别的"><a href="#文件级别的" class="headerlink" title="文件级别的"></a>文件级别的</h3><p>文件有大有小，无法实现很好的负载均衡；难以并行处理</p>
<h3 id="块级别的分布式系统"><a href="#块级别的分布式系统" class="headerlink" title="块级别的分布式系统"></a>块级别的分布式系统</h3><p>把文件分成大小相同的块<br>云计算-2006年Amazon提出AWS，EC2-虚拟机，之前只有物理机器，S3 object storage第一个把它商品化的公司。<br>服务器租赁，颠覆了整个计算机行业的租赁和购买。</p>
<p>HDFS基本架构<br>standby namenode 是active namenode的替补  </p>
<p>HDFS关键技术<br>HDFS的容错性设计</p>
<p>副本放置策略-三副本放置策略</p>
<p>机架-机架上有交换机（局域网和城域网的区别）</p>
<ul>
<li>client 和 datanode在同节点</li>
<li>在不同节点</li>
</ul>
<h3 id="异构存储介质"><a href="#异构存储介质" class="headerlink" title="异构存储介质"></a>异构存储介质</h3><h3 id="集中式缓存管理"><a href="#集中式缓存管理" class="headerlink" title="集中式缓存管理"></a>集中式缓存管理</h3><p>每个节点都有一定空间用来做cache，集中式的缓存管理就是把这些东西收上来</p>
<h3 id="HDFS-Shell"><a href="#HDFS-Shell" class="headerlink" title="HDFS Shell"></a>HDFS Shell</h3><p>文件一致性的检验</p>
<ol>
<li>数据搜集</li>
</ol>
]]></content>
      <categories>
        <category>大数据技术基础</category>
      </categories>
  </entry>
  <entry>
    <title>沙河半日</title>
    <url>/201909/%E6%B2%99%E6%B2%B3%E5%8D%8A%E6%97%A5/</url>
    <content><![CDATA[<p><img src="https://s2.ax1x.com/2019/09/28/u1scM8.jpg" alt="我和祖国共成长，青春筑梦新时代"></p>
<p><center>温馨和感动的一天。</center><br><br /><br><br /></p>
<span id="more"></span>
<p>今天去沙河和小排长们一起商议关于微职2019级招新的事情，早晨和中午发生的事情，让我觉得莫名的温暖。<br>早晨六点半起床，匆忙和Wbh、Yyr、Lyt会合，三个人骑车到地铁站。<br>地铁站上四个人商量一会儿会议的流程。<br>到了沙河，到处都是国庆的氛围。<br>进教学楼之后我们体验了一下高级的智能售货机。<br>然后四个人一起布置教室，迎接小排长们的到来。<br>然后是自我介绍和萝卜蹲游戏。<br>然后就是大家的头脑风暴。<br>再然后就是制定时间和Ending.</p>
<hr>
<p><br /><br>我发现和参谋部的大家在一起就有一种安心的感觉，和参谋部大伙的感情就像是空气，我时时刻刻都能呼吸到。<br /><br>海霞学姐前两天说，老桑学长到现在一直有很大的心力在微职上，我今天突然明白了这种感觉。我想起《小王子》里的一段话。<br><br /><br><br /><br><blockquote><p>他又回到了狐狸身边。<br>“再见了。”小王子说道。<br>“再见。”狐狸说，“喏，这就是我的秘密。很简单：只有用心才能看得清。实质性的东西用眼睛是看不见的。”<br>“实质性的东西，用眼睛是看不见的。”小王子重复着这句话，以便能把它记在心间。<br>“正因为你为你的玫瑰花费了时间，这才使你的玫瑰变得如此重要。”<br>“正因为你为你的玫瑰花费了时间…”小王又重复着，要使自己记住这些。<br>“人们已经忘记了这个道理，”狐狸说，“可是，你不应该忘记它。你现在要对你驯服过的一切负责到底。你要对你的玫瑰负责…”<br>“我要对我的玫瑰负责…”小王子重复着……</p>
</blockquote></p>
<p>没有什么事情是天生就对你重要的，它对你意义非凡是因为你在它身上倾注了太多心力，你在它身上看得到过去的自己、现在的自己和未来的自己，你希望它更好，也希望自己更好。  </p>
<p>无论是一直指引着我的学长学姐，还是身边参谋部和合伙人地朋友们，还有无限活力的学弟学妹，有你们在真是一件很好的事情。<br>接下来一年我在参谋部首席运营官的事务，我一定会做的更好的。</p>
<hr>
<p><img src="https://s2.ax1x.com/2019/09/28/u1sDPI.jpg" alt="杀狗现场"><br>yr和yt是我身边的我最喜欢的一对情侣。<br>他们之间的感觉我太羡慕了。就是那种淡淡的但是能感觉到他们很喜欢很喜欢对方。日常斗嘴调情，走路的时候两个人开心的闹腾，yt有时走着走着就挽起yr，或者两个人就牵起了手。<br>我根本没法用文字形容他们两个人之间的感觉。  </p>
<p>我们仨去操场，今晚在操场有一场《我和我的祖国》露天电影。yr跟yt说“你晚上来信通这边坐嘛”，yt：“你晚上来现邮这边坐嘛”，yr：“要不咱们去计算机坐嘛”哈哈哈哈哈<br>他们真的好好啊，就跟他俩在一起根本没有电灯泡的感觉。<br>我酸了，他们太好了🍋</p>
<hr>
<p>这届学弟学妹也是相当的给力啊！<br>真的要感谢二进制的氛围带出来这么一群挺活跃的小伙子小姑娘们，鲨鱼也有很棒的小伙子和小姑娘们！Chz真的鲨鱼之光了哈哈哈（什么破形容）！<br>Szy真就是那种办事踏实还特别可爱的乖学弟人设啊，，他看起来太可爱了吧哈哈哈wsl<br>今年把二进制的小排长分开覆盖到所有新兵群里去，是一件再正确不过的事情。希望之后整个微职的团队气氛都能像今天的会议一样这么好！<br>值得一提的是，今天关于整个招新流程的商议，我是在按照字节跳动的校园宣传的前辈的讲课方式进行的，这说明我也真的收获了一个项目制的头脑风暴的模板。真棒！</p>
<hr>
<p>另，沙河早饭的肉夹馍小了一圈还是这么贵，，，<br><img src="https://s2.ax1x.com/2019/09/28/u1s0IA.jpg" width="200" height="200" /></p>
<p>炒饭没有了，被一个羊肉麻辣烫味的饭替代了，，不过倒真挺好吃嘿嘿🐏<br><img src="https://s2.ax1x.com/2019/09/28/u1syxf.jpg" width="200" height="200" /></p>
<hr>
<p>就到这里啦~明天还要早起去健身！<br>提前晚安💖</p>
]]></content>
      <categories>
        <category>参省乎己</category>
      </categories>
  </entry>
  <entry>
    <title>关于细节</title>
    <url>/201909/2019-09-24-%E5%85%B3%E4%BA%8E%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<p>最近的生活中“细节”这个词出现了很多次。我们从小就被大人们叮嘱要“注意细节”，随着年龄的增长这个词很少再被人提起。这两天发生的一系列事情都让我回过头来重新关注这个词。  </p>
<p>近期让我重新注意到这个词的时候是在发给合伙人中秋茶话会的问卷时，标题后面“【复制】”两个字没有删掉，凤民学姐一句“要细心呐”让我突然楞了一下。上次听到这种提醒应该是在小学了。那个时候做错了自己本应该做对的题，会收到老师这样的提醒。  </p>
<p>我突然意识到自己在浮躁地做很多事情，这种做事的状态应该调整过来。自己想要做的事情太多，但是行动力没有预期的那么高，所以很多事情都没有做到百分百的完美。对于一个思想活跃的大学生来说，产生新鲜的想法是一件最廉价的事情，真正重要的是做事的行动力。现在的自己应该是有“做减法”的需求，一些事情要么就不做，要么就做到自己的百分之百。尤其是无法逃避的课程作业和课程设计，这些事情理应做到自己的最完美。  </p>
<p>在和李京老师的面谈中也提到了关于细节的一些问题。李京老师讲到的关于面试比赛的策划，项目组给出了106页的策划书——不管策划到底怎样，仅仅从策划书的量来看，就知道做这件事的人已经做到尽善尽美了。当我们在职场中或者在平时的学习生活中，我们不可能一上来就拥有很优越的机会，也不可能一下子就做出惊为天人的事情。那么我们的能力和出众点就体现在细节上，在细节上做到无可挑剔同样能给人留下很深的印象。“做好细节”能够让我们“被人注意到”。  </p>
<p>认真雕刻细节能够让我们给人留下很好的第一印象。今天欧老师在上课的时候提到免试研究生的复试，单单从一个学生的简历就能发现很多事情——那些认认真真琢磨简历的人至少说明他们把这件事情“放在心上”，这说明他们愿意把之后的时间投入到实验室，愿意和身边的同学交流等等。一份认真的简历能够表达很多东西。老师提醒我们，一定要注意细节，特别是在第一印象中的细节十分重要。  </p>
<p>今天在线上和一位快手的学长交流，他着重强调了“亮点”这个词，它可以是学历、专业、论文或者实践等等，重要的是我们要留意开始打造“个人品牌”。  </p>
<p>大厂不缺好学校的学生，比如快手一度清北比例高达40%，组里一半以上的清北中科院，但是永远缺乏岗位极度匹配的人。原因并非是大学的专业和研究方向不对口，也并非是高校的教育和职场脱节，而是我们一直是从大学的培养方案出发，去适应不同公司的需求；而非从岗位需求出发，面向岗位技能在大学中学习。这种培养方法是一把双刃剑，它虽然保证了对岗位的高度适应，但是也削弱了人的全面的能力，在社会飞速发展中，可能会随着职业的没落，这种培训方式的偏颇也就显现出来。  </p>
<p>我们也应该去尝试构建一种结果导向的培养方案，按照未来的需求在大学阶段集成能力，尤其是在大学专业划分模糊且行业发展迅速的时代。</p>
<p>今天：肝数据科学导论作业到3点，玩手机到4点。九点二十起床，马马虎虎听了课 （大数据技术基础），中午完了一会游戏，美美地吃了一顿，宿舍睡了一会儿，就去上课，没怎么认真听（数据科学导论）在研究博客地SEO。晚上看了好久的乐队的夏天。然后忙于各种琐事，一边学习一边聊天。</p>
<p>效率好低啊，明天还要写作业呢。</p>
]]></content>
      <categories>
        <category>参省乎己</category>
      </categories>
  </entry>
  <entry>
    <title>数据库系统原理（3）</title>
    <url>/201909/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86(3)/</url>
    <content><![CDATA[<p>赋值操作 Assign<br>关系代数表示的除法<br>Outer join<br>aggregation function 聚集函数</p>
<p>chap3. introduction to SQL<br>structured query language 结构化的查询语言<br>data def 3.2<br>data query/retrieve 3.3-3.8<br>data manipulation 3.9 对数据的操作和管理</p>
<p>3.1 overview<br>SQL基本结构和功能是基本一致的<br>“Query”<br>generalized def<br>define, retrieve, modify, contro etc.<br>Parts in SQL(SQL语句的部分功能)</p>
<ul>
<li>Data defination language</li>
<li>Data-manipulation language</li>
<li>Integrity</li>
<li>Transaction management</li>
<li>authorization</li>
<li>embedded and dynamic SQL</li>
</ul>
<hr>
<p>date.<br>time.<br>timestamp 时间戳<br>Interval 时间点的间隔</p>
<p>Null 空值 表示未知的状态</p>
<p>开发大型数据库应用时，程序所访问的表中的属性的名字最好取为英文，便于应用程序的可移植性</p>
<p>创建表的完整性限制</p>
<p>schema defination<br><code>insert into branch</code><br><code>values(&#39;Perryridge&#39;,&#39;Blooklyn&#39;,8000)</code></p>
<p>drop table 删除表中的所有信息<code>drop table r</code>删掉r的定义<br><code>delete from r</code>把r中的某些元组删掉，r还是存在于其中的。</p>
<p>alter table 对表的内容进行修改</p>
<p>distinct 强制去除查询结果里的重复元组<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct dept_name</span><br><span class="line">from instructor</span><br></pre></td></tr></table></figure><br>all 强制不能去重<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select all dept_name</span><br><span class="line">from instructor</span><br></pre></td></tr></table></figure></p>
<p>asterisk 星号 all attributes<br>select语句还可以接相应的运算符<br>where语句</p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习学习笔记（3）</title>
    <url>/201909/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<h1 id="「机器学习」学习笔记（3）"><a href="#「机器学习」学习笔记（3）" class="headerlink" title="「机器学习」学习笔记（3）"></a>「机器学习」学习笔记（3）</h1><h2 id="review"><a href="#review" class="headerlink" title="review"></a>review</h2><ul>
<li>几何模型</li>
</ul>
<p>设计基本线性分类器</p>
<h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>今天的内容，介绍五个模型（除去感知机其实是四个）：</p>
<ol>
<li>Fisher：更好的策略，复杂的求解</li>
<li>SVM：更好的策略，复杂的求解</li>
<li>感知机（并非几何模型，而是基于神经元思想构建的模型）：简单的策略，迭代的求解（启发式搜索），得到的有可能仅仅是局部最优解</li>
<li><code>KNN</code></li>
<li>无监督聚类</li>
</ol>
<h3 id="Fisher线性分类器"><a href="#Fisher线性分类器" class="headerlink" title="Fisher线性分类器"></a><code>Fisher</code>线性分类器</h3><h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><p>在边上最容易被混淆的样本是最有价值的。我们希望<strong>间隔</strong>最大化。<br>基本线性分类器中间隔是质心之间的举例；支持向量机中的间隔指的是最容易混淆的样本到分割线的距离。<br><strong>支持向量</strong><br>自己推导（至少能把二维的推导出来，能够清晰地理解这个问题）</p>
<div class="note primary">
机器学习地关键点
- 任务：二分类问题
- 模型：几何模型-线性模型
- 策略：
    1. 基本线性分类器：直接优化两类之间地距离
    2. Fisher：优化投影轴（两类的投影的类间距离和类内距离）
    3. 支持向量机：优化间隔（两类之间的距离）
- 算法
    1. 都是最优化算法
    2. 基本线性分类器，求均值


    2. 
</div>

<div class="note wrong">
1. 如果不是线性可分？（不考）
用核函数进行**升维**
如果不是线性可分，但是允许一些点不满足间隔最大化（无法去除的噪声点），甚至一些误分类。可以采用软间隔最大化的方法。（需要添加一些代价）
2. 还有没有其他的学习方法？
</div>

<h3 id="感知器（启发式搜索）"><a href="#感知器（启发式搜索）" class="headerlink" title="感知器（启发式搜索）"></a>感知器（启发式搜索）</h3><ul>
<li>二分类线性分类模型</li>
<li>严格意义上是感知机模型</li>
</ul>
<p>输入加权值<br>让正数据产生1的反应，让负数据产生-1的反应<br>策略：优化绝对损失。<br>当长时间得不到最优解的时候，可以调大学习速率或者更换初始值。</p>
<h3 id="KNN—最近邻方法"><a href="#KNN—最近邻方法" class="headerlink" title="KNN—最近邻方法"></a>KNN—最近邻方法</h3><ul>
<li>背景：样本之间有很大的相似性的。</li>
<li>实现k邻近算法时，主要考虑的问题是如何对训练数据进行快速k近邻搜索算法。</li>
<li>“距离”的概念：闵科夫斯基距离——曼哈顿距离、欧式距离（在欧式距离里，大的值会有更多的影响）。距离的计算需要根据数据本省的特点进行定义。（余弦相似度衡量夹角（不考））</li>
<li>VDM</li>
<li>其他的问题：k值的选取</li>
<li>存储数据的时候能不能进行优化</li>
</ul>
<h3 id="k均值聚类"><a href="#k均值聚类" class="headerlink" title="k均值聚类"></a>k均值聚类</h3><p>（无监督的数据重在discover，有监督的数据重在学习）<br>无监督类：任务：找到紧凑且独立的“簇”spyder/python3.7</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>几何模型</tag>
      </tags>
  </entry>
  <entry>
    <title>数据科学导论学习笔记（5）</title>
    <url>/201909/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第四章-数据预处理"><a href="#第四章-数据预处理" class="headerlink" title="第四章 数据预处理"></a>第四章 数据预处理</h1><h2 id="数据预处理概述"><a href="#数据预处理概述" class="headerlink" title="数据预处理概述"></a>数据预处理概述</h2><ol>
<li>现实世界的数据是“脏”的：不完整、含有噪音、不一致。</li>
<li>没有质量保证的数据，就没有高质量的挖掘结果。</li>
<li>数据质量的多维测度：准确性（Accuracy）、完整性（Completeness）、一致性（Consistency）、时效性（Timeliness）、相关性（Relevance）、可信性（Believability）、可解释性（Interpretability）</li>
</ol>
<div class="note info no-icon">
    🧜‍♂️课件中的代码都要亲自进行实验❗️ ❕
</div>
### 背景知识
1. 数据对象与属性类型  
数据集是由**数据对象**构成的，一个数据对象代表一个实体，通常数据对象用属性来描述。  
**属性**是一个数据字段，表示数据对象的特征。
<div class="note info no-icon">
    属性的分类：<br />
    标称属性：标称属性的值不具有有意义的序。<br />
    二元属性<br />
    序数属性： 有意义的先后次序<br />
    数据属性：定量的可度量的量<br />
    离散属性<br />
    连续属性<br />
</div>

<p><img src="https://s2.ax1x.com/2019/10/01/uUna0x.jpg" alt="数据属性举例"></p>
<h3 id="数据的基本统计描述的图形显示"><a href="#数据的基本统计描述的图形显示" class="headerlink" title="数据的基本统计描述的图形显示"></a>数据的基本统计描述的图形显示</h3><ol>
<li>分位数图</li>
<li>分位数-分位数图</li>
<li>直方图</li>
<li>散点图</li>
</ol>
<h2 id="数据清洗（4个主要任务）"><a href="#数据清洗（4个主要任务）" class="headerlink" title="数据清洗（4个主要任务）"></a>数据清洗（4个主要任务）</h2><h3 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h3><p>如何处理缺失数据：</p>
<ol>
<li>忽略元组</li>
<li>手工填入缺失值</li>
<li>填充全局常数（Unknown）-尽管该方法简单，但是并不非常可靠</li>
<li>填充属性的中心度量（均值或中位数）<ul>
<li>对于对称的数据分布而言，可以用均值来填充</li>
<li>当数据分布是倾斜的，则更应该使用中位数来填充缺失值。也可以使用与给定元组属同一类的所有样本的属性均值或中位数来填充。</li>
</ul>
</li>
<li>填充最可能的值<br>可以用回归、贝叶斯形式化方法的基于推理的工具或决策树归纳确定。</li>
</ol>
<h3 id="噪声光滑"><a href="#噪声光滑" class="headerlink" title="噪声光滑"></a>噪声光滑</h3><p><font color="FF0000">噪声：</font>在可测度变量中的随机错误或偏差<br>常用的噪声光滑技术：</p>
<ul>
<li>分箱（Binning method）<br>通过考察“邻居”来平滑存储数据的值  <ul>
<li>回归：通过让数据合适一个函数来平滑数据。</li>
<li>离群点分析：通过如聚类等方法来检测离群点。直观地，将落在簇集合之外的值视为离群点。</li>
</ul>
</li>
</ul>
<h3 id="异常值的检测和处理"><a href="#异常值的检测和处理" class="headerlink" title="异常值的检测和处理"></a>异常值的检测和处理</h3><p>异常值：与总体的行为特征、结构或相关性等不一样。<br>检测异常值的方法：</p>
<ol>
<li>简单统计（线性模型）</li>
<li>3$/sigma$原则</li>
<li>箱型图</li>
<li>基于模型检测</li>
<li>基于距离</li>
<li>基于密度</li>
<li>基于聚类</li>
</ol>
<p>处理异常值的方法：</p>
<ol>
<li>删除含有异常值的记录</li>
<li>将异常值视为缺失值</li>
<li>用平均值进行修正：可用前后两个观测值的平均值修正该异常值。</li>
<li>不处理：直接在具有异常值的数据集上进行挖掘建模</li>
</ol>
<h3 id="不一致数据的修正"><a href="#不一致数据的修正" class="headerlink" title="不一致数据的修正"></a>不一致数据的修正</h3><ol>
<li>对于有些事务，所记录的数据可能存在不一致。有些数据不一致可以使用其他材料人工地加以更正。</li>
<li>知识工程工具也可以用来检测违反限制的数据</li>
</ol>
<h2 id="数据集成"><a href="#数据集成" class="headerlink" title="数据集成"></a>数据集成</h2><h3 id="数据集成的主要任务"><a href="#数据集成的主要任务" class="headerlink" title="数据集成的主要任务"></a>数据集成的主要任务</h3><p>数据挖掘经常需要数据集成————合并来自多个数据源的数据。正确的集成过程有助于减少结果数据集的冗余与不一致，这有助于提高数据挖掘过程的准确性与速度  </p>
<ol>
<li><p>实体识别问题<br>实体识别是指从不同数据源识别出现实世界的实体，它的任务是统一不同源数据的矛盾之处。<br>常见形式：同名异义、异名同义、单位不统一<br>对于上面这些矛盾一般用元数据解决。元数据是“描述数据的数据”。每个属性的元数据包括名字、含义、数据类型和属性的值的允许范围，以及处理空值的规则。</p>
</li>
<li><p>检测和解决数据值冲突</p>
</li>
<li><p>冗余数据与相关性分析</p>
</li>
</ol>
<ul>
<li>一个属性如果能由另一个或另一组属性“导出”，则这个属性可能是冗余的。同一属性多次出现，同一属性命名不一致等也可能导致结果数据集中的冗余。</li>
<li>对于属性间的冗余可以用相关性分析检测到，然后删除。</li>
<li>对于标称数据，我们使用卡方检测</li>
<li>对于数值属性，我们使用相关系数（<code>correlation coefficient</code>）和协方差（<code>covariancce</code>），他们都评估一个属性的值如何随另一个变化。</li>
</ul>
<ol>
<li>元组重复</li>
</ol>
<ul>
<li>除了检测属性间的冗余外，还应当在元组级检测重复。</li>
<li>去规范表（<code>denormalized table</code>）的使用（这样做通常是为了通过避免连接来改善性能）是数据冗余的另一个来源。</li>
</ul>
<h2 id="数据规约"><a href="#数据规约" class="headerlink" title="数据规约"></a>数据规约</h2><ol>
<li>数据仓库可能存储T数量级的数据，如果运行于完整的数据集，复杂数据分析或挖掘要花费非常长的时间。</li>
<li>数据规约（<code>Data reduction</code>）：获得数据集的一个简约表示，使得在容量上大大减小，但仍接近于保持原数据的完整性，并产生相同或基本相同的分析结果。</li>
<li>数据规约的策略：<ul>
<li>维规约（<code>Dimensionality reduction</code>）</li>
<li>数量规约（<code>Quantity specification</code>）</li>
<li>数据规约（<code>Data compression</code>）</li>
</ul>
</li>
<li>用于数据规约的时间不应当超过或“抵消”在规约后数据挖掘上挖掘节省的时间。</li>
</ol>
<h2 id="数据变换"><a href="#数据变换" class="headerlink" title="数据变换"></a>数据变换</h2><h3 id="数据变换策略"><a href="#数据变换策略" class="headerlink" title="数据变换策略"></a>数据变换策略</h3><p>将数据转换成适合于挖掘的形式。涉及以下策略：<br>平滑<br>聚集<br>属性构造<br>规范化<br>离散化<br>由标称数据产生概念分层  </p>
<h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><h3 id="标称数据的概念分层生成"><a href="#标称数据的概念分层生成" class="headerlink" title="标称数据的概念分层生成"></a>标称数据的概念分层生成</h3>]]></content>
      <categories>
        <category>数据科学导论</category>
      </categories>
  </entry>
  <entry>
    <title>「学生宿舍管理系统」实验报告</title>
    <url>/201909/%E5%91%A8%E5%AE%87%E6%B4%8B_%E3%80%8C%E5%AD%A6%E7%94%9F%E5%AE%BF%E8%88%8D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E3%80%8D%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="「学生宿舍管理系统」实验报告（第一次作业）"><a href="#「学生宿舍管理系统」实验报告（第一次作业）" class="headerlink" title="「学生宿舍管理系统」实验报告（第一次作业）"></a>「学生宿舍管理系统」实验报告（第一次作业）</h1><hr>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>使用<code>Python</code>语言，设计一个小型的学生宿舍管理系统，系统用户为宿舍管理员。</p>
<span id="more"></span>
<h2 id="功能要求"><a href="#功能要求" class="headerlink" title="功能要求"></a>功能要求</h2><ol>
<li>学生信息：学号、姓名、性别（男/女）、宿舍房间号、联系电话。</li>
<li>系统功能<ol>
<li>可按学号查找某一位学生的具体信息</li>
<li>可以录入新的学生信息</li>
<li>可以显示现有的所有学生信息</li>
</ol>
</li>
</ol>
<h2 id="程序要求"><a href="#程序要求" class="headerlink" title="程序要求"></a>程序要求</h2><ol>
<li>使用函数、列表、字典、字符串、条件循环等解决问题；</li>
<li>程序规模在80~200行左右。</li>
</ol>
<hr>
<h2 id="任务分析"><a href="#任务分析" class="headerlink" title="任务分析"></a>任务分析</h2><p>实现宿舍管理程序的三个功能。<br>添加的功能包括：可以利用学生的姓名进行查找。<br>错误处理：在功能选择、输入学号、姓名、性别、宿舍房间号、联系电话时都有可能出现数据格式不正确的情况，需要请求用户重新输入。在查找失败时，需要向用户提供查找失败信息。</p>
<h2 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h2><p>共有一个主函数和三个模块函数：</p>
<ol>
<li><code>search_stu</code>可按照学号查找某一位学生的具体信息。（这里做了一个功能拓展，可以通过学生姓名来进行查找，如果有重名的同学都会查找出来）</li>
<li><code>add_stu</code>模块录入新的学生信息</li>
<li><code>show_all_students</code>显示现有的所有学生信息</li>
<li><code>main</code>函数进行功能选择</li>
</ol>
<h2 id="数据结构和关键算法"><a href="#数据结构和关键算法" class="headerlink" title="数据结构和关键算法"></a>数据结构和关键算法</h2><ol>
<li>导入<code>prettytable</code>模块，使输出结果更为美观。</li>
<li><code>stu_info</code>是一个$n * 5$ 的数组，其中$n$为学生数量</li>
</ol>
<hr>
<h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><h3 id="search-stu函数"><a href="#search-stu函数" class="headerlink" title="search_stu函数"></a><code>search_stu</code>函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search_stu</span>():</span><br><span class="line">    <span class="string">&quot;按照学号或姓名查找某一位学生的具体信息&quot;</span></span><br><span class="line">    find = -<span class="number">1</span></span><br><span class="line">    t = PrettyTable([<span class="string">&quot;学号&quot;</span>,<span class="string">&quot;姓名&quot;</span>,<span class="string">&quot;性别&quot;</span>,<span class="string">&quot;宿舍房间号&quot;</span>,<span class="string">&quot;联系电话&quot;</span>])</span><br><span class="line">    sea = <span class="built_in">input</span>(<span class="string">&quot;请输入要搜索的学号或姓名： &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> sea.isdigit() == <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(stu_info)):</span><br><span class="line">            <span class="keyword">if</span> stu_info[i][<span class="number">0</span>] == sea:</span><br><span class="line">                find = i</span><br><span class="line">                t.add_row(stu_info[i])</span><br><span class="line">    <span class="keyword">if</span> sea.isalpha() == <span class="literal">True</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(stu_info)):</span><br><span class="line">            <span class="keyword">if</span> stu_info[i][<span class="number">1</span>] == sea:</span><br><span class="line">                find = i</span><br><span class="line">                t.add_row(stu_info[i])</span><br><span class="line">    <span class="keyword">if</span> find == -<span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;抱歉，未查找到该学生。&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(t)</span><br></pre></td></tr></table></figure>
<h3 id="add-stu函数"><a href="#add-stu函数" class="headerlink" title="add_stu函数"></a><code>add_stu</code>函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_stu</span>():</span><br><span class="line">    <span class="string">&quot;录入新的学生信息&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">50</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;新增学生&quot;</span>)</span><br><span class="line">    num = <span class="built_in">input</span>(<span class="string">&quot;请输入学号： &quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> num.isdigit() != <span class="literal">True</span>:</span><br><span class="line">        num = <span class="built_in">input</span>(<span class="string">&quot;输入错误，请重新输入： &quot;</span>)</span><br><span class="line">    name = <span class="built_in">input</span>(<span class="string">&quot;请输入姓名： &quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> name.isalpha() != <span class="literal">True</span>:</span><br><span class="line">        name = <span class="built_in">input</span>(<span class="string">&quot;输入错误，请重新输入： &quot;</span>)</span><br><span class="line">    sex = <span class="built_in">input</span>(<span class="string">&quot;请输入性别：（男/女） &quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> sex != <span class="string">&quot;男&quot;</span> <span class="keyword">and</span> sex != <span class="string">&quot;女&quot;</span>:</span><br><span class="line">        sex = <span class="built_in">input</span>(<span class="string">&quot;输入错误，请重新输入： &quot;</span>)</span><br><span class="line">    room_no = <span class="built_in">input</span>(<span class="string">&quot;请输入房间号： &quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> room_no.isdigit() != <span class="literal">True</span>:</span><br><span class="line">        room_no = <span class="built_in">input</span>(<span class="string">&quot;输入错误，请重新输入： &quot;</span>)</span><br><span class="line">    tel = <span class="built_in">input</span>(<span class="string">&quot;请输入电话：&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> tel.isdigit() != <span class="literal">True</span>:</span><br><span class="line">        tel = <span class="built_in">input</span>(<span class="string">&quot;输入错误，请重新输入： &quot;</span>)</span><br><span class="line">    stu = [num, name, sex, room_no, tel]</span><br><span class="line">    stu_info.append(stu)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;添加&quot;</span>+num+<span class="string">&quot;成功&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="show-all-students函数"><a href="#show-all-students函数" class="headerlink" title="show_all_students函数"></a><code>show_all_students</code>函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show_all_students</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(stu_info)):</span><br><span class="line">        table.add_row(stu_info[i])</span><br><span class="line">    <span class="built_in">print</span>(table)</span><br></pre></td></tr></table></figure>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;欢迎使用【宿舍管理系统】&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;1.查找学生&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;2.新增学生&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;3.显示全部&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;0.退出系统&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">        instruct = <span class="built_in">input</span>(<span class="string">&quot;请选择希望执行的操作：&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> instruct == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">            search_stu()</span><br><span class="line">        <span class="keyword">elif</span> instruct == <span class="string">&quot;2&quot;</span>:</span><br><span class="line">            add_stu()</span><br><span class="line">        <span class="keyword">elif</span> instruct == <span class="string">&quot;3&quot;</span>:</span><br><span class="line">            show_all_students()</span><br><span class="line">        <span class="keyword">elif</span> instruct == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;欢迎再次使用【宿舍管理系统】&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;输入错误，请重新输入指令！&quot;</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><h3 id="功能2-录入学生信息"><a href="#功能2-录入学生信息" class="headerlink" title="功能2. 录入学生信息"></a>功能2. 录入学生信息</h3><p><img src="https://s2.ax1x.com/2019/09/23/uCWEmF.jpg" alt=""></p>
<h3 id="功能3-显示所有学生信息"><a href="#功能3-显示所有学生信息" class="headerlink" title="功能3.显示所有学生信息"></a>功能3.显示所有学生信息</h3><p><img src="https://s2.ax1x.com/2019/09/23/uCWZTJ.jpg" alt=""></p>
<h3 id="功能1-根据学号或姓名进行查找"><a href="#功能1-根据学号或姓名进行查找" class="headerlink" title="功能1. 根据学号或姓名进行查找"></a>功能1. 根据学号或姓名进行查找</h3><ol>
<li><p>根据学号查找<br><img src="https://s2.ax1x.com/2019/09/23/uCWVw4.jpg" alt=""></p>
</li>
<li><p>根据姓名查找<br><img src="https://s2.ax1x.com/2019/09/23/uCWkOU.jpg" alt=""></p>
</li>
</ol>
<div class="note success">
可见，重名的学生被查找出来
</div>

<h3 id="功能0-退出系统"><a href="#功能0-退出系统" class="headerlink" title="功能0. 退出系统"></a>功能0. 退出系统</h3><p><img src="https://s2.ax1x.com/2019/09/23/uCW1OO.jpg" alt=""></p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p><img src="https://s2.ax1x.com/2019/09/23/uCWmk9.jpg" alt="指令选择错误"></p>
<p><img src="https://s2.ax1x.com/2019/09/23/uCWuf1.jpg" alt="信息录入错误"></p>
<p><img src="https://s2.ax1x.com/2019/09/23/uCWMSx.md.jpg" alt="查找错误"></p>
]]></content>
      <categories>
        <category>数据科学导论</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>口译英语学习笔记（2）</title>
    <url>/201909/%E5%8F%A3%E8%AF%91%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<p>李平老师说，这门选修课即使选的人再少她也会坚持讲下去。因为组建口译班是她一直想做的事，现在她一定要实现自己的这个梦想。<br /><br>坚持做自己喜欢的事情是一定是有意义的，因为至少以后回想起来不会后悔。</p>
<span id="more"></span>
<h1 id="Chap2-关于记忆"><a href="#Chap2-关于记忆" class="headerlink" title="Chap2. 关于记忆"></a>Chap2. 关于记忆</h1><center><font face="broadway" color="778899" size=6> -- Gains --</font></center>

<h3 id="记忆的分类"><a href="#记忆的分类" class="headerlink" title="记忆的分类"></a>记忆的分类</h3><ol>
<li>immidiate memory - 启动注意</li>
<li>short-term memory - 信息处理（对口译非常重要）</li>
<li>long-term memory 后台处理</li>
</ol>
<h3 id="Technics"><a href="#Technics" class="headerlink" title="Technics"></a>Technics</h3><ol>
<li>Visualization</li>
<li>Logical restructing</li>
<li>Time Sequence</li>
<li>Put yourself in</li>
<li>Emotion</li>
</ol>
<hr>
<p><center><font face="broadway" color="778899" size=6>-- Problems --</font></center><br>对细节记忆不准确；在对较长的内容进行记忆时容易走神，后半段都会忘掉；对专业相关的内容记忆会更加准确；听力不好。</p>
<hr>
<p><center><font face="broadway" color="778899" size=6>-- Solutions --</font></center><br>训练长时间集中注意力；训练听力</p>
]]></content>
      <categories>
        <category>口译英语</category>
      </categories>
      <tags>
        <tag>口译</tag>
        <tag>记忆</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux开发环境及其应用学习笔记（2）</title>
    <url>/201910/Linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<p>（重点）中断在我们现在的Linux系统起到怎样的作用？<br>open-系统调用<br>fopen-被包装后的open<br>越界-处理方法：中断，有页表。使用的地址不可以超过分配的地址。有MMD硬件进行监视。<br>越权：在用户态进行内核态的操作。只读时进行写。<br>copy-on-write。两个程序使用同一块内存地址，两个程序都只能设置能只读。当程序要求写的时候，将内存的东西进行复制。</p>
<span id="more"></span>
<p>串口卡：接口<br>终端做的相同的事情抽出来构成行律<br>行律的作用<br>ascii码：回车13 换行10</p>
<p>scanf 进行阻塞态<br>修改行律-比如输入密码的时候不回显，按Ctrl+C的时候不停止<br>终端转义序列<br>转义字符：Esc<br>终端字符集也可以修改<br><code>secureCRT</code><br>终端类型</p>
<p>主机和终端之间的流量控制<br>流控方法：</p>
<ul>
<li>硬件方式：CTS-Clear to Send （可以发送）</li>
<li>软件方式：<code>Xon</code>, <code>Xoff</code>当终端接收不了时，向主机发送<code>Xoff</code>。<br>Ctrl-S  Ctrl-Q<br>(next 主题的按键写法？）</li>
</ul>
<p>虚拟终端<br>数据压缩的基本算法 还是哈夫曼编码 难点在于编码对象——对频繁出现的码设置成一个编码对象。利用了程序的“局部性”<br>买一个云端，想干嘛干嘛（<br>在shell提示符下就可以键入UNIX命令<br>大小写有区别<br>查阅联机手册</p>
<p>常见的命令<br>date：打印系统日期和时间<br>ntpdate 计算机的时间是很不准确的，需要定时和时间服务器校准误差<br>cal 10 2019日历<br>bc计算器<br>355/113<br>password 更换口令<br>不存储明码口令</p>
<p>who：确定有谁在系统<br>linux：一切皆文件<br>who am i和whoami是两个不同的命令<br>uptime<br>top<br>ps -ef</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>记和李京老师的一次面谈</title>
    <url>/201909/%E8%AE%B0%E5%92%8C%E6%9D%8E%E4%BA%AC%E8%80%81%E5%B8%88%E7%9A%84%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%B0%88/</url>
    <content><![CDATA[<p>内省不疚，夫何惧何忧？</p>
<div style="text-align:right">——《论语·颜渊》</div>


<span id="more"></span>
<p>针对今年微·职招新和“书与咖啡”项目的一系列问题，我们中午约了李京老师谈话。<br>和李京老师的每次讲话我能收获到的信息量都是非常巨大的，这也让我意识到自己的一个很大的问题——思考深度不足。从大一开始，我们要求每日自省，完成感悟。可是我的感悟依然仅仅停留在“记录”和“摘抄”的层面，很多书评和影评的观点也都是受到了其他评论人的影响。<strong>自己产出新锐一手观点的能力非常差。</strong><br>我想这也是自己每次和老师以及学长学姐聊天时有醍醐灌顶的感觉的原因——自己思考深度不足，面对来自前辈们更加深刻的观点的时候，自己就会感觉他们的观点和想法很深刻。</p>
<p>下面对这次面谈做一个简单的记录。</p>
<hr>
<h1 id="关于招新的相关事宜"><a href="#关于招新的相关事宜" class="headerlink" title="关于招新的相关事宜"></a>关于招新的相关事宜</h1><ol>
<li>李老师跟上级报备，决定<strong>在信息门户发布通知</strong>或者是<strong>在2019级导员群中发布通知</strong>，我们向李老师提供官方报名通道之后，消息传达到同学们手中仅需要两三天。</li>
<li>招新时间为9月23日到10月23日，先让18级小伙伴们得到训练，再进行官方渠道的招新宣传。</li>
<li>关于场宣的问题，通过职协的名义招新，与其他社团一起。“枪打出头鸟”，我们只需要做好自己内部的氛围就可以了。</li>
</ol>
<h1 id="关于感悟"><a href="#关于感悟" class="headerlink" title="关于感悟"></a>关于感悟</h1><p>Q：小伙伴们写感悟不积极，怎么办？<br>A：通过观察，可以看出来18级以上的小伙伴们写感悟的质量还是很高的，但是对于18级的小伙伴，要么不写感悟、要么每天只是进行一个打卡。<font  color="FF0000">你们应该先在自己的身上找问题，问问自己是否已经做到完美。</font>并非大家不配合，而是我们自己没有继续向18级的小伙伴们灌输感悟的意义了。<br>Ponder：在与学长学姐们的交流中我们也可以感觉到，这一年我们和18级之间的交流太太少了。导致有特别多的想法和文化观念我们无法向18级传达，也就忽视了向他们传达感悟的意义。在此，我想自己先思考一下，每日感悟对我自己有什么意义。<br>现在可能很多人都没法通过“失去感悟”这件事情来知晓感悟的价值，因为大家好像没有真正的“拥有过”感悟，所以觉得不写感悟好像从来没有影响过自己的生活。<br>我们现在来仔细思考感悟的意义。<br>从一个最功利的角度说起：李京老师接触过无数的本科毕业生，他问大家：“你的大学生涯有没有什么一件可以拿出来吹牛的事情？”基本所有人的回答都是“没有。”大家都没有做过什么“没有第二个人做过的事情。”而感悟就是这样一件让你可以吹牛的谈资，当HR听到你说你的大学四年完成了“40万字感悟”的时候，他们的眼睛都在发亮，他们都对此非常好奇。这是很多学长学姐屡试不爽的一个面试经验。  </p>
<div class="note success">
当然这个例子对我们的启发不仅仅是感悟，我们要仔细想想，当大学四年结束时，我能不能自豪地说出一件“值得吹牛”的事情。
</div>

<p>再来，就是利用我前面所说的“失去感悟”的方法来探寻它的价值。<br>我大一一年的感悟完成质量还是很高的，我的每天都记录下来了，我读过的书、去过的地方、学过的东西、看过的电影都存在于我的感悟里，我回去看的时候能够确定地告诉自己，我这一年一直没有过停止进步。<br>但是现在的我回去看我的大二时光，我发现了自己的生活里有一大片空白，我根本想不起来我这些日子是怎样度过的。我会想，“多可惜啊，如果我那时候仅仅是记录自己一天都干了什么也好啊。”<br>这个时候，我体会到了“失去感悟”带给我的影响，我发现我的一大段时间都是空白的，这让我非常可惜。  </p>
<p>我们做任何事情的时候都喜欢去思考事情的意义，当然这不一定是正确的做法，有时候做没有意义的事情也是很好的事情。<br>比如说，我去做志愿，我能获得什么意义呢？<br>我可以拥有志愿时长、可以拥有德育分，我为了它们我去做志愿。<br>有时候我去做了没有志愿时长的志愿活动，这时候我会发一条朋友圈“不为其他，只为世上的每个人都能得到温暖。”这时候我得到了虚荣心和满足感，得到了比那些“为了德育分去做志愿的同学”更多的优越感，得到了老师和同学们眼中的一个优秀人设。<br>但是这些都太浅了，就像是我写感悟是为了积累字数、方便我去面试，为了我以后拥有更多的谈资。但这些并非是我们写感悟的最终意义，我们写感悟的最终意义，是养成“日参省乎己”的习惯。这是我眼中的感悟的最终的意义，——不仅仅是记录、不仅仅是摘抄、不仅仅是记录别人的观点，而是通过我们普通的生活去挖掘更深层的意义，学会深度思考。这和我们微·职“修炼内功”的思维是很类似的。<br>为了达到这个目的，我还有很长的路要走。</p>
<h1 id="关于“书与咖啡”合伙人参与不积极"><a href="#关于“书与咖啡”合伙人参与不积极" class="headerlink" title="关于“书与咖啡”合伙人参与不积极"></a>关于“书与咖啡”合伙人参与不积极</h1><p>李京老师还是说，先找自身的问题。<br>当我第一眼看到这次书与咖啡的通知时，没有想要参与的欲望。原因是什么？<br>“港独”和我自己有什么关系？讨论政治我没兴趣啊。我为什么要花时间在与自己不相干的事情上？有这些时间为什么不去做一些更重要的事情？<br>书与咖啡的宗旨是“务虚”，目标是让大家（合伙人）拥有更宏观的“格局”。我们不应该往下看，而是应该往上看。  </p>
<font color="FF0000">这世界上我们看到的东西，都能够衍生成和我们自己有关的事情。</font>

<p>月亮和我们有什么关系？<br>中秋节，吃月饼，月球的潮汐与女性生理期还有关系，等等。  </p>
<p>9月14日，沙特石油巨头企业沙特阿拉伯国家石油公司（以下简称：沙特阿美）的两处石油设施（一家炼油厂和一座油田）在受到无人机攻击后起火。<br>这和我们有什么关系？<br>你爸妈不开车？油价受到怎样的影响？最终怎样影响到我们自己的生活？</p>
<p>我们应该从这样的宏观纵向角度去思考问题。而现在的我们大多数情况下在面对新闻的时候，都仅仅是获得新闻信息，简单的评论新闻。比如这次的港独主题，我就只会感慨愤青的差劲，不会联想这些事情对于我自身会产生怎样的影响。这样的思考方式都是<font color="FF0000">孤立事件</font>。我们要学会把事情都联系起来。  </p>
<p>对于香港问题，我们就可以从政府、社会、个体层面去思考问题。<br>比如从香港大学生切入，这个角度就会让大家有身份认同感。</p>
<p><strong>这样的宏观纵向思考方式还需要进一步的养成。</strong></p>
<p>做事情先找内因，再找外因。</p>
]]></content>
      <categories>
        <category>参省乎己</category>
      </categories>
  </entry>
  <entry>
    <title>数据库系统原理学习笔记（2）</title>
    <url>/201909/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Chap2-Introduction-to-the-Relational-Model-关系模型介绍"><a href="#Chap2-Introduction-to-the-Relational-Model-关系模型介绍" class="headerlink" title="Chap2. Introduction to the Relational Model(关系模型介绍)"></a>Chap2. Introduction to the Relational Model(关系模型介绍)</h1><div class="note success">
    本章最好通过举例来理解定义。
</div>

<h2 id="Introduction-to-Chapter-2"><a href="#Introduction-to-Chapter-2" class="headerlink" title="Introduction to Chapter 2"></a>Introduction to Chapter 2</h2><h3 id="Relational-data-model"><a href="#Relational-data-model" class="headerlink" title="Relational data model"></a>Relational data model</h3><ul>
<li>relational data structure (syntax)语法</li>
<li>integrity constraints (semantic) 完整性约束（语义）<ul>
<li>constraints on <strong>attributes of schemas</strong>, e.g. value domain, type</li>
<li>constraints on <strong>dependencies among attributes of a schema</strong></li>
<li>constraints on <strong>dependencies among attributes of different schemas</strong></li>
</ul>
</li>
<li>operations on the model</li>
</ul>
<span id="more"></span>
<p><img src="https://s2.ax1x.com/2019/09/18/nTlHFx.jpg" alt="Fig.2.1 The instructor relation"></p>
<h2 id="2-1-Structure-of-Relational-Databases（关系数据库）"><a href="#2-1-Structure-of-Relational-Databases（关系数据库）" class="headerlink" title="2.1 Structure of Relational Databases（关系数据库）"></a>2.1 Structure of Relational Databases（关系数据库）</h2><p>attributes(or columns)<br>tuples(or rows)</p>
<h3 id="Basic-structures"><a href="#Basic-structures" class="headerlink" title="Basic structures"></a>Basic structures</h3><p><strong>关系（relation）</strong>定义为：一系列域上的笛卡尔积的子集。<br><strong>Attributes ：</strong>$A_1, A_2, … ,A_n$<br><strong>domain</strong> of relation’s attributes $D_1, D_2,…D_n$</p>
<p><div class="note info"></p>
<pre><code>1. relation r in DBS is the limited set.&lt;br /&gt;
2. attributes are  non-ordered.&lt;br /&gt;
3. tuples&#39; order is irrelevant.&lt;br /&gt;
4. `null` is a member of every domain.
</code></pre><p>&lt;/div&gt;<br><img src="https://s2.ax1x.com/2019/09/18/nT1rcD.jpg" alt=""></p>
<p>A domain is <strong>atomic</strong> if its elements are considered to be invisible.</p>
<h2 id="2-2-Database-schema-数据库模式"><a href="#2-2-Database-schema-数据库模式" class="headerlink" title="2.2 Database schema(数据库模式)"></a>2.2 Database schema(数据库模式)</h2><h3 id="Relation-schema-关系模式"><a href="#Relation-schema-关系模式" class="headerlink" title="Relation schema 关系模式"></a>Relation schema 关系模式</h3><ol>
<li>For attributes $A_1, A_2, … , A_n, R=(A_1, A_2, …, A_n)$ is a <strong>relation schema</strong>.<br>e.g. Instructor-schema = (ID, name, depart_name, salary)</li>
<li>$r(R)$ is a relation on the relation schema $R$<br>e.g. customer(customer-name, customer-street, customer-city) on Customer-schema</li>
<li><code>relation instance</code>与<code>relation</code>不作区分。</li>
<li>an <strong>element</strong> $t$ in set $r$ is a <strong>tuple</strong>, represented by a $row$ in a table.</li>
<li>$t[A_i]$ = the value of $t$ on the attribute $A_i$.<br> e.g. t2[customer-name] = Smith</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/09/18/nbpQ0g.jpg" alt="Fig2.2"></p>
<h2 id="2-3-Keys-键，码"><a href="#2-3-Keys-键，码" class="headerlink" title="2.3 Keys(键，码)"></a>2.3 Keys(键，码)</h2><ol>
<li><strong>super key</strong> - can be used to identify uniquely a tuple in the relation.能用来被区分不同的元组。</li>
<li><strong>candidate key</strong>（候选码）<br> 候选码是最小的超码。</li>
<li><strong>Primary key:</strong> A relation may have several candidate keys. Primary key is chosen as principal means to identify tuples.</li>
<li><strong>Primary attributes //non-primary attributes</strong> </li>
<li><strong>foreign key&amp;referencing relation &amp; referenced relation</strong><br>这里比较容易混，注意看定义。<br><strong>Def.</strong> If X is one or more attributes in relation r1, and X is also the primary-key of another relation schema r2.<br>X is called a foreign key from r1 referencing r2 X是由r1参照/关联r2的外键<br>r1 is called the referencing relation of the foreign key<br>r2 is called the referenced relation of the foreign key<br>e.g. <code>dept_name</code> in <code>instructor-schema</code> and <code>department-schema</code>, <code>dept_name</code> in <code>instructor</code> is a foreign key from <code>instructor</code> referencing <code>department</code>.   </li>
<li><strong>schema diagram</strong>(模式图)、<strong>node</strong>、<strong>directed arc</strong></li>
<li><strong>Referential integrity constraint(参照完整性约束)</strong>：在参照关系中，任意元组在特定关系中的取值必然等于被参照关系中某个元组在特定关系上的取值。</li>
</ol>
<h2 id="2-5-Query-language-查询语言"><a href="#2-5-Query-language-查询语言" class="headerlink" title="2.5 Query language(查询语言)"></a>2.5 Query language(查询语言)</h2><p>procedural 过程化的：用户指导系统对数据库执行一系列操作以计算所需结果。<br>non-procedural 非过程化的：用户只需描述所需信息，而不用给出获取该信息的具体过程。</p>
<h2 id="2-6-basic-relation-algebra-operations-基本关系运算"><a href="#2-6-basic-relation-algebra-operations-基本关系运算" class="headerlink" title="2.6 basic relation algebra operations 基本关系运算"></a>2.6 basic relation algebra operations 基本关系运算</h2><ol>
<li><p>Select Operation - selection of rows(tuples)<br>$\sigma_p(r)$<br><img src="https://s2.ax1x.com/2019/09/19/nbiyVO.jpg" alt="eg1"></p>
</li>
<li><p>Project Operation<br>将元组投影到某些属性上<br>$\prod_{A_1, A_2, …A_k}(r)$<br>筛选后还要去重<br><img src="https://s2.ax1x.com/2019/09/19/nbicIe.md.jpg" alt="eg2"></p>
</li>
<li><p>Union Operation<br>$\bigcup$<br>$r, s$ must have the same arity(元)<br>compatible(相容的)<br>多个操作的组合运算（查看例题）<br><img src="https://s2.ax1x.com/2019/09/19/nbi6aD.jpg" alt="eg3"></p>
</li>
<li><p>Set Difference Operation<br>$r - s$<br><img src="https://s2.ax1x.com/2019/09/19/nbirqK.md.jpg" alt="eg4"></p>
</li>
<li><p>Set Intersection Operation<br>$r \bigcap s$<br><img src="https://s2.ax1x.com/2019/09/19/nbiDr6.jpg" alt="eg5"></p>
</li>
<li><p>Cartesian-Product Operation(笛卡儿积运算)<br><img src="https://s2.ax1x.com/2019/09/19/nbi2PH.jpg" alt="eg6"></p>
</li>
<li><p>Natural Join<br>$\bowtie$<br>自然连接运算首先形成它的两个参数的笛卡儿积，然后基于两个关系模式中都出现的属性上的相等性进行选择，最后还要去除重复属性。<br><img src="https://s2.ax1x.com/2019/09/19/nbiWRA.md.jpg" alt="eg7"></p>
</li>
<li><p>Renaming Operation</p>
</li>
</ol>
<h2 id="Compositon-of-Operations"><a href="#Compositon-of-Operations" class="headerlink" title="Compositon of Operations"></a>Compositon of Operations</h2><h1 id="Chap-6-Formal-Relational-Query-Language"><a href="#Chap-6-Formal-Relational-Query-Language" class="headerlink" title="Chap.6 Formal Relational Query Language"></a>Chap.6 Formal Relational Query Language</h1><h2 id="6-1-Relational-Algebra"><a href="#6-1-Relational-Algebra" class="headerlink" title="6.1 Relational Algebra"></a>6.1 Relational Algebra</h2><h3 id="Fundamental-operations"><a href="#Fundamental-operations" class="headerlink" title="Fundamental operations"></a>Fundamental operations</h3><p>第二章都讲过了。详见下节课的笔记吧。</p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习课堂笔记（2）</title>
    <url>/201909/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<div class="note warning">
    机器学习的第二次课程。感觉新专业课程安排的不够合理，有很多机器学习的先修课程都在和机器学习同时进行。🤦‍♂️ Anyway,努力学习吧。<br />
    在本次课程中还没有做到的事：<br />
    1. 多查看笔记里的概念类内容，作到掌握。<br />
    2. 近一步理解笔记里出现的公式。<br />
    3. 对机器学习历史里出现的算法做进一步了解。<br />
    4. 对笔记里提到的算法进行各种实践！只有理论不可以的。🙌
</div>

<h1 id="第二次上课"><a href="#第二次上课" class="headerlink" title="第二次上课"></a>第二次上课</h1><h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><ul>
<li>Def of Machine Learning</li>
</ul>
<p>A compute program is said to learn from experience E with respect to same task T and some performance measure P, if its performance on T, as measure by P, improves with experience E.</p>
<span id="more"></span>
<p>假设用$P$来评估计算机程序在某任务$T$上的性能，若一个程序通过利用经验$E$在$T$上获得性能改善，则我们就说该程序对$E$进行了学习。</p>
<ul>
<li>机器学习的模型分类<ul>
<li><strong>归纳学习：</strong>从样例中学习。</li>
<li><strong>机械学习：</strong>死记硬背式学习。</li>
<li><strong>进化学习、强化学习：</strong>在问题求解和规划中学习。</li>
<li><strong>类比学习（如迁移学习）：</strong>通过观察和发现学习。</li>
<li><strong>示教学习（如机器人模仿人的动作）：</strong>从指令中学习。<br><em>Tips:进化学习来源于达尔文的进化理论，遗传算法是进化学习的经典方法。</em></li>
</ul>
</li>
</ul>
<p><a href="http://people.csail.mit.edu/dsontag/courses/ml16/">一个非常优秀的机器学习资源网址(还未仔细查看)</a></p>
<hr>
<h2 id="本节课的主要内容"><a href="#本节课的主要内容" class="headerlink" title="本节课的主要内容"></a>本节课的主要内容</h2><ul>
<li>以监督学习为例，谈一下学习的策略和学习的算法。</li>
<li>机器学习的发展史</li>
<li>几何模型</li>
</ul>
<h3 id="机器学习系统构成的要素"><a href="#机器学习系统构成的要素" class="headerlink" title="机器学习系统构成的要素"></a>机器学习系统构成的要素</h3><p><img src="https://s2.ax1x.com/2019/09/18/noNEk9.jpg" alt="机器学习系统构成要素"></p>
<ul>
<li><strong>任务：</strong>可通过机器学习解决的问题。</li>
<li><strong>特征：</strong>适用于样本集合中任意实例的度量方法。</li>
<li><strong>模型：</strong>从数据中学习以便解决给定任务的系统方法。</li>
</ul>
<h3 id="学习算法的核心"><a href="#学习算法的核心" class="headerlink" title="学习算法的核心"></a>学习算法的核心</h3><p><font color="FF0000">策略 + 求解算法</font><br><strong>一些基本概念：</strong></p>
<ol>
<li>损失函数<br><img src="https://s2.ax1x.com/2019/09/18/noU6Ve.jpg" alt="损失函数"></li>
<li>期望损失：损失函数的期望<br> （理论上存在，但是很难利用它）<br> <img src="https://s2.ax1x.com/2019/09/18/noU7Vg.jpg" alt=""><br> <em>打公式真的麻烦死了😡，公式都直接用图片好了</em></li>
<li>经验风险（又称“经验损失”）<br> 模型关于训练样本的平均损失。根据大数定律，当样本的容量趋于无穷大时，经验损失无限趋近于期望损失。<br> <img src="https://s2.ax1x.com/2019/09/18/noaAR1.jpg" alt=""></li>
</ol>
<p><strong>策略1：</strong>经验风险最小化<br><img src="https://s2.ax1x.com/2019/09/18/noa3RI.jpg" alt=""><br>可以用此公式推导$f(x)$<br>当样本小或者取样有问题的时候容易出现过拟合。</p>
<p><strong>策略2：</strong>结构风险最小化<br><img src="https://s2.ax1x.com/2019/09/18/noa1JA.jpg" alt=""><br>加入<font color="FF0000">正则化项</font>，使模型不要太“特例”，避免过拟合。</p>
<p><strong>求解算法：</strong><br>机器学习的学习算法本质上是一个优化问题求解算法。</p>
<p>至此，机器学习的概念已经全部结束。<br>机器学习能干什么？列出四五个<br>机器学习的分类，不同的分类下面能列出3.4个<br>机器学习的算法，不同的模型怎样度量自己的风险。</p>
<h3 id="机器学习的发展"><a href="#机器学习的发展" class="headerlink" title="机器学习的发展"></a>机器学习的发展</h3><p>详见博客地址<br>classic alg 黄色的点是基于神经网络</p>
<p><strong>机器学习的历史：</strong>（上课随便记了一点，不重要的）<br>详细资料：<br><a href="http://www.erogol.com/brief-history-machine-learning/">机器学习的历史</a></p>
<ol>
<li>1949年，Hebb提出了神经心理学学习范式，这为以后的神经网络奠下基础。</li>
<li>1957年，Rosenblatt提出了感知器算法，是神经网络的基础。</li>
<li>1995年，Vapnik和Cortes提出的<font color="FF0000">支持向量机（网络）（SVM）</font><br><img src="https://s2.ax1x.com/2019/09/18/nodwnK.jpg" alt="机器学习重要节点"></li>
</ol>
<p>不一定所有模型都套用深度学习，有很多其他解决问题的模型。</p>
<p><strong>从样例中学习：</strong></p>
<ol>
<li>符号主意——“对智能行为的符号化建模”。<br>概念学习的结果可以是显性的。</li>
<li>连接主意——基于神经网络。<br>效果更好，但是知识是隐性的。</li>
<li>统计学习——基于数据构建概率统计模型并运用模型对数据进行预测分析。</li>
<li>深度学习——深度学习缺乏严格的理论基础，但是显著降低了应用者的门槛。<br>学习深度学习的时候关心一下开源的软件。</li>
</ol>
<hr>
<h2 id="第二章、几何模型"><a href="#第二章、几何模型" class="headerlink" title="第二章、几何模型"></a>第二章、几何模型</h2><p><strong>任务、模型、策略、算法</strong><br>有一些数据的<font color="FF0000">几何特征</font>，如直线、曲线、平面、距离等，有助于我们区分样本的分布特征。<font color="FF0000">利用几何特征构建的机器学习模型</font>，我们称之为<font color="FF0000">几何模型</font>。几何模型主要包括<font color="FF0000">线性分类器、支持向量机、最近邻算法以及K均值聚类</font>等。</p>
<h3 id="线性分类问题"><a href="#线性分类问题" class="headerlink" title="线性分类问题"></a>线性分类问题</h3><p>如果存在某个线性决策面能够将两类样本分离，则称所给数据集是线性可分的。<br><img src="https://s2.ax1x.com/2019/09/18/nowVHO.jpg" alt="线性决策面举例"></p>
<p><strong>基本线性分类器</strong><br>体现了经验风险最小化。<br><img src="https://s2.ax1x.com/2019/09/18/nowYVS.jpg" alt="基本线性分类器求解"></p>
<p><strong><code>Fisher</code>线性分类器</strong></p>
<ul>
<li>基本原理：找到一个最合适的投影轴，使两类样本在该轴上的投影之间的举例尽可能远，而每一类样本的投影尽可能紧凑，从而使分类效果最佳。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>几何模型</tag>
        <tag>机器学习</tag>
        <tag>线性分类</tag>
      </tags>
  </entry>
  <entry>
    <title>口译英语学习笔记（1）</title>
    <url>/201909/%E5%8F%A3%E8%AF%91%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p><img src="https://s2.ax1x.com/2019/09/20/nXwlI1.jpg" alt="Booth"></p>
<div class="note info">
口译英语课程，周四晚，李平老师。周四对我来说是另一种意义上的“辛苦”的一天。上午要上男神的Linux，下午网球、健身房，晚上还有口译训练。口译是非常辛苦的过程，老师说她原先翻译一天整个人神经紧张到无法松弛下来了，听到别人说话就想翻译。<br />
比较幸运的是，选这门课的人还不到十个人，所以每个人训练的机会都很多，希望能通过这门课程提高自己的口语和听力能力吧。
</div>

<span id="more"></span>
<h1 id="Gains"><a href="#Gains" class="headerlink" title="Gains:"></a>Gains:</h1><h2 id="Knowledge-Points"><a href="#Knowledge-Points" class="headerlink" title="Knowledge Points"></a>Knowledge Points</h2><ol>
<li><p>大学四年学生说法：<br>大一 freshman<br>大二 sophomore<br>大三 junior<br>大四 senior  </p>
</li>
<li><p>北京师范大学 Beijing Normal School<br>中国政法大学 China University of Political Science and Law<br>工商管理硕士 MBA Master of Business Administration  </p>
</li>
<li><p>研究生 postgraduates<br>本科生 undergraduates</p>
</li>
<li><p>Give birth to 生了…<br>Intensive reading 精读</p>
</li>
</ol>
<div class="note primary">
Tips：翻译时如果不确定可以只翻译中心词
</div>

<p>Archery 射箭场<br>Oral English 口语<br>爱情长跑 love marothon（马拉松）<br>Middle schoolers 中学生<br>大约400    400 about<br>早产儿    premature<br>有时我绘画。    Seldom I draw.<br>硕士研究生    master candidate<br>长足的进步    leap forward<br>谢谢我的翻译者。    Thanks for my interpreter.<br>摇滚乐    rock and roll<br>电子乐    electronic music<br>消除隔阂、缩短差距 Bridge the gap<br>“联络口译”    liason interpreting<br>同传箱    booth<br>Coordinate 使协调，使相配合<br>These shade coordinates with a wide range of other colors.  这种深浅的颜色可以与很多其他颜色搭配。<br>不管怎么说我饿了。  I’m hungry anyway.<br>Give me a break. 别说了。  </p>
<div class="note primary">
Tips: 翻译时候要有自信。
</div>

<h2 id="初级英语口译"><a href="#初级英语口译" class="headerlink" title="初级英语口译"></a>初级英语口译</h2><p>70%: Quizzes, presentation, assignment<br>30%: 期末考察</p>
<h2 id="Basic-concept"><a href="#Basic-concept" class="headerlink" title="Basic concept"></a>Basic concept</h2><p>Translation.</p>
<h3 id="Written-translation-笔译"><a href="#Written-translation-笔译" class="headerlink" title="Written translation    笔译"></a>Written translation    笔译</h3><h3 id="Oral-translation-口译"><a href="#Oral-translation-口译" class="headerlink" title="Oral translation    口译"></a>Oral translation    口译</h3><ol>
<li>交传 consecutive</li>
<li>同传 simultaneous</li>
<li>视阅口译    sight<br>Interpretation 一般不用这个词做“口译”，因为它大多数代表“解释”的意思。<br>Interpreting</li>
</ol>
<h2 id="翻译的方法"><a href="#翻译的方法" class="headerlink" title="翻译的方法"></a>翻译的方法</h2><h3 id="Literal-word-for-word-直译"><a href="#Literal-word-for-word-直译" class="headerlink" title="Literal: word for word 直译"></a>Literal: word for word 直译</h3><p>纸老虎 paper tiger<br>一国两制 one nation two systems<br>君子协定 gentleman’s agreement<br>武装到牙齿    armed to the teeth</p>
<h3 id="Free-意译"><a href="#Free-意译" class="headerlink" title="Free    意译"></a>Free    意译</h3><p>我铁石心肠。    I’m so hard.<br>我难以接近。    I’m so difficult.<br>我还想问你呢？    You have stolen my questions.<br>秃子头上的虱子——明摆着。    It’s as plain as your nose in your face.<br>胳膊拧不过大腿。    Little fish does not eat big fish.</p>
<h2 id="口译的原则"><a href="#口译的原则" class="headerlink" title="口译的原则"></a>口译的原则</h2><p>准、顺、快</p>
<h2 id="口译员的素质："><a href="#口译员的素质：" class="headerlink" title="口译员的素质："></a>口译员的素质：</h2><ol>
<li>对语言熟练，口语熟练</li>
<li>知识 “百科全书”</li>
<li>思维</li>
<li>技能</li>
</ol>
<h1 id="Problems"><a href="#Problems" class="headerlink" title="Problems:"></a>Problems:</h1><p>词汇量差的太多，无论是中译英还是英译中脑子都会断片。很多词仅仅是认识，但是不会用起来。</p>
<h1 id="Solutions："><a href="#Solutions：" class="headerlink" title="Solutions："></a>Solutions：</h1><p>注意词汇学习的深度，学会运用。</p>
]]></content>
      <categories>
        <category>口译英语</category>
      </categories>
      <tags>
        <tag>口译</tag>
      </tags>
  </entry>
  <entry>
    <title>数据科学导论学习笔记（1）</title>
    <url>/201909/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<div class="note info">
    <br />
    数据科学导论作为数据科学与大数据技术专业的导论课程具有相当重要的意义。每周4课时（提前结课），授课教师石川老师。
    <br />
    希望新学期的自己能够积极完成每一门课程的课后复习和拓展，认真写博客整理知识点。
</div>

<span id="more"></span>
<p><br /></p>
<h1 id="Chap-1-数据科学概论"><a href="#Chap-1-数据科学概论" class="headerlink" title="Chap.1 数据科学概论"></a>Chap.1 数据科学概论</h1><p><strong>课程性质:</strong><br>一门导论性质的课程；包含理论知识和案例分析<br /><br><strong>先修课程:</strong><br>高等数学，线性代数，概率论，数据结构，算法导论，计算机组成原理等<br /><br><strong>后继课程:</strong><br>数据挖掘，数据库，机器学习，深度学习，大数据分析等<br /></p>
<hr>
<h2 id="1-1-数据和大数据"><a href="#1-1-数据和大数据" class="headerlink" title="1.1 数据和大数据"></a>1.1 数据和大数据</h2><h3 id="1-1-1-数据"><a href="#1-1-1-数据" class="headerlink" title="1.1.1 数据"></a>1.1.1 数据</h3><p><strong>数据的定义:</strong><br>从数据科学的角度，将数据定义为，<strong>在一定背景下 有意义的 对于现实世界中的事物定性或定量的记录。</strong><br /><br><strong>数据的类型:</strong></p>
<ul>
<li>依据结构分类 :<br>结构化数据：如数字、字符、日期等等属于结构化数据类型；<br>非结构化数据：文字、图片、视频、音频等；</li>
<li>依据形式分类 :<br>文本、数字、声音、图片等</li>
<li>依据来源分类:<br>观测数据和实验数据<br><br /></li>
</ul>
<p><strong>数据的DIKW模型:</strong><br>DIKW模型通常也被称为知识金字塔，是一个金字塔状的层状模型。<br /><br>Data, Infomation, Knowledge, Wisdom  </p>
<p><img src="https://s2.ax1x.com/2019/09/12/n0o1Rf.jpg" alt="DIKW模型图"></p>
<h3 id="1-1-2-大数据"><a href="#1-1-2-大数据" class="headerlink" title="1.1.2 大数据"></a>1.1.2 大数据</h3><p><strong>大数据的定义:</strong><br>1998年的 <code>USENIX</code> 大会上，美国硅图公司的首席科学家 <code>John R.Mashey</code> 首次提出了“大数据”这一概念，发表了名为《大数据与下一次基础设施压力的浪潮》的报告。<br>首先，大数据依旧是数据，或数据相关的过程；其次，大数据的规模并非一定要达到某一确切的数值，关键在于，是否超过了实际情况下的数据存储能力和数据计算能力。</p>
<p><strong>大数据相关定理与模型:</strong><br><strong>（1）5V模型</strong><br>多样性（ <code>Variety</code> ），大量性（ <code>Volume</code> ），高速性（<code>Velocity</code>），价值性（ <code>Value</code> ），真实性（<code>Veracity</code>）</p>
<p><strong>（2）5R模型</strong><br>从数据管理的角度认识从大数据中获取有用信息的过程。<br>该模型包括大数据的相关特性（<code>Relevant</code>），实时特性（<code>Realtime</code>），真实特性（<code>Realistic</code>），可靠特性（<code>Reliable</code>），以及投资回报特性（<code>Return on investment</code>, <code>ROI</code>）  </p>
<font color="FF0000">值得注意的是5R模型中的投资回报（`ROI`）。许多的大数据项目最初关注的重点只是数据本身的利用，而没有认识到对数据的利用怎么与整个商业计划相适应，忽略了数据之下的知识的价值。</font>

<p><strong>（3）4P模型</strong><br>在医疗大数据的环境中产生了医学4P模型，包含预测性（<code>Predictive</code>），预防性（<code>Preventive</code>），个体化（<code>Personalized</code>），参与性（<code>Participatory</code>）。<br>该医疗模型基于大数据，对疾病做出<font color="FF0000">预测</font>，并基于个人数据对病人做出<font color="FF0000">个性化的服务</font>，同时，诊疗过程中的数据将再次被<font color="FF0000">记录到数据库中</font>，从而为病人提供基于大数据的健康建议。</p>
<p><strong>（4）HACE定理</strong><br><em>用于阐述大数据的定理</em><br>HACE定理将大数据描述为，始于异构（<code>Heterogeneous</code>）,自治（<code>Autonomous</code>）的多源海量数据，旨在寻求探索复杂的（<code>Complex</code>）和演化的（<code>Evolving</code>）数据关联的方法和途径。<br>基于<code>HACE定理</code>，文章还提出了大数据处理的三层框架。</p>
<ol>
<li>框架的第一层是大数据的计算平台。</li>
<li>框架的第二层是大数据的语义和应用知识，包含数据共享与隐私、领域和应用知识的问题。</li>
<li>框架的第三层是大数据分析算法。  </li>
</ol>
<p><img src="https://s2.ax1x.com/2019/09/15/n2dPiT.jpg" alt="基于HACE定理的大数据三层框架"></p>
<hr>
<h2 id="1-2-数据科学理论基础"><a href="#1-2-数据科学理论基础" class="headerlink" title="1.2 数据科学理论基础"></a>1.2 数据科学理论基础</h2><h3 id="1-2-1-数据科学发展历程"><a href="#1-2-1-数据科学发展历程" class="headerlink" title="1.2.1 数据科学发展历程"></a>1.2.1 数据科学发展历程</h3><p><em>仅记录几个时间节点</em></p>
<ul>
<li>1974年，图灵奖获得者 Peter Naur 首次提到了“数据科学”的概念。</li>
<li>2002年，<code>CODATA</code>创立了学术期刊<code>&lt; Data Science Journal &gt;</code>，这是首个关于数据科学的学术期刊。</li>
<li>2009年，谷歌首席经济学家Hal Ronald Varian发表意见称，未来十年最性感的工作是统计学家。</li>
<li>2010年，作家Kenneth Cukier 在《经济学人》中发表特别报告提出，“数据科学家作为一种新的职业出现，他们具备了<font color="FF0000">软件程序员，统计学家和讲故事者的技能</font>，用来提取大量数据背后隐藏的规律”</li>
<li>2010年，Drew Conway在文章中指出，“能够胜任工作的数据科学家需要学习很多方面东西”，并将其以韦恩图的形式总结为<font class="FF0000">黑客技能、数学和统计学知识、以及专业领域知识。</font></li>
</ul>
<h3 id="1-2-2-数据科学的主要内容"><a href="#1-2-2-数据科学的主要内容" class="headerlink" title="1.2.2 数据科学的主要内容"></a>1.2.2 数据科学的主要内容</h3><p><strong>研究内容和研究对象:</strong><br>现实世界中来源不同类型不同的数据。</p>
<p><strong>理论体系:</strong><br><img src="https://s2.ax1x.com/2019/09/16/nfeK9P.jpg" alt="Drew Conway提出的数据科学韦恩图"></p>
<p><code>Hacking skill</code>：计算机科学、人工智能等方面的方法和技术。<br><code>Math&amp;Statistics Knowledge</code>：数学和统计学方法理论。<br><code>Substantive Expertise</code>：实质性领域知识。  </p>
<p><img src="https://s2.ax1x.com/2019/09/16/nfHx41.jpg" alt="数据科学韦恩图"></p>
<p><strong>数据科学与第四范式:</strong><br>2007年图灵奖得主 Jim Gray 在演讲中提出了“指数级增长的科学依据”背景下的数据密集型科学研究的第四范式。</p>
<ul>
<li>几千年前，科学的星星之火刚刚点燃时的<font color="FF0000">实验科学范式</font>；</li>
<li>几百年前以牛顿的经典力学，麦克斯韦理论解释的电磁学，所代表的<font color="FF0000">理论科学范式</font></li>
<li>几十年前的<font color="FF0000">计算机科学范式</font></li>
<li>到信息爆炸的今天，我们需要<strong>从计算机科学中把数据密集型科学区分出来，作为一个新的、科学探索的第四种范式</strong>，这就是第四范式的由来。<font color="FF0000">数据密集型范式</font><br><br /></li>
</ul>
<p><em>国际数据委员会（CODATA）原称国际科技数据委员会，是原国际科学联合会下属一级学术机构，其宗旨是推动科技数据应用，发展数据科学，促进科学研究，造福人类社会，成立于1966年，秘书处设在法国巴黎。国际科学联合会和国际社会科学联合会于2018年7月正式合并成为International Science Council (ISC)，国际科技数据委员会也相应更名为国际数据委员会，从ICSU下一个专门关注科学数据的跨学科的国际组织演变成ISC下推动大数据与数据科学发展的主要机构。</em>  </p>
<p>数据密集型科学由三个基本活动组成：数据采集、数据管理和数据分析。  </p>
<p>数据科学与第四范式的联系在于，这两者是大数据研究的两大理论基础，前者是更广泛意义上的数据科学，后者是针对科学研究范式而言的。</p>
<hr>
<h2 id="1-3-数据科学应用实践"><a href="#1-3-数据科学应用实践" class="headerlink" title="1.3 数据科学应用实践"></a>1.3 数据科学应用实践</h2><h3 id="1-3-1-数据科学家"><a href="#1-3-1-数据科学家" class="headerlink" title="1.3.1 数据科学家"></a>1.3.1 数据科学家</h3><p><strong>数据科学家的定义:</strong></p>
<ol>
<li>具有计算机科学技术，数学和统计学知识基础和实质性专业理论知识的人。</li>
<li><strong>能够发现现实世界的问题，收集问题相关的数据，抽取数据中的信息，并解释数据背后的意义的人。</strong></li>
</ol>
<p><strong>数据科学家的技能:</strong><br><img src="https://s2.ax1x.com/2019/09/16/nfj9mT.jpg" alt="数据科学家韦恩图"></p>
<p>数据科学家的工作需要使用：Python, R, SQL, Hadoop, Spark, Java, SAS, C++, Tensorflow等语言、库或是工具。</p>
<h3 id="1-3-2-数据科学工作流程"><a href="#1-3-2-数据科学工作流程" class="headerlink" title="1.3.2 数据科学工作流程"></a>1.3.2 数据科学工作流程</h3><p><img src="https://s2.ax1x.com/2019/09/16/nfx3QI.jpg" alt="数据科学工作流程图"></p>
<p>分析数据包括两步，第一步是探索性分析，第二步是通过机器学习算法和统计学模型对数据进行分析。<br>探索性分析是指对已有的数据在尽量少的先验假定下进行探索，通过制图，制表，方程拟合等手段探索数据结构和规律的一种数据分析方法，适用于面对大量数据不知如何下手从何处分析的情况。</p>
<h3 id="1-3-3-数据科学实践案例"><a href="#1-3-3-数据科学实践案例" class="headerlink" title="1.3.3 数据科学实践案例"></a>1.3.3 数据科学实践案例</h3><ol>
<li>医疗健康大数据</li>
<li>沃尔玛与社交大数据</li>
<li>大数据与智慧城市</li>
</ol>
]]></content>
      <categories>
        <category>数据科学导论</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>30天自制操作系统（27）</title>
    <url>/201905/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8827%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY27-LDT与库"><a href="#DAY27-LDT与库" class="headerlink" title="DAY27_LDT与库"></a>DAY27_LDT与库</h1><h2 id="1-先来修复bug"><a href="#1-先来修复bug" class="headerlink" title="1. 先来修复bug"></a>1. 先来修复bug</h2><p>bug：用nsct命令运行的应用程序，无论是按Shift+F1还是点击窗口的”x”按钮狗没有反应。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task_run(task, -1, 0);</span><br></pre></td></tr></table></figure></p>
<span id="more"></span>
<h2 id="2-应用程序运行时关闭命令行窗口"><a href="#2-应用程序运行时关闭命令行窗口" class="headerlink" title="2. 应用程序运行时关闭命令行窗口"></a>2. 应用程序运行时关闭命令行窗口</h2><ul>
<li>目标：在应用程序运行的时候无法关闭所对应的命令行窗口。</li>
<li>修改：1.让系统在按下”x”按钮的时候暂且将命令行窗口从画面上隐藏起来。（因为关闭命令行窗口会有延迟）<ol>
<li>当FIFO接收到从console.c发送的“关闭窗口”请求数据时所进行的处理，主要是释放指定的图层。</li>
</ol>
</li>
</ul>
<h2 id="3-保护应用程序-1"><a href="#3-保护应用程序-1" class="headerlink" title="3. 保护应用程序(1)"></a>3. 保护应用程序(1)</h2><p>破坏程序：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[FORMAT &quot;WCOFF&quot;] </span><br><span class="line">[INSTRSET &quot;i486p&quot;] </span><br><span class="line">[BITS 32] </span><br><span class="line">[FILE &quot;crack7.nas&quot;] </span><br><span class="line">    GLOBAL _HariMain </span><br><span class="line">[SECTION .text] </span><br><span class="line">_HariMain: </span><br><span class="line">     MOV AX,1005*8 </span><br><span class="line">     MOV DS,AX </span><br><span class="line">     CMP DWORD [DS:0x0004],&#x27;Hari&#x27; </span><br><span class="line">     JNE fin ; 不是应用程序，因此不执行任何操作</span><br><span class="line">     MOV ECX,[DS:0x0000] ; 读取该应用程序数据段的大小</span><br><span class="line">     MOV AX,2005*8 </span><br><span class="line">     MOV DS,AX </span><br><span class="line">crackloop: ; 整个用123填充</span><br><span class="line">     ADD ECX,-1 </span><br><span class="line">     MOV BYTE [DS:ECX],123 </span><br><span class="line">     CMP ECX,0 </span><br><span class="line">     JNE crackloop </span><br><span class="line">fin: ; 结束</span><br><span class="line">     MOV EDX,4 </span><br><span class="line">     INT 0x40</span><br></pre></td></tr></table></figure></p>
<h2 id="4-保护应用程序-2"><a href="#4-保护应用程序-2" class="headerlink" title="4. 保护应用程序(2)"></a>4. 保护应用程序(2)</h2><p>CPU为我们提供了解决方案，那就是LDT。<br>GDT: global descriptor table<br>LDT: local descriptor table<br>其中GDT中的段设置是供所有任务通用的，而LDT中的段设置只对某个应用程序有效。</p>
<h2 id="5-优化应用程序的大小"><a href="#5-优化应用程序的大小" class="headerlink" title="5. 优化应用程序的大小"></a>5. 优化应用程序的大小</h2><p>那么我们该怎么办呢？我们可以将这些函数做成不同的.obj文件，将_api_putchar等需要用到的函数和_api_openwin等不需要用到的函数分离开。</p>
<h2 id="6-库"><a href="#6-库" class="headerlink" title="6. 库"></a>6. 库</h2><p>如果像上一节那样，把函数拆分开来，并用连接器来进行连接的话，我们需要创建很多很多个.obj文件。当然，如果不拆分函数，而是做成一个大的.obj文件也可以（如同a_nask.obj），但这样的话应用程序没有引用的函数也会被包含进去，生成的应用程序文件就会像之前那样无端增大很多。<br>库：将很多个.obj文件打包成一个文件。<br>要创建一个库，我们首先需要.obj文件作为原材料，除此之外，我们还需要一个叫做库管理器的程序。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GOLIB = $(TOOLPATH)golib00.exe </span><br><span class="line"></span><br><span class="line">apilib.lib : Makefile $(OBJS_API) </span><br><span class="line"> $(GOLIB) $(OBJS_API) out:apilib.lib</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.bim : a.obj apilib.lib Makefile </span><br><span class="line">  $(OBJ2BIM) @$(RULEFILE) out:a.bim map:a.map a.obj apilib.lib</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void api_putchar(int c); </span><br><span class="line">void api_putstr0(char *s); </span><br><span class="line">void api_putstr1(char *s, int l); </span><br><span class="line">void api_end(void); </span><br><span class="line">int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title); </span><br><span class="line">void api_putstrwin(int win, int x, int y, int col, int len, char *str); </span><br><span class="line">void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col); </span><br><span class="line">void api_initmalloc(void); </span><br><span class="line">char *api_malloc(int size); </span><br><span class="line">void api_free(char *addr, int size); </span><br><span class="line">void api_point(int win, int x, int y, int col); </span><br><span class="line">void api_refreshwin(int win, int x0, int y0, int x1, int y1);</span><br><span class="line">void api_linewin(int win, int x0, int y0, int x1, int y1, int col); </span><br><span class="line">void api_closewin(int win); </span><br><span class="line">int api_getkey(int mode); </span><br><span class="line">int api_alloctimer(void); </span><br><span class="line">void api_inittimer(int timer, int data); </span><br><span class="line">void api_settimer(int timer, int time); </span><br><span class="line">void api_freetimer(int timer); </span><br><span class="line">void api_beep(int tone);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;apilib.h&quot;</span><br></pre></td></tr></table></figure>
<h2 id="7-整理make环境"><a href="#7-整理make环境" class="headerlink" title="7. 整理make环境"></a>7. 整理make环境</h2><p>整理操作系统、库、应用程序的文件和代码。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>Git教程——分布式版本控制系统</title>
    <url>/201908/Git%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="一、Git简介"><a href="#一、Git简介" class="headerlink" title="一、Git简介"></a>一、Git简介</h2><p>功能：备份历史版本，合并多人的修改。结束手动管理多个版本的时代。</p>
<h3 id="1-Git的诞生（Linux公司NB就完事儿了）"><a href="#1-Git的诞生（Linux公司NB就完事儿了）" class="headerlink" title="1. Git的诞生（Linux公司NB就完事儿了）"></a>1. Git的诞生（Linux公司NB就完事儿了）</h3><h3 id="2-集中式vs分布式"><a href="#2-集中式vs分布式" class="headerlink" title="2. 集中式vs分布式"></a>2. 集中式vs分布式</h3><ul>
<li><p>集中式版本控制系统<br>版本库存放在==中央服务器==，要先从中央服务器获取最新版本，然后干活，干完活儿了再把自己的改动推送给中央服务器。<br>缺点：必须联网才能工作。</p>
</li>
<li><p>分布式版本控制系统</p>
<p>没有“中央服务器”，每个人的电脑都是一个完整的版本库。两个用户都修改了文件，那么他们只需要把各自的修改推送给对方。</p>
<p>优点：安全性，因为版本库分布在多个电脑上。</p>
<p>分布式版本控制系统通常也有一台充当“中央服务器” 的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
</li>
<li><p>当然，Git的优势不单是不必联网这么简单，Git还有极其强大的分支管理。</p>
</li>
</ul>
<h2 id="3-安装Git"><a href="#3-安装Git" class="headerlink" title="3. 安装Git"></a>3. 安装Git</h2><h2 id="4-创建版本库"><a href="#4-创建版本库" class="headerlink" title="4. 创建版本库"></a>4. 创建版本库</h2><p>版本库又名仓库，英文名repository。这是一个目录，这个目录里多有的文件都可以被Git管理起来。每个文件的修改、删除，Git都能跟踪。</p>
<ol>
<li><p>选择一个合适的地方创建一个空目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir /e/learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd</span><br><span class="line">/e/learngit</span><br></pre></td></tr></table></figure>
<p>mkdir 在指定目录创建文件  </p>
<p>cd 定位  </p>
<p>pwd 显示当前目录</p>
</li>
<li><p>通过git init命令把这个目录变成Git可以管理的仓库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init</span></span><br></pre></td></tr></table></figure>
<p>发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事不要手动修改这个目录里的文件，不然会把Git仓库破坏了。</p>
</li>
</ol>
<h3 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h3><p>所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT, 网页,所有的程序代码等等。  </p>
<p>Word格式是二进制格式，因此版本控制系统是没法跟踪Word文件的改动的。想要使用版本控制系统，就要以纯文本方式编写文件。</p>
<p>请使用UTF-8编码。</p>
<p>千万不要用Windows自带的记事本编辑任何文本文件。请用Notepad++代替记事本。记得把Notepad++的默认编码设置为UTF-8 without BOM。</p>
<ul>
<li><p>编写一个readme.txt文件</p>
</li>
<li><p>将readme.txt保存在learngit目录下</p>
</li>
<li><p>git add添加文件到仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>用命令git commit告诉Git，把文件提交到仓库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;write a readme file&quot;</span><br></pre></td></tr></table></figure>
<p>为什么需要add,commit两步呢？因为commit可以一次提交很多文件，所以可以多次add不同的文件。</p>
</li>
</ul>
<h2 id="二、-时空穿梭机"><a href="#二、-时空穿梭机" class="headerlink" title="二、 时空穿梭机"></a>二、 时空穿梭机</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>掌握工作区的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>
<p>查看修改内容。</p>
<h3 id="1-版本回退"><a href="#1-版本回退" class="headerlink" title="1. 版本回退"></a>1. 版本回退</h3><ul>
<li>Head指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset —hard commit_id</li>
<li>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用git reflog 查看历史命令，以便确定要回到未来的哪个版本。</li>
</ul>
<h3 id="2-工作区和暂存区"><a href="#2-工作区和暂存区" class="headerlink" title="2. 工作区和暂存区"></a>2. 工作区和暂存区</h3><ul>
<li><p>工作区(Workign Directory)</p>
<p>你在电脑里能看到的目录</p>
</li>
<li><p>版本库(Repository)</p>
<p>工作区的隐藏目录.git，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里有很多东西，其中最重要的就是称为stage(或index)的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p>
<p>git add实际上就是把文件修改添加到暂存区。</p>
<p>git commit 就是把暂存区的所有内容提交到当前分支。</p>
</li>
</ul>
<h3 id="3-管理修改"><a href="#3-管理修改" class="headerlink" title="3. 管理修改"></a>3. 管理修改</h3><p>Git跟踪并管理的是修改，而非文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff HEAD -- readme.txt</span><br></pre></td></tr></table></figure>
<p>查看工作区和版本库里面最新版本的区别。</p>
<p>每次修改，如果不用git add到暂存区，那就不会加入到commit中。</p>
<h3 id="4-撤销修改"><a href="#4-撤销修改" class="headerlink" title="4. 撤销修改"></a>4. 撤销修改</h3><ul>
<li><p>撤销工作区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>把readme.txt文件在工作区的修改全部撤销（在没有add之前，在工作区。等效于手动删除。）</p>
<ul>
<li><p>撤销暂存区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br></pre></td></tr></table></figure>
<p>然后再按情况1撤销工作区。</p>
</li>
<li><p>撤销分支</p>
<p>详见“版本退回”那一节</p>
</li>
</ul>
<p>但是如果提交到远程版本库，就完了。。。  </p>
<h3 id="5-删除文件"><a href="#5-删除文件" class="headerlink" title="5. 删除文件"></a>5. 删除文件</h3><ul>
<li>删除分支上的文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">$ git commit</span><br></pre></td></tr></table></figure>
<ul>
<li><p>误删了，要恢复</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>30天自制操作系统（26）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8826%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY26-为窗口移动提速"><a href="#DAY26-为窗口移动提速" class="headerlink" title="DAY26_为窗口移动提速"></a>DAY26_为窗口移动提速</h1><h2 id="1-提高窗口的移动速度-1"><a href="#1-提高窗口的移动速度-1" class="headerlink" title="1. 提高窗口的移动速度(1)"></a>1. 提高窗口的移动速度(1)</h2><p>导致窗口移动速度慢的原因有很多，其中之一就是sheet_refreshmap的速度太慢。这个函数在<br>sheet_slide中被调用了两次，如果能提高它的速度效果应该会很明显。</p>
<h2 id="2-提高窗口的移动速度-2"><a href="#2-提高窗口的移动速度-2" class="headerlink" title="2. 提高窗口的移动速度(2)"></a>2. 提高窗口的移动速度(2)</h2><span id="more"></span>
<p>sheet_refreshmap中有这样一句<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map[vy * ctl-&gt;xsize + vx] = sid;</span><br></pre></td></tr></table></figure></p>
<p>在汇编语言中，如果我们用16位寄存器代替8位寄存器来执行MOV指令的话，相邻的地址中也会同时写入数据，而如果用32位寄存器，仅1条指令就可以同时向相邻的4个地址写入值了。<br>更重要的是，即便是同时写入4个字节的值，只要指定地址是4的整数倍，指令的执行速度就<br>和1个字节的MOV是相同的。也就是说，速度说不定能提高到原来的4倍！</p>
<h2 id="3-提高窗口移动速度-3"><a href="#3-提高窗口移动速度-3" class="headerlink" title="3.提高窗口移动速度(3)"></a>3.提高窗口移动速度(3)</h2><p>于是我们首先想到了sheet_refreshsub，窗口移动的时候也调用了这个函数，因此通过修改它可以提高窗口移动的速度，此外其他一些地方也会调用这个函数。</p>
<h2 id="4-提高窗口移动速度-4"><a href="#4-提高窗口移动速度-4" class="headerlink" title="4.提高窗口移动速度(4)"></a>4.提高窗口移动速度(4)</h2><p>为什么明明已经放开了鼠标键，窗口却还在挪动呢？这是因为伴随图层移动所进行的绘图操<br>作非常消耗时间，导致系统来不及处理FIFO中的鼠标移动数据。那么我们可以在接收到鼠标移动数据后不立即进行绘图操作，但如果一直不绘图的话鼠标和窗口就静止不动了，那不就没意义了吗？我们可以等FIFO为空时再进行绘图操作嘛。</p>
<h2 id="5-启动时只打开一个命令行窗口"><a href="#5-启动时只打开一个命令行窗口" class="headerlink" title="5.启动时只打开一个命令行窗口"></a>5.启动时只打开一个命令行窗口</h2><p>一般都是先打开一个命令行窗口，然后根据需要增加。下面我们就将启动时显示的命令行窗口数量改为一个，并且实现可以随意启动新命令行窗口的功能吧。</p>
<hr>
<p>在Windows中，即便不在命令行中输入命令，只通过鼠标的操作也可以打开新的命令行窗口。不过鼠标点击开始菜单这种方式实现起来太难，我们还是做快捷键吧。</p>
<h2 id="6-增加更多的命令行窗口"><a href="#6-增加更多的命令行窗口" class="headerlink" title="6.增加更多的命令行窗口"></a>6.增加更多的命令行窗口</h2><h2 id="7-关闭命令行窗口-1"><a href="#7-关闭命令行窗口-1" class="headerlink" title="7. 关闭命令行窗口(1)"></a>7. 关闭命令行窗口(1)</h2><p>在Windows的命令行窗口中，输入“exit”命令就可以关闭当前窗口.<br>在关闭一个命令行窗口时系统需要做些什么事呢？首先需要将创建该窗口时所占用的内存<br>空间全部释放出来，然后还需要释放窗口的图层和任务结构。咦，问题来了，在创建任务时我们为命令行窗口准备了专用的栈，却没有将这个栈的地址保存起来，这样的话就无法执行释放操作了。怎么办呢？我们可以在TASK结构中添加一个cons_stack成员，用来保存栈的地址。</p>
<h2 id="8-关闭命令行窗口-2"><a href="#8-关闭命令行窗口-2" class="headerlink" title="8. 关闭命令行窗口(2)"></a>8. 关闭命令行窗口(2)</h2><p>实现用鼠标关闭命令行窗口的功能。当鼠标点击窗口上的“×”按钮时，向命令行窗口任务发送4这个数据，命令行窗口接收到这个数据后则开始执行exit命令的程序。</p>
<h2 id="9-start命令"><a href="#9-start命令" class="headerlink" title="9.start命令"></a>9.start命令</h2><p>Windows的命令行窗口里有一个start命令，它的功能是可以打开一个新的命令行窗口并运行指定的应用程序。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void cmd_start(struct CONSOLE *cons, char *cmdline, int memtotal) </span><br><span class="line">&#123; </span><br><span class="line"> struct SHTCTL *shtctl = (struct SHTCTL *) *((int *) 0x0fe4); </span><br><span class="line"> struct SHEET *sht = open_console(shtctl, memtotal); </span><br><span class="line"> struct FIFO32 *fifo = &amp;sht-&gt;task-&gt;fifo; </span><br><span class="line"> int i; </span><br><span class="line"> sheet_slide(sht, 32, 4); </span><br><span class="line"> sheet_updown(sht, shtctl-&gt;top); </span><br><span class="line"> /*将命令行输入的字符串逐字复制到新的命令行窗口中*/ </span><br><span class="line"> for (i = 6; cmdline[i] != 0; i++) &#123; </span><br><span class="line"> fifo32_put(fifo, cmdline[i] + 256); </span><br><span class="line"> &#125; </span><br><span class="line"> fifo32_put(fifo, 10 + 256); /*回车键*/ </span><br><span class="line"> cons_newline(cons); </span><br><span class="line"> return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="10-ncst命令"><a href="#10-ncst命令" class="headerlink" title="10. ncst命令"></a>10. ncst命令</h2><p>用start命令启动应用程序看起来很不错，但如果运行color这样的程序的话，我们并不希望真的新开一个命令行窗口出来，反倒是没有这个多余的窗口比较好。那么下面我们就来做一个不打开新命令行窗口的start命令吧，给它起个名字，叫做“no console start”，简称ncst命令。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（25）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8825%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY25-增加命令行窗口"><a href="#DAY25-增加命令行窗口" class="headerlink" title="DAY25_增加命令行窗口"></a>DAY25_增加命令行窗口</h1><h2 id="1-蜂鸣器发声"><a href="#1-蜂鸣器发声" class="headerlink" title="1.蜂鸣器发声"></a>1.蜂鸣器发声</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">蜂鸣器发声</span><br><span class="line">EDX=20 </span><br><span class="line">EAX=声音频率（单位是mHz，即毫赫兹）</span><br><span class="line">例如当EAX=4400000时，则发出440Hz的声音</span><br><span class="line">频率设为0则表示停止发声</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax) </span><br><span class="line">&#123; </span><br><span class="line"> （中略）</span><br><span class="line"> &#125; else if (edx == 20) &#123; </span><br><span class="line"> if (eax == 0) &#123; </span><br><span class="line"> i = io_in8(0x61); </span><br><span class="line"> io_out8(0x61, i &amp; 0x0d); </span><br><span class="line"> &#125; else &#123; </span><br><span class="line"> i = 1193180000 / eax; </span><br><span class="line"> io_out8(0x43, 0xb6); </span><br><span class="line"> io_out8(0x42, i &amp; 0xff);</span><br><span class="line"> io_out8(0x42, i &gt;&gt; 8); </span><br><span class="line"> i = io_in8(0x61); </span><br><span class="line"> io_out8(0x61, (i | 0x03) &amp; 0x0f); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-增加更多的颜色-1"><a href="#2-增加更多的颜色-1" class="headerlink" title="2.增加更多的颜色(1)"></a>2.增加更多的颜色(1)</h2><p>修改graphic.c<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void init_palette(void) </span><br><span class="line">&#123; </span><br><span class="line"> static unsigned char table_rgb[16 * 3] = &#123; </span><br><span class="line"> （中略）</span><br><span class="line"> &#125;; </span><br><span class="line"> unsigned char table2[216 * 3]; </span><br><span class="line"> int r, g, b; </span><br><span class="line"> set_palette(0, 15, table_rgb); </span><br><span class="line"> for (b = 0; b &lt; 6; b++) &#123; </span><br><span class="line"> for (g = 0; g &lt; 6; g++) &#123; </span><br><span class="line"> for (r = 0; r &lt; 6; r++) &#123; </span><br><span class="line"> table2[(r + g * 6 + b * 36) * 3 + 0] = r * 51; </span><br><span class="line"> table2[(r + g * 6 + b * 36) * 3 + 1] = g * 51; </span><br><span class="line"> table2[(r + g * 6 + b * 36) * 3 + 2] = b * 51; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> set_palette(16, 231, table2); </span><br><span class="line"> return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-增加更多的颜色-2"><a href="#3-增加更多的颜色-2" class="headerlink" title="3.增加更多的颜色(2)"></a>3.增加更多的颜色(2)</h2><p>我们可以用两种颜色交替排列，看上去就像这两种颜色混合在一起一样，这就是要点。颜色的混合方式我们考虑了下面3种（算上完全不混合的情况，一共有5种）。<br><img src="https://s2.ax1x.com/2019/04/28/El968s.jpg" alt="25.1"></p>
<h2 id="4-窗口初始位置"><a href="#4-窗口初始位置" class="headerlink" title="4. 窗口初始位置"></a>4. 窗口初始位置</h2><p>因此我们希望让窗口总是显示在画面的中央，而且显示窗口时的图层高度也不能总是固定为3，而是要判断当前画面中窗口的数量并自动显示在最上面。</p>
<h2 id="5-增加命令行窗口-1"><a href="#5-增加命令行窗口-1" class="headerlink" title="5. 增加命令行窗口(1)"></a>5. 增加命令行窗口(1)</h2><p>于是，我们这次只修改bootpack.c，将命令行窗口的相关变量（buf_cons、sht_cons、task_cons和cons）各准备2个，分别分给命令行1和命令行2。</p>
<h2 id="6-增加命令行窗口-2"><a href="#6-增加命令行窗口-2" class="headerlink" title="6.增加命令行窗口(2)"></a>6.增加命令行窗口(2)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec);</span><br></pre></td></tr></table></figure>
<p>这里的cons变量是用来判断“要向哪个命令行窗口输出字符”的关键。该变量的值是从内存地址0x0fec读取出来的，而无论从哪个任务读取这个内存地址中的值，得到的肯定都是同一个值，因此不管在哪个窗口中运行a.hrb，都只能在固定的其中一个窗口中显示字符。</p>
<h2 id="7-增加命令行窗口-3"><a href="#7-增加命令行窗口-3" class="headerlink" title="7. 增加命令行窗口(3)"></a>7. 增加命令行窗口(3)</h2><p>问题出在cmd_app身上<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set_segmdesc(gdt + 1003, finfo-&gt;size - 1, (int) p, AR_CODE32_ER + 0x60); </span><br><span class="line"> set_segmdesc(gdt + 1004, segsiz - 1, (int) q, AR_DATA32_RW + 0x60); </span><br><span class="line"> （中略）</span><br><span class="line"> start_app(0x1b, 1003 * 8, esp, 1004 * 8, &amp;(task-&gt;tss.esp0));</span><br><span class="line"> </span><br></pre></td></tr></table></figure></p>
<p>首先，color.hrb在某个窗口中被运行，启动程序一切顺利，然后显示窗口并绘图，接下来等待键盘输入并进入休眠状态。到这里为止没有任何问题。<br>然后我们在另外一个窗口中运行color.hrb，程序也顺利启动了，显示窗口并绘图，随后进入休眠状态。然而在这个时候，问题其实已经发生了。这是怎么回事呢？因为我们为color.hrb准备的1003号代码段和1004号数据段，被color2.hrb所用的段给覆盖掉了。<br>因此，当按下回车键唤醒color.hrb时，就会发生异常情况——明明应该去运行color.hrb的，结果却错误地运行了color2.hrb，这样当然会出错了。</p>
<h2 id="8-增加命令行窗口-4"><a href="#8-增加命令行窗口-4" class="headerlink" title="8.增加命令行窗口(4)"></a>8.增加命令行窗口(4)</h2><p>这次的修改也很简单，首先将原来task_cons[0]的地方改为key_wintask和shttask，这样一来，用键盘强制结束时会以当前输入窗口为对象，而用鼠标点击“×”按钮时会以被点击的窗口为对象。</p>
<h2 id="9-变得更像真正的操作系统-1"><a href="#9-变得更像真正的操作系统-1" class="headerlink" title="9.变得更像真正的操作系统(1)"></a>9.变得更像真正的操作系统(1)</h2><h2 id="10-变得更像真正的操作系统-2"><a href="#10-变得更像真正的操作系统-2" class="headerlink" title="10.变得更像真正的操作系统(2)"></a>10.变得更像真正的操作系统(2)</h2><p>这样肯定不行，因为命令行窗口任务的优先级比较低，只有当bootpack.c的HariMain休眠之后才会运行命令行窗口任务，而如果不运行这个任务的话，FIFO缓冲区就不会被初始化，这就相当于我们在向一个还没初始化的FIFO强行发送数据，于是造成fifo32_put混乱而导致重启。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（24）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8824%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY24-窗口操作"><a href="#DAY24-窗口操作" class="headerlink" title="DAY24_窗口操作"></a>DAY24_窗口操作</h1><h2 id="1-窗口切换-1"><a href="#1-窗口切换-1" class="headerlink" title="1.窗口切换(1)"></a>1.窗口切换(1)</h2><ul>
<li>目标：实现切换窗口顺序得功能。</li>
<li>先实现按下F11时，将最下面得那个窗口放到最上面。</li>
</ul>
<span id="more"></span>
<hr>
<p>修改bootpack.c<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">256</span> + <span class="number">0x57</span> &amp;&amp; shtctl-&gt;top &gt; <span class="number">2</span>) &#123; <span class="comment">/* F11 */</span> </span><br><span class="line">    sheet_updown(shtctl-&gt;sheets[<span class="number">1</span>], shtctl-&gt;top - <span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-窗口切换-2"><a href="#2-窗口切换-2" class="headerlink" title="2. 窗口切换(2)"></a>2. 窗口切换(2)</h2><p>我们需要按照从上到下得顺序，判断鼠标得位置落在哪个图层得范围内，并且还需要确保该位置不是透明色区域。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = shtctl-&gt;top - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123; </span><br><span class="line">     sht = shtctl-&gt;sheets[j]; </span><br><span class="line">     x = mx - sht-&gt;vx0; </span><br><span class="line">     y = my - sht-&gt;vy0; </span><br><span class="line">     <span class="keyword">if</span> (<span class="number">0</span> &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; sht-&gt;bysize) &#123; </span><br><span class="line">         <span class="keyword">if</span> (sht-&gt;buf[y * sht-&gt;bxsize + x] != sht-&gt;col_inv) &#123; </span><br><span class="line">             sheet_updown(sht, shtctl-&gt;top - <span class="number">1</span>); </span><br><span class="line">             <span class="keyword">break</span>; </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-移动窗口"><a href="#3-移动窗口" class="headerlink" title="3.移动窗口"></a>3.移动窗口</h2><p>当鼠标左键点击窗口时，如果点击位置位于窗口的标题栏区域，则进入“窗口移动模式”，使窗口的位置追随鼠标指针的移动，当放开鼠标左键时，退出“窗口移动模式”，返回通常模式。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mmx &lt; <span class="number">0</span>) &#123; </span><br><span class="line">     <span class="comment">/*如果处于通常模式*/</span> </span><br><span class="line">     <span class="comment">/*按照从上到下的顺序寻找鼠标所指向的图层*/</span> </span><br><span class="line">     <span class="keyword">for</span> (j = shtctl-&gt;top - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123; </span><br><span class="line">         sht = shtctl-&gt;sheets[j]; </span><br><span class="line">         x = mx - sht-&gt;vx0; </span><br><span class="line">         y = my - sht-&gt;vy0; </span><br><span class="line">         <span class="keyword">if</span> (<span class="number">0</span> &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; sht-&gt;bysize) &#123; </span><br><span class="line">            <span class="keyword">if</span> (sht-&gt;buf[y * sht-&gt;bxsize + x] != sht-&gt;col_inv) &#123; </span><br><span class="line">                sheet_updown(sht, shtctl-&gt;top - <span class="number">1</span>); </span><br><span class="line">                <span class="keyword">if</span> (<span class="number">3</span> &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize - <span class="number">3</span> &amp;&amp; <span class="number">3</span> &lt;= y &amp;&amp; y &lt; <span class="number">21</span>) &#123; </span><br><span class="line">                    mmx = mx; <span class="comment">/*进入窗口移动模式*/</span> </span><br><span class="line">                    mmy = my; </span><br><span class="line">                &#125; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">     <span class="comment">/*如果处于窗口移动模式*/</span> </span><br><span class="line">     x = mx - mmx; <span class="comment">/*计算鼠标的移动距离*/</span> </span><br><span class="line">     y = my - mmy; </span><br><span class="line">     sheet_slide(sht, sht-&gt;vx0 + x, sht-&gt;vy0 + y); </span><br><span class="line">     mmx = mx; <span class="comment">/*更新为移动后的坐标*/</span> </span><br><span class="line">     mmy = my; </span><br><span class="line">     &#125; </span><br><span class="line">     &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">     <span class="comment">/*没有按下左键*/</span> </span><br><span class="line">    mmx = <span class="number">-1</span>; <span class="comment">/*返回通常模式*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-用鼠标关闭窗口"><a href="#4-用鼠标关闭窗口" class="headerlink" title="4.用鼠标关闭窗口"></a>4.用鼠标关闭窗口</h2><h2 id="5-将输入切换到应用程序窗口"><a href="#5-将输入切换到应用程序窗口" class="headerlink" title="5.将输入切换到应用程序窗口"></a>5.将输入切换到应用程序窗口</h2><p>按下Tab键时将键盘输入切换到当前输入窗口下面一层的窗口中，若当前窗口为最下层，则切换到最上层窗口。</p>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (key_win == sht_win) &#123; <span class="comment">/*发送至任务A */</span> </span><br><span class="line"> <span class="keyword">if</span> (cursor_x &lt; <span class="number">128</span>) &#123; </span><br><span class="line"> <span class="comment">/*显示一个字符并将光标后移一位*/</span> </span><br><span class="line"> s[<span class="number">1</span>] = <span class="number">0</span>; </span><br><span class="line">putfonts8_asc_sht(sht_win, cursor_x, <span class="number">28</span>, COL8_000000, COL8_FFFFFF, s, <span class="number">1</span>); </span><br><span class="line"> cursor_x += <span class="number">8</span>;</span><br><span class="line"> &#125; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; <span class="comment">/*发送至命令行窗口*/</span> </span><br><span class="line"> fifo32_put(&amp;key_win-&gt;task-&gt;fifo, s[<span class="number">0</span>] + <span class="number">256</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (i == <span class="number">256</span> + <span class="number">0x0e</span>) &#123; <span class="comment">/*退格键*/</span> </span><br><span class="line"> <span class="keyword">if</span> (key_win == sht_win) &#123; <span class="comment">/*发送至任务A */</span> </span><br><span class="line"> <span class="keyword">if</span> (cursor_x &gt; <span class="number">8</span>) &#123; </span><br><span class="line"> <span class="comment">/*用空格擦除光标后将光标前移一位*/</span> </span><br><span class="line"> putfonts8_asc_sht(sht_win, cursor_x, <span class="number">28</span>, COL8_000000, COL8_FFFFFF, <span class="string">&quot; </span></span><br><span class="line"><span class="string"> &quot;</span>, <span class="number">1</span>); </span><br><span class="line"> cursor_x -= <span class="number">8</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; <span class="comment">/*发送至命令行窗口*/</span> </span><br><span class="line"> fifo32_put(&amp;key_win-&gt;task-&gt;fifo, <span class="number">8</span> + <span class="number">256</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (i == <span class="number">256</span> + <span class="number">0x1c</span>) &#123; <span class="comment">/*回车键*/</span> </span><br><span class="line"> <span class="keyword">if</span> (key_win != sht_win) &#123; <span class="comment">/*发送至命令行窗口*/</span> </span><br><span class="line"> fifo32_put(&amp;key_win-&gt;task-&gt;fifo, <span class="number">10</span> + <span class="number">256</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (i == <span class="number">256</span> + <span class="number">0x0f</span>) &#123; <span class="comment">/* Tab键*/</span> </span><br><span class="line"> cursor_c = keywin_off(key_win, sht_win, cursor_c, cursor_x); </span><br><span class="line"> j = key_win-&gt;height - <span class="number">1</span>; </span><br><span class="line"> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123; </span><br><span class="line"> j = shtctl-&gt;top - <span class="number">1</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> key_win = shtctl-&gt;sheets[j]; </span><br><span class="line"><span class="comment">/*到此结束*/</span> cursor_c = keywin_on(key_win, sht_win, cursor_c); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-用鼠标切换输入窗口"><a href="#6-用鼠标切换输入窗口" class="headerlink" title="6.用鼠标切换输入窗口"></a>6.用鼠标切换输入窗口</h2><p>目标：让操作系统可以通过简单的点击就能完成输入切换。  </p>
<h2 id="7-定时器API"><a href="#7-定时器API" class="headerlink" title="7.定时器API"></a>7.定时器API</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取定时器（alloc）</span><br><span class="line">EDX=16 </span><br><span class="line">EAX=定时器句柄（由操作系统返回）</span><br><span class="line"></span><br><span class="line">设置定时器的发送数据（init）</span><br><span class="line">EDX=17 </span><br><span class="line">EBX=定时器句柄</span><br><span class="line">EAX=数据</span><br><span class="line"></span><br><span class="line">定时器时间设定（set）</span><br><span class="line">EDX=18 </span><br><span class="line">EBX=定时器句柄</span><br><span class="line">EAX=时间</span><br><span class="line"></span><br><span class="line">释放定时器（free）</span><br><span class="line">EDX=19 </span><br><span class="line">EBX=定时器句柄</span><br></pre></td></tr></table></figure>
<h2 id="8-取消定时器"><a href="#8-取消定时器" class="headerlink" title="8.取消定时器"></a>8.取消定时器</h2><p>问题：<br>应用程序设置了一个1秒的定时器，当定时器到达指定时间时会产生超时，并向任务发送事先设置的数据。问题是，如果这时应用程序已经结束了，定时器的数据就会被发送到命令行窗口，而命令行窗口肯定是一头雾水。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>「迁移学习简明手册」学习笔记（1）</title>
    <url>/201908/%E3%80%8C%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C%E3%80%8D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h1 id="1-迁移学习的基本概念"><a href="#1-迁移学习的基本概念" class="headerlink" title="1.迁移学习的基本概念"></a>1.迁移学习的基本概念</h1><h2 id="1-2-迁移学习基本概念"><a href="#1-2-迁移学习基本概念" class="headerlink" title="1.2 迁移学习基本概念"></a>1.2 迁移学习基本概念</h2><ul>
<li>核心问题：找到新问题和原问题之间的相似性，才可以顺利地实现知识的迁移。</li>
<li>定义：迁移学习，是指利用数据、任务、或模型之间的相似性，将在旧领域学习过的模型，应用在新领域的一种学习过程。</li>
</ul>
<h2 id="1-3-为什么要迁移学习"><a href="#1-3-为什么要迁移学习" class="headerlink" title="1.3 为什么要迁移学习"></a>1.3 为什么要迁移学习</h2><p>这个表格包括了1.3的所有内容，可以只看这个表格：</p>
<p><img src="https://s2.ax1x.com/2019/04/24/EVv4IS.jpg" alt="1.3"></p>
<span id="more"></span>
<ul>
<li>1.大数据与少标注之间的矛盾</li>
<li>2.大数据与弱计算之间的矛盾</li>
<li>3.普适化模型与个性化需求之间的矛盾<br>机器学习的目标是构建一个尽可能通用的模型，而人们的个性化需求五花八门，短期内根本无法用一个通用的模型去满足。</li>
<li>4.特定应用的需求<br>推荐系统的冷启动问题：一个新的推荐系统，没有足够的用户数据，如何进行精准的推荐；一个崭新的图片标注系统，没有足够的标签，如何进行精准的服务？</li>
</ul>
<p><strong>针对以上问题，迁移学习是如何解决的呢？</strong></p>
<ul>
<li>1.迁移数据标注</li>
<li>2.模型迁移（将那些大公司在大数据上训练好的模型，迁移到我们的任务中）</li>
<li>3.自适应学习（对普适化模型进行灵活的调整，以便完成我们的任务）</li>
<li>4.相似领域知识迁移</li>
</ul>
<h2 id="1-4-与已有概念的区别和联系"><a href="#1-4-与已有概念的区别和联系" class="headerlink" title="1.4 与已有概念的区别和联系"></a>1.4 与已有概念的区别和联系</h2><h3 id="1-迁移学习和机器学习"><a href="#1-迁移学习和机器学习" class="headerlink" title="1.迁移学习和机器学习"></a>1.迁移学习和机器学习</h3><p>迁移学习属于机器学习的一类<br><img src="https://s2.ax1x.com/2019/04/24/EVxMQA.jpg" alt="2"></p>
<h3 id="2-迁移学习和多任务学习"><a href="#2-迁移学习和多任务学习" class="headerlink" title="2.迁移学习和多任务学习"></a>2.迁移学习和多任务学习</h3><p>多任务学习指多个相关的任务一起协同学习。</p>
<h3 id="3-迁移学习和终身学习"><a href="#3-迁移学习和终身学习" class="headerlink" title="3.迁移学习和终身学习"></a>3.迁移学习和终身学习</h3><p>终身学习是在已经学习好若干个任务之后，面对新的任务可以继续学习而不遗忘之前学习的任务。</p>
<h3 id="4-迁移学习和领域自适应"><a href="#4-迁移学习和领域自适应" class="headerlink" title="4.迁移学习和领域自适应"></a>4.迁移学习和领域自适应</h3><h3 id="5-迁移学习和增量学习"><a href="#5-迁移学习和增量学习" class="headerlink" title="5.迁移学习和增量学习"></a>5.迁移学习和增量学习</h3><p>增量学习侧重解决数据不断到来，模型不断更新的问题。</p>
<h3 id="6-迁移学习和自我学习"><a href="#6-迁移学习和自我学习" class="headerlink" title="6.迁移学习和自我学习"></a>6.迁移学习和自我学习</h3><p>自我学习指的是模型不断地从自身处进行更新</p>
<h3 id="7-迁移学习和协方差漂移"><a href="#7-迁移学习和协方差漂移" class="headerlink" title="7.迁移学习和协方差漂移"></a>7.迁移学习和协方差漂移</h3><p>协方差漂移指数据地边缘概率分布发生变化</p>
<h2 id="1-5-负迁移（“东施效颦”）"><a href="#1-5-负迁移（“东施效颦”）" class="headerlink" title="1.5 负迁移（“东施效颦”）"></a>1.5 负迁移（“东施效颦”）</h2><p>如果两个领域之间不存在相似性，或者基本不相似，那么就会大大损害迁移学习地效果。这时候，我们可以说出现了==负迁移(Negative Transfer)==  </p>
<ul>
<li>定义：在源域上学习到的知识，对于目标域上的学习产生负面作用。</li>
<li>产生负迁移的原因：<ul>
<li>数据问题</li>
<li>方法问题：源域和目标域是相似的，但是迁移学习的方法不够好。</li>
</ul>
</li>
<li>传递迁移学习：传统迁移学习好比是踩着一块石头过河，传递迁移学习就是踩着连续的两块石头。当两个领域不相似时，传递迁移学习却可以利用处于这两个领域之间的若干领域，将知识传递式的完成迁移。</li>
</ul>
<h1 id="2-迁移学习的研究领域"><a href="#2-迁移学习的研究领域" class="headerlink" title="2.迁移学习的研究领域"></a>2.迁移学习的研究领域</h1><p>机器学习可分为有监督、半监督和无监督的机器学习三大类。迁移学习也可以进行这样的分类。<br><img src="https://s2.ax1x.com/2019/04/24/EZVW1P.jpg" alt="t8"></p>
<p>分类的四个准则：按目标域有无标签分、按学习方法分、按特征分、按在线形式分</p>
<h2 id="2-1-按目标域标签分"><a href="#2-1-按目标域标签分" class="headerlink" title="2.1 按目标域标签分"></a>2.1 按目标域标签分</h2><ul>
<li>1.监督迁移学习 Supervised Transfer Learning</li>
<li>2.半监督迁移学习 Semi-Supervised Transfer Learning</li>
<li>3.无监督迁移学习 Unsupervised Transfer Learning  </li>
</ul>
<p>显然，少标签或无标签的问题（半监督和无监督迁移学习）<br>，是研究的热点和难点。</p>
<h2 id="2-2-按学习方法分类"><a href="#2-2-按学习方法分类" class="headerlink" title="2.2 按学习方法分类"></a>2.2 按学习方法分类</h2><ul>
<li>1.基于样本的迁移学习方法(Instance based Transfer Learning)<br>通过权重重用，对源域和目标域的样例进行迁移</li>
<li>2.基于==特征==的迁移学习方法(Feature based Transfer Leaning)<br>意思是说，假设源域和目标域的特征<br>原来不在一个空间，或者说它们在原来那个空间上不相似，那我们就想办法把它们变换到一个空间里面，那这些特征不就相似了？</li>
<li>3.基于==模型==的迁移学习方法(Model based Transfer Leaning)<br>构建参数共享的模型</li>
<li>4.基于关系的迁移学习方法(Relation based Transfer Learning)<br>挖掘和利用关系进行类比迁移</li>
</ul>
<h2 id="2-3-按特征分类"><a href="#2-3-按特征分类" class="headerlink" title="2.3 按特征分类"></a>2.3 按特征分类</h2><ul>
<li>1.同构迁移学习(Homogeneous Transfer Learning)</li>
<li>2.异构迁移学习(Heterogeneous Transfer Learning)<br>如果特征语义和维度都相同，那么就是同构；反之，如果特征完全不相同，那么就是异构。举个例子来说，不同图片的迁移，就可以认为是同构；而图片到文本的迁移，则是异构的。</li>
</ul>
<h2 id="2-4-按离线与在线形式分"><a href="#2-4-按离线与在线形式分" class="headerlink" title="2.4 按离线与在线形式分"></a>2.4 按离线与在线形式分</h2><ul>
<li>1.离线迁移学习(Offline Transfer Learning)</li>
<li>2.在线迁移学习(Online Transfer Learning)</li>
</ul>
<p>目前，绝大多数的迁移学习方法，都采用了离线方式。即，源域和目标域均是给定的，<br>迁移一次即可。这种方式的缺点是显而易见的：算法无法对新加入的数据进行学习，模型也无法得到更新。与之相对的，是在线的方式。即随着数据的动态加入，迁移学习算法也可以不断地更新。</p>
<h1 id="3-迁移学习的应用"><a href="#3-迁移学习的应用" class="headerlink" title="3.迁移学习的应用"></a>3.迁移学习的应用</h1><p>计算机视觉、文本分类、行为识别、自然语言处理、室内定位、视频监控、舆情分析、人机交互</p>
<h2 id="3-1-计算机视觉"><a href="#3-1-计算机视觉" class="headerlink" title="3.1 计算机视觉"></a>3.1 计算机视觉</h2><p>同一类图片，不同的拍摄角度、不同光照、不同背景，都会造成特征分布发生改变。因此，使用迁移学习构建跨领域的鲁棒分类器是十分重要的。</p>
<h2 id="3-2-文本分类"><a href="#3-2-文本分类" class="headerlink" title="3.2 文本分类"></a>3.2 文本分类</h2><p>由于文本数据有其领域特殊性，因此，在一个领域上训练的分类器，不能直接拿来作用到另一个领域上。这就需要用到迁移学习。例如，在电影评论文本数据集上训练好的分类器，不能直接用于图书评论的预测。这就需要进行迁移学习。</p>
<h2 id="3-3-时间序列"><a href="#3-3-时间序列" class="headerlink" title="3.3 时间序列"></a>3.3 时间序列</h2><p>行为识别 (Activity Recognition) 主要通过佩戴在用户身体上的传感器，研究用户的行<br>为。行为数据是一种时间序列数据。不同用户、不同环境、不同位置、不同设备，都会导致时间序列数据的分布发生变化。</p>
<h2 id="3-4-医疗健康"><a href="#3-4-医疗健康" class="headerlink" title="3.4 医疗健康"></a>3.4 医疗健康</h2><p>医疗领域研究的难点问题是，无法获取足够有效的医疗数据。</p>
<h1 id="4-基础知识"><a href="#4-基础知识" class="headerlink" title="4.基础知识"></a>4.基础知识</h1><h2 id="4-1迁移学习的问题形式化"><a href="#4-1迁移学习的问题形式化" class="headerlink" title="4.1迁移学习的问题形式化"></a>4.1迁移学习的问题形式化</h2><h3 id="4-1-1-领域"><a href="#4-1-1-领域" class="headerlink" title="4.1.1 领域"></a>4.1.1 领域</h3><p>领域(Domain)是进行学习的主体。领域主要由两部分构成：数据和生成这些数据的概率分布。源领域：有知识、有大量数据标注的领域；目标域：我们最终要赋予知识、赋予标注的对象。</p>
<h3 id="4-1-2-任务"><a href="#4-1-2-任务" class="headerlink" title="4.1.2 任务"></a>4.1.2 任务</h3><p>任务(Task)：学习的目标。由两部分组成：标签和标签对应的函数。</p>
<h3 id="4-1-3-迁移学习"><a href="#4-1-3-迁移学习" class="headerlink" title="4.1.3 迁移学习"></a>4.1.3 迁移学习</h3><p>领域自适应(Domain Adaptation)</p>
<h2 id="4-2-总体思路"><a href="#4-2-总体思路" class="headerlink" title="4.2 总体思路"></a>4.2 总体思路</h2><p>开发算法来最大限度地利用有标注地领域地知识，来辅助目标领域的知识获取和学习。<br>找到相似性 (不变量)，是进行迁移学习的核心。<br>度量工作的目标有两点：</p>
<ul>
<li>一是很好地度量两个领域的相似性，不仅定性地告诉我们它们是否相似，更定量地给<br>出相似程度。</li>
<li>二是以度量为准则，通过我们所要采用的学习手段，增大两个领域之间的相似性，从而完成迁移学习。</li>
</ul>
<p>一句话总结： ==相似性是核心，度量准则是重要手段。==</p>
<h2 id="4-3-度量准则"><a href="#4-3-度量准则" class="headerlink" title="4.3 度量准则"></a>4.3 度量准则</h2><p>核心：衡量两个数据域的差异。</p>
<h3 id="4-3-1-常见的几种距离"><a href="#4-3-1-常见的几种距离" class="headerlink" title="4.3.1 常见的几种距离"></a>4.3.1 常见的几种距离</h3><ul>
<li>1.欧式距离</li>
<li>2.闵科夫斯基距离</li>
<li>3.马氏距离</li>
</ul>
<h3 id="4-3-2-相似度"><a href="#4-3-2-相似度" class="headerlink" title="4.3.2 相似度"></a>4.3.2 相似度</h3><ul>
<li>1.余弦相似度</li>
<li>2.互信息</li>
<li>3.皮尔逊相关系数</li>
<li>4.Jaccard相关系数</li>
</ul>
<h3 id="4-3-3-KL散度与JS距离"><a href="#4-3-3-KL散度与JS距离" class="headerlink" title="4.3.3 KL散度与JS距离"></a>4.3.3 KL散度与JS距离</h3><h3 id="4-3-4-最大均值差异MMD-Maximun-mean-discrepancy"><a href="#4-3-4-最大均值差异MMD-Maximun-mean-discrepancy" class="headerlink" title="4.3.4 最大均值差异MMD(Maximun mean discrepancy)"></a>4.3.4 最大均值差异MMD(Maximun mean discrepancy)</h3><h3 id="4-3-5-Principle-Angle"><a href="#4-3-5-Principle-Angle" class="headerlink" title="4.3.5 Principle Angle"></a>4.3.5 Principle Angle</h3><h3 id="4-3-6-A-distance"><a href="#4-3-6-A-distance" class="headerlink" title="4.3.6 A-distance"></a>4.3.6 A-distance</h3><h3 id="4-3-7-Hilbert-Schmidt-Independence-Criterion"><a href="#4-3-7-Hilbert-Schmidt-Independence-Criterion" class="headerlink" title="4.3.7 Hilbert-Schmidt Independence Criterion"></a>4.3.7 Hilbert-Schmidt Independence Criterion</h3><h3 id="4-3-8-Wasserstein-Distance"><a href="#4-3-8-Wasserstein-Distance" class="headerlink" title="4.3.8 Wasserstein Distance"></a>4.3.8 Wasserstein Distance</h3><h2 id="4-4-迁移学习的理论保证"><a href="#4-4-迁移学习的理论保证" class="headerlink" title="4.4 迁移学习的理论保证"></a>4.4 迁移学习的理论保证</h2><p>这一部分有些难度。当自己提出的算法需要理论证明时，可以借鉴这一部分。</p>
<h1 id="5-迁移学习的基本方法"><a href="#5-迁移学习的基本方法" class="headerlink" title="5.迁移学习的基本方法"></a>5.迁移学习的基本方法</h1><p>四种基本方法：基于样本的迁移，基于模型的迁移，基于特征的迁移，以及基于关系的迁移。</p>
<h2 id="5-1-基于样本的迁移学习方法-Instance-based-Transfer-Learning"><a href="#5-1-基于样本的迁移学习方法-Instance-based-Transfer-Learning" class="headerlink" title="5.1 基于样本的迁移学习方法(Instance based Transfer Learning)"></a>5.1 基于样本的迁移学习方法(Instance based Transfer Learning)</h2><p><img src="https://s2.ax1x.com/2019/04/25/Ee9XWT.jpg" alt="t8"><br>如图，在迁移时，为了最大限度地和目标域相似，我们可以人为地提高源域中属于狗这个类别地样本权重。<br>优缺点：虽然实例权重法具有较好的理论支撑、容易推导泛化误差上界，但这类方法通常只在领域间分布差异较小时有效，因此对自然语言处理、计算机视觉等任务效果并不理想。</p>
<h2 id="5-2-基于特征迁移"><a href="#5-2-基于特征迁移" class="headerlink" title="5.2 基于特征迁移"></a>5.2 基于特征迁移</h2><p>通过特征变换的方式互相迁移，来减少源域和目标域之间地差距；或者将源域和目标域的数据特征变换到统一特征空间中，然后利用传统的机器学习方法进行分类识别。根据特征的同构和异构性，又可以分为同构和异构迁移学习。<br><img src="https://s2.ax1x.com/2019/04/25/EePN8K.jpg" alt="t15"><br>这类方法通常假设源域和目标域间有一些交叉的特征。</p>
<h2 id="5-3-基于模型学习"><a href="#5-3-基于模型学习" class="headerlink" title="5.3 基于模型学习"></a>5.3 基于模型学习</h2><p>基于模型的迁移方法 (Parameter/Model based Transfer Learning) 是指从源域和目标域中找到他们之间共享的参数信息，以实现迁移的方法。这种迁移方式要求的假设条件是：源域中的数据与目标域中的数据可以共享一些模型的参数。<br><img src="https://s2.ax1x.com/2019/04/25/EeFT3V.jpg" alt="t16"></p>
<h2 id="5-4-基于关系迁移"><a href="#5-4-基于关系迁移" class="headerlink" title="5.4 基于关系迁移"></a>5.4 基于关系迁移</h2><p>这种方法比较关注源域和目标域的样本之间的关系。<br>这些文章都借助于马尔科夫逻辑网络 (Markov Logic Net)来挖掘不同领域之间的关系相似性。<br>我们将重点讨论基于特征和基于模型的迁移学习方法，这也是目前绝大多数研究工作的热点。<br><img src="https://s2.ax1x.com/2019/04/25/EekS9x.jpg" alt="t17"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>迁移学习</tag>
      </tags>
  </entry>
  <entry>
    <title>「第一行代码」学习笔记（2）</title>
    <url>/201904/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Chap-2-先从看得到的入手——探究活动"><a href="#Chap-2-先从看得到的入手——探究活动" class="headerlink" title="Chap.2 先从看得到的入手——探究活动"></a>Chap.2 先从看得到的入手——探究活动</h2><h3 id="2-1-活动的定义"><a href="#2-1-活动的定义" class="headerlink" title="2.1 活动的定义"></a>2.1 活动的定义</h3><p><font color="FF0000">活动</font>是一种可以包含用户界面的组件，主要用于和用户交互。</p>
<span id="more"></span>
<h3 id="2-2-活动的基本用法"><a href="#2-2-活动的基本用法" class="headerlink" title="2.2 活动的基本用法"></a>2.2 活动的基本用法</h3><p>下面我们尝试自己创建一个项目。<br>Android Studio在工作区间只允许打开一个项目。 </p>
<h3 id="2-2-1-手动创建活动"><a href="#2-2-1-手动创建活动" class="headerlink" title="2.2.1 手动创建活动"></a>2.2.1 手动创建活动</h3><p>在java-com.example.activitytest文件夹下创建FirstActivity活动</p>
<h3 id="2-2-2-创建和加载布局"><a href="#2-2-2-创建和加载布局" class="headerlink" title="2.2.2 创建和加载布局"></a>2.2.2 创建和加载布局</h3><p>Android的程序设计讲究逻辑和视图分离，最好每一个活动都能对应有一个布局。</p>
<ul>
<li>创建布局</li>
<li>在活动中加载这个布局</li>
</ul>
<h3 id="2-2-3-在AndroidManifest文件中注册"><a href="#2-2-3-在AndroidManifest文件中注册" class="headerlink" title="2.2.3 在AndroidManifest文件中注册"></a>2.2.3 在AndroidManifest文件中注册</h3><ul>
<li>（Android Studio已经帮我们注册好了）</li>
<li>配置主活动<br>如果应用程序没有声明任何活动作为主活动，这个程序仍然可以正常安装，只是无法在启动器中看到或打开这个文件。这种程序一般都是作为第三方服务供其他应用程序在内部进行调用的，如支付宝快捷支付服务。</li>
</ul>
<h3 id="2-2-4-在活动中使用Toast"><a href="#2-2-4-在活动中使用Toast" class="headerlink" title="2.2.4 在活动中使用Toast"></a>2.2.4 在活动中使用Toast</h3><p>Toast是Android系统提供的一种非常好的提醒方式，在程序中可以使用它将一些短小的信息通知给用户，这些信息会在一段时间后自动消失，并且不会占用任何屏幕空间。</p>
<ul>
<li>定义弹出Toast的触发点<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.first_layout);</span><br><span class="line">        <span class="type">Button</span> <span class="variable">button1</span> <span class="operator">=</span> (Button) findViewById(R.id.button_1);</span><br><span class="line">        button1.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                Toast.makeText(FirstActivity.<span class="built_in">this</span>,<span class="string">&quot;You clicked Botton 1&quot;</span>,</span><br><span class="line">                        Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-2-5-在活动中使用Menu"><a href="#2-2-5-在活动中使用Menu" class="headerlink" title="2.2.5 在活动中使用Menu"></a>2.2.5 在活动中使用Menu</h3><h3 id="2-2-6-销毁一个活动"><a href="#2-2-6-销毁一个活动" class="headerlink" title="2.2.6 销毁一个活动"></a>2.2.6 销毁一个活动</h3><h2 id="2-3-使用Intent在活动之间穿梭"><a href="#2-3-使用Intent在活动之间穿梭" class="headerlink" title="2.3 使用Intent在活动之间穿梭"></a>2.3 使用Intent在活动之间穿梭</h2><p>在启动器中点击应用的图标只会进入到该应用的主活动，怎么才能由主活动跳转到其他活动呢？</p>
<h3 id="2-3-1-使用显式Intent"><a href="#2-3-1-使用显式Intent" class="headerlink" title="2.3.1 使用显式Intent"></a>2.3.1 使用显式Intent</h3><p>Intent的“意图”非常明显，因此我们称之为显式Intent。</p>
<h3 id="2-3-2-使用隐式Intent"><a href="#2-3-2-使用隐式Intent" class="headerlink" title="2.3.2 使用隐式Intent"></a>2.3.2 使用隐式Intent</h3><p>不指明我们要启动哪个程序，而是指定了一系列更为抽象的action和category等信息，然后交由系统去分析这个Intent，并帮助我们找出合适的活动去启动。</p>
<p>只有<action>和<category>中的内容同时能够匹配上Intent中指定的action和category时，这个活动才能响应该Intent。</p>
<p><a href="https://www.jianshu.com/p/5bf828806125">https://www.jianshu.com/p/5bf828806125</a><br>下面会有一个链接，让你装缺少的包</p>
<p>Cannot resolve symbol ‘R’(XXX)<br>代码有问题，相应的名称没有定义。</p>
<ul>
<li>修改代码</li>
<li>或者Alt+Enter</li>
</ul>
<p><a href="https://www.jianshu.com/p/93678f8b3421">https://www.jianshu.com/p/93678f8b3421</a></p>
<p>Intent是程序各组件之间进行交互的一种重要方式，可以指明当前组件想要执行的动作，可以在不同的组件之间传递数据。Intent一般可用于启动活动、启动服务以及发送广播等场景。</p>
<p>4.2</p>
<h3 id="2-2-3-更多隐式Intent的用法"><a href="#2-2-3-更多隐式Intent的用法" class="headerlink" title="2.2.3 更多隐式Intent的用法"></a>2.2.3 更多隐式Intent的用法</h3><ul>
<li>使用隐式Intent可以启动其他程序的活动</li>
<li>intent.setData()，接收一个Uri对象，主要用于指定当前Intent正在操作的数据，而这些数据通常是以字符串的形式传入到Uri.parse()方法中解析产生的。</li>
<li>我们自己建立一个活动，让它也能响应网页的Intent。</li>
<li>AndroidMainfest.xml文件报Activity supporting ACTION_VIEW is not set as BROWSABLE的解决方案</li>
<li><a href="https://blog.csdn.net/wqh0830/article/details/88528784">https://blog.csdn.net/wqh0830/article/details/88528784</a></li>
</ul>
<h3 id="2-3-4-向下一个活动传递数据"><a href="#2-3-4-向下一个活动传递数据" class="headerlink" title="2.3.4 向下一个活动传递数据"></a>2.3.4 向下一个活动传递数据</h3><ul>
<li>intent提供了一系列putExtra()方法的重载，可以把我们想要传递的数据暂存在Intent中。启动另一个活动后，只需要再把数据从Intent取出来就可以了。</li>
<li>Activity中还有一个startActivityForResult()方法，在活动销毁时，能够返回结果给上一个活动</li>
<li>重写父类方法快捷键：CTRL+o</li>
<li>我们使用startActivityForResult()来启动SecondActivity的，在SecondActivity被销毁之后回回调上一个活动的onActivityResult()方法</li>
</ul>
<h3 id="2-4-活动的生命周期"><a href="#2-4-活动的生命周期" class="headerlink" title="2.4 活动的生命周期"></a>2.4 活动的生命周期</h3><h4 id="2-4-1-返回栈"><a href="#2-4-1-返回栈" class="headerlink" title="2.4.1 返回栈"></a>2.4.1 返回栈</h4><p>Android的活动是可以重叠的。<br>Android是使用任务(Task)来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈(Back Stsck)</p>
<h4 id="2-4-2-活动状态"><a href="#2-4-2-活动状态" class="headerlink" title="2.4.2 活动状态"></a>2.4.2 活动状态</h4><p>每个活动在其生命周期最多可能会有4种状态。</p>
<ul>
<li>01.运行状态<br>位于返回栈栈顶，如果强行回收会影响用户体验</li>
<li>02.暂停状态<br>仍然可见，但是不再处于栈顶的位置。（因为不是所有活动都会占满整个屏幕。）</li>
<li>03.停止状态</li>
<li>04.销毁状态</li>
</ul>
<h4 id="2-4-3-活动的生存期"><a href="#2-4-3-活动的生存期" class="headerlink" title="2.4.3 活动的生存期"></a>2.4.3 活动的生存期</h4><p>Activity类定义了7个回调方法，覆盖了生命活动的每一个周期。（**重要）</p>
<ul>
<li>onCreate()<br>在活动第一次被创建时调用。在这里完成活动的初始化操作，比如加载布局、绑定事件。</li>
<li>onStart()<br>由活动不可见变为可见的时候调用。</li>
<li>onResume()<br>准备好和用户进行交互时进行调用。此时活动必须位于栈顶且处于运行状态。</li>
<li>onPause()<br>系统准备去启动或者恢复另一个活动时进行调用。在这个方法中，我们将一些消耗CPU的资源释放掉，以及保存一些关键数据。</li>
<li>onStop()<br>在活动完全不可见时进行调用</li>
<li>onDestroy()<br>在活动被销毁之前调用，之后的活动状态变为销毁状态。</li>
<li>onRestart()<br>在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。</li>
</ul>
<p>==以上的7个方法除了onRestart()之外，其他都是两两相对的，从而又可以将活动分为3中生存期。==</p>
<ul>
<li><p>完整生存期<br>活动在onCreate()方法和onDestroy()方法之间所经历的就是完整的生存期。</p>
</li>
<li><p>可见生存期<br>活动在onStart()和onStop()之间经历的就是生存期。</p>
</li>
<li><p>前台生存期<br>onResume()和onPause()方法之间所经历的就是前台生存期。</p>
</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/04/16/Avtkp8.jpg" alt="2.1"></p>
<h4 id="2-4-4-体验活动的生命周期"><a href="#2-4-4-体验活动的生命周期" class="headerlink" title="2.4.4 体验活动的生命周期"></a>2.4.4 体验活动的生命周期</h4><h4 id="2-4-5-活动被回收了怎么办"><a href="#2-4-5-活动被回收了怎么办" class="headerlink" title="2.4.5 活动被回收了怎么办"></a>2.4.5 活动被回收了怎么办</h4><p>如果系统内存不足，后台的程序就会关掉，这时会调用onCreate()而不再是onRestart()。<br>但是存在一个问题：我们的应用程序可能会存在临时数据和状态。</p>
<h3 id="2-5-活动的启动模式"><a href="#2-5-活动的启动模式" class="headerlink" title="2.5 活动的启动模式"></a>2.5 活动的启动模式</h3><p>在活动中我们应该根据特定的需求为每个活动指定恰当的启动模式。启动模式一共有4种，分别是standard、singleTop、singleTask和singleInstance。</p>
<h4 id="2-5-1-standard"><a href="#2-5-1-standard" class="headerlink" title="2.5.1 standard"></a>2.5.1 standard</h4><p>standard每启动一个新的活动，就会在返回栈中入栈，系统不在乎它是否已经在返回栈中存在，每次启动都会创建一个新的实例。</p>
<p><img src="https://s2.ax1x.com/2019/04/23/EAa8fK.jpg" alt="standard"></p>
<h4 id="2-5-2-singleTop"><a href="#2-5-2-singleTop" class="headerlink" title="2.5.2 singleTop"></a>2.5.2 singleTop</h4><p>当活动的启动模式指定为singleTop时，在启动活动时如果发现返回栈的栈顶已经是该活动，则可以直接使用它，不用创建新的活动实例。<br>不过当它并未处于栈顶位置时，这时再启动，还是会创建新的实例。<br><img src="https://s2.ax1x.com/2019/04/23/EAa3Y6.jpg" alt="singleTop"></p>
<h4 id="2-5-3-singleTask"><a href="#2-5-3-singleTask" class="headerlink" title="2.5.3 singleTask"></a>2.5.3 singleTask</h4><p>每次启动该活动时系统会先在返回栈中检查是否存在该活动的实例，如果发现已经存在，则直接使用该实例，并把这个活动之上的活动全部出栈，如果没有发现就会创建一个新的活动实例。<br><img src="https://s2.ax1x.com/2019/04/23/EAaJSO.jpg" alt="singleTask"></p>
<h4 id="2-5-4-singleInstance"><a href="#2-5-4-singleInstance" class="headerlink" title="2.5.4 singleInstance"></a>2.5.4 singleInstance</h4><p>启动一个新的返回栈来管理这个活动。<br>这样做有什么意义：前面三种活动的启动方式，都是把活动放在自己程序的返回栈里。如果有两个活动想要用同一个活动，那么必然要创建两个活动实例。而singleInstance解决了这个问题，用一个专门的返回栈管理这个活动。<br><img src="https://s2.ax1x.com/2019/04/23/EAaYlD.jpg" alt="singleInstance"></p>
<h3 id="2-6-活动的最佳实践"><a href="#2-6-活动的最佳实践" class="headerlink" title="2.6 活动的最佳实践"></a>2.6 活动的最佳实践</h3><h4 id="2-6-1-知晓当前是在哪一个活动"><a href="#2-6-1-知晓当前是在哪一个活动" class="headerlink" title="2.6.1 知晓当前是在哪一个活动"></a>2.6.1 知晓当前是在哪一个活动</h4><p>在AppCompatActivity下继承一个BaseActivity打印当前活动，然后让其他活动继承BaseActivity。</p>
<h4 id="2-6-2-随时随地退出程序"><a href="#2-6-2-随时随地退出程序" class="headerlink" title="2.6.2 随时随地退出程序"></a>2.6.2 随时随地退出程序</h4><p>新建ActivityCollector类来作为活动管理器addActivity、removeActivity、finishAll<br>修改BaseActivity，在其中添加ActivityCollector中的方法。</p>
<h4 id="2-6-3-启动活动的最佳写法"><a href="#2-6-3-启动活动的最佳写法" class="headerlink" title="2.6.3 启动活动的最佳写法"></a>2.6.3 启动活动的最佳写法</h4>]]></content>
      <categories>
        <category>安卓开发</category>
      </categories>
  </entry>
  <entry>
    <title>「第一行代码」学习笔记（1）</title>
    <url>/201904/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Chap1-开始启程——你的第一行Android代码"><a href="#Chap1-开始启程——你的第一行Android代码" class="headerlink" title="Chap1 开始启程——你的第一行Android代码"></a>Chap1 开始启程——你的第一行Android代码</h2><h3 id="1-1了解全貌——Android王国简介"><a href="#1-1了解全貌——Android王国简介" class="headerlink" title="1.1了解全貌——Android王国简介"></a>1.1了解全貌——Android王国简介</h3><h4 id="1-1-3-Android开发应用特色"><a href="#1-1-3-Android开发应用特色" class="headerlink" title="1.1.3 Android开发应用特色"></a>1.1.3 Android开发应用特色</h4><h5 id="01-四大组件"><a href="#01-四大组件" class="headerlink" title="01 四大组件"></a>01 四大组件</h5><p>Android系统四大组件分别是活动（’Activity’）、服务（’Service’）、广播接收器（’Broadcast Reciever’）和内容提供器（’Content Provider’）。</p>
<ul>
<li>活动应用程序的门面，所有能看到的东西都放在活动中。</li>
<li>服务一直在后台默默运行。</li>
<li>广播接收器允许你的应用接受来自各处的广播消息，比如电话、短信等。</li>
<li>内容提供器则为应用程序之间共享数据提供了可能，比如可以通过内容提供器读取系统电话簿中的联系人。  </li>
</ul>
<span id="more"></span>
<h5 id="02-丰富的系统控件"><a href="#02-丰富的系统控件" class="headerlink" title="02 丰富的系统控件"></a>02 丰富的系统控件</h5><h5 id="03-SQLite数据库"><a href="#03-SQLite数据库" class="headerlink" title="03 SQLite数据库"></a>03 SQLite数据库</h5><h5 id="04-强大的多媒体"><a href="#04-强大的多媒体" class="headerlink" title="04 强大的多媒体"></a>04 强大的多媒体</h5><h5 id="05-地理位置定位"><a href="#05-地理位置定位" class="headerlink" title="05 地理位置定位"></a>05 地理位置定位</h5><h4 id="1-3-4-分析你的第一个Android程序"><a href="#1-3-4-分析你的第一个Android程序" class="headerlink" title="1.3.4 分析你的第一个Android程序"></a>1.3.4 分析你的第一个Android程序</h4><h5 id="01-gradle-和-idea-Android"><a href="#01-gradle-和-idea-Android" class="headerlink" title="01 .gradle 和.idea  Android"></a>01 .gradle 和.idea  Android</h5><p>Studio自动生成的一些文件</p>
<h5 id="02-app-项目中代码、资源的存放"><a href="#02-app-项目中代码、资源的存放" class="headerlink" title="02 app 项目中代码、资源的存放"></a>02 app 项目中代码、资源的存放</h5><h5 id="03-build-存放编译时自动生成的文件"><a href="#03-build-存放编译时自动生成的文件" class="headerlink" title="03 build 存放编译时自动生成的文件"></a>03 build 存放编译时自动生成的文件</h5><h5 id="04-gitignore"><a href="#04-gitignore" class="headerlink" title="04 .gitignore"></a>04 .gitignore</h5><p>用来将制定的目录或文件排除在版本控制之外</p>
<h5 id="05-build-gradle"><a href="#05-build-gradle" class="headerlink" title="05 build.gradle"></a>05 build.gradle</h5><p>不需要修改、项目全局的gradle构建脚本</p>
<p>……</p>
<p>除了app目录之外，大多数的文件和目录都是自动生成的，我们并不需要进行修改。</p>
<h5 id="app目录下的结构"><a href="#app目录下的结构" class="headerlink" title="app目录下的结构"></a>app目录下的结构</h5><ol>
<li>build<br>包含编译时生成的文件</li>
<li>libs<br>把第三方jar包放在libs目录下，放在这里的jar包都会被自动添加到构筑路径中去。</li>
<li>androidTest<br>编写Android Test测试用例，可以对项目进行一些自动化测试</li>
<li>java<br>存放所有java代码</li>
<li>res<br>存放项目中使用到的所有图片、布局、字符串等资源。<ol>
<li>图片放在drawable目录下</li>
<li>布局放在layout目录下</li>
<li>字符串放在values目录下</li>
</ol>
</li>
<li>AndroidManifest.xml<br>整个Android项目的配置文件，在程序中定义的四大组件都需要在这个文件里注册，可以给应用程序添加权限声明。</li>
<li>test<br>编写Unit Test测试用例的，是对项目进行自动化测试的另一种方式</li>
<li>.gitignore<br>将app模板内的指定的目录或文件排除在版本控制之外</li>
</ol>
<p>‘AndroidManifest.xml’文件<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.HelloWorldActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">        //表示HelloWorldActivity是这个项目的主活动</span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">        //点击图标，首先启动的就是这个活动</span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><br>‘HelloWorldActivity.java’<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;<span class="comment">//继承</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.hello_world_layout);</span><br><span class="line">        Log.d(<span class="string">&quot;HelloWorldAcitivity&quot;</span>,<span class="string">&quot;onCreate execute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>Android程序的设计讲究逻辑和视图分离，因此是不推荐在活动中直接编写界面的，更加通用的一种做法是，在布局文件中编写界面，然后在活动中引入进来。</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.HelloWorldActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Hello World!&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.constraint.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="1-3-5详解项目中的资源"><a href="#1-3-5详解项目中的资源" class="headerlink" title="1.3.5详解项目中的资源"></a>1.3.5详解项目中的资源</h4><p><img src="https://s2.ax1x.com/2019/03/19/An0crj.png" alt="res目录下的结构">  </p>
<p>‘res’目录下的结构<br>‘drawable’开头的文件就是用来存放图片的。<br>‘mipmap’开头的文件夹是用来存放应用图标的。<br>‘values’用来存放字符串、样式、颜色等配置。<br>‘layout’存放布局。  </p>
<p>res/values/strings.xml<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;app_name&quot;</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">```  </span><br><span class="line">有两种方式来引用这个字符串</span><br><span class="line"></span><br><span class="line">- 在代码中： R.string.app_name</span><br><span class="line">- 在XML中：@string/app_name</span><br><span class="line"></span><br><span class="line">#### 1.3.6详解build.gradle文件</span><br><span class="line"></span><br><span class="line">最外层目录下的build.gradle文件部分代码</span><br></pre></td></tr></table></figure><br>buildscript {</p>
<pre><code>repositories &#123;
    google()
    jcenter()
    //jcenter代码托管仓库，可以在项目中轻松引用jcenter上的开源项目
&#125;
dependencies &#123;
    classpath &#39;com.android.tools.build:gradle:3.1.4&#39;
    //声明用Gradle来构建Android项目

    // NOTE: Do not place your application dependencies here; they belong
    // in the individual module build.gradle files
&#125;
</code></pre><p>}</p>
<p>app目录内的build.gradle文件<br>apply plugin: ‘com.android.application’<br>//应用了一个插件，一般有两种值可以选。<br>//com.android.application 表示应用程序模块,可以直接运行<br>//com.android.library 表示这是一个库模块，依附于别的应用程序模块来运行</p>
<p>android {<br>    compileSdkVersion 28 //指定项目的编译版本<br>    defaultConfig {//更多细节配置<br>        applicationId “com.example.helloworld”//指定项目包名<br>        minSdkVersion 15//项目最低兼容的系统版本<br>        targetSdkVersion 28<br>        versionCode 1<br>        versionName “1.0”<br>        testInstrumentationRunner “android.support.test.runner.AndroidJUnitRunner”<br>    }<br>    buildTypes {//指定生成安装文件的相关配置<br>    //buildTypes通常有两个子包 debug（测试版的配置）和release（正式版的配置）<br>        release {<br>            minifyEnabled false //是否对项目的代码进行混淆<br>            proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’<br>        }<br>    }<br>}</p>
<p>dependencies {//指定当前项目所有的依赖关系<br>    //本地依赖 对本地的Jar包或目录添加依赖关系<br>    //库依赖 对项目的库模块添加依赖关系<br>    //远程依赖 对jcenter库上的开源项目添加依赖关系<br>    implementation fileTree(dir: ‘libs’, include: [‘*.jar’])//本地依赖<br>    implementation ‘com.android.support:appcompat-v7:28.0.0’//远程依赖<br>    implementation ‘com.android.support.constraint:constraint-layout:1.1.3’<br>    testImplementation ‘junit:junit:4.12’<br>    androidTestImplementation ‘com.android.support.test:runner:1.0.2’<br>    androidTestImplementation ‘com.android.support.test.espresso:espresso-core:3.0.2’<br>}<br>```</p>
<h3 id="1-4-前行必备——掌握日志工具的使用"><a href="#1-4-前行必备——掌握日志工具的使用" class="headerlink" title="1.4 前行必备——掌握日志工具的使用"></a>1.4 前行必备——掌握日志工具的使用</h3><p>‘Log.v( )’    verbose<br>‘Log.d( )’     debug<br>‘Log.i( )’    info<br>‘Log.w( )’    warn<br>‘Log.e( )’    error  </p>
<p><em>Log.d(“HelloWorldAcitivity”,”onCreate execute”);</em></p>
<p>“tag”:当前类名，对打印信息进行过滤<br>“msg”:要打印的具体内容</p>
]]></content>
      <categories>
        <category>安卓开发</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（23）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8823%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY23-图形处理相关"><a href="#DAY23-图形处理相关" class="headerlink" title="DAY23_图形处理相关"></a>DAY23_图形处理相关</h1><h2 id="1-编写malloc"><a href="#1-编写malloc" class="headerlink" title="1.编写malloc"></a>1.编写malloc</h2><p>如果api_malloc只是调用操作系统中的memman_alloc，并将分配到的内存空间地址返回给应用程序的话，是行不通的，因为通过memman_alloc所获得的内存空间并不位于应用程序的数据段范围内，应用程序是无法进行读写操作的。如果应用程序在不知情的情况下执行了读写操作，将会产生异常并强制结束。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">memman初始化</span><br><span class="line">EDX=8 </span><br><span class="line">EBX=memman的地址</span><br><span class="line">EAX=memman所管理的内存空间的起始地址</span><br><span class="line">ECX=memman所管理的内存空间的字节数</span><br><span class="line">malloc</span><br><span class="line">EDX=9 </span><br><span class="line">EBX=memman的地址</span><br><span class="line">ECX=需要请求的字节数</span><br><span class="line">EAX=分配到的内存空间地址</span><br><span class="line">free</span><br><span class="line">EDX=10 </span><br><span class="line">EBX=memman的地址</span><br><span class="line">EAX=需要释放的内存空间地址</span><br><span class="line">ECX=需要释放的字节数</span><br></pre></td></tr></table></figure>
<h2 id="2-画点"><a href="#2-画点" class="headerlink" title="2.画点"></a>2.画点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在窗口中画点</span><br><span class="line">EDX =11 </span><br><span class="line">EBX =窗口句柄</span><br><span class="line">ESI =显示位置的x坐标</span><br><span class="line">EDI =显示位置的y坐标</span><br><span class="line">EAX =色号</span><br></pre></td></tr></table></figure>
<p>画星星<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title); </span><br><span class="line">void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col); </span><br><span class="line">void api_initmalloc(void); </span><br><span class="line">char *api_malloc(int size); </span><br><span class="line">void api_point(int win, int x, int y, int col); </span><br><span class="line">void api_end(void); </span><br><span class="line">int rand(void); /*产生0～32767之间的随机数*/ </span><br><span class="line">void HariMain(void) </span><br><span class="line">&#123; </span><br><span class="line"> char *buf; </span><br><span class="line"> int win, i, x, y; </span><br><span class="line"> api_initmalloc(); </span><br><span class="line"> buf = api_malloc(150 * 100);</span><br><span class="line">  win = api_openwin(buf, 150, 100, -1, &quot;stars&quot;); </span><br><span class="line"> api_boxfilwin(win, 6, 26, 143, 93, 0 /*黑色*/); </span><br><span class="line"> for (i = 0; i &lt; 50; i++) &#123; </span><br><span class="line"> x = (rand() % 137) + 6; </span><br><span class="line"> y = (rand() % 67) + 26; </span><br><span class="line"> api_point(win, x, y, 3 /*黄色*/); </span><br><span class="line"> &#125; </span><br><span class="line"> api_end(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-刷新窗口"><a href="#3-刷新窗口" class="headerlink" title="3.刷新窗口"></a>3.刷新窗口</h2><p>在所有的窗口绘图命令中设置一个“不自动刷新”的选项，然后再编写一个仅用来刷新的API<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">刷新窗口</span><br><span class="line">EDX = 12 </span><br><span class="line">EBX = 窗口句柄</span><br><span class="line">EAX = x0 </span><br><span class="line">ECX = y0 </span><br><span class="line">ESI = x1 </span><br><span class="line">EDI = y1</span><br></pre></td></tr></table></figure></p>
<h2 id="4-画直线"><a href="#4-画直线" class="headerlink" title="4.画直线"></a>4.画直线</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (i = 0; i &lt; len; i++) &#123; </span><br><span class="line"> api_point(win, x, y, col); </span><br><span class="line"> x += dx; </span><br><span class="line"> y += dy; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-关闭窗口"><a href="#5-关闭窗口" class="headerlink" title="5.关闭窗口"></a>5.关闭窗口</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关闭窗口</span><br><span class="line">EDX=14 </span><br><span class="line">EBX=窗口句柄</span><br></pre></td></tr></table></figure>
<h2 id="6-键盘输入API"><a href="#6-键盘输入API" class="headerlink" title="6.键盘输入API"></a>6.键盘输入API</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">键盘输入</span><br><span class="line">EDX = 15 </span><br><span class="line">EAX = 0……没有键盘输入时返回1，不休眠</span><br><span class="line"> = 1……休眠直到发生键盘输入</span><br><span class="line">EAX = 输入的字符编码</span><br></pre></td></tr></table></figure>
<h2 id="8-强制结束并关闭窗口"><a href="#8-强制结束并关闭窗口" class="headerlink" title="8.强制结束并关闭窗口"></a>8.强制结束并关闭窗口</h2><p>问题：在运行walk.hrb和lines.hrb时，如果不按回车键结束，而是按Shift+F1强制结束程序的话，窗口就会残留在画面上。<br>解决方法：在struct SHEET中添加一个用来存放task的成员，当应用程序结束时，查询所有的图层，如果图层的task为将要结束的应用程序任务，则关闭该图层。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（22）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8822%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY22-用C语言编写应用程序"><a href="#DAY22-用C语言编写应用程序" class="headerlink" title="DAY22_用C语言编写应用程序"></a>DAY22_用C语言编写应用程序</h1><h2 id="1-保护操作系统（5）"><a href="#1-保护操作系统（5）" class="headerlink" title="1.保护操作系统（5）"></a>1.保护操作系统（5）</h2><p>问题：在定时器上做手脚，光标闪烁变得异常缓慢，任务切换的速度也会变得缓慢。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[INSTRSET &quot;i486p&quot;] </span><br><span class="line">[BITS 32] </span><br><span class="line">    MOV AL,0x34 </span><br><span class="line">    OUT 0x43,AL </span><br><span class="line">    MOV AL,0xff</span><br><span class="line">    OUT 0x40,AL </span><br><span class="line">    MOV AL,0xff </span><br><span class="line">    OUT 0x40,AL</span><br><span class="line">    </span><br><span class="line">; 上述代码的功能与下面代码相当</span><br><span class="line">; io_out8(PIT_CTRL, 0x34); </span><br><span class="line">; io_out8(PIT_CNT0, 0xff); </span><br><span class="line">; io_out8(PIT_CNT0, 0xff); </span><br><span class="line"> </span><br><span class="line">    MOV EDX,4 </span><br><span class="line">    INT 0x40</span><br></pre></td></tr></table></figure></p>
<span id="more"></span>
<ul>
<li>执行CLI然后再HLT。由于不再产生定时器中断，任务切换也会停止，键盘和鼠标中断也停止响应。</li>
</ul>
<h2 id="2-帮助发现bug"><a href="#2-帮助发现bug" class="headerlink" title="2.帮助发现bug"></a>2.帮助发现bug</h2><p>CPU的异常处理功能，除了可以保护操作系统免遭应用程序的破坏，还可以帮助我们在编写应用程序时及早发现bug。</p>
<hr>
<p>对栈异常的处理：<br>要想让它发现bug，最好能知道引发异常的指令的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *inthandler0c(int *esp) </span><br><span class="line">&#123; </span><br><span class="line"> struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec); </span><br><span class="line"> struct TASK *task = task_now(); </span><br><span class="line"> char s[30]; /*这里！*/ </span><br><span class="line"> cons_putstr0(cons, &quot;\nINT 0C :\n Stack Exception.\n&quot;); </span><br><span class="line"> sprintf(s, &quot;EIP = %08X\n&quot;, esp[11]); /*这里！*/ </span><br><span class="line"> cons_putstr0(cons, s); /*这里！*/ </span><br><span class="line"> return &amp;(task-&gt;tss.esp0); /*强制结束程序*/ </span><br><span class="line">&#125; </span><br><span class="line">int *inthandler0d(int *esp) </span><br><span class="line">&#123; </span><br><span class="line"> struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec); </span><br><span class="line"> struct TASK *task = task_now(); </span><br><span class="line"> char s[30]; /*这里！*/ </span><br><span class="line"> cons_putstr0(cons, &quot;\nINT 0D :\n General Protected Exception.\n&quot;); </span><br><span class="line"> sprintf(s, &quot;EIP = %08X\n&quot;, esp[11]); /*这里！*/ </span><br><span class="line"> cons_putstr0(cons, s); /*这里！*/ </span><br><span class="line"> return &amp;(task-&gt;tss.esp0); /*强制结束程序*/ </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-强制结束应用程序"><a href="#3-强制结束应用程序" class="headerlink" title="3.强制结束应用程序"></a>3.强制结束应用程序</h2><ul>
<li>如何实现？<br>将某一个键设定为强制结束键，按一下就可以结束程序。<br>把强制结束处理写在其他的任务中，bootpack.c</li>
</ul>
<h2 id="4-用C语言显示字符串（1）"><a href="#4-用C语言显示字符串（1）" class="headerlink" title="4.用C语言显示字符串（1）"></a>4.用C语言显示字符串（1）</h2><p>已经做好了用来显示字符串的API，却没做可供C语言调用该API的函数。</p>
<h2 id="5-用C语言显示字符串（2）"><a href="#5-用C语言显示字符串（2）" class="headerlink" title="5.用C语言显示字符串（2）"></a>5.用C语言显示字符串（2）</h2><p>连接了.obj文件的bim2hrb认为“hello, world”这个字符串就应该存放在0x400这个地址中。<br>由bim2hrb生成的.hrb文件其实是由两个部分构成的。</p>
<ul>
<li>代码部分</li>
<li>数据部分</li>
</ul>
<p>修改console.c：</p>
<ul>
<li>文件中找不到“Hari”标志则报错。</li>
<li>数据段的大小根据.hrb文件中指定的值进行分配。</li>
<li>将.hrb文件中的数据部分先复制到数据段后再启动程序。</li>
</ul>
<h2 id="6-显示窗口"><a href="#6-显示窗口" class="headerlink" title="6.显示窗口"></a>6.显示窗口</h2><p>编写一个用来显示窗口的API<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EDX = 5 </span><br><span class="line">EBX = 窗口缓冲区</span><br><span class="line">ESI = 窗口在x轴方向上的大小（即窗口宽度）</span><br><span class="line">EDI = 窗口在y轴方向上的大小（即窗口高度）</span><br><span class="line">EAX = 透明色</span><br><span class="line">ECX = 窗口名称</span><br></pre></td></tr></table></figure></p>
<h2 id="7-在窗口中描绘字符和方"><a href="#7-在窗口中描绘字符和方" class="headerlink" title="7.在窗口中描绘字符和方"></a>7.在窗口中描绘字符和方</h2><p>显示字符的API：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EDX = 6 </span><br><span class="line">EBX = 窗口句柄</span><br><span class="line">ESI = 显示位置的x坐标</span><br><span class="line">EDI = 显示位置的y坐标</span><br><span class="line">EAX = 色号</span><br><span class="line">ECX = 字符串长度</span><br><span class="line">EBP = 字符串</span><br></pre></td></tr></table></figure></p>
<p>描绘方块的API：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EDX = 7 </span><br><span class="line">EBX = 窗口句柄</span><br><span class="line">EAX = x0 </span><br><span class="line">ECX = y0 </span><br><span class="line">ESI = x1 </span><br><span class="line">EDI = y1 </span><br><span class="line">EBP = 色号</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（21）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8821%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY21-保护操作系统"><a href="#DAY21-保护操作系统" class="headerlink" title="DAY21_保护操作系统"></a>DAY21_保护操作系统</h1><h2 id="1-攻克难题——字符串显示API"><a href="#1-攻克难题——字符串显示API" class="headerlink" title="1.攻克难题——字符串显示API"></a>1.攻克难题——字符串显示API</h2><ul>
<li>我们需要在API中做个改动，使其能够将应用程序传递的地址解释为代码段内地址。</li>
</ul>
<span id="more"></span>
<h2 id="2-用C语言编写应用程序"><a href="#2-用C语言编写应用程序" class="headerlink" title="2.用C语言编写应用程序"></a>2.用C语言编写应用程序</h2><p>要实现C语言编写应用程序，需要在应用程序方面创建一个api_putchar函数。注意，这个函数不是创建在操作系统中。api_putchar函数需要用C语言来调用，功能是向EDX和AL赋值，并调用INT 0x40。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[FORMAT &quot;WCOFF&quot;] ; 生成对象文件的模式</span><br><span class="line">[INSTRSET &quot;i486p&quot;] ; 表示使用486兼容指令集</span><br><span class="line">[BITS 32] ; 生成32位模式机器语言</span><br><span class="line">[FILE &quot;a_nask.nas&quot;] ; 源文件名信息</span><br><span class="line"> </span><br><span class="line">    GLOBAL _api_putchar </span><br><span class="line"></span><br><span class="line">[SECTION .text] </span><br><span class="line">_api_putchar: ; void api_putchar(int c); </span><br><span class="line">    MOV EDX,1 </span><br><span class="line">    MOV AL,[ESP+4] ; c </span><br><span class="line">    INT 0x40 </span><br><span class="line">    RET</span><br></pre></td></tr></table></figure>
<p>这里的api_putchar需要与a.c的编译结果进行连接，因此我们使用对象文件模式</p>
<h2 id="3-保护操作系统（1）"><a href="#3-保护操作系统（1）" class="headerlink" title="3.保护操作系统（1）"></a>3.保护操作系统（1）</h2><p>操作系统需要运行各种应用程序，而这些应用程序有可能是操作系统开发者编写的，也有可能是用户、别的软件开发商或者是某个自由软件作者出于善意编写的。<br>所谓对操作系统的破坏，严重程度也不同，比如擅自删除重要文件、使其他任务的运行产生异常，或者造成操作系统死机而不得不重新启动等等。</p>
<h2 id="4-保护操作系统（2）"><a href="#4-保护操作系统（2）" class="headerlink" title="4.保护操作系统（2）"></a>4.保护操作系统（2）</h2><p>我们需要为应用程序提供专用的内存空间，并且禁止别的应用程序访问。<br>要做到这一点，我们可以创建应用程序专用的数据段，并在应用程序运行期间，将DS和SS指向该段地址。<br>这次我们还使用了以句点（.）开头的标签名，这是一种被称为本地标签的特殊标签。它基本上和普通的标签功能一样，区别在于即使标签名和其他函数中的标签重复，系统也能将它们区分开来。</p>
<h2 id="5-对异常的支持"><a href="#5-对异常的支持" class="headerlink" title="5.对异常的支持"></a>5.对异常的支持</h2><p>接下来我们要实现强制结束程序的功能。<br>要想强制结束程序，只要在中断号0x0d中注册一个函数即可。<br>这是因为在x86架构规范中，当应用程序试图破坏操作系统，或者试图违背操作系统的设置时，就会自动产生0x0d中断，因此该中断也被称为“异常”。</p>
<h2 id="6-保护操作系统（3）"><a href="#6-保护操作系统（3）" class="headerlink" title="6.保护操作系统（3）"></a>6.保护操作系统（3）</h2><p>可能出现的问题：操作系统会指定应用程序的DS，因此破坏行为会发生异常，那么如果忽略操作系统指定的DS，而是用汇编语言直接将操作系统用的段地址存入DS的话，就又可以干坏事了。</p>
<h2 id="7-保护操作系统（4）"><a href="#7-保护操作系统（4）" class="headerlink" title="7.保护操作系统（4）"></a>7.保护操作系统（4）</h2><ul>
<li>想法：让应用程序无法使用操作系统的段地址。</li>
<li>具体做法：x86架构有这样的功能。<br>在段定义的地方，如果将访问权限加上0x60的话，就可以将段设置为应用程序用。<br>当CS中的段地址为应用程序用段地址时，CPU会认为“当前正在运行应用程序”，这时如果存入操作系统用的段地址就会产生异常。  </li>
</ul>
<hr>
<p>在启动应用程序的时候我们需要让“操作系统向应用程序的段执行far-CALL”<br>解决方案：可以使用RETF</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>基于链接内容的社区发现算法（一）</title>
    <url>/201904/%E5%9F%BA%E4%BA%8E%E9%93%BE%E6%8E%A5%E5%86%85%E5%AE%B9%E7%9A%84%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Robust-Detection-of-Link-Communities-in-Large-Social-Network-by-Exploiting-Link-Semantics"><a href="#Robust-Detection-of-Link-Communities-in-Large-Social-Network-by-Exploiting-Link-Semantics" class="headerlink" title="Robust Detection of Link Communities in Large Social Network by Exploiting Link Semantics"></a>Robust Detection of Link Communities in Large Social Network by Exploiting Link Semantics</h1><h2 id="ZHOU-YUYANG"><a href="#ZHOU-YUYANG" class="headerlink" title="ZHOU YUYANG"></a>ZHOU YUYANG</h2><hr>
<p><a href="https://www.aaai.org/ocs/index.php/AAAI/AAAI18/paper/viewPaper/17345">Robust Detection of Link Communities in Large Social Network by Exploiting Link Semantics </a></p>
<p>这篇论文是我加入张老师实验室读的第一篇论文，寒假里草草读了一遍，感叹了自己垃圾的英文水平，上周除了上课和作业基本没做什么，一直在研读这篇论文。很幸运的是上周关于这篇论文的汇报我做的非常精彩，也不枉自己上周那么辛苦的肝了。  </p>
<p>这篇博客用来记录自己研读时候的思考和整理。  </p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7J9ts.png" alt="1.1"></p>
<p>整个论文的整体内容我将从四个方面介绍。分别是社区发现算法的背景和现存的方法、论文提出的模型和方法、试验和结论与讨论。</p>
<span id="more"></span>
<h2 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h2><p><img src="https://s2.ax1x.com/2019/04/11/A7GvnS.png" alt="1.2">  </p>
<h3 id="1-1-社交网络的发展"><a href="#1-1-社交网络的发展" class="headerlink" title="1.1 社交网络的发展"></a>1.1 社交网络的发展</h3><ul>
<li>社交对于世界各地各领域的人们来讲都越来越重要。随着社交网络的发展，越来越多的信息开始在互联网中聚集。</li>
<li>对于这些大数据的分析能够让我们更加熟悉网络的深层结构、了解用户行为和未来趋势。</li>
<li>社交网络中的一个重要的问题便是社区发现，通过社区发现我们能够为用户提供个性化推荐和异常行为的识别。</li>
<li>所谓的“社区发现”，就是将出现在社交网络中的用户节点划分成不同的组别。每个组的用户结点都有着某些相同的特征。</li>
</ul>
<h3 id="1-2-现存的方法"><a href="#1-2-现存的方法" class="headerlink" title="1.2 现存的方法"></a>1.2 现存的方法</h3><p><img src="https://s2.ax1x.com/2019/04/11/A7Jipq.png" alt="1.3"></p>
<ul>
<li>我们通常用一个图来表示社交网络。其中的点表示用户结点，其中的边表示用户之间的联系。</li>
<li>最初人们社区发现的算法是根据网络的<font color="FF0000">拓扑结构</font>，即让我们划分后的各个社区间的边的数量最少，社区内部点之间的边尽可能的多</li>
<li>之后，社区发现的算法得到改进，我们通过节点内容进行社区划分，即使得同一个社区内的结点内容尽可能多的相似。通过结点内容进行社区发现能够大大提升我们社区发现的效率。</li>
<li>同时我们发现，用户之间的链接，即图中的边也含有大量的信息。</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JChn.png" alt="1.4"></p>
<p>这张图形象的表示了我们的方法和其他方法的区别。其中右边的图是基于结点内容进行社区发现的算法示意图，左边的图是我们基于链接内容进行社区发现的图。<br>我们可以看出现有的其他方法的问题：</p>
<ul>
<li>1.只考虑了节点内容。考虑节点内容进行社区发现在有些时候有很高的效率。以微博用户的社区发现为例，当我们提供的内容是用户简介时，基于节点内容进行社区发现是很可以的。但是当我们提供的内容是用户之间发送的消息时，这其实是一种“链接内容”，我们需要将链接内容转换成节点内容，比如用户A发送的所有消息算成用户A的节点内容。这时候势必导致社区划分的不准确。</li>
<li>2.假设网络拓扑社区和结点内容社区的用户结点是一样的。两个用户间联系紧密，构成一个拓扑社区，但是他们聊天的内容可能是很五花八门的，两个人可能被分到不同的节点内容社区中去，这个时候现有的方法社区发现的效率就会下降。</li>
<li>3.每个社区仅仅有一个话题。比如右边的图把Music和Movies混在一起当作一个话题，而我们的方法（左边）含有两个话题。</li>
<li>4.仅仅用单个词汇进行社区标签。有时候我们可能会不知所云。而我们的方法用句子进行标签，便于理解。</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JF10.png" alt="1.5"></p>
<h2 id="2-The-Model-and-Method"><a href="#2-The-Model-and-Method" class="headerlink" title="2.The Model and Method"></a>2.The Model and Method</h2><h3 id="2-1综述"><a href="#2-1综述" class="headerlink" title="2.1综述"></a>2.1综述</h3><p>详见图片  </p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JVnU.png" alt="1.6"></p>
<h3 id="2-2-详细分析"><a href="#2-2-详细分析" class="headerlink" title="2.2 详细分析"></a>2.2 详细分析</h3><p>我们先来看看我们进行社区发现需要考虑哪一些因素：</p>
<ul>
<li>拓扑角度：结点、链接</li>
<li>内容角度：单词、句子、话题</li>
<li>社区和话题群聚(topic cluster)</li>
</ul>
<h4 id="变量介绍"><a href="#变量介绍" class="headerlink" title="变量介绍"></a>变量介绍</h4><p>详见图片(难理解的内容都已经用中文进行注释)  </p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JkcV.md.png" alt="1.7"></p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JZBF.md.png" alt="1.8"></p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7Je74.md.png" alt="1.9"></p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JQ91.md.png" alt="1.10"></p>
<p>所有变量的详细关系如下图所示  </p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JnAJ.png" alt="1.11"></p>
<p>为了便于理解，我自己又画了一个图。</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JGnO.md.png" alt="1.12"></p>
<p>图左半部分就是根据拓扑结构进行社区发现，右半部分是根据节点内容进行社区发现。</p>
<p>现在，我们的模型已经建立起来了，我们的目标为以下三点：</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JKhR.png" alt="1.13"></p>
<h3 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h3><p>我们算法的整体思想是这样的：首先我们根据某标准把网络中的所有节点划分到不同的社区中（E-step），然后我们将提取每个社区中的关键词，来进行社区标注。（M-step）<br>我们再根据标注进行有监督的学习，对社区进行更精准的划分，以此来一遍遍迭代。  </p>
<p>下面我们运用了极大似然的思想进行EM算法。<br>E-step：</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JuN9.md.png" alt="1.14"></p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7J1c6.md.png" alt="1.15"></p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7Ja4A.md.png" alt="1.16"></p>
<p>我们进行期望化的变量是p，p代表着链接<i,j>被分配到哪个社区中。<br>现在p的取值是Jensen不等式的取等条件。</p>
<p>M-step：</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JJBD.png" alt="1.17"></p>
<p>下面我们要求式(3)的最大值，tau、 omega_ri、 y_rj都是可以通过直接求导求出来的。剩下的psai和fai的最大值我们再一次通过EM算法来求。引入变量p和h，运用JENSEN公式，p和h在取等条件时式子取到最大值。</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JYHe.md.png" alt="1.18"></p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7Jw9I.md.png" alt="1.19"></p>
<p>下面我们给出整个算法的伪代码，看懂这个图整个算法的思路就差不多了。</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7Jsu8.png" alt="1.20"></p>
]]></content>
      <categories>
        <category>社区发现</category>
      </categories>
      <tags>
        <tag>社区发现</tag>
      </tags>
  </entry>
  <entry>
    <title>基于链接内容的社区发现算法（二）</title>
    <url>/201904/%E5%9F%BA%E4%BA%8E%E9%93%BE%E6%8E%A5%E5%86%85%E5%AE%B9%E7%9A%84%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Robust-Detection-of-Link-Communities-in-Large-Social-Network-by-Exploiting-Link-Semantics"><a href="#Robust-Detection-of-Link-Communities-in-Large-Social-Network-by-Exploiting-Link-Semantics" class="headerlink" title="Robust Detection of Link Communities in Large Social Network by Exploiting Link Semantics"></a>Robust Detection of Link Communities in Large Social Network by Exploiting Link Semantics</h1><h2 id="ZHOU-YUYANG"><a href="#ZHOU-YUYANG" class="headerlink" title="ZHOU YUYANG"></a>ZHOU YUYANG</h2><hr>
<div class="note primary">这一部分没什么难点，ppt里写的都很清楚了。。</div>

<h3 id="三、试验"><a href="#三、试验" class="headerlink" title="三、试验"></a>三、试验</h3><h4 id="1-数据集"><a href="#1-数据集" class="headerlink" title="1.数据集"></a>1.数据集</h4><p>我们选择了两个数据集，包括美国安然能源公司内部的邮件内容（安然公司丑闻，加州能源危机）和Reddit新闻网站三天的的三个论坛的内容。如果用户A对用户B的帖子进行评论，就产生了一条从A到B的链接，链接内容为评论的内容。</p>
<span id="more"></span>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JUNd.md.png" alt="2.1"></p>
<p>那么如何判断我们社区发现的结果是正确的呢？<br>对于第一个数据集，伯克利大学的学生已经将这些用户节点分成了11个用户社区，我们可以直接将社区发现的结果与这十一个社区比对。对于第二个数据集，我们可以直接将发现的社区和三个论坛内容相比较。</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7J03t.png" alt="2.2"></p>
<h4 id="2-对比的方法"><a href="#2-对比的方法" class="headerlink" title="2.对比的方法"></a>2.对比的方法</h4><p>我们采取了8种最先进的社区发现算法，包括利用拓扑结构的、利用结点内容的、利用链接内容的、可重叠的、不可重叠的（可重叠的意思就是可以将一个用户结点放进多个社区里）等，如图：</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JBgP.png" alt="2.3"></p>
<h4 id="3-测评参数"><a href="#3-测评参数" class="headerlink" title="3.测评参数"></a>3.测评参数</h4><p>F-score和Jaccard similarity，用于测评相似度的两个参数，结果两个参数越大，说明社区发现的结果越好。</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JgEQ.png" alt="2.4"></p>
<h4 id="4-结果"><a href="#4-结果" class="headerlink" title="4.结果"></a>4.结果</h4><p><img src="https://s2.ax1x.com/2019/04/11/A7JDjf.md.png" alt="2.5"></p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7J5vV.png" alt="2.6"></p>
<h4 id="5-个例研究"><a href="#5-个例研究" class="headerlink" title="5.个例研究"></a>5.个例研究</h4><p>我们选择了Reddit网站2012年8月27号的数据集进行分析，与我们的方法对比的是SCI</p>
<p>SCI方法的结果如下：</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JyDS.png" alt="2.7"></p>
<p>我们的方法：<br><img src="https://s2.ax1x.com/2019/04/17/AxqfbT.jpg" alt="2.8"></p>
<p><img src="https://s2.ax1x.com/2019/04/17/Axq4VU.png" alt="2.9"></p>
<p>我们的方法还有一个好处，就是可以通过fai和Y找到社区的词云：</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JR4s.md.png" alt="2.10"></p>
<p>我们方法的应用建议：</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7Jh3q.png" alt="2.11"></p>
<h3 id="四、结论"><a href="#四、结论" class="headerlink" title="四、结论"></a>四、结论</h3><p><img src="https://s2.ax1x.com/2019/04/11/A7JfCn.md.png" alt="2.12"></p>
<p>这是文章的标题，下面我们对标题的关键词进行讨论和总结。<br>Robust:健壮性。在传统的方法中，当网络拓朴和话题群聚不重合的时候，方法的效率就会变得很低，而我们的方法将网络拓朴和话题群聚分开来讨论，具有一定的健壮性。</p>
<p>Detection of Link Communities：本论文的主要内容——社区发现。</p>
<p>Exploiting Link Semantics: 基于链接语义。</p>
]]></content>
      <categories>
        <category>社区发现</category>
      </categories>
      <tags>
        <tag>社区发现</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫入门</title>
    <url>/201904/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<div class="note info">
    助教说学习`Python`的最好方法是从爬虫下手🤠。正好现在导师把我分配给学姐，让我们完成一个机票价格预测系统。<br />
    但是这学期的课业太忙了😭，自己因为情感的事情状态也没有那么好，希望自己还能有足够的精力去做好这件事。💪
</div>

<h1 id="爬虫入门-0415"><a href="#爬虫入门-0415" class="headerlink" title="爬虫入门 0415"></a>爬虫入门 0415</h1><h2 id="一、网络爬虫概念"><a href="#一、网络爬虫概念" class="headerlink" title="一、网络爬虫概念"></a>一、网络爬虫概念</h2><ul>
<li>网络爬虫（英语：web crawler），也叫网络蜘蛛（spider），是一种用来自动浏览万维网的网络机器人。其目的一般为编纂网络索引。</li>
<li>网络爬虫可以将自己所访问的页面保存下来，以便搜索引擎事后生成索引供用户搜索。</li>
</ul>
<p><em>来源Wikipedia</em></p>
<h2 id="二、爬虫入门"><a href="#二、爬虫入门" class="headerlink" title="二、爬虫入门"></a>二、爬虫入门</h2><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><ul>
<li><font class="FF0000">“入门”是良好的动机，但是可能作用缓慢。如果你手里或者脑子里有一个项目，那么实践起来你会被目标驱动，而不会像学习模块一样慢慢学习。</font></li>
<li>另外如果说知识体系里的每一个知识点是图里的点，依赖关系是边的话，那么这个图一定不是一个有向无环图。因为学习A的经验可以帮助你学习B。因此，你不需要学习怎么样“入门”，因为这样的“入门”点根本不存在！你需要学习的是怎么样做一个比较大的东西，在这个过程中，你会很快地学会需要学会的东西的。当然，你可以争论说需要先懂python，不然怎么学会python做爬虫呢？但是事实上，你完全可以在做这个爬虫的过程中学习python :D</li>
</ul>
<h3 id="你需要学习"><a href="#你需要学习" class="headerlink" title="你需要学习"></a>你需要学习</h3><ul>
<li>基本的爬虫工作原理</li>
<li>基本的http抓取工具，scrapy</li>
<li>Bloom Filter: Bloom Filters by Example</li>
<li>如果需要大规模网页抓取，你需要学习分布式爬虫的概念。其实没那么玄乎，你只要学会怎样维护一个所有集群机器能够有效分享的分布式队列就好。最简单的实现是python-rq: <a href="https://github.com/nvie/rq">https://github.com/nvie/rq</a></li>
<li>rq和Scrapy的结合：darkrho/scrapy-redis · GitHub</li>
<li>后续处理，网页析取(grangier/python-goose · GitHub)，存储(Mongodb)</li>
</ul>
<h3 id="爬虫的原理"><a href="#爬虫的原理" class="headerlink" title="爬虫的原理"></a>爬虫的原理</h3><p>想象你是一只蜘蛛，现在你被放到了互联“网”上。那么，你需要把所有的网页都看一遍。怎么办呢？没问题呀，你就随便从某个地方开始，比如说人民日报的首页，这个叫initial pages，用$表示吧。  </p>
<p>在人民日报的首页，你看到那个页面引向的各种链接。于是你很开心地从爬到了“国内新闻”那个页面。太好了，这样你就已经爬完了俩页面（首页和国内新闻）！暂且不用管爬下来的页面怎么处理的，你就想象你把这个页面完完整整抄成了个html放到了你身上。<br>突然你发现，在国内新闻这个页面上，有一个链接链回“首页”。作为一只聪明的蜘蛛，你肯定知道你不用爬回去的吧，因为你已经看过了啊。所以，你需要用你的脑子，存下你已经看过的页面地址。<br>这样，每次看到一个可能需要爬的新链接，你就先查查你脑子里是不是已经去过这个页面地址。如果去过，那就别去了。好的，理论上如果所有的页面可以从initial page达到的话，那么可以证明你一定可以爬完所有的网页。</p>
<h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><ul>
<li>通常的判重做法是怎样呢？Bloom Filter. </li>
<li>简单讲它仍然是一种hash的方法，但是它的特点是，它可以使用固定的内存（不随url的数量而增长）以O(1)的效率判定url是否已经在set中。</li>
<li>可惜天下没有白吃的午餐，它的唯一问题在于，如果这个url不在set中，BF可以100%确定这个url没有看过。但是如果这个url在set中，它会告诉你：这个url应该已经出现过，不过我有2%的不确定性。注意这里的不确定性在你分配的内存足够大的时候，可以变得很小很少。</li>
</ul>
<h3 id="进一步提高效率"><a href="#进一步提高效率" class="headerlink" title="进一步提高效率"></a>进一步提高效率</h3><ul>
<li>另外一个瓶颈——你只有一台机器。不管你的带宽有多大，只要你的机器下载网页的速度是瓶颈的话，那么你只有加快这个速度。用一台机子不够的话——用很多台吧！当然，我们假设每台机子都已经进了最大的效率——使用多线程（python的话，多进程吧）。</li>
<li>我们把这100台中的99台运算能力较小的机器叫作slave，另外一台较大的机器叫作master，那么回顾上面代码中的url_queue，如果我们能把这个queue放到这台master机器上，所有的slave都可以通过网络跟master联通，每当一个slave完成下载一个网页，就向master请求一个新的网页来抓取。而每次slave新抓到一个网页，就把这个网页上所有的链接送到master的queue里去。同样，bloom filter也放到master上，但是现在master只发送确定没有被访问过的url给slave。Bloom Filter放到master的内存里，而被访问过的url放到运行在master上的Redis里，这样保证所有操作都是O(1)。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><em>作者：谢科</em><br><em>链接：<a href="https://www.zhihu.com/question/20899988/answer/24923424">https://www.zhihu.com/question/20899988/answer/24923424</a></em><br><em>来源：知乎</em><br><em>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</em></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>30天自制操作系统（20）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8820%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY20-API"><a href="#DAY20-API" class="headerlink" title="DAY20_API"></a>DAY20_API</h1><h3 id="1-程序整理"><a href="#1-程序整理" class="headerlink" title="1.程序整理"></a>1.程序整理</h3><p>目标：实现由应用程序对操作系统功能的调用（即API，也叫系统调用）。</p>
<h3 id="2-显示单个字符的API-1"><a href="#2-显示单个字符的API-1" class="headerlink" title="2.显示单个字符的API(1)"></a>2.显示单个字符的API(1)</h3><p>目标：显示单个字符的API。</p>
<span id="more"></span>
<ul>
<li>首先我们做一个测试用的应用程序，将要显示的字符编码存入AL寄存器，然后调用操作系<br>统的函数，字符就显示出来了。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[BITS 32] </span><br><span class="line">    MOV AL,&#x27;A&#x27; </span><br><span class="line">    CALL （cons_putchar的地址）</span><br><span class="line">fin: </span><br><span class="line">    HLT </span><br><span class="line">    JMP fin</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>bootpack.map文件<br>这是一个文本文件，用文本编辑器打开即可，其中应该可以找到这样一行：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00000BE3 : _asm_cons_putchar</span><br></pre></td></tr></table></figure><br>这就是_asm_cons_putchar的地址了，因此，我们将地址填在应用程序中.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[BITS 32] </span><br><span class="line">    MOV AL,&#x27;A&#x27; </span><br><span class="line">    CALL 0xbe3 </span><br><span class="line">fin: </span><br><span class="line">    HLT </span><br><span class="line">    JMP fin</span><br></pre></td></tr></table></figure>
<h3 id="3-显示单个字符的API-2"><a href="#3-显示单个字符的API-2" class="headerlink" title="3.显示单个字符的API(2)"></a>3.显示单个字符的API(2)</h3><ul>
<li>应用程序对API执行CALL的时候，千万不能忘记加上段号。</li>
</ul>
<h3 id="4-结束应用程序"><a href="#4-结束应用程序" class="headerlink" title="4.结束应用程序"></a>4.结束应用程序</h3><ul>
<li>C语言中没有用来执行far-CALL的命令，我们只好来创建一个farcall函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_farcall: ; void farcall(int eip, int cs); </span><br><span class="line">    CALL FAR [ESP+4] ; eip, cs </span><br><span class="line">    RET</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-不随操作系统版本而改变的-API"><a href="#5-不随操作系统版本而改变的-API" class="headerlink" title="5.不随操作系统版本而改变的 API"></a>5.不随操作系统版本而改变的 API</h3><h3 id="6-为应用程序自由命名"><a href="#6-为应用程序自由命名" class="headerlink" title="6.为应用程序自由命名"></a>6.为应用程序自由命名</h3><ul>
<li>目标：让系统支持其他应用程序名<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cons_runcmd</span><span class="params">(<span class="type">char</span> *cmdline, <span class="keyword">struct</span> CONSOLE *cons, <span class="type">int</span> *fat, <span class="type">unsigned</span> <span class="type">int</span> memtotal)</span> </span><br><span class="line">&#123; </span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cmdline, <span class="string">&quot;mem&quot;</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">        cmd_mem(cons, memtotal); </span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cmdline, <span class="string">&quot;cls&quot;</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">        cmd_cls(cons); </span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cmdline, <span class="string">&quot;dir&quot;</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">        cmd_dir(cons); </span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(cmdline, <span class="string">&quot;type &quot;</span>, <span class="number">5</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">        cmd_type(cons, fat, cmdline); </span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmdline[<span class="number">0</span>] != <span class="number">0</span>) &#123; <span class="comment">/*从此开始*/</span> </span><br><span class="line">     <span class="keyword">if</span> (cmd_app(cons, fat, cmdline) == <span class="number">0</span>) &#123; </span><br><span class="line">         <span class="comment">/*不是命令，不是应用程序，也不是空行*/</span> </span><br><span class="line">         putfonts8_asc_sht(cons-&gt;sht, <span class="number">8</span>, cons-&gt;cur_y, COL8_FFFFFF, COL8_000000, <span class="string">&quot;Bad command.&quot;</span>, </span><br><span class="line">         <span class="number">12</span>); </span><br><span class="line">         cons_newline(cons); </span><br><span class="line">         cons_newline(cons); </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; <span class="comment">/*到此结束 */</span> </span><br><span class="line">     <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="7-当心寄存器"><a href="#7-当心寄存器" class="headerlink" title="7.当心寄存器"></a>7.当心寄存器</h3><ul>
<li>命名只显示一个h</li>
<li>给_asm_cons_putchar添上2行代码，就是PUSHAD和POPAD。</li>
</ul>
<h3 id="8-用API显示字符"><a href="#8-用API显示字符" class="headerlink" title="8.用API显示字符"></a>8.用API显示字符</h3><ul>
<li>从实际的应用程序开发角度来说，能显示字符串的API远比只能显示单个字符的API要来的方便，因为一次显示一串字符的情况比一次只显示一个字符的情况多得多。</li>
<li>一般有两种方式：<ul>
<li>种是显示一串字符，遇到字符编码0则结束；</li>
<li>先指定好要显示的字符串的长度再显示。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">功能号 1……显示单个字符（AL = 字符编码）</span><br><span class="line">功能号 2……显示字符串 0（EBX = 字符串地址）</span><br><span class="line">功能号 3……显示字符串 1（EBX = 字符串地址，ECX = 字符串长度）</span><br></pre></td></tr></table></figure>
<ul>
<li>将_asm_cons_putchar改写成一个新的函数。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_asm_hrb_api:</span><br><span class="line">    STI</span><br><span class="line">    PUSHAD;</span><br><span class="line">    PUSHAD;</span><br><span class="line">    CALL _hrb_api</span><br><span class="line">    ADD ESP,32</span><br><span class="line">    POPAD</span><br><span class="line">    IRETD</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（19）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8819%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY19-应用程序"><a href="#DAY19-应用程序" class="headerlink" title="DAY19_应用程序"></a>DAY19_应用程序</h1><h3 id="1-type命令"><a href="#1-type命令" class="headerlink" title="1.type命令"></a>1.type命令</h3><ul>
<li>在Windows的命令行中，有一个叫做type的命令，输入“type 文件名”就会显示出文件的内容。</li>
</ul>
<span id="more"></span>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">磁盘映像中的地址 = clustno * 512 + 0x003e00</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>将s[0～10]这11个字节用空格的字符编码填充，然后读取cmdline[5～]并复制到s[0～]，在复制的同时，将其中的小写字母转换为大写字母。随后，当遇到句点时，则可以断定接下来的部分为扩展名，于是将复制的目标改为s[8～]。经过这样的转换，我们就得到了和磁盘内格式相同的文件名。</li>
<li>“寻找文件”这一段中，我们在磁盘中寻找与所输入的文件名相符的文件。如果成功找到指<br>定文件，则用break跳出for循环；如果找不到，则会在x到达224或者finfo[x].name[0]为0x00时结束循环。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* type命令*/</span> </span><br><span class="line"> <span class="comment">/*准备文件名*/</span> </span><br><span class="line"> <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">11</span>; y++) &#123; </span><br><span class="line">    s[y] = <span class="string">&#x27; &#x27;</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> y = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">for</span> (x = <span class="number">5</span>; y &lt; <span class="number">11</span> &amp;&amp; cmdline[x] != <span class="number">0</span>; x++) &#123; </span><br><span class="line">    <span class="keyword">if</span> (cmdline[x] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; y &lt;= <span class="number">8</span>) &#123; </span><br><span class="line">    y = <span class="number">8</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    s[y] = cmdline[x]; </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> &lt;= s[y] &amp;&amp; s[y] &lt;= <span class="string">&#x27;z&#x27;</span>) &#123; </span><br><span class="line">        <span class="comment">/*将小写字母转换成大写字母 */</span> </span><br><span class="line">        s[y] -= <span class="number">0x20</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    y++; </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">/*寻找文件*/</span> </span><br><span class="line"> <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">224</span>; ) &#123; </span><br><span class="line">    <span class="keyword">if</span> (finfo[x].name[<span class="number">0</span>] == <span class="number">0x00</span>) &#123; </span><br><span class="line">    <span class="keyword">break</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> ((finfo[x].type &amp; <span class="number">0x18</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">11</span>; y++) &#123; </span><br><span class="line">    <span class="keyword">if</span> (finfo[x].name[y] != s[y]) &#123; </span><br><span class="line">        <span class="keyword">goto</span> type_next_file; </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">break</span>; <span class="comment">/*找到文件*/</span> </span><br><span class="line"> &#125; </span><br><span class="line"> type_next_file: </span><br><span class="line"> x++; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (x &lt; <span class="number">224</span> &amp;&amp; finfo[x].name[<span class="number">0</span>] != <span class="number">0x00</span>) &#123; </span><br><span class="line">    <span class="comment">/*找到文件的情况*/</span> </span><br><span class="line">    y = finfo[x].size;</span><br><span class="line">    p = (<span class="type">char</span> *) (finfo[x].clustno * <span class="number">512</span> + <span class="number">0x003e00</span> + ADR_DISKIMG); </span><br><span class="line">    cursor_x = <span class="number">8</span>; </span><br><span class="line"> <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; y; x++) &#123; </span><br><span class="line">    <span class="comment">/*逐字输出*/</span> </span><br><span class="line">    s[<span class="number">0</span>] = p[x]; </span><br><span class="line">    s[<span class="number">1</span>] = <span class="number">0</span>; </span><br><span class="line">    putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, s, <span class="number">1</span>); </span><br><span class="line">     cursor_x += <span class="number">8</span>; </span><br><span class="line">    <span class="keyword">if</span> (cursor_x == <span class="number">8</span> + <span class="number">240</span>) &#123; <span class="comment">/*到达最右端后换行*/</span> </span><br><span class="line">    cursor_x = <span class="number">8</span>; </span><br><span class="line">    cursor_y = cons_newline(cursor_y, sheet); </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="comment">/*没有找到文件的情况*/</span> </span><br><span class="line"> putfonts8_asc_sht(sheet, <span class="number">8</span>, cursor_y, COL8_FFFFFF, COL8_000000, <span class="string">&quot;File </span></span><br><span class="line"><span class="string"> not found.&quot;</span>, <span class="number">15</span>); </span><br><span class="line"> cursor_y = cons_newline(cursor_y, sheet); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-type命令改良"><a href="#2-type命令改良" class="headerlink" title="2.type命令改良"></a>2.type命令改良</h3><ul>
<li><p>目标：实现对换行的支持。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x09……制表符：显示空格直到 x 被 4 整除为止</span><br><span class="line">0x0a……换行符：换行</span><br><span class="line">0x0d……回车符：忽略</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们这里所说的制表符也称为水平制表符（horizonal tab），因为对齐字符位置是在水平方向上移动。相对的，还有一种垂直制表符（vertical tab）</p>
</li>
<li>在Windows中换行的字符编码为“0x0d 0x0a”两个字节，而Linux中只有“0x0a”一个字节。<ul>
<li>字符编码0x0a原本代表折行（line feed）的意思，即只是移动到下一行。</li>
<li>0x0d，也就是回车符的文字编码，代表“让打印头（或者打字机的辊筒）回到行首”的意思，因此才被称为“回车”（carriage return）。</li>
</ul>
</li>
</ul>
<h3 id="3-对FAT的支持"><a href="#3-对FAT的支持" class="headerlink" title="3.对FAT的支持"></a>3.对FAT的支持</h3><ul>
<li>现在的type命令，肯定可以正确显示文件开头的512个字节的内容，但是如果遇到大于512个字节的文件，中间可能就会突然显示出其他文件的内容。</li>
<li>对于文件的下一段存放在哪里，在磁盘中是有记录的，我们只要分析这个记录，就可以正确读取文件内容了。</li>
<li>它位于从0柱面、0磁头、2扇区开始的9个扇区中，在磁盘映像中相当于0x000200～0x0013ff。这个记录被称为FAT，是“file allocation table”的缩写，翻译过来叫作“文件分配表”（即记录文件在磁盘中存放位置的表）。</li>
</ul>
<h3 id="4-代码整理"><a href="#4-代码整理" class="headerlink" title="4.代码整理"></a>4.代码整理</h3><ul>
<li>窗口相关函数 → window.c </li>
<li>命令行窗口相关函数 → console.c </li>
<li>文件相关函数 → file.c</li>
</ul>
<h3 id="5-第一个应用程序"><a href="#5-第一个应用程序" class="headerlink" title="5.第一个应用程序"></a>5.第一个应用程序</h3><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[BITS 32] </span><br><span class="line">fin: </span><br><span class="line"> HLT </span><br><span class="line"> JMP fin</span><br></pre></td></tr></table></figure></h2><ul>
<li>像type命令一样，我们用file_loadfile将文件的内容读到内存中</li>
<li>应用程序不知道自己被读到哪个内存地址，这里暂且由ORG0来生成。因此，为了应用程序能够顺利运行，我们需要为其创建一个内存段。</li>
<li>段创建好之后，接下来只要goto到该段中的程序，程序应该就会开始运行了。要goto到其他的内存段，在汇编语言中用farjmp指令。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">11</span>; y++) &#123; </span><br><span class="line">     s[y] = <span class="string">&#x27; &#x27;</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> s[<span class="number">0</span>] = <span class="string">&#x27;H&#x27;</span>; </span><br><span class="line"> s[<span class="number">1</span>] = <span class="string">&#x27;L&#x27;</span>; </span><br><span class="line"> s[<span class="number">2</span>] = <span class="string">&#x27;T&#x27;</span>; </span><br><span class="line"> s[<span class="number">8</span>] = <span class="string">&#x27;H&#x27;</span>; </span><br><span class="line"> s[<span class="number">9</span>] = <span class="string">&#x27;R&#x27;</span>; </span><br><span class="line"> s[<span class="number">10</span>] = <span class="string">&#x27;B&#x27;</span>; </span><br><span class="line"> <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">224</span>; ) &#123; </span><br><span class="line">     <span class="keyword">if</span> (finfo[x].name[<span class="number">0</span>] == <span class="number">0x00</span>) &#123; </span><br><span class="line">     <span class="keyword">break</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> ((finfo[x].type &amp; <span class="number">0x18</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">     <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">11</span>; y++) &#123; </span><br><span class="line">         <span class="keyword">if</span> (finfo[x].name[y] != s[y]) &#123; </span><br><span class="line">         <span class="keyword">goto</span> hlt_next_file; </span><br><span class="line">         &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">/*找到文件*/</span> </span><br><span class="line">     &#125; </span><br><span class="line">     hlt_next_file: </span><br><span class="line">     x++; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (x &lt; <span class="number">224</span> &amp;&amp; finfo[x].name[<span class="number">0</span>] != <span class="number">0x00</span>) &#123; </span><br><span class="line">     <span class="comment">/*找到文件的情况*/</span> </span><br><span class="line">     p = (<span class="type">char</span> *) memman_alloc_4k(memman, finfo[x].size); </span><br><span class="line">     file_loadfile(finfo[x].clustno, finfo[x].size, p, fat, (<span class="type">char</span> *) </span><br><span class="line">     (ADR_DISKIMG + <span class="number">0x003e00</span>)); </span><br><span class="line">     set_segmdesc(gdt + <span class="number">1003</span>, finfo[x].size - <span class="number">1</span>, (<span class="type">int</span>) p, AR_CODE32_ER); </span><br><span class="line">     farjmp(<span class="number">0</span>, <span class="number">1003</span> * <span class="number">8</span>); </span><br><span class="line">     memman_free_4k(memman, (<span class="type">int</span>) p, finfo[x].size); </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="comment">/*没有找到文件的情况*/</span> </span><br><span class="line">     putfonts8_asc_sht(sheet, <span class="number">8</span>, cursor_y, COL8_FFFFFF, COL8_000000, <span class="string">&quot;File </span></span><br><span class="line"><span class="string">     not found.&quot;</span>, <span class="number">15</span>); </span><br><span class="line">     cursor_y = cons_newline(cursor_y, sheet); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">/*到此结束*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>循环赛赛程安排</title>
    <url>/201904/%E5%BE%AA%E7%8E%AF%E8%B5%9B%E8%B5%9B%E7%A8%8B%E5%AE%89%E6%8E%92/</url>
    <content><![CDATA[<h1 id="算法设计与分析实验报告-2019-4-13"><a href="#算法设计与分析实验报告-2019-4-13" class="headerlink" title="算法设计与分析实验报告 2019.4.13"></a>算法设计与分析实验报告 2019.4.13</h1><h3 id="循环赛赛程安排"><a href="#循环赛赛程安排" class="headerlink" title="循环赛赛程安排"></a>循环赛赛程安排</h3><h2 id="一、问题重述"><a href="#一、问题重述" class="headerlink" title="一、问题重述"></a>一、问题重述</h2><p>设有n个运动员要进行网球循环赛。设计一个满足下列条件的比赛日程表：</p>
<ul>
<li>每个选手必须与其他n-1个选手各赛一次；</li>
<li>每个选手一天只能赛一次；</li>
<li>当n是偶数时，循环赛进行n-1天。</li>
<li>当n是奇数时，循环赛进行n天。</li>
</ul>
<span id="more"></span>
<h2 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h2><h4 id="1-当n是2的次幂时"><a href="#1-当n是2的次幂时" class="headerlink" title="1.当n是2的次幂时"></a>1.当n是2的次幂时</h4><p> $ n=2^k,k=1,2,3,4… $时，此时问题比较简单。按照==分治==的策略，可将所有参赛的选手分为两部分，$ n＝2k $个选手的比赛日程表可以通过为 $ n/2＝2k-1 $ 个选手设计的比赛日程表来决定。递归地执行这种分割，直到只剩下 2 个选手时，比赛日程表的制定就变得很简单：只要让这 2 个选手进行比赛就可以了。再逐步合并子问题的解即可得到原问题的解。<br> 示意图如下：</p>
<p><img src="https://s2.ax1x.com/2019/04/13/ALTauj.jpg" alt="1.1"></p>
<p>此时的分治算法如下所示:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void tourna(int n) //基本的分治算法</span><br><span class="line">&#123;</span><br><span class="line">    if(n==1)&#123;a[0][0]=1;return;&#125;</span><br><span class="line">    tourna(n/2); //分治</span><br><span class="line">    copy(n); //合并</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void copy(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int m=n/2;</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">        //由左上角小块的值算出对应的右上角小块的值</span><br><span class="line">        a[i][j+m]=a[i][j]+m;</span><br><span class="line">        //由右上角小块的值算出对应的左下角小块的值</span><br><span class="line">        a[i+m][j]=a[i][j+m];</span><br><span class="line">        //由左上角小块的值算出对应的右下角小块的值</span><br><span class="line">        a[i+m][j+m]=a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们用a[i][j]表示第i支队伍在第j天遇到的对手。</p>
<h4 id="2-当n不是2的次幂时"><a href="#2-当n不是2的次幂时" class="headerlink" title="2.当n不是2的次幂时"></a>2.当n不是2的次幂时</h4><p>下面讨论当n不是2的次幂时的情况。<br>我们发现当n为奇数时，每天必定有一支队伍轮空。此时我们==假定还有一只不存在的队伍与轮空的队伍比赛==，将我们的奇偶数情况的模型统一。此时n的赛程表与偶数n+1时的赛程表是相似的。<br>比如，当n=4时<br>| 0 | 1 | 2 | 3 |<br>|—-|—-|—-|—-|<br>| 1 | 0 | 3 | 2 |<br>| 2 | 3 | 0 | 1 |<br>| 3 | 2 | 1 | 0 |</p>
<p>当n=3时<br>| 0 | 1 | 2 | / |<br>|—-|—-|—-|—-|<br>| 1 | 0 | / | 2 |<br>| 2 | / | 0 | 1 |<br>| / | 2 | 1 | 0 |</p>
<p>(删去最后一行)其中“/”表示轮空。</p>
<p>综上，当遇到n为奇数的情况，我们便可以转化为偶数来考虑。</p>
<p>接下来我们遇到问题的难点==矩阵的合并==<br>当n/2为偶数时，合并比较容易，就像$ n=2^k $那样。<br>下面我们来考虑n/2为奇数的情况。<br>此时合并的过程我参考了<a href="https://www.cnblogs.com/zhuyijie/p/6465812.html">猪一戒的博客</a></p>
<p>我们考虑当n=6时的情况。<br>我们先将6个人分成2组，每组3个人（[0，1,2],[3,4,5]），然后发现3是个奇数，然后在每组中+1个虚拟人：X和Y；这样，每组就变成了4个人，然后将这4个人在除以2，我们就得到了一个两两组合的小的组。</p>
<p>首先来看[0，1]; [2,x]</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>2</th>
<th>x</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>将这两组合起来：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>x</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>x</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>x</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>x</td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>这里要得到3个选手的比赛安排，所以，我们将假想的X去掉，并将它的位置以/代替：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>/</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>/</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>/</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>然后我们也按照这个规律，安排[3,4,5]的日程，得到表格<br>| 3 | 4 | 5 | / |<br>|—-|—-|—-|—-|<br>| 4 | 3 | / | 5 |<br>| 5 | / | 3 | 4 |</p>
<p>我们得到了两个3x4的矩阵（其中第一列表示每个队伍，实际上只有三天），我们最终想得到6*6（其中第一列表示每个队伍，实际上只有五天）的矩阵。</p>
<p>我们先将上面两个矩阵合并</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>/</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>/</td>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>/</td>
<td>0</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>5</td>
<td>/</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>/</td>
<td>5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>/</td>
<td>3</td>
<td>4</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p> 前三天的比赛已经基本排完了，我们只需要在斜杠/的地方填上相应的比赛。很显然可以让每天轮空的两支队伍比赛。（在程序中没有斜杠表示，还是假想的队伍，方便进行监测）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>4</td>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>5</td>
<td>0</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>5</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>1</td>
<td>5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>上面的矩阵中[0,1,2]和[3,4,5]组内已经比完了，组间比了一次，剩下的只需要轮换两次即可得到后两天的比赛情况。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>4</td>
<td>2</td>
<td>5</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>5</td>
<td>0</td>
<td>1</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>5</td>
<td>0</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>1</td>
<td>5</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>于是我们便可以得到两个奇数矩阵的合并情况。</p>
<p>在程序中，我们的思路不是严格意义上的所谓的“合并”，而是“扩展”。比如对于“合并2个3x4的矩阵”，我们是“将1个3x4的矩阵扩展为6x6的矩阵”（因为这两个3x4的矩阵规格相同，排序顺序一样，所以只需要做一遍）</p>
<h2 id="三、代码展示"><a href="#三、代码展示" class="headerlink" title="三、代码展示"></a>三、代码展示</h2><p>（代码里有一些打印行号的printf语句，不知道为啥一去掉就过不了编译，所以没有删掉。。）<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&quot;Check.cpp&quot;</span><br><span class="line"></span><br><span class="line">void copy(int n, int **a)//偶数情况</span><br><span class="line">&#123;</span><br><span class="line">	//printf(&quot;当前行号%05d\n&quot;,__LINE__);</span><br><span class="line">	int m=n/2;</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">			//由左上角小块的值算出对应的右上角小块的值</span><br><span class="line">			a[i][j+m]=a[i][j]+m;</span><br><span class="line">			//由右上角小块的值算出对应的左下角小块的值</span><br><span class="line">			a[i+m][j]=a[i][j+m];</span><br><span class="line">			//由左上角小块的值算出对应的右下角小块的值</span><br><span class="line">			a[i+m][j+m]=a[i][j];</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void copyodd(int n, int **a) // n/2 为奇数时的合并算法</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;当前行号%05d\n&quot;,__LINE__);</span><br><span class="line">	int m=n/2;</span><br><span class="line">	int b[m];</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		b[i]=m+i;</span><br><span class="line">		b[m+i]=b[i];</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		//由左上角小块的值算出相应的左下角小块的值</span><br><span class="line">		for(int j=0;j&lt;m+1;j++)&#123;</span><br><span class="line">			if(a[i][j]&gt;=m)&#123;</span><br><span class="line">				a[i][j]=b[i];</span><br><span class="line">				a[m+i][j]=(b[i]+m)%n;</span><br><span class="line">			&#125;	else a[m+i][j]=a[i][j]+m;</span><br><span class="line">		&#125;</span><br><span class="line">		//由左上角小块的值算出相应的右上角和右下角小块的值</span><br><span class="line">		for(int j=1;j&lt;m;j++)&#123;</span><br><span class="line">			a[i][m+j]=b[i+j];</span><br><span class="line">			a[b[i+j]][m+j]=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void merge(int n, int **a) //合并算法</span><br><span class="line">&#123;</span><br><span class="line">	if((n/2)&gt;1 &amp;&amp; (n/2)%2 == 1) copyodd(n,a); //n/2 为奇数时,注意是 (n/2)%2 == 1，n别忘了/2 </span><br><span class="line">	else copy(n,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void tournament(int n, int **a) //循环赛算法</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;当前行号%05d\n&quot;,__LINE__);</span><br><span class="line">	if(n==1)&#123;a[0][0]=0;return;&#125;</span><br><span class="line">	if(n%2 == 1)	&#123;tournament(n+1,a);return;&#125; //n为奇数，分治</span><br><span class="line">	tournament(n/2,a); //n为偶数，分治</span><br><span class="line">	merge(n,a); //合并</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	</span><br><span class="line">	//创建数组</span><br><span class="line">	int **a;</span><br><span class="line">	a = (int**)malloc(sizeof(int*)*n);</span><br><span class="line">	</span><br><span class="line">	if(n%2==1)&#123;</span><br><span class="line">		for(int i=0; i&lt;n+1; i++)	a[i] = (int*)malloc(sizeof(int)*(n+1));</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		for(int i=0; i&lt;n; i++)	a[i] = (int*)malloc(sizeof(int)*n);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//生成循坏赛矩阵</span><br><span class="line">	tournament(n,a);</span><br><span class="line">	</span><br><span class="line">	//打印</span><br><span class="line">	printf(&quot;当前行号:%05d\n&quot;,__LINE__);</span><br><span class="line">	for(int i=0; i&lt;n; i++)&#123;</span><br><span class="line">		for(int j=1; j&lt;(n%2 == 1 ? n+1 : n); j++)&#123;</span><br><span class="line">			if(a[i][j]&lt;n)	printf(&quot;%d &quot;,a[i][j]);</span><br><span class="line">			else printf(&quot;x &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//检验程序</span><br><span class="line">	if(Check(a,n)==1) printf(&quot;This gametable is availuable.\n&quot;);</span><br><span class="line">	else printf(&quot;This gametable is unavailuable.\n&quot;);</span><br><span class="line">	if(n%2 ==1)&#123;</span><br><span class="line">		for(int i=0; i&lt;n; i++)	free(a[i]);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		for(int i=0; i&lt;n+1; i++)	free(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	free(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="四、测试程序"><a href="#四、测试程序" class="headerlink" title="四、测试程序"></a>四、测试程序</h2><p>测试程序对我们生成的矩阵进行检验。从两个角度进行。</p>
<ul>
<li>每个队伍都要和其他队伍进行一场比赛</li>
<li>每个队伍每天仅进行一场比赛</li>
</ul>
<p>测试程序代码如下<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Check(int **a, int n)</span><br><span class="line">&#123;</span><br><span class="line">	int column;</span><br><span class="line">	if(n%2==1) column=n+1;</span><br><span class="line">	else column=n;</span><br><span class="line">	int flag=0;</span><br><span class="line">	int check=1;//check为0说明不符合条件，停止检验。 </span><br><span class="line">	//检验每个队伍都与其他队伍比赛 </span><br><span class="line">	for(int i=0; i&lt;n&amp;&amp;check==1; i++)&#123;</span><br><span class="line">		for(int k=0; k&lt;n&amp;&amp;check==1; k++)&#123;</span><br><span class="line">			flag=0;</span><br><span class="line">			for(int j=0;j&lt;column&amp;&amp;flag==0;j++)&#123;</span><br><span class="line">				if(a[i][j] == k) flag=1;</span><br><span class="line">			&#125;</span><br><span class="line">			if(flag==0) check=0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//检验某天是否有队伍重复比赛</span><br><span class="line">	int times[n];</span><br><span class="line">	for(int j=1; j&lt;column&amp;&amp;check==1; j++)&#123;</span><br><span class="line">		for(int w=0; w&lt;n; w++) times[w]=0;</span><br><span class="line">		for(int i=0; i&lt;n&amp;&amp;check==1; i++)&#123;</span><br><span class="line">			times[a[i][j]]++;</span><br><span class="line">			if(times[a[i][j]]&gt;=2) check==0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	if(check==1) return 1;</span><br><span class="line">	else return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="五、实验结果"><a href="#五、实验结果" class="headerlink" title="五、实验结果"></a>五、实验结果</h2><ul>
<li>当n=6时</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/04/13/ALb4Vs.jpg" alt="1.2"></p>
<ul>
<li>当n=9时</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/04/13/ALb5an.jpg" alt="1.3"></p>
<p>测试结果均正确。</p>
<p><em>参考文献</em><br><em>[1]王民川,田永轩.分治法在循环赛日程表设计中的应用[J].光盘技术,2009(05):45-46.</em></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title>30天自制操作系统（18）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8818%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY18-dir命令"><a href="#DAY18-dir命令" class="headerlink" title="DAY18_dir命令"></a>DAY18_dir命令</h1><h3 id="1-控制光标闪烁-1"><a href="#1-控制光标闪烁-1" class="headerlink" title="1.控制光标闪烁(1)"></a>1.控制光标闪烁(1)</h3><ul>
<li>在Windows中，只有可以接受键盘输入的窗口有光标闪烁，而其他的窗口中是不显示光标的。</li>
<li>对HariMain进行改写</li>
</ul>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/*从此开始*/</span> <span class="keyword">if</span> (cursor_c &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">        boxfill8(sht_win-&gt;buf, sht_win-&gt;bxsize, cursor_c, cursor_x, <span class="number">28</span>, cursor_x + <span class="number">7</span>, <span class="number">43</span>); </span><br><span class="line">    <span class="comment">/*到此结束*/</span> &#125; </span><br><span class="line">         sheet_refresh(sht_win, cursor_x, <span class="number">28</span>, cursor_x + <span class="number">8</span>, <span class="number">44</span>); </span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">512</span> &lt;= i &amp;&amp; i &lt;= <span class="number">767</span>) &#123; <span class="comment">/*鼠标数据*/</span> </span><br><span class="line">     （中略）</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123; <span class="comment">/*光标用定时器*/</span> </span><br><span class="line">    <span class="comment">/*从此开始*/</span> <span class="keyword">if</span> (i != <span class="number">0</span>) &#123; </span><br><span class="line">         timer_init(timer, &amp;fifo, <span class="number">0</span>); <span class="comment">/*下次置0 */</span> </span><br><span class="line">     <span class="keyword">if</span> (cursor_c &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">        cursor_c = COL8_000000; </span><br><span class="line">     &#125; </span><br><span class="line">     &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">         timer_init(timer, &amp;fifo, <span class="number">1</span>); <span class="comment">/*下次置1 */</span> </span><br><span class="line">         <span class="keyword">if</span> (cursor_c &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">         cursor_c = COL8_FFFFFF; </span><br><span class="line">        &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     timer_settime(timer, <span class="number">50</span>); </span><br><span class="line">     <span class="keyword">if</span> (cursor_c &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">     boxfill8(sht_win-&gt;buf, sht_win-&gt;bxsize, cursor_c, cursor_x, <span class="number">28</span>, cursor_x + </span><br><span class="line">     <span class="number">7</span>, <span class="number">43</span>); </span><br><span class="line">     sheet_refresh(sht_win, cursor_x, <span class="number">28</span>, cursor_x + <span class="number">8</span>, <span class="number">44</span>); </span><br><span class="line">    <span class="comment">/*到此结束*/</span> &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-控制光标闪烁-2"><a href="#2-控制光标闪烁-2" class="headerlink" title="2.控制光标闪烁(2)"></a>2.控制光标闪烁(2)</h3><ul>
<li>实现命令行窗口中光标闪烁的控制。</li>
<li>像传递按键编码一样，我们可以使用FIFO来实现。</li>
<li>我们先将光标开始闪烁定义为2，停止闪烁定义为3。</li>
</ul>
<hr>
<h3 id="3-对回车键的支持"><a href="#3-对回车键的支持" class="headerlink" title="3.对回车键的支持"></a>3.对回车键的支持</h3><ul>
<li>应该对输入的字符进行判断，然后执行相应的命令<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/*从此开始*/</span> <span class="keyword">if</span> (i == <span class="number">256</span> + <span class="number">0x1c</span>) &#123; <span class="comment">/*回车键*/</span> </span><br><span class="line">     <span class="keyword">if</span> (key_to != <span class="number">0</span>) &#123; <span class="comment">/*发送至命令行窗口*/</span> </span><br><span class="line">        fifo32_put(&amp;task_cons-&gt;fifo, <span class="number">10</span> + <span class="number">256</span>); </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">/*到此结束*/</span> &#125; </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-对窗口滚动的支持"><a href="#4-对窗口滚动的支持" class="headerlink" title="4.对窗口滚动的支持"></a>4.对窗口滚动的支持</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void console_task(struct SHEET *sheet) </span><br><span class="line">&#123; </span><br><span class="line"> （中略）</span><br><span class="line"> int x, y;</span><br><span class="line">  （中略）</span><br><span class="line"> for (;;) &#123; </span><br><span class="line">     io_cli(); </span><br><span class="line">     if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; </span><br><span class="line">     （中略）</span><br><span class="line"> &#125; else &#123; </span><br><span class="line">    （中略）</span><br><span class="line"> if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /*键盘数据（通过任务A） */ </span><br><span class="line"> if (i == 8 + 256) &#123; </span><br><span class="line">     /*退格键*/ </span><br><span class="line">     （中略）</span><br><span class="line"> &#125; else if (i == 10 + 256) &#123; </span><br><span class="line">     /* Enter */ </span><br><span class="line">     /*用空格将光标擦除*/ </span><br><span class="line">     putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, &quot; &quot;, 1); </span><br><span class="line">/*从此开始 */ if (cursor_y &lt; 28 + 112) &#123; </span><br><span class="line"> cursor_y += 16; /*换行*/ </span><br><span class="line"> &#125; else &#123; </span><br><span class="line">     /*滚动*/ </span><br><span class="line">     for (y = 28; y &lt; 28 + 112; y++) &#123; </span><br><span class="line">     for (x = 8; x &lt; 8 + 240; x++) &#123; </span><br><span class="line">     sheet-&gt;buf[x + y * sheet-&gt;bxsize] = sheet-&gt;buf[x + (y + 16) * </span><br><span class="line">     sheet-&gt;bxsize]; </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> for (y = 28 + 112; y &lt; 28 + 128; y++) &#123; </span><br><span class="line">    for (x = 8; x &lt; 8 + 240; x++) &#123; </span><br><span class="line">        sheet-&gt;buf[x + y * sheet-&gt;bxsize] = COL8_000000; </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> sheet_refresh(sheet, 8, 28, 8 + 240, 28 + 128); </span><br><span class="line"> &#125; </span><br><span class="line"> /*显示提示符*/ </span><br><span class="line"> putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, &quot;&gt;&quot;, 1); </span><br><span class="line">/*到此为止*/ cursor_x = 16; </span><br><span class="line"> &#125; else &#123; </span><br><span class="line"> /*一般字符*/ </span><br><span class="line"> （中略）</span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> （中略）</span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-mem命令"><a href="#5-mem命令" class="headerlink" title="5.mem命令"></a>5.mem命令</h3><p>我们已经实现了屏幕滚动，现在该是到了让它执行命令的时候了。<br>mem命令就是memeory的缩写，也就是用来显示内存使用情况的命令。</p>
<hr>
<ul>
<li>介绍一下重点。首先我们添加了memtotal和memman两个变量，它们是执行mem命令所必需的。关于memtotal，我们采用和sheet相同的方法从HariMain传递过来，因此我们还要改写一下HariMain。</li>
<li>我们还添加了一个cmdline变量，也就是“命令行”（command line）的缩写。这个变量用来记录通过键盘输入的内容，在“键盘数据”处理的“一般字符”部分，将输入的内容顺次累积起来。</li>
</ul>
<h3 id="6-cls命令"><a href="#6-cls命令" class="headerlink" title="6.cls命令"></a>6.cls命令</h3><ul>
<li>这个命令的作用是清除屏幕上的内容，也就是“clear screen”（清屏）的缩写。顺便补充个小知识，在Linux中清屏命令是“clear”。<br>代码精简：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (c[0] == &#x27;m&#x27; &amp;&amp; c[1] == &#x27;e&#x27; &amp;&amp; c[2] == &#x27;m&#x27; &amp;&amp; c[3] == 0) &#123;</span><br></pre></td></tr></table></figure>
改成：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (strcmp(cmdline, &quot;mem&quot;) == 0) &#123;</span><br></pre></td></tr></table></figure>
strcmp这个函数，只要声明#include<string.h>即可使用，因此在bootpack.c中我们也要用它。</li>
</ul>
<h3 id="7-dir命令"><a href="#7-dir命令" class="headerlink" title="7. dir命令"></a>7. dir命令</h3><ul>
<li>我们的目标是制作可执行文件（比如.exe）来让它运行。</li>
<li>过在此之前，我们先来制作一个显示磁盘内文件名称的命令吧。</li>
<li>dir指令除了会显示文件名，还会显示文件的日期和大小。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（17）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8817%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY17-命令行窗口"><a href="#DAY17-命令行窗口" class="headerlink" title="DAY17_命令行窗口"></a>DAY17_命令行窗口</h1><h2 id="1-闲置任务"><a href="#1-闲置任务" class="headerlink" title="1.闲置任务"></a>1.闲置任务</h2><ul>
<li>即使不改写程序，也能自动在适当的LEVEL运行适当的任务，这样的操作系统才是优秀的操作系统</li>
<li>因此，一般情况下可以让任务休眠，但当所有LEVEL中都没有任务存在的时候，就需要HTL了。接下来我们就按照这个要求来改写mtask.c。</li>
<li>如果“所有LEVEL中都没有任务”就会出问题，那我们只要避免这种情况发生不就可以了吗？这类似于我们写定时器的时候所采用的“卫兵”的思路。</li>
</ul>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void task_idle(void) </span><br><span class="line">&#123; </span><br><span class="line">    for (;;) &#123; </span><br><span class="line">        io_hlt(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>综上所述，我们完全不需要对task_sleep等代码进行任何改动，只需在task_init中将这个闲置任务放在最下层LEVEL中就可以了。</li>
</ul>
<h2 id="2-创建命令行窗口"><a href="#2-创建命令行窗口" class="headerlink" title="2.创建命令行窗口"></a>2.创建命令行窗口</h2><h2 id="3-切换输入窗口"><a href="#3-切换输入窗口" class="headerlink" title="3.切换输入窗口"></a>3.切换输入窗口</h2><ul>
<li>目标：我们要让系统在按下“Tab”键的时候，将输入窗口切换到命令行窗口上去。</li>
<li>我们先改变窗口标题栏的颜色。</li>
</ul>
<h2 id="4-实现字符输入"><a href="#4-实现字符输入" class="headerlink" title="4.实现字符输入"></a>4.实现字符输入</h2><ul>
<li>要实现字符的输入，只要在键盘被按下的时候向console_task的FIFO发送数据即可。</li>
<li>我们还是把struct FIFO放到struct TASK里面去吧。基本上没有什么任务是完全用不到FIFO的，因此我们把它们绑定起来</li>
<li>在向命令行窗口发送键盘数据的时候，并不是直接发送从键盘接收到的原始数据，而是发送经过keytable[]转换后的值。究其原因，是由于这样做可以省去在命令行窗口任务中将按键编码转换成字符编码的步骤<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void console_task(struct SHEET *sheet) </span><br><span class="line">&#123; </span><br><span class="line"> struct TIMER *timer; </span><br><span class="line"> struct TASK *task = task_now(); </span><br><span class="line"> int i, fifobuf[128], cursor_x = 16, cursor_c = COL8_000000; </span><br><span class="line"> char s[2]; </span><br><span class="line"> fifo32_init(&amp;task-&gt;fifo, 128, fifobuf, task); </span><br><span class="line"> timer = timer_alloc(); </span><br><span class="line"> timer_init(timer, &amp;task-&gt;fifo, 1); </span><br><span class="line"> timer_settime(timer, 50); </span><br><span class="line"> /*显示提示符*/ </span><br><span class="line"> putfonts8_asc_sht(sheet, 8, 28, COL8_FFFFFF, COL8_000000, &quot;&gt;&quot;, 1); </span><br><span class="line"> for (;;) &#123; </span><br><span class="line">    io_cli(); </span><br><span class="line">    if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; </span><br><span class="line">        task_sleep(task); </span><br><span class="line">        io_sti(); </span><br><span class="line">    &#125; else &#123; </span><br><span class="line">        i = fifo32_get(&amp;task-&gt;fifo); </span><br><span class="line">             io_sti(); </span><br><span class="line">             if (i &lt;= 1) &#123; /*光标用定时器*/ </span><br><span class="line">                if (i != 0) &#123; </span><br><span class="line">                    timer_init(timer, &amp;task-&gt;fifo, 0); /*接下来置0 */ </span><br><span class="line">                    cursor_c = COL8_FFFFFF; </span><br><span class="line">                &#125; else &#123; </span><br><span class="line">                    timer_init(timer, &amp;task-&gt;fifo, 1); /*接下来置1 */ </span><br><span class="line">                    cursor_c = COL8_000000; </span><br><span class="line">                &#125; </span><br><span class="line">                timer_settime(timer, 50); </span><br><span class="line">             &#125; </span><br><span class="line">             if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /*键盘数据（通过任务A） */ </span><br><span class="line">                if (i == 8 + 256) &#123;</span><br><span class="line">                /*退格键*/ </span><br><span class="line">                if (cursor_x &gt; 16) &#123; </span><br><span class="line">                    /*用空白擦除光标后将光标前移一位*/ </span><br><span class="line">                    putfonts8_asc_sht(sheet, cursor_x, 28, COL8_FFFFFF, COL8_000000, &quot; &quot;, 1); </span><br><span class="line">                    cursor_x -= 8; </span><br><span class="line">                 &#125; </span><br><span class="line">             &#125; else &#123; </span><br><span class="line">                /*一般字符*/ </span><br><span class="line">                if (cursor_x &lt; 240) &#123; </span><br><span class="line">                    /*显示一个字符之后将光标后移一位 */ </span><br><span class="line">                    s[0] = i - 256; </span><br><span class="line">                    s[1] = 0; </span><br><span class="line">                    putfonts8_asc_sht(sheet, cursor_x, 28, COL8_FFFFFF, COL8_000000, s, 1); </span><br><span class="line">                    cursor_x += 8; </span><br><span class="line">                &#125; </span><br><span class="line">             &#125; </span><br><span class="line">             &#125; </span><br><span class="line">             /*重新显示光标*/ </span><br><span class="line">             boxfill8(sheet-&gt;buf, sheet-&gt;bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43); </span><br><span class="line">             sheet_refresh(sheet, cursor_x, 28, cursor_x + 8, 44); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5-符号的输入"><a href="#5-符号的输入" class="headerlink" title="5.符号的输入"></a>5.符号的输入</h2><ul>
<li>目标：实现！和%的输入</li>
<li>我们必须要处理shift键</li>
</ul>
<h2 id="6-大写字母和小写字母"><a href="#6-大写字母和小写字母" class="headerlink" title="6.大写字母和小写字母"></a>6.大写字母和小写字母</h2><ul>
<li>我们必须同时判断Shift键的状态和CapsLock的状态<ul>
<li>CapsLock 为 OFF &amp; Shift 键为 OFF → 小写英文字母</li>
<li>CapsLock 为 OFF &amp; Shift 键为 ON → 大写英文字母</li>
<li>CapsLock 为 ON &amp; Shift 键为 OFF → 大写英文字母</li>
<li>CapsLock 为 ON &amp; Shift 键为 ON → 小写英文字母</li>
</ul>
</li>
</ul>
<h2 id="7-对各种锁定键的支持"><a href="#7-对各种锁定键的支持" class="headerlink" title="7.对各种锁定键的支持"></a>7.对各种锁定键的支持</h2><ul>
<li>点亮/熄灭键盘上指示灯的方法</li>
<li>原理：<ul>
<li>对于NumLock和CapsLock等LED的控制，可采用下面的方法向键盘发送指令和数据。<ul>
<li>读取状态寄存器，等待 bit 1 的值变为 0。</li>
<li>向数据输出（0060）写入要发送的 1 个字节数据。</li>
<li>等待键盘返回 1 个字节的信息，这和等待键盘输入所采用的方法相同（用 IRQ等待或者用轮询状态寄存器 bit 1 的值直到其变为 0 都可以）。</li>
<li>返回的信息如果为 0xfa，表明 1 个字节的数据已成功发送给键盘。如为 0xfe则表明发送失败，需要返回第 1 步重新发送。</li>
</ul>
</li>
<li>要控制LED的状态，需要按上述方法执行两次，向键盘发送EDxx数据。其中，xx的bit 0代表ScrollLock，bit 1代表NumLock，bit2代表CapsLock（0表示熄灭，1表示点亮）。bit 3～7为保留位，置0即可。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define KEYCMD_LED 0xed </span><br><span class="line">void HariMain(void) </span><br><span class="line">&#123; </span><br><span class="line">     （中略）</span><br><span class="line">     struct FIFO32 fifo, keycmd; </span><br><span class="line">     int fifobuf[128], keycmd_buf[32]; </span><br><span class="line">     （中略）</span><br><span class="line">     int key_to = 0, key_shift = 0, key_leds = (binfo-&gt;leds &gt;&gt; 4) &amp; 7, keycmd_wait = -1; </span><br><span class="line">     （中略）</span><br><span class="line">     fifo32_init(&amp;keycmd, 32, keycmd_buf, 0); </span><br><span class="line">     （中略）</span><br><span class="line">     </span><br><span class="line">     /*为了避免和键盘当前状态冲突，在一开始先进行设置*/ </span><br><span class="line">     fifo32_put(&amp;keycmd, KEYCMD_LED); </span><br><span class="line">     fifo32_put(&amp;keycmd, key_leds); </span><br><span class="line">     </span><br><span class="line">     for (;;) &#123; </span><br><span class="line">         if (fifo32_status(&amp;keycmd) &gt; 0 &amp;&amp; keycmd_wait &lt; 0) &#123; /*从此开始*/ </span><br><span class="line">             /*如果存在向键盘控制器发送的数据，则发送它 */ </span><br><span class="line">             keycmd_wait = fifo32_get(&amp;keycmd); </span><br><span class="line">             wait_KBC_sendready(); </span><br><span class="line">             io_out8(PORT_KEYDAT, keycmd_wait); </span><br><span class="line">         &#125; /*到此结束*/ </span><br><span class="line">         io_cli(); </span><br><span class="line">         if (fifo32_status(&amp;fifo) == 0) &#123; </span><br><span class="line">             task_sleep(task_a); </span><br><span class="line">             io_sti(); </span><br><span class="line">         &#125; else &#123; </span><br><span class="line">             i = fifo32_get(&amp;fifo); </span><br><span class="line">             io_sti(); </span><br><span class="line">             if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /* 键盘数据 */ </span><br><span class="line">             （中略）</span><br><span class="line">            /*从此开始*/ if (i == 256 + 0x3a) &#123; /* CapsLock */ </span><br><span class="line">                 key_leds ^= 4; </span><br><span class="line">                 fifo32_put(&amp;keycmd, KEYCMD_LED); </span><br><span class="line">                 fifo32_put(&amp;keycmd, key_leds); </span><br><span class="line">             &#125; </span><br><span class="line">         if (i == 256 + 0x45) &#123; /* NumLock */ </span><br><span class="line">             key_leds ^= 2; </span><br><span class="line">             fifo32_put(&amp;keycmd, KEYCMD_LED); </span><br><span class="line">             fifo32_put(&amp;keycmd, key_leds); </span><br><span class="line">         &#125; </span><br><span class="line">         if (i == 256 + 0x46) &#123; /* ScrollLock */ </span><br><span class="line">             key_leds ^= 1; </span><br><span class="line">             fifo32_put(&amp;keycmd, KEYCMD_LED); </span><br><span class="line">             fifo32_put(&amp;keycmd, key_leds); </span><br><span class="line">         &#125; </span><br><span class="line">         if (i == 256 + 0xfa) &#123; /*键盘成功接收到数据*/ </span><br><span class="line">            keycmd_wait = -1; </span><br><span class="line">         &#125; </span><br><span class="line">         if (i == 256 + 0xfe) &#123; /*键盘没有成功接收到数据*/ </span><br><span class="line">            wait_KBC_sendready(); </span><br><span class="line">            io_out8(PORT_KEYDAT, keycmd_wait); </span><br><span class="line">            /*到此结束*/ &#125; </span><br><span class="line">         （中略）</span><br><span class="line">         &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; /*鼠标数据*/ </span><br><span class="line">         （中略）</span><br><span class="line">         &#125; else if (i &lt;= 1) &#123; /*光标用定时器*/ </span><br><span class="line">         （中略）</span><br><span class="line">         &#125; </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现方法：<ul>
<li>创建了一个叫keycmd的FIFO缓冲区，它不是用来接收中断请求的，而是用来管理由任务A向键盘控制器发送数据的顺序的。如果有数据要发送到键盘控制器，首先会在这个keycmd中累积起来。</li>
<li>keycmd_wait变量，用来表示向键盘控制器发送数据的状态。当keycmd_wait的值为-1时，表示键盘控制器处于通常状态，可以发送指令；当值不为-1时，表示键盘控制器正在等待发送的数据，这时要发送的数据被保存在keycmd_wait变量中。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（16）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8816%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY16-多任务（2）"><a href="#DAY16-多任务（2）" class="headerlink" title="DAY16_多任务（2）"></a>DAY16_多任务（2）</h1><h2 id="1-任务管理自动化"><a href="#1-任务管理自动化" class="headerlink" title="1.任务管理自动化"></a>1.任务管理自动化</h2><ul>
<li>充分做好多任务机制的基础上，再利用多任务逐步完善操作系统本身。</li>
<li>如果我们想要运行三个任务的话，就必须改写mt_taskswitch的代码。如果能像当初定时器和窗口背景的做法一样更好。</li>
</ul>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct TASKCTL *taskctl; </span><br><span class="line">struct TIMER *task_timer; </span><br><span class="line">struct TASK *task_init(struct MEMMAN *memman) </span><br><span class="line">&#123; </span><br><span class="line">     int i; </span><br><span class="line">     struct TASK *task; </span><br><span class="line">     struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT; </span><br><span class="line">     taskctl = (struct TASKCTL *) memman_alloc_4k(memman, sizeof (struct TASKCTL)); </span><br><span class="line">     for (i = 0; i &lt; MAX_TASKS; i++) &#123; </span><br><span class="line">         taskctl-&gt;tasks0[i].flags = 0; </span><br><span class="line">         taskctl-&gt;tasks0[i].sel = (TASK_GDT0 + i) * 8; </span><br><span class="line">         set_segmdesc(gdt + TASK_GDT0 + i, 103, (int) &amp;taskctl-&gt;tasks0[i].tss, AR_TSS32); </span><br><span class="line">     &#125; </span><br><span class="line">     task = task_alloc();</span><br><span class="line">     task-&gt;flags = 2; /*活动中标志*/ </span><br><span class="line">     taskctl-&gt;running = 1; </span><br><span class="line">     taskctl-&gt;now = 0; </span><br><span class="line">     taskctl-&gt;tasks[0] = task; </span><br><span class="line">     load_tr(task-&gt;sel); </span><br><span class="line">     task_timer = timer_alloc(); </span><br><span class="line">     timer_settime(task_timer, 2); </span><br><span class="line">     return task; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用task_init，会返回一个内存地址，意思是==现在正在运行的这个程序，已经变成一个任务了==。可能大家不是很能理解这个说法，在调用init之后，所有程序的运行都会被当成任务来进行管理，而调用init的这个程序，我们也要让它所属于某个任务，这样一来，通过调用任务的设置函数，就可以对任务进行各种控制，比如说修改优先级等。</li>
</ul>
<h2 id="2-让任务休眠"><a href="#2-让任务休眠" class="headerlink" title="2.让任务休眠"></a>2.让任务休眠</h2><ul>
<li>给每个任务==分配不同的时间==——休眠+唤醒</li>
<li><p>休眠：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void task_sleep(struct TASK *task) </span><br><span class="line">&#123; </span><br><span class="line">     int i; </span><br><span class="line">     char ts = 0; </span><br><span class="line">     if (task-&gt;flags == 2) &#123; /*如果指定任务处于唤醒状态*/ </span><br><span class="line">         if (task == taskctl-&gt;tasks[taskctl-&gt;now]) &#123; </span><br><span class="line">            ts = 1; /*让自己休眠的话，稍后需要进行任务切换*/ </span><br><span class="line">         &#125; </span><br><span class="line">         /*寻找task所在的位置*/ </span><br><span class="line">         for (i = 0; i &lt; taskctl-&gt;running; i++) &#123; </span><br><span class="line">             if (taskctl-&gt;tasks[i] == task) &#123; </span><br><span class="line">                 /*在这里*/ </span><br><span class="line">                 break; </span><br><span class="line">             &#125; </span><br><span class="line">         &#125; </span><br><span class="line">         taskctl-&gt;running--; </span><br><span class="line">         if (i &lt; taskctl-&gt;now) &#123; </span><br><span class="line">            taskctl-&gt;now--; /*需要移动成员，要相应地处理*/ </span><br><span class="line">         &#125; </span><br><span class="line">         /*移动成员*/ </span><br><span class="line">         for (; i &lt; taskctl-&gt;running; i++) &#123; </span><br><span class="line">            taskctl-&gt;tasks[i] = taskctl-&gt;tasks[i + 1]; </span><br><span class="line">         &#125; </span><br><span class="line">         task-&gt;flags = 1; /*不工作的状态*/ </span><br><span class="line">         if (ts != 0) &#123; </span><br><span class="line">            /*任务切换*/ </span><br><span class="line">            if (taskctl-&gt;now &gt;= taskctl-&gt;running) &#123; </span><br><span class="line">                /*如果now的值出现异常，则进行修正*/ </span><br><span class="line">                taskctl-&gt;now = 0; </span><br><span class="line">            &#125; </span><br><span class="line">            farjmp(0, taskctl-&gt;tasks[taskctl-&gt;now]-&gt;sel); </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>唤醒：</p>
<ul>
<li>在FIFO中添加用于记录要唤醒任务的信息的成员。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct FIFO32 &#123; </span><br><span class="line">    int *buf; </span><br><span class="line">    int p, q, size, free, flags; </span><br><span class="line">    struct TASK *task; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-增加窗口数量"><a href="#3-增加窗口数量" class="headerlink" title="3.增加窗口数量"></a>3.增加窗口数量</h2></li>
</ul>
</li>
<li>形成任务A、任务B0、任务B1和任务B2的格局。</li>
<li>任务B0～B2各自拥有自己的窗口，它们的功能都一样，即进行计数，这有点像在Windows中启动了一个应用程序及其2个副本的感觉。</li>
</ul>
<h2 id="4-设定任务优先级（1）"><a href="#4-设定任务优先级（1）" class="headerlink" title="4.设定任务优先级（1）"></a>4.设定任务优先级（1）</h2><ul>
<li>改写mtask.c、task_switch<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void task_switch(void) </span><br><span class="line">&#123; </span><br><span class="line">     struct TASK *task; </span><br><span class="line">     taskctl-&gt;now++; </span><br><span class="line">     if (taskctl-&gt;now == taskctl-&gt;running) &#123; </span><br><span class="line">        taskctl-&gt;now = 0; </span><br><span class="line">     &#125; </span><br><span class="line">     task = taskctl-&gt;tasks[taskctl-&gt;now]; </span><br><span class="line">     timer_settime(task_timer, task-&gt;priority); </span><br><span class="line">     if (taskctl-&gt;running &gt;= 2) &#123; </span><br><span class="line">        farjmp(0, task-&gt;sel); </span><br><span class="line">     &#125;</span><br><span class="line">     return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5-设定任务优先级（2）"><a href="#5-设定任务优先级（2）" class="headerlink" title="5.设定任务优先级（2）"></a>5.设定任务优先级（2）</h2><ul>
<li>在操作系统中有一些处理，即使牺牲其他任务的性能也必须要尽快完成，否则会引起用户的不满，就比如这次对鼠标的处理。对于这类任务，我们可以让它在处理结束后马上休眠，而优先级则可以设置得非常高。</li>
<li>我们需要设计一种架构，使得即便高优先级的任务同时运行，也能够区分哪个更加优先。<br><img src="https://s2.ax1x.com/2019/04/07/AhpVk8.jpg" alt="16.1"></li>
<li>这种架构的工作原理是，最上层的LEVEL 0中只要存在哪怕一个任务，则完全忽略LEVEL 1和LEVEL 2中的任务，只在LEVEL 0的任务中进行任务切换。当LEVEL 0中的任务全部休眠，或者全部降到下层LEVEL，也就是当LEVEL 0中没有任何任务的时候，接下来开始轮到LEVEL 1中的任务进行任务切换。当LEVEL 0和LEVEL 1中都没有任务时，那就该轮到LEVEL2 出场了。<br>在这种架构下，只要把音乐播放任务设置在LEVEL 0中，就可以保证获得比鼠标更高的优先级。</li>
</ul>
<hr>
<ul>
<li>task_now 用于返回现在活动中的struct TASK的内存地址<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct TASK *task_now(void) </span><br><span class="line">&#123; </span><br><span class="line"> struct TASKLEVEL *tl = &amp;taskctl-&gt;level[taskctl-&gt;now_lv]; </span><br><span class="line"> return tl-&gt;tasks[tl-&gt;now]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>task_add，用来向struct TASKLEVEL中添加一个任务<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void task_add(struct TASK *task) </span><br><span class="line">&#123; </span><br><span class="line"> struct TASKLEVEL *tl = &amp;taskctl-&gt;level[task-&gt;level]; </span><br><span class="line"> tl-&gt;tasks[tl-&gt;running] = task; </span><br><span class="line"> tl-&gt;running++; </span><br><span class="line"> task-&gt;flags = 2; /*活动中*/ </span><br><span class="line"> return; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>task_remove</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void task_remove(struct TASK *task) </span><br><span class="line">&#123; </span><br><span class="line">     int i; </span><br><span class="line">     struct TASKLEVEL *tl = &amp;taskctl-&gt;level[task-&gt;level]; </span><br><span class="line">     /*寻找task所在的位置*/ </span><br><span class="line">     for (i = 0; i &lt; tl-&gt;running; i++) &#123; </span><br><span class="line">         if (tl-&gt;tasks[i] == task) &#123; </span><br><span class="line">             /*在这里 */ </span><br><span class="line">             break; </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     tl-&gt;running--; </span><br><span class="line">     if (i &lt; tl-&gt;now) &#123; </span><br><span class="line">        tl-&gt;now--; /*需要移动成员，要相应地处理 */ </span><br><span class="line">     &#125; </span><br><span class="line">     if (tl-&gt;now &gt;= tl-&gt;running) &#123; </span><br><span class="line">         /*如果now的值出现异常，则进行修正*/ </span><br><span class="line">         tl-&gt;now = 0; </span><br><span class="line">     &#125; </span><br><span class="line">     task-&gt;flags = 1; /* 休眠中 */ </span><br><span class="line">     /* 移动 */ </span><br><span class="line">     for (; i &lt; tl-&gt;running; i++) &#123;</span><br><span class="line">        tl-&gt;tasks[i] = tl-&gt;tasks[i + 1]; </span><br><span class="line">     &#125; </span><br><span class="line">     return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>task_switchsub,用来在任务切换时决定接下来切换到哪个LEVEL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void task_switchsub(void) </span><br><span class="line">&#123; </span><br><span class="line">     int i; </span><br><span class="line">     /*寻找最上层的LEVEL */ </span><br><span class="line">     for (i = 0; i &lt; MAX_TASKLEVELS; i++) &#123; </span><br><span class="line">     if (taskctl-&gt;level[i].running &gt; 0) &#123; </span><br><span class="line">     break; /*找到了*/ </span><br><span class="line">     &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     taskctl-&gt;now_lv = i; </span><br><span class="line">     taskctl-&gt;lv_change = 0; </span><br><span class="line">     return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（15）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8815%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY15-多任务（1）"><a href="#DAY15-多任务（1）" class="headerlink" title="DAY15_多任务（1）"></a>DAY15_多任务（1）</h1><h2 id="1-挑战任务切换"><a href="#1-挑战任务切换" class="headerlink" title="1.挑战任务切换"></a>1.挑战任务切换</h2><ul>
<li><strong>多任务</strong>：多个应用程序同时运行的状态（也就是同时打开好几个窗口的状态）。</li>
<li>实际上这些程序==并没有在同时运行==，只是看上去好像是在同时运行一样。<br><img src="https://s2.ax1x.com/2019/04/07/Af2OaT.jpg" alt="15.1"></li>
</ul>
<span id="more"></span>
<ul>
<li>在一般的操作系统中，这个切换的动作每0.01～0.03秒就会进行一次。当然，切换的速度越快，让人觉得程序是在同时运行的效果也就越好。不过，CPU进行程序切换（我们称为“任务切换”）这个动作本身就需要消耗一定的时间，这个时间大约为0.0001秒左右，不同的CPU及操作系统所需的时间也有所不同。</li>
<li>CPU处理方式：当你向CPU发出任务切换的指令时，CPU会先把寄存器中的值全部写入内存中，这样做是为了当以后切换回这个程序的时候，可以从中断的地方继续运行。接下来，为了运行下一个程序，CPU会把所有寄存器中的值从内存中读取出来（当然，这个读取的地址和刚刚写入的地址一定是不同的，不然就相当于什么都没变嘛），这样就完成了一次切换。我们前面所说的任务切换所需要的时间，正是对内存进行写入和读取操作所消耗的时间。</li>
<li>TSS 任务状态段 task status segment</li>
<li>EIP 扩展指令指针寄存器 extended instruction pointer：CPU用来记录下一条需要执行的指令位于内存中哪个地址的寄存器，因此它才被称为“指令指针”。如果没有这个寄存器，记性不好的CPU就会忘记自己正在运行哪里的程序，于是程序就没办法正常运行了。每执行一条指令，EIP寄存器中的值就会自动累加，从而保证一直指向下一条指令所在的内存地址。</li>
</ul>
<h3 id="实际任务切换"><a href="#实际任务切换" class="headerlink" title="实际任务切换"></a>实际任务切换</h3><ul>
<li>创建两个TSS<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct TSS32 tss_a, tss_b;</span><br></pre></td></tr></table></figure></li>
<li>向它们的Idtr和iomap分别存入合适的值<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tss_a.ldtr = 0; </span><br><span class="line">tss_a.iomap = 0x40000000; </span><br><span class="line">tss_b.ldtr = 0; </span><br><span class="line">tss_b.iomap = 0x40000000;</span><br></pre></td></tr></table></figure></li>
<li><p>将它们两个在GDT中进行定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT; </span><br><span class="line"> </span><br><span class="line">set_segmdesc(gdt + 3, 103, (int) &amp;tss_a, AR_TSS32); </span><br><span class="line">set_segmdesc(gdt + 4, 103, (int) &amp;tss_b, AR_TSS32);</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们向TR寄存器存入3 * 8这个值，这是因为我们刚才把当前运行的任务定义为GDT的3号。</p>
</li>
<li>要进行任务切换，我们必须执行far模式的跳转指令</li>
</ul>
<hr>
<ul>
<li>在eip中，我们需要定义在切换到这个任务的时候，要从哪里开始运行。</li>
</ul>
<h2 id="2-任务切换进阶"><a href="#2-任务切换进阶" class="headerlink" title="2.任务切换进阶"></a>2.任务切换进阶</h2><ul>
<li>目标：从任务A切换到任务B，再切换回任务A</li>
</ul>
<h2 id="3-做个简单的多任务（1）"><a href="#3-做个简单的多任务（1）" class="headerlink" title="3.做个简单的多任务（1）"></a>3.做个简单的多任务（1）</h2><ul>
<li>目标：实现更快速的，来回交替的任务切换。这样我们就可以告别光标停住、鼠标卡死、键盘打不了字的情况，让两个任务看上去好像在同时运行一样。</li>
<li>把taskswitch写成一个函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_farjmp: ; void farjmp(int eip, int cs); </span><br><span class="line"> JMP FAR [ESP+4] ; eip, cs </span><br><span class="line"> RET</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-做个简单的多任务（2）"><a href="#4-做个简单的多任务（2）" class="headerlink" title="4.做个简单的多任务（2）"></a>4.做个简单的多任务（2）</h2><h2 id="5-提高运行速度"><a href="#5-提高运行速度" class="headerlink" title="5.提高运行速度"></a>5.提高运行速度</h2><ul>
<li>因为我们的程序每计1个数就在画面上显示一次，但1秒钟之内刷新100次以上的话，人眼根本就分辨不出来，所以我们不需要计1个数就刷新一次，只要每隔0.01秒刷新一次就足够了。</li>
</ul>
<h2 id="6-测试运行速度"><a href="#6-测试运行速度" class="headerlink" title="6.测试运行速度"></a>6.测试运行速度</h2><p>向task_b_main添加代码测试运行速度<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void task_b_main(struct SHEET *sht_back) </span><br><span class="line">&#123; </span><br><span class="line">     struct FIFO32 fifo; </span><br><span class="line">     struct TIMER *timer_ts, *timer_put, *timer_1s; </span><br><span class="line">     int i, fifobuf[128], count = 0, count0 = 0; </span><br><span class="line">     char s[12]; </span><br><span class="line">     （中略）</span><br><span class="line">     timer_1s = timer_alloc(); </span><br><span class="line">     timer_init(timer_1s, &amp;fifo, 100); </span><br><span class="line">     timer_settime(timer_1s, 100); </span><br><span class="line">     for (;;) &#123; </span><br><span class="line">         count++; </span><br><span class="line">         io_cli(); </span><br><span class="line">         if (fifo32_status(&amp;fifo) == 0) &#123; </span><br><span class="line">            io_sti(); </span><br><span class="line">         &#125; else &#123; </span><br><span class="line">             i = fifo32_get(&amp;fifo);</span><br><span class="line">             io_sti(); </span><br><span class="line">             if (i == 1) &#123; </span><br><span class="line">                （中略）</span><br><span class="line">             &#125; else if (i == 2) &#123; </span><br><span class="line">                （中略）</span><br><span class="line">             &#125; else if (i == 100) &#123; </span><br><span class="line">                 sprintf(s, &quot;%11d&quot;, count - count0); </span><br><span class="line">                 putfonts8_asc_sht(sht_back, 0, 128, COL8_FFFFFF, COL8_008484, s, 11); </span><br><span class="line">                 count0 = count; </span><br><span class="line">                 timer_settime(timer_1s, 100); </span><br><span class="line">            &#125; </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="7-多任务进阶"><a href="#7-多任务进阶" class="headerlink" title="7.多任务进阶"></a>7.多任务进阶</h2><ul>
<li>真正的多任务，是要做到在程序本身不知道的情况下进行任务切换。</li>
<li>果使用这样的设计，即便在程序中不进行任务切换的处理（比如忘记写了，或者因为bug没能正常切换之类的），也一定会正常完成切换。之前那种多任务的话，如果任务B因为发生bug而无法进行切换，那么当切换到任务B以后，其他的任务就再也无法运行了，这样会造成无论是按键盘还是动鼠标都毫无反应的悲剧。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>插入排序（Insert Sort）、归并排序（Merge Sort）和快速排序（Quick Sort）</title>
    <url>/201904/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="算法设计与分析实验报告-2019-4-4"><a href="#算法设计与分析实验报告-2019-4-4" class="headerlink" title="算法设计与分析实验报告 2019.4.4"></a>算法设计与分析实验报告 2019.4.4</h1><h3 id="插入排序（Insert-Sort）、归并排序（Merge-Sort）和快速排序（Quick-Sort）"><a href="#插入排序（Insert-Sort）、归并排序（Merge-Sort）和快速排序（Quick-Sort）" class="headerlink" title="插入排序（Insert Sort）、归并排序（Merge Sort）和快速排序（Quick Sort）"></a>插入排序（Insert Sort）、归并排序（Merge Sort）和快速排序（Quick Sort）</h3><h2 id="一、算法简介"><a href="#一、算法简介" class="headerlink" title="一、算法简介"></a>一、算法简介</h2><h4 id="1-插入排序算法（Insert-Sort-Algorithm）"><a href="#1-插入排序算法（Insert-Sort-Algorithm）" class="headerlink" title="1.插入排序算法（Insert Sort Algorithm）"></a>1.插入排序算法（Insert Sort Algorithm）</h4><ul>
<li><strong>直接插入排序(Straight Insertion Sort)的基本思想是</strong>：<br>把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次==从无序表中取==出第一个元素，将它==插入到有序表中==的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。</li>
<li><strong>我们需要做的工作只有两个：</strong>   <ul>
<li>取出无序区中的第1个数，并找出它在有序区对应的位置。  </li>
<li>将无序区的数据插入到有序区；若有必要的话，则对有序区中的相关数据进行移位。</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h4 id="2-归并排序算法（Merge-Sort-Algorithm）"><a href="#2-归并排序算法（Merge-Sort-Algorithm）" class="headerlink" title="2.归并排序算法（Merge Sort Algorithm）"></a>2.归并排序算法（Merge Sort Algorithm）</h4><ul>
<li><strong>归并排序的操作：</strong><br>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</li>
<li><strong>归并排序的应用场景：</strong><br>速度仅次于快速排序，为稳定排序算法，一般用于==对总体无序，但是各子项相对有序的数列==<h4 id="3-快速排序算法（Quick-Sort-Algorithm）"><a href="#3-快速排序算法（Quick-Sort-Algorithm）" class="headerlink" title="3.快速排序算法（Quick Sort Algorithm）"></a>3.快速排序算法（Quick Sort Algorithm）</h4></li>
<li><strong>快速排序的思想：</strong><br>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</li>
<li><strong>适用场景：</strong><br>快速排序是==不稳定的==。它不需要额外的存储空间。它的应用场景是大规模的数据排序，并且实际性能要好于归并排序。</li>
</ul>
<h2 id="二、程序"><a href="#二、程序" class="headerlink" title="二、程序"></a>二、程序</h2><h3 id="Ⅰ、算法程序"><a href="#Ⅰ、算法程序" class="headerlink" title="Ⅰ、算法程序"></a>Ⅰ、算法程序</h3><h4 id="1-插入排序算法（Insert-Sort-Algorithm）-1"><a href="#1-插入排序算法（Insert-Sort-Algorithm）-1" class="headerlink" title="1.插入排序算法（Insert Sort Algorithm）"></a>1.插入排序算法（Insert Sort Algorithm）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Insertion Sorting*/</span></span><br><span class="line"><span class="comment">/*每次从无序的队列中选择一个插入，</span></span><br><span class="line"><span class="comment"> *直到所有元素都排序完成。*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSortUp</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> swap = A[i];</span><br><span class="line">		<span class="type">int</span> j;</span><br><span class="line">		<span class="keyword">for</span> (j = i<span class="number">-1</span> ; A[j] &gt; swap &amp;&amp; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">			A[j+<span class="number">1</span>] = A[j];</span><br><span class="line">		A[j+<span class="number">1</span>] = swap;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-归并排序算法（Merge-Sort-Algorithm）-1"><a href="#2-归并排序算法（Merge-Sort-Algorithm）-1" class="headerlink" title="2.归并排序算法（Merge Sort Algorithm）"></a>2.归并排序算法（Merge Sort Algorithm）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*MergeSort*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//创造左右两个数组L、R，将已经排好的两部分放进去 </span></span><br><span class="line">	<span class="type">int</span> n1 = q - p + <span class="number">1</span>, n2 = r - q;</span><br><span class="line">	<span class="type">int</span> L[n1], R[n2];</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">		L[i] = A[p + i];</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n2; j++)</span><br><span class="line">		R[j] = A[q + <span class="number">1</span> + j];</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	//开始对两个数组进行归并 </span><br><span class="line">	i = 0; j = 0;</span><br><span class="line">	for (int k = p; k &lt;= r; k++) &#123;</span><br><span class="line">		if(i == n1)&#123;//如果左边数组已经全放进去 </span><br><span class="line">			while(j &lt; n2)	A[k++] = R[j++];</span><br><span class="line">		&#125; else if ( j == n2)&#123;//如果右边数组已经全放进去 </span><br><span class="line">			while(i &lt; n1)	A[k++] = L[i++];</span><br><span class="line">		&#125; else&#123;//比较两个数组，把小的数放进A数组，指针后移 </span><br><span class="line">			if (L[i] &lt;= R[j]) &#123;</span><br><span class="line">				A[k] = L[i];</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				A[k] = R[j];</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void MergeSortUp(int A[], int p,int r)</span><br><span class="line">&#123;</span><br><span class="line">	if (p &lt; r) &#123;</span><br><span class="line">		int q = (p + r) / 2;</span><br><span class="line">		MergeSortUp(A, p, q);</span><br><span class="line">		MergeSortUp(A, q + 1, r);</span><br><span class="line">		Merge(A, p, q, r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-快速排序算法（Quick-Sort-Algorithm）-1"><a href="#3-快速排序算法（Quick-Sort-Algorithm）-1" class="headerlink" title="3.快速排序算法（Quick Sort Algorithm）"></a>3.快速排序算法（Quick Sort Algorithm）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*QuickSort*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x = A[i];</span><br><span class="line">	A[i] = A[j];</span><br><span class="line">	A[j] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> p, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x = A[p];</span><br><span class="line">	<span class="type">int</span> i = p;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = p + <span class="number">1</span>; j &lt;= r; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (A[j] &lt; x) &#123;</span><br><span class="line">			i = i + <span class="number">1</span>;</span><br><span class="line">			swap(A, i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(A, p, i);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void QuickSortUp(int A[], int p, int r)</span><br><span class="line">&#123;</span><br><span class="line">	if (p &lt; r) &#123;</span><br><span class="line">		int q = partition(A, p, r);</span><br><span class="line">		QuickSortUp(A, p, q - 1);</span><br><span class="line">		QuickSortUp(A, q + 1, r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Ⅱ、测试程序"><a href="#Ⅱ、测试程序" class="headerlink" title="Ⅱ、测试程序"></a>Ⅱ、测试程序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Test*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> size 10000 <span class="comment">//size为数据规模</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;InsertSort.cpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MergeSort.cpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;QuickSort.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[size];</span><br><span class="line"><span class="type">clock_t</span> start,finish;</span><br><span class="line"><span class="type">double</span> runtime_insert,runtime_merge,runtime_quick;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*Generating test data set*/</span><br><span class="line">void tstdata(int n)</span><br><span class="line">&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	if((fp = fopen(&quot;tstdata.txt&quot;,&quot;w+&quot;))== NULL)</span><br><span class="line">		printf(&quot;cant open the file.\n&quot;);</span><br><span class="line">	else&#123;</span><br><span class="line">		srand(time(NULL));</span><br><span class="line">		for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">			if(i!=n) fprintf(fp,&quot;%d &quot;,rand());</span><br><span class="line">	      else fprintf(fp,&quot;%d\n&quot;,rand());</span><br><span class="line">		&#125;</span><br><span class="line">		fclose(fp);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*output function*/</span><br><span class="line">int output(char *filename,int A[])</span><br><span class="line">&#123;</span><br><span class="line">    FILE * fp;</span><br><span class="line">    if((fp = fopen(filename,&quot;w+&quot;))==NULL)&#123;</span><br><span class="line">      printf(&quot;cant open the file.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">	   for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">		   if(i!=size-1) fprintf(fp,&quot;%d &quot;,A[i]);</span><br><span class="line">		   else fprintf(fp,&quot;%d\n&quot;,A[i]);</span><br><span class="line">	   &#125;</span><br><span class="line">	   fclose(fp);</span><br><span class="line">	 &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	int i=0;</span><br><span class="line">	</span><br><span class="line">	/*generating test data*/</span><br><span class="line">	/*tstdata(size);</span><br><span class="line">	printf(&quot;Data set has been created.\n&quot;);*/</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	/*get the test data*/</span><br><span class="line">	FILE *fp;</span><br><span class="line">	if((fp = fopen(&quot;tstdata.txt&quot;,&quot;r&quot;))==NULL)&#123;</span><br><span class="line">		printf(&quot;cant open the file.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">	while(fscanf(fp, &quot;%d&quot;, &amp;A[i]) != EOF) </span><br><span class="line">        i++;</span><br><span class="line">   fclose(fp);</span><br><span class="line">	 for(i=0;i&lt;size;i++)&#123;</span><br><span class="line">	 	printf(&quot;%d &quot;,A[i]);</span><br><span class="line">	 &#125; </span><br><span class="line">	 printf(&quot;\n&quot;);</span><br><span class="line">	 printf(&quot;Array has been created.\n&quot;);</span><br><span class="line">	   </span><br><span class="line">	    </span><br><span class="line">	/*copy the test data set*/</span><br><span class="line">	int A1[size],A2[size],A3[size];</span><br><span class="line">	for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">		A1[i]=A[i];</span><br><span class="line">		A2[i]=A[i];</span><br><span class="line">		A3[i]=A[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    /*Insert Sorting*/</span><br><span class="line">	printf(&quot;Insert Sorting...\n&quot;);</span><br><span class="line">	</span><br><span class="line">	start = clock();</span><br><span class="line">	InsertSortUp(A1,size);</span><br><span class="line">	finish = clock();</span><br><span class="line">	</span><br><span class="line">	output(&quot;InsertSortUp.txt&quot;,A1);</span><br><span class="line">	runtime_insert = (double)(finish - start)/CLOCKS_PER_SEC;</span><br><span class="line">	printf(&quot;Insert Sort has been finished.\nTime Cost:%lf\n&quot;,runtime_insert);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    /*Merge Sorting*/</span><br><span class="line">	printf(&quot;Merge Sorting...\n&quot;);</span><br><span class="line">	</span><br><span class="line">	start = clock();</span><br><span class="line">	MergeSortUp(A2,0,size-1);</span><br><span class="line">	finish = clock();</span><br><span class="line">	</span><br><span class="line">	output(&quot;MergeSortUp.txt&quot;,A2);</span><br><span class="line">	runtime_merge = (double)(finish-start)/CLOCKS_PER_SEC;</span><br><span class="line">	printf(&quot;Merge Sort has been finished.\nTime Cost:%lf\n&quot;,runtime_merge);</span><br><span class="line"></span><br><span class="line">    /*Quick Sorting*/</span><br><span class="line">	printf(&quot;Quick Sorting...\n&quot;);</span><br><span class="line">	</span><br><span class="line">	start = clock();</span><br><span class="line">	QuickSortUp(A3,0,size-1);</span><br><span class="line">	finish = clock();</span><br><span class="line">	</span><br><span class="line">	output(&quot;QuickSortUp.txt&quot;,A3);</span><br><span class="line">	runtime_quick = (double)(finish-start)/CLOCKS_PER_SEC;</span><br><span class="line">	printf(&quot;Quick Sort has been finished.\nTime Cost:%lf\n&quot;,runtime_quick);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、测试数据集生成及测试"><a href="#三、测试数据集生成及测试" class="headerlink" title="三、测试数据集生成及测试"></a>三、测试数据集生成及测试</h2><ul>
<li><strong>我为算法的测试准备了12个测试数据集，其中数据量分别为10,000\50,000\100,000</strong>  </li>
<li><strong>每个数据量下有==随机生成数据集（用于测试平均复杂度）==和==逆序数据集（用于测试最坏情况）==</strong>  </li>
<li><strong>为了减小误差，每个类型的数据集都准备了两个，这样便生成了3x2x2=12个数据集</strong></li>
<li><strong>算法的正确性测试在数据量很小的时候进行了手动验证，所以这里我们仅着重比较时间复杂度</strong></li>
</ul>
<h3 id="Ⅰ、测试数据集生成"><a href="#Ⅰ、测试数据集生成" class="headerlink" title="Ⅰ、测试数据集生成"></a>Ⅰ、测试数据集生成</h3><p>通过main函数中的/<em>generating test data</em>/部分生成“随机生成测试集”，详细测试数据见附件。<br>通过快速排序算法生成相应的“逆序数据集”进行排序算法的时间复杂度测试，详细数据见附件。</p>
<h3 id="Ⅱ、测试过程"><a href="#Ⅱ、测试过程" class="headerlink" title="Ⅱ、测试过程"></a>Ⅱ、测试过程</h3><p>测试结果如下表：（详见附件）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>data set</th>
<th>Insert Sort(s)</th>
<th>Merge Sort(s)</th>
<th>Quick Sort(s) </th>
</tr>
</thead>
<tbody>
<tr>
<td>S1:10,000\rand array(average condition)</td>
<td>0.082</td>
<td>0.001</td>
<td>0.002</td>
</tr>
<tr>
<td>S2:10,000\rand array(average condition)</td>
<td>0.069</td>
<td>0.002</td>
<td>0.001</td>
</tr>
<tr>
<td>S3:10,000\reserve array(worst condition)</td>
<td>0.469</td>
<td>0.003</td>
<td>0.554</td>
</tr>
<tr>
<td>S4:10,000\reserve array(worst condition)</td>
<td>0.463</td>
<td>0.003</td>
<td>0.546</td>
</tr>
<tr>
<td>S5:50,000\rand array(average condition)</td>
<td>1.718</td>
<td>0.009</td>
<td>0.009</td>
</tr>
<tr>
<td>S6:50,000\rand array(average condition)</td>
<td>1.881</td>
<td>0.01</td>
<td>0.009</td>
</tr>
<tr>
<td>S7:50,000\reserve array(worst condition)</td>
<td>8.54</td>
<td>0.015</td>
<td>/</td>
</tr>
<tr>
<td>S8:50,000\reserve array(worst condition)</td>
<td>7.956</td>
<td>0.015</td>
<td>/</td>
</tr>
<tr>
<td>S9:100,000\rand array(average condition)</td>
<td>7.023</td>
<td>0.022</td>
<td>0.017</td>
</tr>
<tr>
<td>S10:100,000\rand array(average condition)</td>
<td>6.86</td>
<td>0.02</td>
<td>0.018</td>
</tr>
<tr>
<td>S11:100,000\reserve array(worst condition)</td>
<td>31.549</td>
<td>0.027</td>
<td>/</td>
</tr>
<tr>
<td>S12:100,000\reserve array(worst condition)</td>
<td>30.989</td>
<td>0.029</td>
<td>/</td>
</tr>
</tbody>
</table>
</div>
<p><em>注：50,000和100,000数据量下，最坏情况下快速排序算法程序没法完成排序</em></p>
<h2 id="四、算法复杂度分析"><a href="#四、算法复杂度分析" class="headerlink" title="四、算法复杂度分析"></a>四、算法复杂度分析</h2><h4 id="1-插入排序算法（Insert-Sort-Algorithm）-2"><a href="#1-插入排序算法（Insert-Sort-Algorithm）-2" class="headerlink" title="1.插入排序算法（Insert Sort Algorithm）"></a>1.插入排序算法（Insert Sort Algorithm）</h4><ul>
<li>最优情况：<br>最少比较一次，移动两次。<br>Cmin = n-1；Mmin=（n-1）×2；</li>
<li>最坏情况：<br>最多比较i次，移动i＋2次（逆序）（i=1，2，…，n-1）<br>Cmax=1+2+…+（n-1）=（n2-n）/2<br>M max=3+4+…+（n+1）=（n2+3n-4）/2<br>Cave=（n2+n-2）/4<br>M ave=（n2+7n-8）/4</li>
<li>故直接插入排序的时间复杂度为O（n2），它的时间复杂度和待排序列的顺序有关。</li>
</ul>
<h4 id="2-归并排序算法（Merge-Sort-Algorithm）-2"><a href="#2-归并排序算法（Merge-Sort-Algorithm）-2" class="headerlink" title="2.归并排序算法（Merge Sort Algorithm）"></a>2.归并排序算法（Merge Sort Algorithm）</h4><p>通过迭代作图法可知，归并算法的算法复杂度为O(nlogn)，它的时间复杂度和待排序列的顺序无关。</p>
<h4 id="3-快速排序算法（Quick-Sort-Algorithm）-2"><a href="#3-快速排序算法（Quick-Sort-Algorithm）-2" class="headerlink" title="3.快速排序算法（Quick Sort Algorithm）"></a>3.快速排序算法（Quick Sort Algorithm）</h4><ul>
<li>最坏情况：<br>顺序或逆序时，一次partition只能解决一个元素的位置 排列，所以最坏情况下的时间复杂度为O(n^2)</li>
<li>平均情况：<br>O(logn),枢轴元素两边的待排序列分的越平均，时间复杂度越小。</li>
</ul>
<h2 id="五、算法优化"><a href="#五、算法优化" class="headerlink" title="五、算法优化"></a>五、算法优化</h2><h3 id="1-归并排序的“哨兵”"><a href="#1-归并排序的“哨兵”" class="headerlink" title="1.归并排序的“哨兵”"></a>1.归并排序的“哨兵”</h3><p>在归并排序中，将两个已经排号的序列整合在一起时，之前我们是这样做的：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(i == n1)&#123;//如果左边数组已经全放进去 </span><br><span class="line">			while(j &lt; n2)	A[k++] = R[j++];</span><br><span class="line">		&#125; else if ( j == n2)&#123;//如果右边数组已经全放进去 </span><br><span class="line">			while(i &lt; n1)	A[k++] = L[i++];</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure><br>如果在待排的两个序列的最右端添加一个==哨兵==，即最大值MAX，就不用判断有序列已经选完了的问题，能够有效的减少判断的次数。</p>
<h3 id="2-快速排序枢轴元素pivot的选取"><a href="#2-快速排序枢轴元素pivot的选取" class="headerlink" title="2.快速排序枢轴元素pivot的选取"></a>2.快速排序枢轴元素pivot的选取</h3><p>pivot的选择对于快速排序时间复杂度的影响十分的大。从上面的“逆序测试数据”可知，如果每次选择的pivot都是最大/最小值，快速排序的复杂度可能会达到O(n^2)。<br>每次运行过程中，随机选取pivot, 通常能得到比较好的结果。<br>我采用了一种==三者取中==的方法，即选取第一个、最后一个以及中间的元素的中位数作为pivot，这样能够有效的避免“worst condition”的出现。<br>代码如下：(摘自csdn博客)<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//median-of-three pivot rule</span><br><span class="line">private static int choosePivotMedianOfThree(int[] a, int l, int r) &#123;	</span><br><span class="line">	int mid = 0;</span><br><span class="line">	if ((r-l+1) % 2 == 0) &#123;</span><br><span class="line">		mid = l + (r-l+1)/2 - 1;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		mid = l + (r-l+1)/2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//只需要找出中位数即可，不需要交换</span><br><span class="line">    //有的版本也可以进行交换</span><br><span class="line">	if (((a[l]-a[mid]) * (a[l]-a[r])) &lt;= 0) &#123;</span><br><span class="line">		return l;</span><br><span class="line">	&#125; else if (((a[mid]-a[l]) * (a[mid]-a[r])) &lt;= 0) 	&#123;</span><br><span class="line">		return mid;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------- </span><br><span class="line">/*作者：xinyuexy </span><br><span class="line"> *来源：CSDN </span><br><span class="line"> *原文：https://blog.csdn.net/qq_31903733/article/details/82945605 </span><br><span class="line"> *版权声明：本文为博主原创文章，转载请附上博文链接！*/</span><br></pre></td></tr></table></figure><br>再将选取的pivot与队列第一个元素交换即可。</p>
<h3 id="3-快速排序稳定性的改善"><a href="#3-快速排序稳定性的改善" class="headerlink" title="3.快速排序稳定性的改善"></a>3.快速排序稳定性的改善</h3><p>快速排序是“不稳定”的原因在于，partition的最后一步，pivot和指针i位置的元素交换。<br>举例：</p>
<ul>
<li>3  1  3’  5   2   6  1’(大小相同的元素用’区分)</li>
<li>3  1  2   5   3’  6  1’</li>
<li>3  1  2   1’  3’  6  5<br>(这时候还没问题)</li>
<li>1’ 1  2   3   3’  6  5<br>(最后一步1’和1的顺序发生变化)</li>
</ul>
<p>解决方法：每次partition的最后一步时，遍历待排数组A[i]之前的部分，将与A[i]大小相同的元素整体后移。</p>
<h2 id="六、实验心得"><a href="#六、实验心得" class="headerlink" title="六、实验心得"></a>六、实验心得</h2><ul>
<li>本次实验我学习了三种重要算法：插入排序算法、归并排序算法和快速排序算法，了解了它们的原理和适用的情景。</li>
<li>我认为相对于快速排序，归并排序更具有健壮性，它不会因为序列的顺序影响时间复杂度，而且它是一个稳定的排序。可能由于数据集不够大，我还没能充分体会到快速排序在时间上的优势。</li>
<li>最坏情况下的时间复杂度和平均时间复杂度相差非常大，在以后分析算法时要兼顾两者。</li>
</ul>
<h2 id="七、附录大纲"><a href="#七、附录大纲" class="headerlink" title="七、附录大纲"></a>七、附录大纲</h2><ul>
<li>Test.cpp<br>测试程序，包括数据集生成，待排序列输出等等。</li>
<li>InsertSort.cpp<br>插入排序算法</li>
<li>MergeSort.cpp<br>归并排序算法</li>
<li>QuickSort.cpp<br>快速排序算法</li>
<li>12个测试数据集txt</li>
<li>12个测试结果的截图</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>插入排序</tag>
        <tag>归并排序</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>算法作业笔记0404</title>
    <url>/201904/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B00404/</url>
    <content><![CDATA[<h2 id="0404算法作业"><a href="#0404算法作业" class="headerlink" title="0404算法作业"></a>0404算法作业</h2><h3 id="测试程序时间"><a href="#测试程序时间" class="headerlink" title="测试程序时间"></a>测试程序时间</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;ctime&gt;</span><br><span class="line">clock_t start,finish;</span><br><span class="line">double runtime;</span><br><span class="line">start = clock();</span><br><span class="line">//......</span><br><span class="line">finish = clock();</span><br><span class="line">runtime = (double)(finish - start)/CLOCKS_PER_SECOND;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="归并排序Debug"><a href="#归并排序Debug" class="headerlink" title="归并排序Debug"></a>归并排序Debug</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*MergeSort*/</span><br><span class="line"></span><br><span class="line">void Merge(int A[], int p, int q, int r)</span><br><span class="line">&#123;</span><br><span class="line">	//创造左右两个数组L、R，将已经排好的两部分放进去 </span><br><span class="line">	int n1 = q - p + 1, n2 = r - q;</span><br><span class="line">	int L[n1], R[n2];</span><br><span class="line">	int i,j;</span><br><span class="line">	for (i = 0; i &lt; n1; i++)</span><br><span class="line">		L[i] = A[p + i];</span><br><span class="line">	for (j = 0; j &lt; n2; j++)</span><br><span class="line">		R[j] = A[q + 1 + j];</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">	//开始对两个数组进行归并 </span><br><span class="line">	i = 0; j = 0;</span><br><span class="line">	for (int k = p; k &lt;= r; k++) &#123;</span><br><span class="line">		if(i == n1)&#123;//如果左边数组已经全放进去 </span><br><span class="line">			while(j &lt; n2)	A[k++] = R[j++];//这里j&lt;n2,而不是j&lt;n2-1!</span><br><span class="line">		&#125; else if ( j == n2)&#123;//如果右边数组已经全放进去 </span><br><span class="line">			while(i &lt; n1)	A[k++] = L[i++];</span><br><span class="line">		&#125; else&#123;//比较两个数组，把小的数放进A数组，指针后移 </span><br><span class="line">			if (L[i] &lt;= R[j]) &#123;</span><br><span class="line">				A[k] = L[i];</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				A[k] = R[j];</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MergeSortUp(int A[], int p,int r)</span><br><span class="line">&#123;</span><br><span class="line">	if (p &lt; r) &#123;</span><br><span class="line">		int q = (p + r) / 2;</span><br><span class="line">		MergeSortUp(A, p, q);</span><br><span class="line">		MergeSortUp(A, q + 1, r);</span><br><span class="line">		Merge(A, p, q, r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="double类型的占位符"><a href="#double类型的占位符" class="headerlink" title="double类型的占位符"></a>double类型的占位符</h3><p>在C语言中：</p>
<ul>
<li><p>1）用 scanf() 函数输入 double 类型的变量时，转换说明中的转换字符(占位符)只能用 lf，即%lf，写成 %f 无法正确输入double型数据；</p>
</li>
<li><p>2）用 printf() 函数输出 double 类型的变量时，转换说明中的转换字符(占位符)可用 %lf 或%f，皆能正确输出，且输出结果一致。</p>
</li>
<li><p>为简单与一致性起见，在对 double 类型的变量输入输出时，建议都用 %lf 占位符。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>算法作业笔记0403</title>
    <url>/201904/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B00403/</url>
    <content><![CDATA[<h2 id="4月3日作业插入算法、归并排序、快速排序"><a href="#4月3日作业插入算法、归并排序、快速排序" class="headerlink" title="4月3日作业插入算法、归并排序、快速排序"></a>4月3日作业插入算法、归并排序、快速排序</h2><h3 id="fscanf函数"><a href="#fscanf函数" class="headerlink" title="fscanf函数"></a>fscanf函数</h3><span id="more"></span>
<ul>
<li>函数名:<br>fscanf</li>
<li>功 能:<br>从一个流中执行格式化输入,fscanf遇到空格和换行时结束，注意空格时也结束。这与fgets有区别，fgets遇到空格不结束。</li>
<li>返回值：<br>整型，成功返回读入的参数的个数，失败返回EOF(-1)。</li>
<li>用法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FILE *stream：文件指针</span><br><span class="line">char *format：格式字符串</span><br><span class="line">[argument...]：输入列表</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    printf(&quot;Input an integer:&quot;);</span><br><span class="line">    /*从标准输入中读取一个整数*/</span><br><span class="line">    if(fscanf(stdin, &quot;%d&quot;,&amp;i))</span><br><span class="line">    printf(&quot;The integer read was:%d\n&quot;, i);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;Error reading an integer from stdin.\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="int的最大值"><a href="#int的最大值" class="headerlink" title="int的最大值"></a>int的最大值</h3><ul>
<li><p>int占32位的时候，最大可以赋值为：2147483647。也就是0x7fffffff。</p>
</li>
<li><p>在计算机里我们的规定最高位是符号位。为0是正，为1负。所以最高位是不可以参加计算的。</p>
</li>
<li><p>比如二进制数1000最高位是符号位的话，转十进制不是8，而是-0，对就是负0（正0的二进制形式是0000）。</p>
</li>
<li><p>所以，k位的二进制整数可以表示的状态共2^k种，所以，有2^(k-1)个，而int型占4个字节，有32位，所以有2^31-1个，即2147483647。</p>
</li>
</ul>
<h3 id="字符指针的定义"><a href="#字符指针的定义" class="headerlink" title="字符指针的定义"></a>字符指针的定义</h3><p><img src="https://img-blog.csdn.net/20180201210730474?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHdlbnR5b25lcGlsb3Rz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="1.1"></p>
<h3 id="C生成随机数"><a href="#C生成随机数" class="headerlink" title="C生成随机数"></a>C生成随机数</h3><h4 id="lt-一-gt"><a href="#lt-一-gt" class="headerlink" title="&lt;一&gt;"></a>&lt;一&gt;</h4><p>C/C++怎样产生随机数：这里要用到的是rand()函数, srand()函数，C语言/C++里没有自带的random(int number)函数。</p>
<ul>
<li>(1)  如果你只要产生随机数而不需要设定范围的话，你只要用rand()就可以了：rand()会返回一随机数值, 范围在0至RAND_MAX 间。RAND_MAX定义在stdlib.h, 其值为2147483647。</li>
<li>(2)  如果你要随机生成一个在一定范围的数，你可以在宏定义中定义一个random(int number)函数，然后在main()里面直接调用random()函数：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：随机生成10个0~100的数：</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define random(x) (rand()%x)</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">     for(int x=0;x&lt;10;x++)</span><br><span class="line">           printf(&quot;%d/n&quot;,random(100));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>(3)但是上面两个例子所生成的随机数都只能是一次性的，如果你第二次运行的时候输出结果仍和第一次一样。这与srand()函数有关。srand()用来设置rand()产生随机数时的随机数种子。在调用rand()函数产生随机数前，必须先利用srand()设好随机数种子（seed）, 如果未设随机数种子, rand()在调用时会自动设随机数种子为1。上面的两个例子就是因为没有设置随机数种子，每次随机数种子都自动设成相同值1 ，进而导致rand()所产生的随机数值都一样。</li>
</ul>
<p>srand()函数定义 ： void srand (unsigned int seed);<br>通常可以利用geypid()或time(0)的返回值来当做seed<br>如果你用time(0)的话，要加入头文件#include<time.h></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">#define random(x) (rand()%x)</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">     srand((int)time(0));</span><br><span class="line">     for(int x=0;x&lt;10;x++)</span><br><span class="line">           printf(&quot;%d/n&quot;,random(100));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fprintf函数"><a href="#fprintf函数" class="headerlink" title="fprintf函数"></a>fprintf函数</h3><h3 id=""><a href="#" class="headerlink" title="#"></a>#</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int fprintf (FILE* stream, const char*format, [argument])</span><br></pre></td></tr></table></figure>
<p>FILE<em>stream：文件指针<br>const char</em> format：输出格式<br>[argument]：附加参数列表  </p>
<p>示例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//...</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">    FILE *FSPOINTER;</span><br><span class="line">    char STRBUFF[16] = &quot;Hello World.&quot;;</span><br><span class="line">    //...</span><br><span class="line">    FSPOINTER = fopen(&quot;HELLO.TXT&quot;, &quot;w+&quot;);</span><br><span class="line">    //...</span><br><span class="line">    fprintf(FSPOINTER, &quot;%s&quot;, STRBUFF);</span><br><span class="line">    //...</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">输出至文件HELLO.TXT：</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>fscanf</tag>
        <tag>fprint</tag>
      </tags>
  </entry>
  <entry>
    <title>30天自制操作系统（14）</title>
    <url>/201903/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8814%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY14-高分辨率及键盘输入"><a href="#DAY14-高分辨率及键盘输入" class="headerlink" title="DAY14_高分辨率及键盘输入"></a>DAY14_高分辨率及键盘输入</h1><h2 id="1-继续测试性能"><a href="#1-继续测试性能" class="headerlink" title="1. 继续测试性能"></a>1. 继续测试性能</h2><ul>
<li>之前我们通过“消除位移处理”缩短时间，对于很多“位移”情况，改进才能看到效果。所以我们使用大量的定时器，然后对性能进行比较。</li>
</ul>
<h2 id="2-提高分辨率（1）"><a href="#2-提高分辨率（1）" class="headerlink" title="2.提高分辨率（1）"></a>2.提高分辨率（1）</h2><ul>
<li>由于画面切换中我们要使用BIOS，所以就需要改写asmhead.nas的“画面模式设定”部分了。</li>
</ul>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 设定画面模式</span><br><span class="line">     MOV BX,0x4101 ; VBE的640x480x8bi彩色</span><br><span class="line">     MOV AX,0x4f02 </span><br><span class="line">     INT 0x10 </span><br><span class="line">     MOV BYTE [VMODE],8 ; 记下画面模式（参考C语言）</span><br><span class="line">     MOV WORD [SCRNX],640 </span><br><span class="line">     MOV WORD [SCRNY],480 </span><br><span class="line">     MOV DWORD [VRAM],0xe0000000 </span><br></pre></td></tr></table></figure>
<h2 id="3-提高分辨率（2）"><a href="#3-提高分辨率（2）" class="headerlink" title="3.提高分辨率（2）"></a>3.提高分辨率（2）</h2><ul>
<li>将程序改写，使在真机上运行</li>
</ul>
<h2 id="4-键盘输入（1）"><a href="#4-键盘输入（1）" class="headerlink" title="4.键盘输入（1）"></a>4.键盘输入（1）</h2><ul>
<li>按照下表，在键盘按键的基础上加上0x80就可以得到键弹起时的数值<br><img src="https://s2.ax1x.com/2019/03/31/ArbywT.jpg" alt="14.1"></li>
</ul>
<h2 id="5-键盘输入（2）"><a href="#5-键盘输入（2）" class="headerlink" title="5.键盘输入（2）"></a>5.键盘输入（2）</h2><ul>
<li>问题：每一个按键都需要一个if，程序会变长，我们进行修改：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static char keytable[0x54] = &#123; </span><br><span class="line">     0, 0, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;0&#x27;, &#x27;-&#x27;, &#x27;^&#x27;, 0, 0, </span><br><span class="line">     &#x27;Q&#x27;, &#x27;W&#x27;, &#x27;E&#x27;, &#x27;R&#x27;, &#x27;T&#x27;, &#x27;Y&#x27;, &#x27;U&#x27;, &#x27;I&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;@&#x27;, &#x27;[&#x27;, 0, 0, &#x27;A&#x27;, &#x27;S&#x27;, </span><br><span class="line">     &#x27;D&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;;&#x27;, &#x27;:&#x27;, 0, 0, &#x27;]&#x27;, &#x27;Z&#x27;, &#x27;X&#x27;, &#x27;C&#x27;, &#x27;V&#x27;, </span><br><span class="line">     &#x27;B&#x27;, &#x27;N&#x27;, &#x27;M&#x27;, &#x27;,&#x27;, &#x27;.&#x27;, &#x27;/&#x27;, 0, &#x27;*&#x27;, 0, &#x27; &#x27;, 0, 0, 0, 0, 0, 0, </span><br><span class="line">     0, 0, 0, 0, 0, 0, 0, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;-&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;+&#x27;, &#x27;1&#x27;, </span><br><span class="line">     &#x27;2&#x27;, &#x27;3&#x27;, &#x27;0&#x27;, &#x27;.&#x27; </span><br><span class="line">     &#125;; </span><br><span class="line"> if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /* 键盘数据 */ </span><br><span class="line">     sprintf(s, &quot;%02X&quot;, i - 256); </span><br><span class="line">     putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2); </span><br><span class="line">         if (i &lt; 256 + 0x54) &#123; </span><br><span class="line">             if (keytable[i - 256] != 0) &#123; </span><br><span class="line">             s[0] = keytable[i - 256]; </span><br><span class="line">             s[1] = 0; </span><br><span class="line">             putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, s, 1); </span><br><span class="line">             &#125; </span><br><span class="line">        &#125; </span><br><span class="line"> &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; /* 鼠标数据 */ </span><br></pre></td></tr></table></figure>
<h2 id="6-追记内容（1）"><a href="#6-追记内容（1）" class="headerlink" title="6.追记内容（1）"></a>6.追记内容（1）</h2><p>==在窗口中添加一些画，改变鼠标和字符的显示位置以及颜色。按下BackSpace，还可以改写已经输入的字符==</p>
<h2 id="7-追记内容（2）"><a href="#7-追记内容（2）" class="headerlink" title="7.追记内容（2）"></a>7.追记内容（2）</h2><p>==使用鼠标移动窗口==<br>添加的程序<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ((mdec.btn &amp; 0x01) != 0) &#123; </span><br><span class="line"> /* 按下左键、移动sht_win */</span><br><span class="line"> sheet_slide(sht_win, mx - 80, my - 8); </span><br><span class="line">/* 到这里结束！ */ &#125; </span><br></pre></td></tr></table></figure></p>
<ul>
<li>即使窗口跑到了画面外，也没有问题。因为我们已经针对鼠标指针提前采取了对策，这就如<br>同图层跑到了画面外面也可以动起来一样。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（13）</title>
    <url>/201903/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8813%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY13-定时器（2）"><a href="#DAY13-定时器（2）" class="headerlink" title="DAY13_定时器（2）"></a>DAY13_定时器（2）</h1><h2 id="1-简化字符串显示"><a href="#1-简化字符串显示" class="headerlink" title="1. 简化字符串显示"></a>1. 简化字符串显示</h2><ul>
<li>将“涂背景色、写字符、完成刷新”写进一个函数，更方便使用<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void putfonts8_asc_sht(struct SHEET *sht, int x, int y, int c, int b, char *s, int l) </span><br><span class="line">&#123; </span><br><span class="line">     boxfill8(sht-&gt;buf, sht-&gt;bxsize, b, x, y, x + l * 8 - 1, y + 15); </span><br><span class="line">     putfonts8_asc(sht-&gt;buf, sht-&gt;bxsize, x, y, c, s); </span><br><span class="line">     sheet_refresh(sht, x, y, x + l * 8, y + 16); </span><br><span class="line">     return; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x, y ...... 显示位置的坐标</span><br><span class="line">c ...... 字符颜色（color）</span><br><span class="line">b ...... 背景颜色（back color）</span><br><span class="line">s ...... 字符串（string）</span><br><span class="line">l ...... 字符串长度（length）</span><br></pre></td></tr></table></figure>
<h2 id="2-重新调整FIFO缓冲区（1）"><a href="#2-重新调整FIFO缓冲区（1）" class="headerlink" title="2.重新调整FIFO缓冲区（1）"></a>2.重新调整FIFO缓冲区（1）</h2><ul>
<li>将定时器用的多个FIFO缓冲区都集中成一个，往FIFO写入不同的数据，就能够正常地分辨出是哪个寄存器超时了。</li>
</ul>
<h2 id="3-测试性能"><a href="#3-测试性能" class="headerlink" title="3.测试性能"></a>3.测试性能</h2><ul>
<li>我们专注于定时器地改良，是因为在今后地开发中会经常使用定时器。</li>
<li>测试性能地方法：先对HariMain略加修改，恢复变量count，然后完全不显示计数，全力执行“count++；”语句。当到了10秒后超时的时候，再显示这个count值。</li>
</ul>
<h2 id="4-重新调整FIFO缓冲区（2）"><a href="#4-重新调整FIFO缓冲区（2）" class="headerlink" title="4.重新调整FIFO缓冲区（2）"></a>4.重新调整FIFO缓冲区（2）</h2><ul>
<li>把3个定时器全部归纳到一个FIFO缓冲区中，就可以把键盘和鼠标归纳起来，只用1个FIFO缓冲区。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0～ 1…………………光标闪烁用定时器</span><br><span class="line">3…………………3秒定时器</span><br><span class="line">10…………………10秒定时器</span><br><span class="line">256～ 511…………………键盘输入（从键盘控制器读入的值再加上256）</span><br><span class="line">512～ 767……鼠标输入（从键盘控制器读入的值再加上512）</span><br></pre></td></tr></table></figure>
<ul>
<li>此次我们改写最多的是HariMain。在HariMain里，执行“count++;”语句和查询FIFO缓冲区中是否有数据这两个操作，是多次交互进行的。这次修改以后，程序只需要看1个FIFO缓冲区就行了，而以前要看3个。也就是说，FIFO缓冲区的查询能够更快完成，从而使得“count++;”语句执行的次数更多。</li>
</ul>
<h2 id="5-加快中断处理（4）"><a href="#5-加快中断处理（4）" class="headerlink" title="5.加快中断处理（4）"></a>5.加快中断处理（4）</h2><ul>
<li>在FIFO里有一个取代移位处理的方法：读取一个数据以后不是让后面的数据向前靠齐，而是<br>改变下一次的数据读取地址。这是一个很巧妙的方法，但不适用于定时器。因为从timers[ ]中去除超时的中断时，这个方法虽然不错，但问题在于，用timer_settime登录中断时，后面的中断必须后移，在这一点上，以上方法不太好。</li>
<li><p>更好的方法：我们在结构体struct TIMER中加入next变量。这是个地址变量，用来存放下一个即将超时的定时器的地址。<br><img src="https://s2.ax1x.com/2019/03/31/ArHaKx.jpg" alt="13.1"></p>
</li>
<li><p>判断一下顺序，如果我们知道了插入的位置（即知道了在s和t中间插入的话），就可以像下图那样把数据重新连接起来。也就是仅仅改变s-&gt;next和timer-&gt;next的值就可以了。</p>
</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/03/31/ArHgxI.jpg" alt="13.2"></p>
<h2 id="6-使用“哨兵”简化程序"><a href="#6-使用“哨兵”简化程序" class="headerlink" title="6.使用“哨兵”简化程序"></a>6.使用“哨兵”简化程序</h2><ul>
<li>我们来看看具体的做法。在进行初始化的时候，将时刻0xffffffff的定时器连到最后一个定时器上。虽然我们偷了点懒没有设定fifo等，但不必担心。反正无论如何都不可能到达这个时刻（在到达之前会修改时刻），所以不可能发生超时问题。它一直处于后面，只是个附带物，是个留下来看家的留守者。这个留守者正是“哨兵“。</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（12）</title>
    <url>/201903/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8812%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY12-定时器（1）"><a href="#DAY12-定时器（1）" class="headerlink" title="DAY12_定时器（1）"></a>DAY12_定时器（1）</h1><h2 id="1-使用定时器"><a href="#1-使用定时器" class="headerlink" title="1.使用定时器"></a>1.使用定时器</h2><p><font color="FF0000">介绍定时器的作用，添加定时器实现中断。</font></p>
<ul>
<li>定时器（Timer）对于操作系统十分重要，每隔一段时间就发送一个中断信号给CPU。有了定时器，CPU就不用辛苦地计量时间。</li>
<li>没有定时器，我们就没法使用HLT指令，意味着要浪费很多电能。</li>
<li>有了定时器中断，程序只需要以自己的步调处理自己的问题就可以了。至于到底经过了多少时间，只要在中断处理程序中数一数定时器中断发生的次数就可以了。</li>
</ul>
<span id="more"></span>
<hr>
<ul>
<li>要在电脑中管理定时器，只需要对PIT（Programmable Interval Timer可编程的间隔型定时器）进行设定就可以了。通过设定PIT，让定时器每隔多少秒就产生一次中断。</li>
<li>在电脑中PIT连接着IRQ（interrupt request）的0号，所以只要设定了PIT就可以设定IRQ0的中断间隔。</li>
<li>我们不清楚其中的详细原理，只知道只要执行3次OUT指令设定就完成了。将中断周期设定为11932的话，中断频率好像就是100Hz，也就是说1秒钟会发生100次中断。</li>
<li>IRQ0发生时所调用的中断处理程序几乎和键盘的中断处理程序一样。</li>
</ul>
<h2 id="2-计量时间"><a href="#2-计量时间" class="headerlink" title="2.计量时间"></a>2.计量时间</h2><p>==加入计时器显示时间==</p>
<ul>
<li>让中断执行下面的程序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct TIMERCTL &#123; </span><br><span class="line">    unsigned int count; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<ul>
<li>实现方法<ul>
<li>定义struct TIMERCTL结构体，在结构体内定义一个计数变量。</li>
<li>初始化PIT时，计数变量为0，每次发生定时器中断时，计数变量就以1递增。</li>
<li>即计数变量在HariMain中不进行加算，每1s也会增加100.</li>
</ul>
</li>
</ul>
<h2 id="3-超时功能"><a href="#3-超时功能" class="headerlink" title="3.超时功能"></a>3.超时功能</h2><p>==超时功能的定义，添加超时功能==</p>
<ul>
<li>我们可以计量处理所花费的时间。具体做法：处理前看一下时间并把它存放到一个变量变量里，处理结束后再看一下时间，做差即可。根据这个可以编制==基准测试程序==</li>
<li>超时（timeout）：过了一段时间，定时器提示操作系统。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct TIMERCTL &#123; </span><br><span class="line">     unsigned int count; </span><br><span class="line">     unsigned int timeout; </span><br><span class="line">     struct FIFO8 *fifo; </span><br><span class="line">     unsigned char data; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>timeout用于记录离超时还有多长时间，当剩余时间到达0时，程序就往IFIFO缓冲区里发送数据。</p>
<h2 id="4-设定多个定时器"><a href="#4-设定多个定时器" class="headerlink" title="4.设定多个定时器"></a>4.设定多个定时器</h2><ul>
<li>在上一节做的超时功能，超时结束后如果再设定1000的话，那我们就可以让它每10秒显示一<br>次，或是让它一闪一灭地显示。</li>
<li>开发操作系统时，超时功能非常方便，所以在很多地方都可以使用它。比如可以让电子时钟<br>每隔1秒重新显示一次；演奏音乐时，可以用它计量音符的长短；也可以让它以0.1秒1次的频率来监视没有中断功能的装置；另外，还可以用它实现光标的闪烁功能。<br>为了简单地实现这些功能，我们要准备很多能够设定超时的定时器。</li>
</ul>
<h2 id="5-加快中断处理（1）"><a href="#5-加快中断处理（1）" class="headerlink" title="5.加快中断处理（1）"></a>5.加快中断处理（1）</h2><ul>
<li>问题：inthandler20中断花费了很长的时间</li>
<li>优化部分：现每次进行定时器中断处理的时候，都会对所有活动中的定时器进行“timerctl.timer[i].timeout—;”处理。也就是说，CPU要完成从内存中读取变量值，减去1，然后又往内存中写入的操作。</li>
<li>time[i].timeout不再是“所剩时间”而是“予定时刻”，将timerctl.count和timer[i].timeout进行比较，不用再经过内存计算。</li>
<li>问题：count设定成最大值，一段时间后需要重新启动操作系统。</li>
</ul>
<h2 id="6-加快中断处理（2）"><a href="#6-加快中断处理（2）" class="headerlink" title="6.加快中断处理（2）"></a>6.加快中断处理（2）</h2><p>==优化if语句==<br>解决方案：添加timerctl.next，让它记住下一个时刻</p>
<h2 id="7-加快中断处理（3）"><a href="#7-加快中断处理（3）" class="headerlink" title="7.加快中断处理（3）"></a>7.加快中断处理（3）</h2><ul>
<li>问题：到达next时刻和没到next时刻的定时器中断，它们的处理时间差别很大。<br>这样的程序结构不好。因为平常运行一直都很快的程序，会偶尔由于中断处理拖得太长，而搞得像是主程序要停了似的。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（11）</title>
    <url>/201903/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8811%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY11-制作窗口"><a href="#DAY11-制作窗口" class="headerlink" title="DAY11_制作窗口"></a>DAY11_制作窗口</h1><h2 id="1-鼠标显示问题"><a href="#1-鼠标显示问题" class="headerlink" title="1.鼠标显示问题"></a>1.鼠标显示问题</h2><ul>
<li>我们系统的鼠标不能够向右或向下移动到画面之外隐藏起来。为此我们修改HariMain</li>
</ul>
<span id="more"></span>
<p>将<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (mx &gt; binfo-&gt;scrnx - 16) &#123; </span><br><span class="line">    mx = binfo-&gt;scrnx - 16; </span><br><span class="line"> &#125; </span><br><span class="line"> if (my &gt; binfo-&gt;scrny - 16) &#123; </span><br><span class="line">    my = binfo-&gt;scrny - 16; </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><br>修改为<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (mx &gt; binfo-&gt;scrnx - 1) &#123; </span><br><span class="line">    mx = binfo-&gt;scrnx - 1; </span><br><span class="line"> &#125; </span><br><span class="line"> if (my &gt; binfo-&gt;scrny - 1) &#123; </span><br><span class="line">    my = binfo-&gt;scrny - 1; </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure></p>
<h2 id="2-实现画面外的支持"><a href="#2-实现画面外的支持" class="headerlink" title="2.实现画面外的支持"></a>2.实现画面外的支持</h2><h2 id="3-shtctl的指定省略"><a href="#3-shtctl的指定省略" class="headerlink" title="3.shtctl的指定省略"></a>3.shtctl的指定省略</h2><p>仅仅是上下移动图层就必须指定ctl太麻烦了。修改将sheet_refresh、sheet_slide、sheet_free等函数，让它们不再指定ctl</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sheet_refresh</span><span class="params">(<span class="keyword">struct</span> SHEET *sht, <span class="type">int</span> bx0, <span class="type">int</span> by0, <span class="type">int</span> bx1, <span class="type">int</span> by1)</span> </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">if</span> (sht-&gt;height &gt;= <span class="number">0</span>) &#123; <span class="comment">/* 如果正在显示，则按新图层的信息进行刷新*/</span> </span><br><span class="line"> sheet_refreshsub(sht-&gt;ctl, sht-&gt;vx0 + bx0, sht-&gt;vy0 + by0, sht-&gt;vx0 + bx1, sht-&gt;vy0 + by1); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">sheet_slide</span><span class="params">(<span class="keyword">struct</span> SHEET *sht, <span class="type">int</span> vx0, <span class="type">int</span> vy0)</span> </span><br><span class="line">&#123; </span><br><span class="line"> <span class="type">int</span> old_vx0 = sht-&gt;vx0, old_vy0 = sht-&gt;vy0; </span><br><span class="line"> sht-&gt;vx0 = vx0; </span><br><span class="line"> sht-&gt;vy0 = vy0; </span><br><span class="line"> <span class="keyword">if</span> (sht-&gt;height &gt;= <span class="number">0</span>) &#123; <span class="comment">/* 如果正在显示，则按新图层的信息进行刷新 */</span> </span><br><span class="line"> sheet_refreshsub(sht-&gt;ctl, old_vx0, old_vy0, old_vx0 + sht-&gt;bxsize, old_vy0 + </span><br><span class="line">sht-&gt;bysize); </span><br><span class="line"> sheet_refreshsub(sht-&gt;ctl, vx0, vy0, vx0 + sht-&gt;bxsize, vy0 + sht-&gt;bysize); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">sheet_free</span><span class="params">(<span class="keyword">struct</span> SHEET *sht)</span> </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">if</span> (sht-&gt;height &gt;= <span class="number">0</span>) &#123; </span><br><span class="line"> sheet_updown(sht, <span class="number">-1</span>); <span class="comment">/* 如果正在显示，则先设置为隐藏 */</span> </span><br><span class="line"> &#125; </span><br><span class="line"> sht-&gt;flags = <span class="number">0</span>; <span class="comment">/* 未使用标记 */</span> </span><br><span class="line"> <span class="keyword">return</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="4-显示窗口"><a href="#4-显示窗口" class="headerlink" title="4.显示窗口"></a>4.显示窗口</h2><ul>
<li>先准备一张图层，然后在图层缓冲区内描绘一个貌似窗口的图就可以了。</li>
</ul>
<p>只是对graph.c的init_screen8函数稍微进行修改。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void make_window8(unsigned char *buf, int xsize, int ysize, char *title) </span><br><span class="line">&#123; </span><br><span class="line">     static char closebtn[14][16] = &#123; </span><br><span class="line">     &quot;OOOOOOOOOOOOOOO@&quot;, </span><br><span class="line">     &quot;OQQQQQQQQQQQQQ$@&quot;, </span><br><span class="line">     &quot;OQQQQQQQQQQQQQ$@&quot;, </span><br><span class="line">     &quot;OQQQ@@QQQQ@@QQ$@&quot;, </span><br><span class="line">     &quot;OQQQQ@@QQ@@QQQ$@&quot;, </span><br><span class="line">     &quot;OQQQQQ@@@@QQQQ$@&quot;, </span><br><span class="line">     &quot;OQQQQQQ@@QQQQQ$@&quot;, </span><br><span class="line">     &quot;OQQQQQ@@@@QQQQ$@&quot;, </span><br><span class="line">     &quot;OQQQQ@@QQ@@QQQ$@&quot;, </span><br><span class="line">     &quot;OQQQ@@QQQQ@@QQ$@&quot;, </span><br><span class="line">     &quot;OQQQQQQQQQQQQQ$@&quot;, </span><br><span class="line">     &quot;OQQQQQQQQQQQQQ$@&quot;, </span><br><span class="line">     &quot;O$$$$$$$$$$$$$$@&quot;, </span><br><span class="line">     &quot;@@@@@@@@@@@@@@@@&quot; </span><br><span class="line">     &#125;; </span><br><span class="line">     int x, y; </span><br><span class="line">     char c; </span><br><span class="line">     boxfill8(buf, xsize, COL8_C6C6C6, 0, 0, xsize - 1, 0 ); </span><br><span class="line">     boxfill8(buf, xsize, COL8_FFFFFF, 1, 1, xsize - 2, 1 ); </span><br><span class="line">     boxfill8(buf, xsize, COL8_C6C6C6, 0, 0, 0, ysize - 1); </span><br><span class="line">     boxfill8(buf, xsize, COL8_FFFFFF, 1, 1, 1, ysize - 2); </span><br><span class="line">     boxfill8(buf, xsize, COL8_848484, xsize - 2, 1, xsize - 2, ysize - 2); </span><br><span class="line">     boxfill8(buf, xsize, COL8_000000, xsize - 1, 0, xsize - 1, ysize - 1); </span><br><span class="line">     boxfill8(buf, xsize, COL8_C6C6C6, 2, 2, xsize - 3, ysize - 3); </span><br><span class="line">     boxfill8(buf, xsize, COL8_000084, 3, 3, xsize - 4, 20 ); </span><br><span class="line">     boxfill8(buf, xsize, COL8_848484, 1, ysize - 2, xsize - 2, ysize - 2); </span><br><span class="line">     boxfill8(buf, xsize, COL8_000000, 0, ysize - 1, xsize - 1, ysize - 1); </span><br><span class="line">     putfonts8_asc(buf, xsize, 24, 4, COL8_FFFFFF, title); </span><br><span class="line">     for (y = 0; y &lt; 14; y++) &#123; </span><br><span class="line">        for (x = 0; x &lt; 16; x++) &#123; </span><br><span class="line">            c = closebtn[y][x]; </span><br><span class="line">            if (c == &#x27;@&#x27;) &#123; </span><br><span class="line">                c = COL8_000000; </span><br><span class="line">            &#125; else if (c == &#x27;$&#x27;) &#123; </span><br><span class="line">            c = COL8_848484; </span><br><span class="line">            &#125; else if (c == &#x27;Q&#x27;) &#123; </span><br><span class="line">            c = COL8_C6C6C6; </span><br><span class="line">            &#125; else &#123; </span><br><span class="line">            c = COL8_FFFFFF; </span><br><span class="line">            &#125; </span><br><span class="line">            buf[(5 + y) * xsize + (xsize - 21 + x)] = c; </span><br><span class="line">        &#125;   </span><br><span class="line">     &#125; </span><br><span class="line">     return; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<h2 id="5-小实验"><a href="#5-小实验" class="headerlink" title="5.小实验"></a>5.小实验</h2><p>HariMain中有设置图层高度的地方，如果像下面这样，把窗口图层放在最上面，光标图层放在其次，会变成什么样呢？<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sheet_updown(sht_back, 0); </span><br><span class="line">sheet_updown(sht_mouse, 1); </span><br><span class="line">sheet_updown(sht_win, 2); </span><br></pre></td></tr></table></figure><br>鼠标会跑到窗口图层的下面。</p>
<h2 id="6-高速计数器"><a href="#6-高速计数器" class="headerlink" title="6.高速计数器"></a>6.高速计数器</h2><ul>
<li>我们要做一个能够计数，并且能够把计数结果显示出来的窗口。</li>
<li>但是在刷新的时候，总是先刷新refresh范围内的背景图层，然后再刷新窗口图层，导致数字闪烁。</li>
</ul>
<h2 id="7-消除闪烁（1）"><a href="#7-消除闪烁（1）" class="headerlink" title="7.消除闪烁（1）"></a>7.消除闪烁（1）</h2><ul>
<li>窗口图层刷新是因为窗口的内容有变化，所以要在画面上显示变化后的新内容。基本上来讲，可以认为其他图层的内容没有变化（如果其他图层的内容也变了，那么应该会随后执行该图层的刷新）。<br>既然如此，图层内容没有变化也进行刷新的话就太浪费了。如果只是窗口变了，那背景就不<br>用刷新了。假如上面有鼠标，但鼠标的图层没有变化，我们也必须要刷新。窗口的刷新，可能会覆盖鼠标的一部分显示区域。</li>
<li>在sheet_slide函数里，图层的移动有时会导致下面的图层露出，所以要从最下面开始刷新。<br>另一方面，在移动目标处，比新移来的图层位置还要低的图层没有什么变化，而且只是隐藏起来了，所以只要刷新移动的图层和它上面的图层就可以了。</li>
<li>但是修改代码后，鼠标放在数字区的时候，鼠标又开始闪烁。</li>
</ul>
<h2 id="8-消除闪烁（2）"><a href="#8-消除闪烁（2）" class="headerlink" title="8.消除闪烁（2）"></a>8.消除闪烁（2）</h2><ul>
<li>闪烁现象是由于一会儿描绘一会儿消除造成的。所以说要想消除闪烁，就要在刷新窗口时避开鼠标所在的地方对VRAM进行写入处理。</li>
<li><p>方法：先开辟一块儿内存，大小和VRAM一样，这块内存用来表示画面上的点是哪个图层的像素，相当于图层的地图。<br><img src="https://s2.ax1x.com/2019/03/24/AYhJwF.png" alt="d11.1"></p>
</li>
<li><p>今后程序会对照map内容来向VRAM中写入，所以有时没必要从下面开始一直刷新到最上面<br>一层。</p>
</li>
<li>在sheet_slide函数里，首先重写map，分别对应移动前后的图层，然后调用sheet_refreshsub函数。在移动前的地方，只针对上层图层移走之后而露出的下层图层进行重绘就可以了。在移动目的地处仅重绘了一张移动过去的图层。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（10）</title>
    <url>/201903/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8810%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY10-叠加处理"><a href="#DAY10-叠加处理" class="headerlink" title="DAY10_叠加处理"></a>DAY10_叠加处理</h1><h2 id="1-内存管理（续）"><a href="#1-内存管理（续）" class="headerlink" title="1.内存管理（续）"></a>1.内存管理（续）</h2><span id="more"></span>
<ul>
<li>memory.c中增加了“向上舍入”的部分，即我们要编写一些总是以0x1000字节为单位进行内存分配和释放的函数，它们会把指定的内存大小按0x1000字节为单位向上舍入（ roundup）。</li>
<li>从向下舍入开始<br>要想把十六进制的某一位设置为0，同样只进行“与运算”就可以。</li>
<li>向上舍入：先向下舍入，再在它的结果上做个加法运算就可以了。（要先判断后几位是不是0）</li>
<li>更好的向上舍入的方法：i = (i + 0xfff) &amp; 0xfffff000; </li>
</ul>
<h2 id="2-叠加处理"><a href="#2-叠加处理" class="headerlink" title="2.叠加处理"></a>2.叠加处理</h2><ul>
<li>寻找一种方法，不仅适用于鼠标的叠加，还适用于窗口的叠加。</li>
<li>在程序中创建管理多重图层信息的结构SHTCTL</li>
<li>sheet_refresh函数：这个函数会从下到上描绘所有的图层。refresh是“刷新”的意思。电视屏幕就是在1秒内完成多帧的描绘才做出动画效果的，这个动作就被称为刷新。而这种对图层的刷新动作，与电视屏幕的动作有些相似，所以我们也给它起名字叫做刷新。</li>
<li>sheet_slide：不改变图层的高度而只上下左右移动图层的函数。</li>
<li>sheet_free释放已使用图层的内存的函数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct SHTCTL *shtctl_init(struct MEMMAN *memman, unsigned char *vram, int xsize, int ysize) </span><br><span class="line">&#123; </span><br><span class="line">     struct SHTCTL *ctl; </span><br><span class="line">     int i; </span><br><span class="line">     ctl = (struct SHTCTL *) memman_alloc_4k(memman, sizeof (struct SHTCTL)); </span><br><span class="line">     if (ctl == 0) &#123; </span><br><span class="line">     goto err; </span><br><span class="line">     &#125; </span><br><span class="line">         ctl-&gt;vram = vram; </span><br><span class="line">         ctl-&gt;xsize = xsize; </span><br><span class="line">         ctl-&gt;ysize = ysize; </span><br><span class="line">         ctl-&gt;top = -1; /*一个SHEET没都有 */ </span><br><span class="line">         for (i = 0; i &lt; MAX_SHEETS; i++) &#123; </span><br><span class="line">         ctl-&gt;sheets0[i].flags = 0; /* 标记为未使用 */ </span><br><span class="line">        &#125; </span><br><span class="line">    err: </span><br><span class="line">     return ctl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先使用memman_alloc_4k来分配用于记忆图层控制变量的内存空间，这时必须指定该变量所占空间的大小，不过我们可以使用sizeof（struct SHTCTL）这种写法，让C编译器自动计算。只要写sizeof（变量型），C编译器就会计算出该变量型所需的字节数。<br>接着，我们给控制变量赋值，给其下的所有图层变量都加上“未使用”标签。</p>
<h2 id="3-提高叠加处理速度（1）"><a href="#3-提高叠加处理速度（1）" class="headerlink" title="3.提高叠加处理速度（1）"></a>3.提高叠加处理速度（1）</h2><ul>
<li>只需要重新描绘鼠标移动相关的部分，也就是移动前后的部分就可以了，即256×2=512个像素。这只是64 000像素的0.8%而已，所以有望提速很多。现在我们根据这个思路写一下程序。</li>
<li>要在画面上显示坐标等信息，结果又执行了sheet_refresh程序。所以我们要解决图层内文字显示的问题。</li>
</ul>
<h2 id="4-提高叠加处理速度（2）"><a href="#4-提高叠加处理速度（2）" class="headerlink" title="4.提高叠加处理速度（2）"></a>4.提高叠加处理速度（2）</h2><ul>
<li>使不写入像素内容，也要多次执行if语句。我们最初就应该把for语句的范围限定在刷新范围之内。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1) </span><br><span class="line">&#123; </span><br><span class="line">     int h, bx, by, vx, vy, bx0, by0, bx1, by1; </span><br><span class="line">     unsigned char *buf, c, *vram = ctl-&gt;vram; </span><br><span class="line">     struct SHEET *sht; </span><br><span class="line">     for (h = 0; h &lt;= ctl-&gt;top; h++) &#123; </span><br><span class="line">     sht = ctl-&gt;sheets[h]; </span><br><span class="line">     buf = sht-&gt;buf; </span><br><span class="line">     /* 使用vx0～vy1，对bx0～by1进行倒推 */ </span><br><span class="line">     bx0 = vx0 - sht-&gt;vx0; </span><br><span class="line">     by0 = vy0 - sht-&gt;vy0; </span><br><span class="line">     bx1 = vx1 - sht-&gt;vx0; </span><br><span class="line">     by1 = vy1 - sht-&gt;vy0; </span><br><span class="line">     if (bx0 &lt; 0) &#123; bx0 = 0; &#125; /* 说明(1) */ </span><br><span class="line">     if (by0 &lt; 0) &#123; by0 = 0; &#125; </span><br><span class="line">     if (bx1 &gt; sht-&gt;bxsize) &#123; bx1 = sht-&gt;bxsize; &#125; /* 说明(2) */ </span><br><span class="line">     if (by1 &gt; sht-&gt;bysize) &#123; by1 = sht-&gt;bysize; &#125; </span><br><span class="line">     for (by = by0; by &lt; by1; by++) &#123; </span><br><span class="line">        vy = sht-&gt;vy0 + by; </span><br><span class="line">        for (bx = bx0; bx &lt; bx1; bx++) &#123; </span><br><span class="line">            vx = sht-&gt;vx0 + bx; </span><br><span class="line">            c = buf[by * sht-&gt;bxsize + bx]; </span><br><span class="line">            if (c != sht-&gt;col_inv) &#123; </span><br><span class="line">            vram[vy * ctl-&gt;xsize + vx] = c; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     return; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（9）</title>
    <url>/201903/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%889%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY9-内存管理"><a href="#DAY9-内存管理" class="headerlink" title="DAY9_内存管理"></a>DAY9_内存管理</h1><h2 id="1-整理源文件"><a href="#1-整理源文件" class="headerlink" title="1.整理源文件"></a>1.整理源文件</h2><p><img src="https://s2.ax1x.com/2019/03/24/AYgbB4.md.png" alt="d9.1"></p>
<span id="more"></span>
<h2 id="2-内存容量检查"><a href="#2-内存容量检查" class="headerlink" title="2.内存容量检查"></a>2.内存容量检查</h2><ul>
<li>在最初启动时，BIOS肯定要检查内存容量，所以只要我们问一问BIOS，就能知道内存容量有多大。但是会很麻烦，我们选择自己动手检查内存。</li>
<li>做法：<ul>
<li>首先，暂时让486以后的CPU的高速缓存（cache）功能无效。<br>原理：内存检查时，要往内存里随便写入一个值，然后马上读取，来检查读取的值与写入的值是否相等。如果内存连接正常，则写入的值能够记在内存里。如果没连接上，则读出的值肯定是乱七八糟的。如果CPU里加上了缓存，写入和读出的不是内存，而是缓存。结果，所有的内存都“正常”，检查处理不能完成。<ul>
<li>通过HariMain识别3GB范围的内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-内存容量检查（2）"><a href="#3-内存容量检查（2）" class="headerlink" title="3.内存容量检查（2）"></a>3.内存容量检查（2）</h2><ul>
<li>编译器对程序进行了优化，无法识别内存，于是我们选择用汇编来写。</li>
</ul>
<h2 id="4-挑战内存管理"><a href="#4-挑战内存管理" class="headerlink" title="4.挑战内存管理"></a>4.挑战内存管理</h2><h3 id="内存管理是什么，为什么要进行内存管理？"><a href="#内存管理是什么，为什么要进行内存管理？" class="headerlink" title="内存管理是什么，为什么要进行内存管理？"></a>内存管理是什么，为什么要进行内存管理？</h3><p>操作系统在工作中，有时需要分配一定大小的内存，用完以后又不再需要，这种事会频繁发生。为了应付这些需求，必须恰当管理好哪些内存可以使用（哪些内存空闲），哪些内存不可以使用（正在使用），这就是内存管理。如果不进行管理，系统会变得一塌糊涂，要么知道哪里可用，要么多个应用程序使用同一地址的内存。</p>
<h3 id="内存管理的方法"><a href="#内存管理的方法" class="headerlink" title="内存管理的方法"></a>内存管理的方法</h3><ul>
<li>创建相应数量的区域，用1和0表示该区域是否被使用。但是这种方法的缺点就是，在内存区域很多的情况下，管理表很大。</li>
<li>列表管理的方法：从xxx号开始，yyy字节的空间是空着的。优点：占用内存小。大块内存的分配和释放都非常迅速。<br>缺点：程序管理变复杂了；当可用空间零散的时候，空间管理信息可能会被用完。  </li>
<li>我们的操作系统使用的方法是，当MEMMAN用完的时候，将小的内存区域舍弃，先不去管它。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统课程笔记（7）</title>
    <url>/201903/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89/</url>
    <content><![CDATA[<h1 id="操作系统课程笔记（七）-3月19日"><a href="#操作系统课程笔记（七）-3月19日" class="headerlink" title="操作系统课程笔记（七） 3月19日"></a>操作系统课程笔记（七） 3月19日</h1><h2 id="Chap-5-CPU调度"><a href="#Chap-5-CPU调度" class="headerlink" title="Chap.5 CPU调度"></a>Chap.5 CPU调度</h2><p><em>（简单的一章）</em></p>
<h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><p>调度对象都是由CPU-burst和I/O-burst组成的，CPU-burst占用的时间很短。</p>
<span id="more"></span>
<h4 id="2-调度程序（短期）"><a href="#2-调度程序（短期）" class="headerlink" title="2.调度程序（短期）"></a>2.调度程序（短期）</h4><ul>
<li>分为==抢占式==和==非抢占式==，两者的区别是调用调度时，CPU上是否有东西。</li>
<li>运行-&gt;等待：非抢占</li>
<li>运行-&gt;就绪：抢占</li>
<li>等待-&gt;就绪：抢占</li>
<li>终结：非抢占</li>
<li>（有人进入就绪状态调度就被激活——抢占！）</li>
</ul>
<h4 id="3-Dispatcher-分派"><a href="#3-Dispatcher-分派" class="headerlink" title="3.Dispatcher 分派"></a>3.Dispatcher 分派</h4><p>（上下文切换） 减少延时</p>
<h3 id="二、准则（判断CPU调度的好坏）"><a href="#二、准则（判断CPU调度的好坏）" class="headerlink" title="二、准则（判断CPU调度的好坏）"></a>二、准则（判断CPU调度的好坏）</h3><ul>
<li>1.CPU使用率</li>
<li>2.吞吐量</li>
<li>3.周转时间（到达-执行结束的时间）</li>
<li>4.等待时间（进程在就绪队列中等待的所有时间之和）</li>
<li>5.响应时间<br>==要找例题学会算这些准则==<h3 id="三、调度算法"><a href="#三、调度算法" class="headerlink" title="三、调度算法"></a>三、调度算法</h3><h4 id="Ⅰ、单队列（把所有就绪进程排进一个队列）"><a href="#Ⅰ、单队列（把所有就绪进程排进一个队列）" class="headerlink" title="Ⅰ、单队列（把所有就绪进程排进一个队列）"></a>Ⅰ、单队列（把所有就绪进程排进一个队列）</h4></li>
<li>1.FCFS先到先服务</li>
<li>2.最短作业优先<ul>
<li>非抢占</li>
<li>抢占preemitive（最短剩余作业优先）从平均时间来讲效果最好。<br>最短剩余作业的意义：相当于“基准”，其他调度算法越接近越好</li>
</ul>
</li>
<li><ol>
<li>优先级（调度时准入时有大概的时间，操作系统给任务赋优先级）<ul>
<li>抢占</li>
<li>非抢占<br>缺点：可能会把某些进程饿死（优先级太低了）<br>解决办法：老化（可以通过升降规则解决）</li>
</ul>
</li>
</ol>
</li>
<li>4.RR Round Robin时间片转换<ul>
<li>运行结束或时间片到就选下一个 </li>
<li>与时间片大小的选取有很大关系，至少要大于切换代价<br>响应时间很迅速，跟之前讲的OS分时一个道理。</li>
</ul>
</li>
</ul>
<h4 id="Ⅱ、多队列"><a href="#Ⅱ、多队列" class="headerlink" title="Ⅱ、多队列"></a>Ⅱ、多队列</h4><ul>
<li>1.普通队列<br>不够灵活（没有考虑系统运用期间去调整）</li>
<li>2.多级反馈队列<br>进程在队列间变换（比如太慢的进程扔到后台队列）<br>队列的优先级可以有升级、降级</li>
</ul>
<p><em>调度算法的评估</em></p>
<ul>
<li><em>确定性模型——静态的计算</em></li>
<li><em>分布模型——动态分布，到达时间满足某种分布</em></li>
<li><em>模拟——；对进程进行调度；得到某种参数</em></li>
<li><em>真实实现</em></li>
</ul>
<p>多级反馈队列的定义？（设计多级反馈队列，需要考虑什么参数？）</p>
<ul>
<li>1.几个队列</li>
<li>2.每个队列的调度算法</li>
<li>3.队列间调度（优先级升降？分时间片？）</li>
<li>4.初始队列（当进程需要服务时进入哪个队列？）</li>
</ul>
<h3 id="四、实时调度-real-time-scheduling"><a href="#四、实时调度-real-time-scheduling" class="headerlink" title="四、实时调度 real-time scheduling"></a>四、实时调度 real-time scheduling</h3><ul>
<li>硬实时<br>有准入，不能满足你就不接待你</li>
<li>软实时<br>TCP/IP<br>尽力服务你<ul>
<li>给高优先级</li>
<li>不降级</li>
<li>别人不能升级</li>
<li>分派代价降低</li>
</ul>
</li>
</ul>
<h3 id="五、调度距离"><a href="#五、调度距离" class="headerlink" title="五、调度距离"></a>五、调度距离</h3><p>Unix Solaris</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统课程笔记（6）</title>
    <url>/201903/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89/</url>
    <content><![CDATA[<h1 id="操作系统课程笔记（六）3月15日"><a href="#操作系统课程笔记（六）3月15日" class="headerlink" title="操作系统课程笔记（六）3月15日"></a>操作系统课程笔记（六）3月15日</h1><h2 id="Chap-4-线程-Thread"><a href="#Chap-4-线程-Thread" class="headerlink" title="Chap.4 线程 Thread"></a>Chap.4 线程 Thread</h2><h3 id="一、多进程"><a href="#一、多进程" class="headerlink" title="一、多进程"></a>一、多进程</h3><p><img src="https://s2.ax1x.com/2019/03/23/AJMsiV.png" alt="6.1"></p>
<span id="more"></span>
<ul>
<li>原始进程只有一个可执行序列。</li>
<li>上图右边-不同的进程寄存器、栈都要区分。进程间需要通信，但通信的成本很高。</li>
<li><p>于是我们将协作/并发的任务用线程实现<br>  每个进程有一个可执行序列，多个CPU无意义<br>每个进程有多个可执行序列，可分配到不同的CPU（多处理器）——即可以实现资源共享、经济性（不用切换上方的资源）</p>
</li>
<li><p>Q1：多线程和多进程的优缺点</p>
</li>
<li>A：<ul>
<li>响应速度多线程较快</li>
<li>资源占用，多线程共享资源</li>
<li>协作，进程间协作的成本更高。</li>
<li>CPU直接对应进程，进程集成度更强，结束更简单。</li>
</ul>
</li>
</ul>
<h3 id="二、多线程"><a href="#二、多线程" class="headerlink" title="二、多线程"></a>二、多线程</h3><p>==（将线程和进程对比学习，从结构和功能入手）==</p>
<ul>
<li>TCB线程控制块</li>
<li>用户线程、内核线程</li>
</ul>
<h4 id="1-线程的实现（结构）"><a href="#1-线程的实现（结构）" class="headerlink" title="1.线程的实现（结构）"></a>1.线程的实现（结构）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A(用户程序)---B(TCB)</span><br><span class="line">B---C(线程库)</span><br><span class="line">C---D(OS-&gt;PCB)</span><br></pre></td></tr></table></figure>
<h5 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h5><p><img src="https://s2.ax1x.com/2019/03/24/AYkjWd.png" alt="6.2"><br>用户态频繁地使用系统调用，下面被阻塞时，上面的用户态线程也无法使用。</p>
<h5 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h5><p><img src="https://s2.ax1x.com/2019/03/24/AYkxSA.png" alt="6.3"></p>
<ul>
<li>内核能看到用户态线程，每个用户态对应一个内核线程。</li>
<li>线程间并发互不影响</li>
<li>CPU提供给用户调用，用户可通过调用创建线程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A(user thread)---B(kernel thread)</span><br><span class="line">B---C(CPU)</span><br></pre></td></tr></table></figure>
<h5 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h5><p><img src="https://s2.ax1x.com/2019/03/24/AYkOFe.md.png" alt="6.5"></p>
<ul>
<li>线程库提供创建和删除LWP（light weight thread轻量级进程）的功能。</li>
<li>即内核线程调度LWP，LWP调度TCB</li>
<li>对于重要的用户线程可以分配一个专门的内核线程</li>
</ul>
<h4 id="2-线程的调度"><a href="#2-线程的调度" class="headerlink" title="2.线程的调度"></a>2.线程的调度</h4><h5 id="全局调度和局部调度"><a href="#全局调度和局部调度" class="headerlink" title="全局调度和局部调度"></a>全局调度和局部调度</h5><ul>
<li>对所有进程中的线程进行调度就是全局调度</li>
<li>对一个进程中的线程进行调度就是局部调度</li>
</ul>
<h5 id="一次调度和二次调度"><a href="#一次调度和二次调度" class="headerlink" title="一次调度和二次调度"></a>一次调度和二次调度</h5><ul>
<li>一对一是一次调度</li>
<li>多对一和多对多是二次调度</li>
</ul>
<h4 id="3-线程上下文切换（进程间-进程内）"><a href="#3-线程上下文切换（进程间-进程内）" class="headerlink" title="3.线程上下文切换（进程间/进程内）"></a>3.线程上下文切换（进程间/进程内）</h4><h4 id="4-线程的功能"><a href="#4-线程的功能" class="headerlink" title="4.线程的功能"></a>4.线程的功能</h4><ul>
<li>创建<br>  fork(),esec()</li>
<li><p>取消</p>
<ul>
<li>异步取消<br>  在线程未完成之前终止它，可能会导致系统不稳定。</li>
<li>延迟取消<br>  给线程信号，让它自己把占用的资源清理掉。<br>清理进程时占用的资源比较好清理。线程取消进程不一定取消，垃圾不方便清理。所以延迟取消有很大作用。</li>
</ul>
</li>
<li><p>线程池<br>线程已经创建好了，可以直接拿去服务。便于系统资源的控制</p>
</li>
<li><p>线程特定数据<br>允许每个线程有自己数据的复制（当没有线程创建权的时候十分有用）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统课程笔记（4）</title>
    <url>/201903/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/</url>
    <content><![CDATA[<h2 id="操作系统课程笔记（四）3月8日"><a href="#操作系统课程笔记（四）3月8日" class="headerlink" title="操作系统课程笔记（四）3月8日"></a>操作系统课程笔记（四）3月8日</h2><h3 id="Chap-2-操作系统的结构"><a href="#Chap-2-操作系统的结构" class="headerlink" title="Chap.2 操作系统的结构"></a>Chap.2 操作系统的结构</h3><h4 id="二、服务的组织结构"><a href="#二、服务的组织结构" class="headerlink" title="二、服务的组织结构"></a>二、服务的组织结构</h4><span id="more"></span>
<ul>
<li>简单结构<br>  如MS-DOS和Linux，服务简单的组合，没有结构可言。</li>
<li>分层<br>  内层为外层的服务提供服务。然而有时候的场景决定难以分层。比如“CPU调度”和“辅助存储驱动”两个服务，两者可能会互相调用，难以区分。</li>
<li>微内核  <ul>
<li>只保留最小的功能集合，其余的扔到外面</li>
<li>内核中应该留什么？ 进程管理（创建、销毁进程），内存管理，服务间的沟通（通信）</li>
<li>优点：内核的代码量小，便于维护、便于移植。</li>
<li>缺点：服务间通信的代价太大（外层服务之间通信还要经过内层服务）</li>
</ul>
</li>
<li>模块化  <ul>
<li>将内核态中的服务模块化，这些模块类似于积木块，可以进行“拆”、“装”，即添加或删除相应的模块。</li>
<li>服务间沟通可以用核内接口（把接口开放给其他对象，直接通过调用的方式）</li>
</ul>
</li>
<li>混合</li>
</ul>
<h4 id="三、操作系统的生成"><a href="#三、操作系统的生成" class="headerlink" title="三、操作系统的生成"></a>三、操作系统的生成</h4><ul>
<li>比如傻瓜生成法——调整代码。  </li>
<li>计算机用在不同的场所，并具有不同外设配置。对某个特定场所，必须要配置和生成系统。SYSGNEN  </li>
<li>操作系统的生成是“操作系统”和“硬件”的磨合。</li>
<li>bootstrap loader 定位核，装载进内存，开启。  </li>
<li>操作系统在硬件上，需加载到内存。</li>
</ul>
<h2 id="Chap-3-进程管理"><a href="#Chap-3-进程管理" class="headerlink" title="Chap.3 进程管理"></a>Chap.3 进程管理</h2><p>意义：用有限的资源实现大量的任务。  </p>
<h3 id="“数据结构”"><a href="#“数据结构”" class="headerlink" title="“数据结构”"></a>“数据结构”</h3><h4 id="1-一个任务"><a href="#1-一个任务" class="headerlink" title="1.一个任务"></a>1.一个任务</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[sort.c]--&gt;B[sort.exe]</span><br><span class="line">B--&gt;C[内存]</span><br></pre></td></tr></table></figure>
<p>内存：堆+栈、参数等。</p>
<h4 id="2-多个任务"><a href="#2-多个任务" class="headerlink" title="2.多个任务"></a>2.多个任务</h4><h5 id="2-1-PCB"><a href="#2-1-PCB" class="headerlink" title="2.1 PCB"></a>2.1 PCB</h5><p>需要添加一些结构才能管理了。<br>引入==进程控制块==PCB（process control block）。进程控制块的内容包括：</p>
<ul>
<li>进程描述信息<br>  比如标识符、属于哪个用户</li>
<li>进程控制信息<br>  目前运行的状态、优先级</li>
<li>资源占用信息</li>
<li>处理器现场保护<br>  当有任务被打断时保护现场</li>
</ul>
<p>我们用PCB代替了原任务的代码和数据库。<br>为了把这些杂乱无章的各种PCB组织起来，引入各种队列。</p>
<ul>
<li>作业队列（running）</li>
<li>就绪队列（ready）</li>
<li>设备队列（wait）</li>
</ul>
<p>在队列中我们能看到PCB的生命周期：在不同队列间转换。<br><img src="https://s2.ax1x.com/2019/03/23/AJiPHg.png" alt="4.1"></p>
<h5 id="2-2-调度Schedulers（控制PCB换队）"><a href="#2-2-调度Schedulers（控制PCB换队）" class="headerlink" title="2.2 调度Schedulers（控制PCB换队）"></a>2.2 调度Schedulers（控制PCB换队）</h5><ul>
<li>长期调度<br>  相当于“看门的”，PCB准入。<br>特性：执行频率不高.放准入进来要严格：使得CPU中使用I/O和使用CPU的PCB达到平衡。（the balance of I/O-bound process and CPU-bound process）</li>
<li>短期调度<br>  从就绪队列中选人。<br>  特性：执行频率高，所以速度应该很快，尽量不占用时间片。</li>
<li>中期调度<br>  把PCB扔出去，有资源了再进来。</li>
</ul>
<h6 id="2-3-到CPU中执行"><a href="#2-3-到CPU中执行" class="headerlink" title="2.3 到CPU中执行"></a>2.3 到CPU中执行</h6><h6 id="2-4-上下文切换（context-switch）（保护、恢复现场）"><a href="#2-4-上下文切换（context-switch）（保护、恢复现场）" class="headerlink" title="2.4 上下文切换（context switch）（保护、恢复现场）"></a>2.4 上下文切换（context switch）（保护、恢复现场）</h6><p>多任务、多用户时，这样的“代价”一定要减小。<br>有的OS有多组寄存器，便于上下文切换。（便于保存现场）</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统课程笔记（5）</title>
    <url>/201903/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/</url>
    <content><![CDATA[<h1 id="操作系统课程笔记（五）3月12日"><a href="#操作系统课程笔记（五）3月12日" class="headerlink" title="操作系统课程笔记（五）3月12日"></a>操作系统课程笔记（五）3月12日</h1><h2 id="Chap-3-进程管理"><a href="#Chap-3-进程管理" class="headerlink" title="Chap.3 进程管理"></a>Chap.3 进程管理</h2><h3 id="进程的“操作功能”"><a href="#进程的“操作功能”" class="headerlink" title="进程的“操作功能”"></a>进程的“操作功能”</h3><p>==(这一部分都要好好联系PPT仔细看)==</p>
<h4 id="一、创建"><a href="#一、创建" class="headerlink" title="一、创建"></a>一、创建</h4><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(父进程)--&gt;B(子进程)</span><br><span class="line">B--&gt;C(子子进程)</span><br></pre></td></tr></table></figure>
<p>子进程复制父进程，但fork的返回值不同。父进程返回子进程的id，子进程返回0。<br><img src="https://s2.ax1x.com/2019/03/23/AJVgHK.png" alt="5.1"><br>我们创造操作系统就是为了给用户提供fork，esec这样的函数。</p>
<ul>
<li>fork<br>  函数创建新的进程</li>
<li>esec<br>  在fork系统调用之后用，用新进程代替原存储空间的进程。</li>
</ul>
<h4 id="二、终止"><a href="#二、终止" class="headerlink" title="二、终止"></a>二、终止</h4><ul>
<li>正常终止<br>  任务完成，进程终止。</li>
<li>非正常终止<ul>
<li>父进程把子进程终止掉<br>两种非正常终止的原因：<ul>
<li>无用的子进程</li>
<li>子进程占用太多的资源</li>
</ul>
</li>
<li>父进程死<ul>
<li>级联终止（子进程全部结束）</li>
<li>在挂到上级节点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="三、挂起"><a href="#三、挂起" class="headerlink" title="三、挂起"></a>三、挂起</h4><p>“ready”状态没有进入到“running”状态，就去睡觉了。</p>
<h4 id="四、唤醒"><a href="#四、唤醒" class="headerlink" title="四、唤醒"></a>四、唤醒</h4><h4 id="五、进程协作"><a href="#五、进程协作" class="headerlink" title="五、进程协作"></a>五、进程协作</h4><p>IPC：Inter-process communication进程间通信<br>广义IPC的分类</p>
<ul>
<li>OS只提供内存，A和B自己干</li>
<li>消息机制（Kernel参与）</li>
<li>若两进程在网络上，socket，RPC（remote procedure calls远程进程调用），RMI（remote method interaction远程方法调用）</li>
</ul>
<h5 id="1-内存共享"><a href="#1-内存共享" class="headerlink" title="1.内存共享"></a>1.内存共享</h5><p>当buffer存在时（查看PPT，理解程序）<br><img src="https://s2.ax1x.com/2019/03/23/AJmQhD.jpg" alt="5.2"></p>
<h5 id="2-消息机制"><a href="#2-消息机制" class="headerlink" title="2.消息机制"></a>2.消息机制</h5><p>在OS内核里提供调用。</p>
<ul>
<li>分类<ul>
<li>直接通信</li>
<li>间接通信（通过邮箱）</li>
</ul>
</li>
<li>逻辑特性（同步）<ul>
<li>阻塞<br>  我发送信息，要等到对方接受才好</li>
<li>非阻塞<br>  只发送，然后去做别的事情<br>Buffer：</li>
<li>没有buffer时，消息机制只能阻塞。</li>
<li>有限缓存 都可以</li>
<li>无限缓存 必然非阻塞</li>
</ul>
</li>
</ul>
<h5 id="3-网络上"><a href="#3-网络上" class="headerlink" title="3.网络上"></a>3.网络上</h5><ul>
<li>socket<br>  IP+端口（IP定位到一个主机，端口（port）定位到程序）<br>socket用来传输最底层的二进制刘，起到连接的作用</li>
<li>RPC（remote procedure calls远程进程调用）</li>
<li>RMI（remote method interaction远程方法调用）</li>
</ul>
<hr>
<p>进程间通信，协作的两个进程必须自己做的事（o），需要OS做的事（x）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">/</th>
<th style="text-align:center">传数据</th>
<th style="text-align:center">控制</th>
<th style="text-align:center">解释数据</th>
<th style="text-align:center">给出反应 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">共享内存</td>
<td style="text-align:center">o</td>
<td style="text-align:center">o</td>
<td style="text-align:center">o</td>
<td style="text-align:center">o</td>
</tr>
<tr>
<td style="text-align:center">消息机制</td>
<td style="text-align:center">x</td>
<td style="text-align:center">o</td>
<td style="text-align:center">o</td>
<td style="text-align:center">o</td>
</tr>
<tr>
<td style="text-align:center">socket</td>
<td style="text-align:center">x</td>
<td style="text-align:center">o</td>
<td style="text-align:center">o</td>
<td style="text-align:center">o</td>
</tr>
<tr>
<td style="text-align:center">RMI</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">o</td>
</tr>
<tr>
<td style="text-align:center">RPC</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">o</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统课程笔记（3）</title>
    <url>/201903/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<h2 id="操作系统课程笔记（三）3月5日"><a href="#操作系统课程笔记（三）3月5日" class="headerlink" title="操作系统课程笔记（三）3月5日"></a>操作系统课程笔记（三）3月5日</h2><h3 id="Chap-2-操作系统的结构"><a href="#Chap-2-操作系统的结构" class="headerlink" title="Chap.2 操作系统的结构"></a>Chap.2 操作系统的结构</h3><h4 id="一、操作系统的结构"><a href="#一、操作系统的结构" class="headerlink" title="一、操作系统的结构"></a>一、操作系统的结构</h4><p>上一章我们说到了操作系统为我们提供服务，使我们能够更好地使用硬件。那么用户如何使用服务呢？</p>
<ul>
<li>命令接口：提供给最终用户，提供“统一”的接口<ul>
<li>命令行（如cmd）</li>
<li>图形界面（如图形操作界面）</li>
</ul>
</li>
<li>系统调用接口：提供给程序员统一的接口。</li>
</ul>
<span id="more"></span>
<p>服务可以通过各种方式使用硬件，只要使用的够好。</p>
<p><img src="https://s2.ax1x.com/2019/03/19/AulY5j.md.png" alt="操作系统结构"></p>
<ul>
<li>系统/应用程序通过==API或直接使用==系统调用接口。<br>为什么更多时候是用API而不是直接调用呢？<br>答：使用API便于跨平台和移植。比如通过C库，在Windows平台和Unix平台上C语言都能编译和运行。</li>
</ul>
<p>从系统/用户程序到硬件，我们分为三大块来讲解：</p>
<ul>
<li>调用</li>
<li>参数</li>
<li>返回值</li>
</ul>
<h5 id="1-调用"><a href="#1-调用" class="headerlink" title="1.调用"></a>1.调用</h5><p>以输出字符串的C程序“a.c”为例。<br>“a.c”不可以调用“显示a”的服务，因为用户态和内核态的区分。</p>
<ul>
<li>程序通过系统调用接口查找需要的服务的功能号和中断号（只用一个中断号多个功能号，是因为中断号数量不够）</li>
<li>形成软中断，陷入内核态<ul>
<li>保护现场</li>
<li>压栈（传参）</li>
<li>调用</li>
<li>去参</li>
<li>恢复现场</li>
</ul>
</li>
<li>调用服务</li>
</ul>
<p>注：系统调用接口解决了用户态和内核态分离的效果。</p>
<h5 id="2-传参"><a href="#2-传参" class="headerlink" title="2.传参"></a>2.传参</h5><ul>
<li>寄存器<br>  寄存器容量太小了，存不了多少</li>
<li>堆栈<br>  可能是一个栈，也有可能是内核栈+用户栈，需要栈之间数据的拷贝和同步。</li>
<li>内存块</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统课程笔记（2）</title>
    <url>/201903/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h2 id="操作系统课程笔记（二）3月1日"><a href="#操作系统课程笔记（二）3月1日" class="headerlink" title="操作系统课程笔记（二）3月1日"></a>操作系统课程笔记（二）3月1日</h2><h3 id="一、操作系统的定义"><a href="#一、操作系统的定义" class="headerlink" title="一、操作系统的定义"></a>一、操作系统的定义</h3><p><img src="https://s2.ax1x.com/2019/03/18/AnF5IU.jpg" alt="应用/OS/硬件"></p>
<ul>
<li>使用硬件是有过程的，硬件的使用十分困难，于是我们开发了操作系统，来帮助我们更好地使用硬件。</li>
<li>从操作系统向下看是硬件，硬件的资源是有限的，操作系统是==资源分配器==</li>
<li>从操作系统往上看，任务是无限的，操作系统是==控制程序==。负责各个任务的调度，使任务之间相互不影响。（如果没有“控制程序”，一个应用程序出现的BUG，可能会导致电脑的蓝屏）</li>
</ul>
<span id="more"></span>
<h3 id="二、从硬件的功能出发"><a href="#二、从硬件的功能出发" class="headerlink" title="二、从硬件的功能出发"></a>二、从硬件的功能出发</h3><h4 id="1-完成计算（通用计算）的功能"><a href="#1-完成计算（通用计算）的功能" class="headerlink" title="1. 完成计算（通用计算）的功能"></a>1. 完成计算（通用计算）的功能</h4><ul>
<li>找到高效的运算机制<br>  CPU和各个部分配合工作的方式有两种：<ul>
<li>轮询的工作方式；</li>
<li>中断的工作方式（Interrupt Handling）<br>  中断的过程<ul>
<li>保存现场</li>
<li>响应</li>
<li>恢复现场</li>
</ul>
</li>
</ul>
</li>
<li><p>为了提升效率，我们要==考虑降低中断的频率==。相比于“单字符”处理，“块”处理效率更高。（对于慢速设备，用==单字符中断==，对于快速设备，用==块中断==）<br>  比如DMA通道，就是囤一组磁盘的信息再进行传递，降低了中断的频率。</p>
</li>
<li><p>中断产生的原因包括：</p>
<ul>
<li>I/O设备中断</li>
<li>计时器（系统保护里用到，产生中断，防止错误程序一直占用CPU）</li>
<li>软件出错</li>
<li>Trap 软件主动产生中断</li>
</ul>
</li>
<li><p>I/O 的工作方式包括同步和异步。</p>
<ul>
<li>同步即CPU等待I/O设备，如此循环。</li>
<li>异步可能有多个I/O，CPU和I/O设备之间，I/O设备和I/O设备之间都可以并行。工作过程即“睡眠”、“唤醒” 。<br>异步工作机制有设备状态表。<br>同步工作机制下CPU一直在监视数据寄存器，没办法干别的。</li>
</ul>
</li>
</ul>
<ol>
<li>性价比</li>
</ol>
<ul>
<li>从速度、价格、易失性三个角度考虑，形成存储层次：即计算时够快，存储时够大。</li>
<li><p>存储层次最大的问题是一致性问题。（速度不匹配）</p>
</li>
<li><p>操作系统的保护机制<br>包括双重模式和计时器。</p>
<ul>
<li>双重模式把指令分为特权指令和普通指令，让操作系统执行在特权模式（可以执行所有指令的“内核态”）。</li>
<li>用户程序的执行需要调用操作系统执行特权指令。（“用户态”）</li>
</ul>
</li>
<li>计时器即形成中断。</li>
</ul>
<h3 id="三、OS需要提供什么功能（五大功能）"><a href="#三、OS需要提供什么功能（五大功能）" class="headerlink" title="三、OS需要提供什么功能（五大功能）"></a>三、OS需要提供什么功能（五大功能）</h3><ul>
<li>进程管理——管理CPU<ul>
<li>创建、删除进程</li>
<li>挂起和唤醒进程</li>
<li>两进程间通信、防止“死锁”</li>
</ul>
</li>
<li>内存管理——管理内存</li>
<li>文件管理——管理外存<br>  以文件的形式对外存进行管理。</li>
<li>I/O设备管理</li>
<li>保护和安全<ul>
<li>保护：用户之间的隐私、用户的权限等</li>
<li>安全：外来因素，比如病毒等</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统课程笔记（1）</title>
    <url>/201903/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h2 id="操作系统课程笔记（一）2月26日"><a href="#操作系统课程笔记（一）2月26日" class="headerlink" title="操作系统课程笔记（一）2月26日"></a>操作系统课程笔记（一）2月26日</h2><h3 id="一、从硬件出发"><a href="#一、从硬件出发" class="headerlink" title="一、从硬件出发"></a>一、从硬件出发</h3><p>操作系统作为硬件和系统/应用程序之间的桥梁，让我们无穷的应用程序能够在有限的硬件资源上运行。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A(系统/应用程序)---B(操作系统)</span><br><span class="line">    B(操作系统)---C(硬件)</span><br></pre></td></tr></table></figure></p>
<span id="more"></span>
<ul>
<li>硬件的分类<ul>
<li>机械<ul>
<li>手动<br>比如算盘</li>
<li>自动<br>比如加法器</li>
</ul>
</li>
<li>电子<ul>
<li>非通用<br>ENIC 每次计算硬件结构都要改变</li>
<li>通用</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A(表示//编码)-- 执行//编程 --&gt;B(解释//解码)</span><br><span class="line">```  </span><br><span class="line">我们对硬件的追求从“稳定”到“加速”</span><br><span class="line">硬件发生变化，支撑它的体系也会发生变化，我们需要一个通用的体系结构冯诺依曼结构具有“通用性”,它把变动的东西放到了存储器里。</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 二、OS的进化历程  </span><br><span class="line">##### 我们的追求：尽可能压榨CPU与更好的用户体验</span><br></pre></td></tr></table></figure>
<p>graph TB</p>
<p>A(无OS)—&gt;B(批处理)<br>B—&gt;C(多道)<br>C—&gt;D(分时)<br>```</p>
<h5 id="无OS"><a href="#无OS" class="headerlink" title="无OS"></a>无OS</h5><p>“既需要编程，又需要操作”<br>这样子对人类的要求非常高，昂贵且效率低下。<br>工作衔接很差。</p>
<h5 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h5><p>“角色”（把编程和操作分开，串行的方式是绝对不行的，串行的效率太低）和“工作衔接”得到强化。<br>其中工作衔接分为两种情况</p>
<ul>
<li>联机</li>
<li>脱机  </li>
</ul>
<p>两者的最主要区别区别在于CPU是否参与到输入和输出的工作。所谓的“脱机”即将CPU脱出“输入”和“输出”的范畴，使得CPU的使用效率再次提升。（I/O部分被分给了设备控制器）</p>
<h5 id="多道"><a href="#多道" class="headerlink" title="多道"></a>多道</h5><p>单道时，一个应用程序的执行过程：CPU,I/O,CPU,I/O……<br>多道时，一个程序在I/O的过程中可以引用其他程序占用CPU。</p>
<h5 id="分时"><a href="#分时" class="headerlink" title="分时"></a>分时</h5><p>分时是在多道的基础上让CPU能够更好的响应用户。“多道”对于用户体验不友好，而“分时”让CPU在时间单位内都能轮到一次。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>硬件</tag>
        <tag>OS的发展</tag>
      </tags>
  </entry>
</search>
