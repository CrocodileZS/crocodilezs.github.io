<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>荷兰保险选购 Aon v.s. Swisscare (附PrEP Programme指南)</title>
    <url>/202308/%E8%8D%B7%E5%85%B0%E4%BF%9D%E9%99%A9%E9%80%89%E8%B4%AD/</url>
    <content><![CDATA[<h2 id="Why-Insurance"><a href="#Why-Insurance" class="headerlink" title="Why Insurance?"></a>Why Insurance?</h2><p><a href="https://www.studyinnl.org/plan-your-stay/insurance">Study-in-nl官方解释</a><br>学生没法购买国民保险, 只能购买学生保险</p>
<p>参考了这条<a href="http://xhslink.com/rz8p6s">🍠post</a>, 只考虑Swisscare和Aon这两家的. 其他的保险, 要么无法中途取消, 要么价格过于昂贵(比如ONVZ). Aon提供了很多保险方案, 但tue只支持complete+.</p>
<h3 id="关于PrEP"><a href="#关于PrEP" class="headerlink" title="关于PrEP"></a>关于<a href="https://www.ggd.amsterdam.nl/english/sti-hiv-sense/prep/">PrEP</a></h3><p>(总结) 选保险不用关注PrEP.</p>
<p>在荷兰获取PrEP的方法可以参考<a href="https://www.mantotman.nl/en/quick-help/prep-prevents-hiv/all-options-to-get-prep-in-netherlands">这个</a>, 主要的两种途径就是通过GGD和GP(需要自己去药房买).</p>
<p>在GGD领取PrEP的方法参考 <a href="https://www.ggd.amsterdam.nl/english/sti-hiv-sense/prep/national-prep-program/">National PrEP Programme</a>, 我记得🍠上说参加这个项目还可以免费接种HPV和猴痘疫苗, 但是GGD现在完全已经没名额了(阿姆和埃村都没有了), 其他方法可以参考<a href="https://www.ggdbzo.nl/seks-en-gezondheid/prep/">埃村GGD</a>. Pills一般不在保险的范围内, STI treatment or tests (性病检测) 有时候低于deductible(免赔额), 也需要自费. p.s. 本文提到的两个保险项目均不cover STI的费用.</p>
<h2 id="Swisscare"><a href="#Swisscare" class="headerlink" title="Swisscare"></a>Swisscare</h2><p>International Students’ product is shown here:<br><a href="https://swisscare.com/en/product/international-student-health-insurance-europe">international-student-health-insurance-europe</a></p>
<p><img src="https://imgurlcrcz.oss-cn-hangzhou.aliyuncs.com/img/202308061718130.png" alt="投保内容"></p>
<p>需要注意的点是不包含居家财产险(这个保险之前在Holland2Stay签合同的时候有强调需要买, 但我感觉有点用不上), 不包含心理治疗和非紧急牙科.</p>
<p>具体金额: <a href="https://s3.eu-central-1.amazonaws.com/website.swisscare.com/downloads/isie-gic-012023.pdf">pdf</a></p>
<h3 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h3><p><img src="https://imgurlcrcz.oss-cn-hangzhou.aliyuncs.com/img/202308062141337.png" alt=""><br>Standard/Comfort/Premium分别是197/219/312欧一年.</p>
<h2 id="Aon-Complete"><a href="#Aon-Complete" class="headerlink" title="Aon Complete+"></a>Aon Complete+</h2><p>保险范围:<br><img src="https://imgurlcrcz.oss-cn-hangzhou.aliyuncs.com/img/202308062150904.png" alt=""></p>
<p>具体金额: <a href="https://media.aonverzekeringen.nl/-/media/Tenants/IPM/Documents/Aon-Student-Insurance/Voorwaarden123/Summary-of-coverage---CompletePlus.pdf">pdf</a></p>
<h3 id="价格-1"><a href="#价格-1" class="headerlink" title="价格"></a>价格</h3><p>每月56.70欧, 一年是680.4欧.</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><div class="table-container">
<table>
<thead>
<tr>
<th>项目</th>
<th>Swisscare</th>
<th>Aon</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Medical</td>
<td>读了条款之后发现主要报销住院的钱和处方药, 限制范围太窄了..</td>
<td>包括心理治疗和怀孕的各种花销</td>
<td><del>说实话, 看金额表格感觉两者的差距没那么大, 只是Aon包含了心理治疗和怀孕. 仔细读了条款才发觉swisscare的覆盖面真的小(只报销紧急医疗情况)…看GP不给报销.</del> 我看🍠上说去看GP swisscare也报销, 那两个保险差距实际上就没这么大了. 关于药品两个保险都只能报销处方药.</td>
</tr>
<tr>
<td>Third Party Liability</td>
<td>50,000</td>
<td>1,250,000</td>
<td>这个没什么差, 毕竟很少遇到的情况</td>
</tr>
<tr>
<td>Luggage</td>
<td>赔付条件过于苛刻</td>
<td>可能丢的常见物品都有赔付</td>
<td>/</td>
</tr>
<tr>
<td>Home Contents</td>
<td>无</td>
<td>有</td>
<td>/</td>
</tr>
<tr>
<td>Accident</td>
<td>有</td>
<td>有</td>
<td>死亡和终身残疾概率很小这里就不分析了</td>
<td>/</td>
</tr>
<tr>
<td>Legal Assistance</td>
<td>无</td>
<td>有</td>
<td>/</td>
</tr>
<tr>
<td>Repatriation</td>
<td>有</td>
<td>有</td>
<td>感觉概率也不是很大, 这里就没考虑</td>
</tr>
<tr>
<td>Dental</td>
<td>有</td>
<td>有</td>
<td>两者都有但是都要求紧急情况或意外, 没什么差</td>
</tr>
<tr>
<td>Price</td>
<td>197 / 219 / 312 欧 / 年</td>
<td>680欧 / 年</td>
<td>/</td>
</tr>
</tbody>
</table>
</div>
<p>Swisscare的物资险基本不会赔付(基本把所有物资都划进去了….):<br><img src="https://imgurlcrcz.oss-cn-hangzhou.aliyuncs.com/img/202308062308975.png" alt=""></p>
<p>Aon价格每年贵了500欧, 增加了居家财产险/行李险/牙医/心理治疗/法律援助. 说实话我觉得并不值得这个价钱, 其实更建议买Swisscare 219 价位的. 因为basic价位医疗保险每次限额50,000欧, 可能不太够.</p>
<p>但是刚过去为了保障自己的财产安全(怕丢行李), 我决定还是先买半年的Aon的Complete+, 后续再考虑. 最终买了2023-08到2024-02的Complete+, 价格在340欧.</p>
]]></content>
      <categories>
        <category>荷兰生活</category>
      </categories>
      <tags>
        <tag>保险</tag>
      </tags>
  </entry>
  <entry>
    <title>23Fall申请总结</title>
    <url>/202307/23Fall%E7%94%B3%E8%AF%B7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="BG"><a href="#BG" class="headerlink" title="BG"></a>BG</h2><p>标化: 北邮本, 数据科学与大数据技术, 均分87/100; 雅思6.5(6.5), 无G;<br>实习: 三段不相关实习, 一段中科院 NLP RA, 一段快手JAVA后端;<br>论文: 一篇NLP顶会挂名, 一篇水刊挂名;<br>奖项: 三年三等奖学金, 一个数学竞赛奖三;</p>
<h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>澳新欧 CS or EE Master;<br>factors:</p>
<ul>
<li>优先拿身份;</li>
<li>奖后预算在一年20w (gap一年可以凑够的cost);</li>
</ul>
<h2 id="申请结果"><a href="#申请结果" class="headerlink" title="申请结果"></a>申请结果</h2><p>申请的时候最优先考虑的是奖学金(因为要自己攒学费), 所以申了很多明显 overqualified 的学校比如Wollongong/Tampere/Twente. 瑞典只有第一志愿可以申请奖学金, 所以一志愿非常保守地选择了SU.<br>因为当时我还在做港新PhD的陶瓷和面试, 所以下面硕士申请的系统都是对象帮填的. 虽然不了解具体细节但是我知道真的很麻烦 (本来想申请丹麦的但是因为需要的材料太繁琐了, 我对象懒得搞了). 呜呜感谢我强宝! <span class="tag-plugin emoji"><img no-lazy="" class="inline" src="https://gcore.jsdelivr.net/gh/cdn-x/emoji/aru-l/8030.gif" style="height:3em"/></span></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>录取状态</th>
<th>国家</th>
<th>学校</th>
<th>专业/方向</th>
<th>Ms/PhD</th>
<th>奖学金情况</th>
<th>提交申请/收到结果日期</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>AD</td>
<td>NL</td>
<td>Eindhoven University of Technology</td>
<td>CSE</td>
<td>Ms</td>
<td>/</td>
<td>Feb. 15</td>
</tr>
<tr>
<td>2</td>
<td>OFFER</td>
<td>AU</td>
<td>University of Wollongong</td>
<td>CS</td>
<td>Ms</td>
<td>30%学费</td>
<td>Nov. 26</td>
</tr>
<tr>
<td>3</td>
<td>AD</td>
<td>NL</td>
<td>University of Twente</td>
<td>CS</td>
<td>Ms</td>
<td>/</td>
<td>Dec. 12</td>
</tr>
<tr>
<td>4</td>
<td>AD</td>
<td>NL</td>
<td>Universiteit Leiden</td>
<td>CS</td>
<td>Ms</td>
<td>/</td>
<td>Dec. 27</td>
</tr>
<tr>
<td>5</td>
<td>AD</td>
<td>NL</td>
<td>University of Amsterdam &amp; Vrije Universiteit Amsterdam 联合项目</td>
<td>CS</td>
<td>Ms</td>
<td>/</td>
<td>Jan. 2</td>
</tr>
<tr>
<td>6</td>
<td>AD</td>
<td>FI</td>
<td>Aalto University</td>
<td>Speech and Language Technology</td>
<td>Ms</td>
<td>/</td>
<td>Mar. 29</td>
</tr>
<tr>
<td>7</td>
<td>AD</td>
<td>SE</td>
<td>Stockholm University</td>
<td>CS</td>
<td>Ms</td>
<td>/</td>
<td>Mar. 30</td>
</tr>
<tr>
<td>8</td>
<td>OFFER</td>
<td>FI</td>
<td>Tampere University</td>
<td>CSE</td>
<td>Ms</td>
<td>100%学费</td>
<td>Apr. 25</td>
</tr>
<tr>
<td>9</td>
<td>AD</td>
<td>AU</td>
<td>the University of Sydney</td>
<td>SE</td>
<td>Ms</td>
<td>/</td>
<td>Dec. 13</td>
</tr>
<tr>
<td>10</td>
<td>REJ</td>
<td>SG</td>
<td>Nanyang Technological University</td>
<td>AI</td>
<td>Ms</td>
<td>/</td>
<td>Jul. 14</td>
</tr>
</tbody>
</table>
</div>
<h2 id="择校"><a href="#择校" class="headerlink" title="择校"></a>择校</h2><p>首先因为预算pass掉了悉大. 最终还是选择欧洲的学校.<br>我先在每个国家选择一个学校, 瑞典不用说第一志愿SU; 芬兰的Aalto是我申请到的最好的学校, 也没有纠结太久;<br>荷兰在三个项目中纠结了好久, 最终因为阿姆生活成本太高放弃了uva和uv的联合项目; 本来想选择Twente省点钱的的, 但最终还是因为学校质量选择了TU/e.<br>在 芬兰 / 荷兰 / 瑞典的三个项目之间纠结了很久, 简单对比以下三者:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr>
<td>Aalto</td>
<td>学校质量最高; 学费便宜; 拿PR的年限最短</td>
<td>项目偏研究类型, 容易被限制; 冬天日照时间短; 找工难度在三个国家中最大;</td>
</tr>
<tr>
<td>SU</td>
<td>学费便宜; 瑞典好找工;</td>
<td>学校名气不如其他两所; 瑞典PR最难拿;</td>
</tr>
<tr>
<td>TU/e</td>
<td>学校有名; 找工最好找; PR好拿;</td>
<td>贵;</td>
</tr>
</tbody>
</table>
</div>
<p>最后想来想去觉得TU/e除了贵没什么缺点, 最终咬咬牙选了TU/e.</p>
<h2 id="一些感想"><a href="#一些感想" class="headerlink" title="一些感想"></a>一些感想</h2><p>最关键的是稳定的心态, 因为申请到最后总会有学上的(会申请不少保底校), 很多的录取结果也是看运气. 所以准备好需要的材料当成一件工作来投递就可以了, 不需要担心太多.<br>我在申请这段时间的日子非常难熬, 最主要的原因其实是中途换了一次大方向, 最开始打算申请AI方向的PhD, 后面是因为各种碰壁还是决定转CS和SDE方向的硕士, 一边做着手上的套词一边等待着学校的结果, 最后也算是有学上了.<br>荷兰找房真的太难了, 还好最后找到了还不错的studio, 就是通勤时间太长了.<br>申请硕士的时候因为上个季度申请phd手里的材料都准备的差不多, 所以没花太多功夫.<br>七月份从北邮退学了, 明天也是快手的lastday.<br>月底订婚, 年底帮对象申请伴侣签之后强宝也有居住证啦. 希望后续的学习和生活一切顺利!</p>
<p><img src="https://imgurlcrcz.oss-cn-hangzhou.aliyuncs.com/img/5aa37e1f512063f865c6d0ad72d43b5d_0.png" alt=""><br><img src="https://imgurlcrcz.oss-cn-hangzhou.aliyuncs.com/img/0d3404b792e438abceea681e1f291940_0.png" alt=""></p>
]]></content>
      <categories>
        <category>留学</category>
      </categories>
      <tags>
        <tag>留学</tag>
      </tags>
  </entry>
  <entry>
    <title>零经验 转sde 找日常实习总结</title>
    <url>/202305/%E9%9B%B6%E7%BB%8F%E9%AA%8C%E8%BD%ACSDE%E6%89%BE%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<p>今年年初收到欧洲和澳洲一些学校cs的offer, 加上套词SMU的结果不太好 (老板信誓旦旦地给你画饼, 跟着做了一个月项目, 各种看论文做Pre复现代码, 等到申请的时候又说自己没法决定, 要看comittee. 没法决定你这样白嫖? <span class="tag-plugin emoji"><img no-lazy="" class="inline" src="https://gcore.jsdelivr.net/gh/cdn-x/emoji/aru-l/4220.gif" style="height:2em"/></span> 老师主页我放网页源码了, 需要避雷的盆友自己看. ) 最后决定接TU/e的cs offer转sde.</p>
<span id="more"></span>
<div style="display:none"> Liao Lizi: "https://liziliao.github.io/"</div>

<p>因为8月要出国了, 本想着四月入职实习/工作三个月之后回家陪陪父母, 没想到日常实习都这么难找, 找实习都被扒了一层皮.</p>
<p>BG: 零开发经验, Java语法还算熟悉. 有NLP算法的经验, 很久之前用Python刷过一阵子力扣.</p>
<p>1月2月, 出去旅游并且随缘学了学前端, 进展不是很大.</p>
<p>3月开学之后, 和朋友们吃饭觉得自己后端也没问题的, 于是开始刷力扣, 准备找Java岗.</p>
<p>力扣把<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.html">CS-Note</a>的题目刷完了, 差不多有100道吧.</p>
<p>面经看的<a href="https://javaguide.cn/">JavaGuide</a>, 把主要知识点都过了一遍.</p>
<p>4月6日投出第一份简历, 5月10日收到快手offer就准备去了, 实习和正式岗都有找. 时间线如下(只记录了简历过筛的公司):</p>
<ul>
<li>4月6日, 阿里大淘宝投简历, 快手商业化投简历;</li>
<li>4月14日, 阿里大淘宝一面;</li>
<li>4月17日, 微筑科技投简历, 快手商业化一面;</li>
<li>4月19日, 快手商业化二面, 微筑科技一面, 阿里达摩院捞起;</li>
<li>4月21日, 华为OD一面;</li>
<li>4月24日, 快手商业化hr面, 阿里达摩院一面, 阿里FC技术部捞起;</li>
<li>4月25日, 华为OD二面;</li>
<li>4月30日, 华为OD三面;(五一假期还面试, 很敬业了)</li>
<li>5月9日, 快手商业化oc, 阿里钉钉捞起, 微筑科技, 阿里和华为OD的面试就主动终止了;</li>
</ul>
<p>最后决定去快手商业化, 希望实习的这段时间能有所收获, 积累更多经验.</p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库常见面试题汇总</title>
    <url>/202304/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="数据库基础知识"><a href="#数据库基础知识" class="headerlink" title="数据库基础知识"></a>数据库基础知识</h2><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ol>
<li>数据库范式了解吗?</li>
<li>主键和外键有什么区别?</li>
<li>为什么不推荐使用外键和级联?</li>
<li><code>drop</code>, <code>truncate</code> 和 <code>delete</code> 的区别?</li>
</ol>
<h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><ol>
<li>非关系型数据库是什么?</li>
<li>SQL和NoSQL有什么区别?</li>
<li>NoSQL数据库有什么优势?</li>
<li>常见的NoSQL有哪些?</li>
</ol>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ol>
<li>关系型数据库是什么?</li>
</ol>
<h3 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h3><ol>
<li>Mysql支持哪些存储引擎? 默认使用哪个?</li>
<li>MySQL存储引擎架构了解吗?</li>
</ol>
<h3 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h3><ol>
<li>索引底层的数据结构有哪些?</li>
<li>为什么MySQL不适用Hash表作为索引结构?</li>
<li>B树和B+树有什么异同? InnoDB为什么用B+树作为底层索引而不是B树?</li>
</ol>
<h3 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h3><ol>
<li>并发事务带来了哪些问题?</li>
</ol>
<ul>
<li>脏读</li>
<li>丢失修改</li>
<li>不可重复读</li>
<li>幻读</li>
</ul>
<ol>
<li>不可重复读和幻读有什么区别?</li>
<li>并发事务的控制方法有哪些? 锁 + MVCC</li>
<li>SQL标准定义了哪些事务隔离级别?</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里达摩院面经</title>
    <url>/202304/%E9%98%BF%E9%87%8C%E8%BE%BE%E6%91%A9%E9%99%A2%E9%9D%A2%E8%AF%950424/</url>
    <content><![CDATA[<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><ol>
<li>多态是什么? 优点?<br>多态是指允许不同类对同一函数调用做出反应. 即同一函数可以根据对象的不同而采用多种不同的行为方式.<br>实现多态的技术: 动态绑定, 是指在<strong>执行期间</strong>判断所引用对象的实际类型, 根据其实际的类型调用其相应的方法.<br>Java中多态的实现方式: 接口实现, 继承父类方法进行重写, 同一个类中进行方法重载.</li>
</ol>
<p>多态的好处: 代码更容易扩展和维护, 更加灵活. 比如<br><a href="https://cloud.tencent.com/developer/article/1404810">举例</a><br>因为可以通过调用接口的引用来调用各种不同的接口实现类, 扩展的时候不用修改接口, 十分灵活.</p>
<ol>
<li>Java <code>equals()</code> 和 <code>==</code> 有什么区别?<br><code>==</code>对于基本类型来说比较的是值是否相同, 对于引用类型来说是比较地址是否相同.<br>而<code>equals()</code>方法是比较地址值. 不过一般会重写<code>equals</code>让它来比较变量值.</li>
</ol>
<p>比如String的<code>equals()</code>方法, 就是比较两个字符串的值是否相等.</p>
<ol>
<li><code>hashcode</code>和<code>equals</code>有什么区别? <code>hashcode</code>是怎么实现的?<br>两者都是用来比较对象是否相等. 但是使用<code>hashcode</code>的效率会更高. 比如把对象加入hashset时, hashset会先计算对象的hashcode, 如果hashcode和现有的元素相同再用equals比较地址.<br>总结下来就是:</li>
</ol>
<ul>
<li>如果两个对象的 hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。</li>
<li>如果两个对象的 hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等。</li>
<li>如果两个对象的 hashCode 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<ol>
<li><p>你知道的其他解决碰撞的方法吗?<br><a href="https://segmentfault.com/a/1190000041421664">参考</a><br>链地址法, 再哈希法, 公共溢出区, 开放地址法</p>
</li>
<li><p>如果链表太长该怎么办?<br>转化成红黑树或B+树.</p>
</li>
<li><p>为什么不用平衡二叉树, 而是B+树, 红黑树?<br>B+树的高度更矮, 查找路径更短且更稳定. 红黑树不同于二叉平衡树的是平衡性更弱, 对于插入和删除操作更加友好.</p>
</li>
<li><p>hashmap是否线程安全?<br>否. concurrentHashmap是线程安全的.</p>
</li>
<li><p>concurrentHashmap底层怎么实现的? 和hashmap有什么区别?</p>
</li>
</ol>
<ul>
<li>concurrentHashmap直接用Node数组+链表+红黑树来实现, 并发控制使用<code>synchronized</code>和CAS来操作.<br><a href="https://javaguide.cn/java/collection/java-collection-questions-02.html#concurrenthashmap-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E5%BA%95%E5%B1%82%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">参考</a></li>
<li>hashtable底层是数组+链表+红黑树, 仅使用<code>synchronized</code>来保证线程安全, 效率低下. 当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
<p>tips: hashmap是非线程安全的, hashtable是线程安全的.</p>
<hr>
<p>补充学习:</p>
<ol>
<li>为什么hashmap会有线程安全问题?<br>jdk7之前, rehash(扩容)可能会导致环形链表; 而jdk8会导致数据覆盖.<br><a href="https://cloud.tencent.com/developer/article/1871944#">https://cloud.tencent.com/developer/article/1871944#</a></li>
</ol>
<hr>
<ol>
<li><p>HTTP和HTTPS有什么区别? 如果要实现HTTP, 服务器端需要做什么?</p>
</li>
<li><p>HTTP请求会经历哪些过程?</p>
</li>
<li><p>反问: 是否要准备项目? 是. 只有有项目才能更加深入地理解相关知识;</p>
</li>
<li><p>反问: 烂大街的项目是否会有不好的影响? 不会. 项目只是挖掘你基础知识的工具, 一个学习能力强的人在项目中学到的东西会更多. 在做项目的过程中要多问为什么.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快手商业化Java后端实习面经</title>
    <url>/202304/%E5%BF%AB%E6%89%8BJava%E9%9D%A2%E8%AF%950417/</url>
    <content><![CDATA[<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>Q: JVM的内存架构?</p>
<p>Q: IO这里了解吗?</p>
<p>Q: 多线程呢? 线程池怎么创建? 线程有哪些状态? 为什么选择多线程而非多进程?</p>
<p>Q: 设计原则有哪些?</p>
<p>Q: TCP和UDP的区别是什么? TCP的拥塞控制了解吗? 滑动窗口模型?<br>A: <a href="https://www.cnblogs.com/xiaolincoding/p/12732052.html">TCP流量控制和拥塞控制</a><br><a href="https://zhuanlan.zhihu.com/p/101702312">超时与重传机制</a><br>发送窗口 = Min(接收窗口, 拥塞窗口)</p>
<p>Q: 数据库索引有哪些? 为什么用B+树? 索引缺失了解吗?<br>A: (我把数据库索引和引擎记混了)</p>
<p>Q: MySQL的四种隔离级别了解吗?</p>
<p>Q: 解释一下可重复读?</p>
<p>Q: hashmap和concurrenthashmap底层分别是怎么实现的?</p>
<p>代码题:<br><div class="tag-plugin note" color="blue"><div class="body"><p>一个班考试成绩mysql存储，表结构如下：</p><p>create table stu_score (</p><p>   id bigint unsigned NOT NULL comment ‘学号’,</p><p>   type varchar(16) NOT NULL DEFAULT ‘’ comment ‘考试科目’,</p><p>   score double(16,2) DEFAULT ‘0’ comment ‘考试分数’</p><p>)</p><p>要求一条sql分别完成如下统计：</p><p>1.求科目为数学(type=math)最高分的对应的学号</p><p>2.科目为数学(type=math)的及格率(60分以上的人数与总人数的比例)</p></div></div></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select anum/ bnum <span class="title function_">from</span> <span class="params">(SELECT count(*)</span> as anum</span><br><span class="line">FROM stu_score</span><br><span class="line">WHERE type=math AND score &gt;= <span class="number">60</span>) a, (SELECT <span class="title function_">count</span><span class="params">(*)</span> as bnum</span><br><span class="line">FROM stu_score</span><br><span class="line">WHERE type=math) b</span><br></pre></td></tr></table></figure>
<p>问了关于Java的很多问题, 但是我都还没准备到…</p>
<p>所以这里先对照Java Guide学习一下并发编程的部分.</p>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>简历挖掘, 中科院那段算法经历疯狂挖掘.</p>
<h2 id="面试中需要补充的知识点"><a href="#面试中需要补充的知识点" class="headerlink" title="面试中需要补充的知识点"></a>面试中需要补充的知识点</h2><h3 id="Java并发常见面试题"><a href="#Java并发常见面试题" class="headerlink" title="Java并发常见面试题"></a>Java并发常见面试题</h3><ol>
<li>什么是线程和进程?<br>多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈.<br>一个 Java 程序的运行是 main 线程和多个其他线程同时运行.</li>
<li>请简要描述进程和线程的关系, 区别, 和优缺点?<br>总结： 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</li>
<li>并发和并行的区别?</li>
<li>同步和异步的区别?</li>
<li>为什么要使用多线程?</li>
<li>使用多线程可能带来什么问题?<br><a href="https://www.51cto.com/article/715124.html">内存泄漏</a>、死锁、线程不安全.<br>内存泄漏: 垃圾回收器会回收长时间没有引用的对象，但是它不会回收那些还存在引用的对象，这就是产生内存泄漏的原因。</li>
<li>说说线程的生命周期和状态?</li>
<li>什么是线程上下文切换?</li>
<li>什么是线程死锁?</li>
<li>如何预防和避免死锁?</li>
<li>sleep方法和wait方法对比.</li>
<li>为什么wait方法不定义在Thread中?</li>
<li>可以直接调用Thread类的run方法吗?</li>
</ol>
<h4 id="JMM模型"><a href="#JMM模型" class="headerlink" title="JMM模型"></a>JMM模型</h4><ol>
<li>什么事JMM? 为什么需要JMM?</li>
<li>JMM如何抽象线程和主存间的关系?</li>
<li>happens-before的原则是什么?<br>happens-before 原则表达的意义其实并不是一个操作发生在另外一个操作的前面，虽然这从程序员的角度上来说也并无大碍。更准确地来说，它更想表达的意义是前一个操作的结果对于后一个操作是可见的，无论这两个操作是否在同一个线程里。</li>
<li>并发编程的三个特性是什么? 怎样理解?<br>原子性, 可见性, 有序性</li>
</ol>
<h4 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a><code>volatile</code> 关键字</h4><ol>
<li>如何保证变量的可见性?</li>
<li>如何禁止指令重排序?</li>
<li><code>volatile</code> 可以保证原子性吗?<br><code>volatile</code> 关键字能保证数据的可见性, 但不能保证数据的原子性. <code>synchronized</code> 关键字两者都能保证.</li>
</ol>
<h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><ol>
<li>什么是悲观锁?<br>共享资源每次只给一个线程使用, 其它线程阻塞, 用完后再把资源转让给其它线程.<br>像 Java 中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现.</li>
<li>什么是乐观锁?<br>线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）<br>在 Java 中java.util.concurrent.atomic包下面的原子变量类（比如AtomicInteger、LongAdder）就是使用了乐观锁的一种实现方式 CAS 实现的。</li>
<li>如何实现乐观锁?<br>版本号机制和CAS算法.</li>
<li>乐观锁存在哪些问题?<br>ABA问题, 循环时间长开销大(自旋), 只能保证一个共享变量的原子操作.</li>
</ol>
<h4 id="Synchronized-关键字"><a href="#Synchronized-关键字" class="headerlink" title="Synchronized 关键字"></a><code>Synchronized</code> 关键字</h4><ol>
<li><code>synchronized</code> 是什么? 有什么用?</li>
<li>如何使用<code>Syncronized</code>?</li>
<li><code>synchronized</code> 和 <code>volatile</code> 有什么区别？</li>
</ol>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><h4 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h4><ol>
<li>什么是IO流?<br>IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</li>
</ol>
<h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><h4 id="随机访问流"><a href="#随机访问流" class="headerlink" title="随机访问流"></a>随机访问流</h4><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="lt-重点-gt-JVM内存区域详解"><a href="#lt-重点-gt-JVM内存区域详解" class="headerlink" title="&lt;重点&gt;JVM内存区域详解"></a>&lt;重点&gt;JVM内存区域详解</h4><h4 id="lt-重点-gt-JVM垃圾回收详解"><a href="#lt-重点-gt-JVM垃圾回收详解" class="headerlink" title="&lt;重点&gt;JVM垃圾回收详解"></a>&lt;重点&gt;JVM垃圾回收详解</h4>]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里大淘宝技术后端实习笔面经</title>
    <url>/202304/%E9%98%BF%E9%87%8C%E5%A4%A7%E6%B7%98%E5%AE%9D%E5%90%8E%E7%AB%AF%E7%AC%94%E9%9D%A2%E8%AF%950412/</url>
    <content><![CDATA[<p>笔试: 单选6+多选7+编程题3, 满分100, 好像做到40分就能进面试.<br>! 不能用本地IDE</p>
<span id="more"></span>
<h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h2><h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h3><p>单选和多选感觉挺难, 记录几个知识点.</p>
<ol>
<li>如何根据中序遍历 + 后序遍历 确定唯一的二叉树.</li>
<li>基数排序, 高位优先(MSD)和低位优先(LSD).</li>
<li>Linux grep指令</li>
<li>正则表达式 <code>\w</code> 等价于 <code>[A-Za-z0-9_]</code>; <code>\W</code>等价于<code>[^A-Za-z0-9_]</code>.</li>
<li>分页管理中, 内部碎片和外部碎片.</li>
<li>树和森林与二叉树的转换: 左孩子右兄弟法<a href="https://zhuanlan.zhihu.com/p/134251528">参考</a></li>
<li>循环队列的<code>front</code>和<code>rear</code>. 当<code>front == rear</code>时, 队列为空; <code>(rear + 1) % size == front</code> 时, 队列满; <code>(rear - front + size) % size</code> 为队列长度.</li>
</ol>
<h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h3><p>第一题 定义好树是红色节点比蓝色节点多的树。输入一棵好树，想要从其中删去一边后得到的两棵树都是好树，输出有多少种删除的方法。简单的dfs ，0%</p>
<p>用一个数组r[n]存以各个节点为根的子树的红色节点数，一个数组b[n]存以各个节点为根的子树的蓝色节点数，第一次dfs 求出这两个数组的值，第二次dfs 时候，如果要去掉一个节点和它的子节点（设这个子节点是编号为i的节点）之间的一条边，那么得到的一棵树的蓝色节点数为b[i]，红色节点数为r[i]，另一棵树的红色节点数为r[1]-r[i]，蓝色节点为b[1]-b[i]，（1号节点是根节点），然后判断一下这种情况是否满足要求，满足就把结果加一。</p>
<hr>
<p>第二题 输入一个无符号整数数组，每次操作可以修改一个数的二进制表示的一个位，想要使得数组中每个数都相等，输出最少操作次数。只要看一下各个数位上有多少个数是0，有多少个数是1，将较小者累加到结果就行了。ac<br>这个题浪费了太久的时间.<br>Tips:<br>求二进制的时候, 每次除以2的余数是从后往前写的.<br>java直接转化的方法 <code>Integer.toBinaryString(5);</code><br>java中<code>LinkedList</code>实现了<code>Queue</code>的接口, 所以可以把它当做队列来用.</p>
<hr>
<p>第三题 输入一个整数，删除其连续的数位，使其成为15的倍数（可以有前导0），输出有多少种删除方法。0%</p>
<p>Tips: 难点: 15的倍数特点是个位数是5或0, 其余各个位之和为3的倍数.</p>
<h2 id="面试-一面"><a href="#面试-一面" class="headerlink" title="面试 - 一面"></a>面试 - 一面</h2><p>面试自我介绍的时候我说我25年才能毕业, 然后面试官说他们只招24年毕业的, 因为那边转正率蛮高的.<br>我简历上忘了改了呜呜呜… 早知道自我介绍的时候不说了.</p>
<p>然后场面很尴尬, 我说我想练练开发岗的面试, 面试官超级好, 就给我来了一次模拟面试.<br>他说项目经历一点也不重要, 重要的是基础知识一定一定一定要扎实. 一般基础知识能回答到85%以上就可以进二面, 80%-75%会比较犹豫. 反正在校期间做的项目都没啥卵用, 不用补项目.</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><p>树<br>Q: 你了解的树结构有哪些?<br>A: 二叉树, 多叉树, 完全二叉树, 二叉平衡查找树, B树, B+树, 红黑树.<br>Tips: 平衡二叉树的常用实现方法有 红黑树、AVL 树、替罪羊树、加权平衡树、伸展树 等。<br>树的关键词: <u>完全, 平衡, 查找</u><br>Q: 什么是完全二叉树?<br>A: 按照层序遍历从左到右, 完全没有空隙的树就是完全二叉树. (我当时不知道该怎么形容, 然后百度了一下)对树中的结点按从上至下、从左到右的顺序进行编号，如果编和满二叉树中的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。<br>Q: 怎么向完全二叉树中插入节点?<br>A: (没答上来, 之后查了下)<br>两种方式.<br>第一种利用队列, 把倒数第二行子节点数小于2的节点从左到右入队, 然后最后一层从左到右入队. 插入新节点的时候, 让它作为队头节点的子节点, 如果队头的子节点满了, 则出队. 把新节点入队.<br>第二种利用二进制. 先遍历一遍求节点数. 插入的节点为第n个节点, 将n转换成二进制, 去掉首位, 从第二位开始, 0往左走1往右走, 最后就能走到自己的位置.<br>Tips: 树的BFS和层序遍历是一回事.</p>
</li>
<li><p>链表<br>Q: 你了解哪些链表?<br>A: 单向链表, 双向链表, 循环链表, 双向循环链表.<br>Q: 好的. 每个链表适用于哪些场景?<br>A: (懵逼)(不会… 下来整理了一下)双向链表可以在节点前后插入, 也可以删掉前驱和后继. 而单向链表只能向后插入. 双向链表通过增加了一定的空间复杂度, 提升了向前遍历的时间复杂度. 循环链表首尾相连, 可以从任意一个节点出发, 遍历链表全部节点, 适合解决有环装特性的数据(如约瑟夫环). 双向循环链表有循环链表和双向链表的特性.<br>Q: 循环链表怎样插入?<br>A: (思考: 我真的好不熟悉, 还要现场思考.) 循环链表一般保存尾节点的指针(因为这样头插和尾插都很快). 实际在任何一个位置插入的方式都是一样的.<br>Q: 你知道跳表吗?<br>A: 不知道 (汗)</p>
</li>
</ul>
<p>补充学习:<br><a href="https://www.jianshu.com/p/9d8296562806">跳表</a>: 可以实现二分查找的有序链表. 跳表的查找、插入、删除的时间复杂度都是 O(logn)，而且可以按照范围区间查找元素.<br>为什么Redis使用跳表而不是红黑树来实现有序集合?<br>当需要按照区间查找元素时, 跳表的效率更高O(logn).</p>
<p><a href="https://www.jianshu.com/p/e136ec79235c">红黑树</a>: 红黑树（Red Black Tree） 是一种 自平衡 二叉查找树，典型的用途是实现关联数组.<br>它可以在O(log n)时间内做查找，插入和删除，这里的 n 是树中元素的数目.<br>把二叉树所有结点投射在X轴上，所有结点都是从左到右排好序的，所有目标结点的前后结点就是对应前继和后继结点.</p>
<p><a href="https://www.cnblogs.com/sxkgeek/p/9349931.html">BST, AVL, Red-black tree, B tree, B+ tree</a></p>
<p>Q: 一般内存和运行内存了解吗?<br>A: (懵逼… 好像面经里没有这个东西呀) 不了解.<br>Tips: 实际上就是ROM和RAM. RAM随机存取, 掉电后就丢失数据. RAM的运行速度远高于ROM. 之前就只知道运行内存这个东西, 学os的时候根本没把它和ram联系起来.</p>
<p>Q: CPU的一级缓存二级缓存可以向我介绍一下吗?<br>A: 不了解.<br>Tips: <a href="https://www.cnblogs.com/yzl050819/p/11335652.html">CPU缓存</a><br>印象里只有Cache了, 不记得它的中文是缓存. CPU缓存（Cache Memory）是位于CPU与内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多.<br>一般有一级二级三级缓存,一级缓存有一级指令缓存和一级数据缓存, 二三级缓存主要都是存储数据.</p>
<p><a href="https://www.jianshu.com/p/05c6c1d73144">一条指令在CPU中的执行过程</a></p>
<p>Q: Java中的锁了解吗?<br>A: 不…<br>Q: 这些都是要了解的呀. Java的单机锁, 分布式锁. 还有互斥锁这些…</p>
<p>Q: 再来问一个计网的问题, 当数据从发送端到接收端, 数据经历了哪些部件?<br>A:…</p>
<p>Q: 丢包之后会发生什么?</p>
<p>Q: 所以是没发送一个数据段, 接收端都会发送一个ACK吗?<br>A: 是吧.</p>
<p>Q: 再来问问数据库好了, 关于索引的底层实现你知道哪些?<br>A: B+树, 红黑树.<br>Q: 它们有哪些特征?</p>
<p>Q: 你这里最好还要补充一下Java中间件 / 开源框架的知识. 去看源文档或者看论坛的解析啦.</p>
<p>后面就是闲聊…</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>华为OD后端开发岗笔面试记录</title>
    <url>/202304/%E5%8D%8E%E4%B8%BAOD%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>三道题, 分值分别为100, 100, 200. 做到150分以上就有面试机会, 半年内只能考一次.</p>
<span id="more"></span>
<h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h2><h3 id="第一题-寻找子串"><a href="#第一题-寻找子串" class="headerlink" title="第一题: 寻找子串"></a>第一题: 寻找子串</h3><p>最后过了97%</p>
<p>字符串1和字符串2都是由数字和小写字母组成.<br>其中字符串1采用了数字和小写字母a-f作为分隔符, 可以被分割为多个子串.</p>
<p>要求输出字符串1的子串, 满足: 该子串中不同字符的数量不大于字符串2中不同字符的数量.<br>如果有多个子串, 按照子串的长度降序排列; 如果子串长度相同, 按照字母序降序排列.</p>
<p>输入为两行, 第一行为字符串1, 第二行为字符串2.</p>
<p>思路: 处理字符串, 自己写一个<code>Comparator</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exm1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先算str2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">str2Count</span> <span class="operator">=</span> countChars(str2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分割str1</span></span><br><span class="line">        String[] strInStr1 = str1.split(<span class="string">&quot;[0-9a-f]&quot;</span>); <span class="comment">// 有空字符串</span></span><br><span class="line">        Arrays.sort(strInStr1, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> countChars(o1) != countChars(o2) ? countChars(o2) - countChars(o1) : o2.compareTo(o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : strInStr1) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curCount</span> <span class="operator">=</span> countChars(s);</span><br><span class="line">            <span class="keyword">if</span> (curCount &lt;= str2Count &amp;&amp; curCount != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">countChars</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] strCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            strCount[idx] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">charCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) charCount += strCount[i];</span><br><span class="line">        <span class="keyword">return</span> charCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二题-求排列组合数"><a href="#第二题-求排列组合数" class="headerlink" title="第二题: 求排列组合数"></a>第二题: 求排列组合数</h3><p>最后过了95%</p>
<p>系统中有两个任务, 第一个任务的执行时间为task1, 第二个任务的执行时间为task2, 总共能够执行n个任务.<br>求执行的n个任务可能花费的时间.<br>输入: task1,task2,n<br>输出: [time1, time2, …]</p>
<p>思路: 组合.</p>
<ol>
<li>易错点在于task1和task2执行时间相同时, 数组中不能有重复的时间.</li>
<li>直接打印数组: <code>Arrays.toString(arr);</code>.</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exm2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        String[] input = in.nextLine().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">time1</span> <span class="operator">=</span> Integer.parseInt(input[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">time2</span> <span class="operator">=</span> Integer.parseInt(input[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalNum</span> <span class="operator">=</span> Integer.parseInt(input[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[totalNum+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">minTime</span> <span class="operator">=</span> Math.min(time1, time2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxTime</span> <span class="operator">=</span> Math.max(time1, time2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">curTime</span> <span class="operator">=</span> minTime * totalNum;</span><br><span class="line">        res[<span class="number">0</span>] = curTime;</span><br><span class="line">        System.out.printf(<span class="string">&quot;[%d, &quot;</span>, res[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; totalNum+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            curTime = curTime - minTime + maxTime;</span><br><span class="line">            res[i] = curTime;</span><br><span class="line">            <span class="keyword">if</span>(i != res.length-<span class="number">1</span>) System.out.printf(<span class="string">&quot;%d, &quot;</span>, res[i]);</span><br><span class="line">            <span class="keyword">else</span> System.out.print(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //打印[3, 4, 5, 6]</span></span><br><span class="line"><span class="comment">//        System.out.print(&quot;[&quot;);</span></span><br><span class="line"><span class="comment">//        for(int i = 0; i &lt; res.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            if(i != res.length-1) System.out.printf(&quot;%d, &quot;, res[i]);</span></span><br><span class="line"><span class="comment">//            else System.out.print(res[i]);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="comment">// System.out.println(Arrays.toString(res));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三题-求树的第x行第y个节点"><a href="#第三题-求树的第x行第y个节点" class="headerlink" title="第三题: 求树的第x行第y个节点"></a>第三题: 求树的第x行第y个节点</h3><p>最后过了83%.</p>
<p>输入:<br>第一行为节点数, 接下来的每一行第一个数字是节点的value, 后面的数是它的孩子.<br>最后一行是”坐标”.</p>
<p>输出:<br>{节点值}, 如果不存在节点则输出{}</p>
<p>样例输入:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">15 1 2 3</span><br><span class="line">6 4</span><br><span class="line">7 5</span><br><span class="line">23</span><br><span class="line">9</span><br><span class="line">11</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><br>样例输出:<br><code>&#123;7&#125;</code></p>
<p>代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exm3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 构建树</span></span><br><span class="line">        <span class="comment">//创建节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(in.nextLine());</span><br><span class="line">        TreeNode[] nodes = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[num];</span><br><span class="line">        List&lt;Integer&gt;[] childs = <span class="keyword">new</span> <span class="title class_">List</span>[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            String[] line = in.nextLine().split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">            nodes[i] = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(line[<span class="number">0</span>]));</span><br><span class="line">            childs[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; line.length; j++) childs[i].add(Integer.valueOf(line[j]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; cs = childs[i];</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">curNode</span> <span class="operator">=</span> nodes[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> idx : cs) &#123;</span><br><span class="line">                curNode.childs.add(nodes[idx]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> nodes[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建完成</span></span><br><span class="line">        <span class="comment">// 用队列进行层次遍历</span></span><br><span class="line">        String[] loc = in.nextLine().split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Integer.parseInt(loc[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> Integer.parseInt(loc[<span class="number">1</span>]);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">curRow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">curLineNum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextLineNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(curRow &lt; x &amp;&amp; !queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            List&lt;TreeNode&gt; curChilds = cur.childs;</span><br><span class="line">            <span class="keyword">for</span>(TreeNode child : curChilds) &#123;</span><br><span class="line">                queue.offer(child);</span><br><span class="line">                nextLineNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            curLineNum--;</span><br><span class="line">            <span class="keyword">if</span>(curLineNum == <span class="number">0</span>) &#123;</span><br><span class="line">                curLineNum = nextLineNum;</span><br><span class="line">                nextLineNum = <span class="number">0</span>;</span><br><span class="line">                curRow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(queue.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&#123;&#125;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//寻找y</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; y &amp;&amp; !queue.isEmpty(); j++) &#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(queue.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&#123;&#125;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> System.out.printf(<span class="string">&quot;&#123;%d&#125;\n&quot;</span>, queue.poll().value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        List&lt;TreeNode&gt; childs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> value, List&lt;TreeNode&gt; childs)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.childs = childs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="技术一面"><a href="#技术一面" class="headerlink" title="技术一面"></a>技术一面</h2><h3 id="基础知识部分"><a href="#基础知识部分" class="headerlink" title="基础知识部分"></a>基础知识部分</h3><ol>
<li>问我的代码量. 我整个懵逼了, 怎么直接问这个的? 最后我说几千应该是有的.</li>
<li>进程和线程了解吗？进程间怎么进行通信？</li>
<li>线程间是如何进行同步的？(注意区分进程通信和线程同步)</li>
<li>怎么优化数据库的查询速度？ (没复习到这个, 详见<a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html#%E6%89%80%E6%9C%89%E8%A1%A8%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8-innodb-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">Javaguide</a>)<br>答:<ul>
<li>使用InnoDB引擎;</li>
<li>统一使用UTF-8编码;</li>
<li>反范式;</li>
<li>控制数据表的大小, 过大的表会导致修改表的存储结构(or跨区存储);</li>
<li>限制索引数量(否则会导致插入和删除时效率变低)</li>
<li>选择索引的顺序: 区分度最高的索引在最左侧, 最频繁使用的放在最左侧, 字段长度小的放在最左侧;</li>
</ul>
</li>
<li>HTTP和TCP了解多少? 向我介绍一下?</li>
</ol>
<h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><ol>
<li>删除链表后面的一个节点；</li>
<li>查询表A的所有项目, 并且按照B进行排列.</li>
<li>还有一个Linux的题目, 我给忘记了呜呜..</li>
</ol>
<h3 id="手撕代码"><a href="#手撕代码" class="headerlink" title="手撕代码"></a>手撕代码</h3><p>[输入] 第一行一个整数T(1 &lt;= T &lt;= 100), 表示有T组测试数据。对于每组测试数据：一行无序的括号，最长有3000个半括号。<br>[输出] 一个整数，即最少要添加的括号数使之成为满足题意的括号序列。<br>[样例1]</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">[[[</span><br><span class="line">[)(]</span><br><span class="line">[)</span><br></pre></td></tr></table></figure></p>
<p>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h2 id="技术二面"><a href="#技术二面" class="headerlink" title="技术二面"></a>技术二面</h2><p>手撕代码: <a href="https://leetcode.cn/problems/brick-wall/">力扣554 砖墙</a> 怎么新建一个</p>
<ol>
<li>java的进程和线程了解吗?</li>
<li>ArrayList怎么进行扩容?</li>
<li>ArrayList和LinkedList区别?</li>
<li>线程池了解吗?</li>
<li>ThreadLocal了解吗?</li>
<li>JVM的垃圾回收算法?</li>
<li>Java的锁向我介绍一下?</li>
</ol>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p>
<ul>
<li>Thread.start() 和 run()的区别?<br>直接运行run方法, 会把它当成main线程下的一个普通方法运行, 并不是多线程.<br>start方法会创建新的线程, 等待分配到时间片就开始运行.</li>
</ul>
<ol>
<li>ThreadLocal有什么用?<br>让每个线程都绑定自己的值.</li>
<li>ThreadLocal原理了解吗?<br>每一个线程都有一个<code>ThreadLocalMap</code>, key是ThreadLocal, value是存储的对象.</li>
<li>ThreadLocal内存泄漏问题是怎么导致的?<br>key是弱引用而value是强引用. ThreadLocal在调用set, get, remove方法后会清理key为null的记录. 使用完ThreadLocal的方法后最好手动调用remove方法.<br>补充: <a href="https://www.cnblogs.com/CodeBear/p/12447554.html">Java中强引用, 弱引用, 软引用, 虚引用测试</a><br><a href="https://juejin.cn/post/6844903665241686029">理解Java中各种引用</a></li>
</ol>
<p>tips: 软连接那里, 在命令行执行<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac softref.java</span><br><span class="line">java -Xmx20m softref</span><br></pre></td></tr></table></figure></p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ol>
<li>什么是线程池?<br>线程池就是管理一系列线程的资源池. 当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务.</li>
<li>为什么要使用线程池?<br>节约资源; 提高响应速度; 提高线程可管理性.</li>
<li>如何创建线程?<br>使用<code>ThreadPoolExecutor</code>构造函数的方式创建, 而不使用<code>Executer</code>.<br>原因: <code>FixedThreadPool</code>, <code>SingleThreadPool</code> 和 <code>ScheduledThreadPool</code> 使用无界的阻塞队列</li>
<li>线程池的重要参数<br><a href="https://javaguide.cn/assets/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.d65f3309.png">一图流</a><br><code>corePoolSize</code> 任务队列未达到队列容量时, 最大可以同时运行的线程数量;<br><code>maxiumumPoolSize</code> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数;<br><code>workQueue</code> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中.</li>
<li>线程池的饱和策略?<br><code>ThreadPoolExcuter.AbortPolicy</code>: 抛出<code>RejectedExcutionException</code>来拒绝新任务的处理.<br><code>ThreadPoolExcuter.CallerRunsPolicy</code>: 把任务退回给调用者, 使用调用者的线程来执行任务.<br><code>ThreadPoolExcuter.DiscardPolicy</code>: 不处理新任务, 直接丢掉.<br><code>ThreadPoolExcuter.DiscardOldestPolicy</code>: 丢弃最早的未处理请求;</li>
<li>线程池常用的阻塞队列有哪些?</li>
</ol>
<ul>
<li>无界队列<code>LinkedBlockingQueue</code>: <code>FixedThreadPool</code>,<code>SingleThreadExcuter</code></li>
<li>同步队列 <code>CacheThreadPool</code></li>
<li>延迟阻塞队列 <code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExcutor</code></li>
</ul>
<h3 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a>ArrayList扩容机制</h3><h3 id="JVM垃圾回收详解"><a href="#JVM垃圾回收详解" class="headerlink" title="JVM垃圾回收详解"></a>JVM垃圾回收详解</h3><h2 id="技术三面"><a href="#技术三面" class="headerlink" title="技术三面"></a>技术三面</h2><p>因为前两面定级不一致, 开始第三面.<br>第三面主要就是挖简历.<br>手撕代码: 力扣105: 从前序和中序恢复二叉树.</p>
<hr>
<p>最后定岗定到测开了, HR面完就拒了.</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常见面试问题汇总(一)</title>
    <url>/202304/Java%E9%9D%A2%E7%BB%8F%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><h3 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h3><ol>
<li>OSI七层模型是什么? 每一层的作用是什么?</li>
<li>TCP/IP四层模型是什么? 每一层的作用是什么?</li>
<li>为什么网络要分层?</li>
<li>应用层常见的协议有哪些?</li>
<li>电子邮件的发送过程?</li>
<li>如何判断邮箱是真正存在的?</li>
</ol>
<hr>
<h3 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h3><ol>
<li>⭐ TCP和UDP的区别?</li>
<li>什么时候用TCP, 什么时候用UDP?</li>
<li>HTTP是基于TCP还是UDP?</li>
<li>使用TCP的协议有哪些? 使用UDP的协议有哪些?</li>
<li>⭐⭐ TCP的三次握手和四次挥手(握手和挥手均可由客户端或服务端发起)<ul>
<li>为什么建立连接时要三次握手?</li>
<li>第二次握手传回了ACK, 为什么还要回传SYN?</li>
<li>为什么要四次挥手</li>
<li>为什么不能把服务器发送的ACK和FIN合并起来, 变成三次挥手?</li>
<li>如果第二次挥手时服务器的ACK没有送达客户端, 会怎样?</li>
<li>为什么第四次挥手客户端要等待2MSL(报文段最长寿命)后才进入CLOSE状态?</li>
</ul>
</li>
<li>⭐ TCP如何保证传输可靠性保证.(6)<ul>
<li>TCP 如何保证数据可靠性?</li>
<li>TCP 如何实现流量控制?</li>
<li>TCP的拥塞控制是怎么实现的?</li>
<li>ARQ协议了解吗?</li>
</ul>
</li>
</ol>
<hr>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ol>
<li>⭐⭐ 从输入URL到页面展示发生了什么?</li>
<li>HTTP状态码有哪些?</li>
<li>⭐ HTTP和HTTPS有什么区别?</li>
<li>HTTP 1.0 和 HTTP 1.1 有什么区别?</li>
<li>HTTP是不保存状态的协议, 如何保存用户状态?</li>
<li>URL 和 URI的区别?</li>
</ol>
<hr>
<h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><ol>
<li>什么是MAC地址?</li>
<li>ARP协议解决了什么问题, 地位如何?</li>
<li>ARP协议的工作原理? (3) ARP表 / 广播问询 / 单播响应</li>
</ol>
<h3 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h3><ol>
<li>网络攻击常见手段?</li>
</ol>
<hr>
<h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><h3 id="OS基础"><a href="#OS基础" class="headerlink" title="OS基础"></a>OS基础</h3><ol>
<li>什么是操作系统?</li>
<li>什么是系统调用?</li>
<li>进程和线程的区别? 独立性, 开销.<br>3.1 有了进程为什么还需要线程?<br>3.2 为什么要使用多线程?<br>3.3 线程间同步的方式有哪些?</li>
<li>PCB是什么? 包含哪些信息?</li>
<li>进程有哪几种状态?</li>
<li>进程间的通信方式?<br><del>6. 线程间同步的方式?</del></li>
<li>进程的调度算法有哪些? (5)</li>
<li>什么是僵尸进程和孤儿进程?</li>
<li>什么是死锁?</li>
<li>死锁的四个必要条件是什么?</li>
<li>如何解决死锁? (4)</li>
</ol>
<hr>
<h3 id="OS内存管理基础"><a href="#OS内存管理基础" class="headerlink" title="OS内存管理基础"></a>OS内存管理基础</h3><ol>
<li>操作系统内存管理主要是做什么? (6)</li>
<li>什么是内存碎片? (2)</li>
<li>内存管理有哪几种方式? (2, 连续 + 非连续(段式, 页式和段页式))</li>
<li>分别介绍一下分段机制和分页机制? 分页机制和分段机制有哪些共同点和区别呢?<br>13.1 什么是页缺失? (2)<br>13.2 常见的页面置换算法有哪些? (5)</li>
<li>介绍一下快表和多级表?</li>
<li>逻辑地址和物理地址的区别?</li>
</ol>
<hr>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><ol>
<li>什么是虚拟内存? 有什么用?</li>
<li>局部性原理?</li>
</ol>
<hr>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ol>
<li>文件系统主要做什么? (4)</li>
<li>硬连接和软连接有什么区别?</li>
<li>硬链接为什么不能跨文件系统?</li>
<li>提高文件系统性能的方式有哪些? (5)</li>
<li>常见的磁盘调度算法有哪些? (6)</li>
</ol>
<h2 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h2><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="Java基础与常识"><a href="#Java基础与常识" class="headerlink" title="Java基础与常识"></a>Java基础与常识</h3><ol>
<li>Java语言有哪些特点?</li>
<li>JVM &amp; JDK &amp; JRE</li>
<li>什么是字节码? 采用字节码的好处是什么?</li>
<li>为什么不全部使用AOT?</li>
<li>为什么说Java语言”编译与解释共存”?</li>
<li>Oracle JDK vs OpenJDK</li>
<li>Java 和 C++的区别?</li>
</ol>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ol>
<li>java的注释类型有哪些?</li>
<li>标识符和关键字的区别是什么?</li>
</ol>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ol>
<li>Java的几种基本数据类型了解吗? (8)</li>
<li>基本类型和包装类型的区别?</li>
<li>包装类型的缓存机制了解吗?</li>
<li>自动装箱与拆箱了解吗? 原理是什么?</li>
<li>为什么浮点数运算时会有精度丢失的危险?</li>
<li>如何解决浮点数精度丢失的问题? (BigDecimal)</li>
<li>超过long整型的数据应该如何表示? (BigInteger)</li>
</ol>
<h3 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h3><ol>
<li>面向对象和面向过程的区别?</li>
<li>创建一个对象用什么运算符? 对象实体与对象引用有何不同?</li>
<li>构造方法有哪些特点? 时候可以被override?</li>
<li>面向对象的三大特征? 封装, 继承, 多态.</li>
<li>接口和抽象类有什么共同点和区别?</li>
<li>深拷贝和浅拷贝的区别? 什么是引用拷贝?</li>
</ol>
<h3 id="Java常见类"><a href="#Java常见类" class="headerlink" title="Java常见类"></a>Java常见类</h3><ol>
<li>Object类的常见方法有哪些?</li>
<li>hashCode()有什么用?</li>
<li><code>String</code>, <code>StringBuffer</code>, <code>StringBuilder</code>的区别?</li>
<li>为什么String类型值不能被修改?</li>
<li>字符串常量池的作用了解吗?</li>
<li><code>String s1 = new String(&quot;abc&quot;);</code> 这句话创建了几个字符串对象?</li>
</ol>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ol>
<li><code>Exception</code>和<code>Error</code>有什么区别?</li>
<li><code>Checked Exception</code> 和 <code>Unchecked Exception</code> 有什么区别?</li>
<li><code>Throwable</code> 类常用方法有哪些?</li>
<li><code>try-catch-finally</code>如何使用?</li>
<li>如何使用<code>try-with-resources</code>代替<code>try-catch-finally</code>?</li>
</ol>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ol>
<li>什么是泛型? 有什么作用?</li>
<li>泛型的使用方式有哪几种?</li>
</ol>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射(?)"></a>反射(?)</h3><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><h3 id="序列化-反序列化"><a href="#序列化-反序列化" class="headerlink" title="序列化 / 反序列化"></a>序列化 / 反序列化</h3><ol>
<li>什么是序列化? 反序列化?</li>
</ol>
<h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><ol>
<li>Java IO流了解吗?</li>
<li>IO流为什么要分为字节流和字符流呢?</li>
<li>Java IO中的设计模式有哪些?</li>
<li>BIO, NIO 和 AIO的区别?</li>
</ol>
<h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><ol>
<li>什么是语法糖?</li>
<li>Java中有哪些常用的语法糖?</li>
</ol>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h3><ol>
<li>说说List, Set, Queue, Map四者的区别?</li>
</ol>
<h3 id="Collection-之-List"><a href="#Collection-之-List" class="headerlink" title="Collection 之 List"></a>Collection 之 List</h3><ol>
<li>ArrayList和LinkedList有什么区别?</li>
<li><del>说说ArrayList的扩容机制吧?</del></li>
</ol>
<h3 id="Collection-之-Set"><a href="#Collection-之-Set" class="headerlink" title="Collection 之 Set"></a>Collection 之 Set</h3><ol>
<li>comparable 和 Comparator 的区别?</li>
<li>比较HashSet, LinkedHashSet, TreeSet 三者的异同.</li>
</ol>
<h3 id="Collection-之-Queue"><a href="#Collection-之-Queue" class="headerlink" title="Collection 之 Queue"></a>Collection 之 Queue</h3><ol>
<li>Queue和Deque的区别.</li>
<li>ArrayDeque和LinkedList的区别.</li>
<li>介绍一下 PriorityQueue.</li>
</ol>
<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><ol>
<li>HashMap和Hashtable的区别.</li>
<li>HashMap和HashSet的区别.</li>
<li>HashMap和TreeMap的区别.</li>
<li>HashSet如何检查重复?</li>
</ol>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>计算机网络</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>2023冬春季留学申请总结</title>
    <url>/202301/%E7%94%B3%E8%AF%B7Log/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><ul>
<li>2022-09-27 Adelaide 申请系统显示 Referred to Professor;</li>
<li>2022-10-13 McMaster 教授反套, 约面试并且要写一个简短的Survey;</li>
<li>2022-10-18 发邮件问了下SUTD的流程, 那边说结果在11月中旬之前会出来;</li>
<li>2022-10-21 McMaster 面试. 主要的问题: 最近的research做一个简短的Pre / 正负样本不平衡怎么处理 / 关于肺部疾病imaging, 设计NN / 如何解决有时间序列的深度学习问题 / Bert细节考察 (早知道面试之前应该再看下Bert的论文, 当时已经忘得差不多了) / 介绍了实验室近况 / 问了下签证的情况; 本来前面聊得很好的, 我说北邮研究型硕士签证可能会有问题之后, 教授瞬间失去了兴趣的样子… (我甚至感觉加拿大本地人不理解签证这个东西) 不过自己口语水平真的提升了不少, 交流过程都还蛮流利.</li>
<li>2022-10-21 Adelaide 状态显示 Outcome Pending;</li>
<li>2022-11-05 Adelaide DSO找了Prof, 说因为北邮的敏感原因, 不能给我admission. 我还是有点心理准备的. x北邮, 一点好处没捞到, 在读期间天天折磨人, 毕业了还拖后腿. (讲真有点后悔的, 当初去川大学计算机不香吗)<br>刘教授推荐了的三位教授, 后续的联系过程会单独写一篇秋季申请总结.</li>
<li>2022-11-07 给 SUTD 的 admission team 发了邮件, 但是两天了也没有收到任何回复;</li>
<li>2022-11-11 Waterloo ECE 拒. </li>
<li>2022-11-15 SUTD 收到拒信, 原因是没有自己的pub;</li>
<li>2022-11-17 Waterloo syde 拒. 说实话真的有点沮丧和意外, 寄托那里看到了waterloo的ece和syde很多offer的bg都比我差一些.</li>
<li>2022-11-24 Waterloo cs phd admission 发邮件说由于他们工作失误, 我的申请被当成缺少文件的废处理了. 让我决定是继续申请春季还是转移申请到秋季. 我转移申请到了秋季, 不过估计照样也就是rej的结果;</li>
<li>2022-11-25 收到 McMaster ECE 的拒信; 至此, 2023 spring / Winter 的申请全拒, 后续准备港新的 PhD 和欧洲的 Master 了.</li>
<li>2023-01-20 目前收到SMU的PhD口头offer, 荷兰Leiden, Twente, 阿自由的硕士offer; 澳洲悉大和卧龙岗大学的硕士offer. </li>
</ul>
<h2 id="Prologue"><a href="#Prologue" class="headerlink" title="Prologue"></a>Prologue</h2><p>从今年4月底收到坡MOM拒签的消息, 到9月份刚填完申请系统, 感觉自己这段时间经历了好多, 也真的体会到留学申请的困难. 因为直到考完雅思之前我都准备申请9月入学的项目, 但是8月底突然知道有一堆春/冬季项目也可以申请, 所以真正的准备时间是从8月31日开始, 到9月23日填完系统. 用这一篇Post来记录自己申请的过程.</p>
<p><strong>Target</strong>:<br>加澳新 CS PhD 混申; ECE 和 SDE 等相关专业 Master 也尝试一下.</p>
<p><strong>BG</strong>:<br>北邮本, 数据科学与大数据技术, 均分87/100;<br>三年三等奖学金, 两个美赛M奖, 一个数学竞赛三等奖;<br>雅思 6.5 小分 6.5, 无 GRE (其实考过一次但是分数太烂了用不了);</p>
<p>论文有两篇挂名: 一篇NLP顶会 (CCF-B), 一篇水刊;<br>有四段实习(每段大概3个月): 学而思-小猴启蒙教育-用户增长运营, 小米-互联网业务部-商业平台产品经理, 国网区块链-科研实习, 中科院自动化所-自然语言处理研究小组-科研实习.</p>
<h2 id="选校定位"><a href="#选校定位" class="headerlink" title="选校定位"></a>选校定位</h2><p>因为家里不提供任何资金支持 (23年秋季申请爸妈改变主意了, 所以考虑了很多欧洲的自费硕士项目), 所以只能去能申全奖的项目, 于是优先考虑 PhD. 欧陆的 PhD (除了英国) 待遇普遍都很好, 但是看了大部分项目都需要Master学历或者非常强的本科生, 所以直接放弃. 英国的 PhD 自费的可能多一些, 所以也没有考虑. 剩下的地区就选择了加澳新, 其中加拿大还申请了比较多的 MSc 或者 MASc 项目, 研究型硕士靠奖, RA&amp;TA 工资和老师的补贴也能养活自己. 因为自己已经gap一年了, 不是很想再等了, 所以打算申请23年1月或者5月入学的项目.</p>
<p>因为是主申PhD, 学校的因素可能就没有那么重要了, 我就按照 CSRanking 去找NLP方向比较强的导师去套词.</p>
<p>Tips: 北半球大部分学校冬季项目在前一年的7月份就截止了.</p>
<details class="tag-plugin folding" ><summary><span>加拿大选校</span></summary><div class="body"><div class="table-container"><table><thead><tr><th>学校</th><th>assessment (2023年)</th></tr></thead><tbody><tr><td>UoT</td><td>❌ cs无春季项目, 且我的英语成绩不够</td></tr><tr><td>McGill</td><td>❌ 强 committee, 语言成绩不够没法 argue</td></tr><tr><td>SFU</td><td>➖ 语言成绩不够 (应该套一下词的)</td></tr><tr><td>Alberta</td><td>❌ cs 方向没有春季入学项目</td></tr><tr><td>York</td><td>❌ cs 没有冬/春季项目</td></tr><tr><td>UBC</td><td>❌ cs 没有冬/春季项目</td></tr><tr><td>Calgary</td><td>❌ cs 没有冬/春季项目</td></tr><tr><td>Queen’s</td><td>❌ cs 没有冬/春季项目</td></tr><tr><td>Waterloo</td><td>✅ cs, ece, syde 都有项目</td></tr><tr><td>Victoria</td><td>✅ cs, ece 有项目</td></tr><tr><td>Carleton</td><td>✅ ece, hci 有项目</td></tr><tr><td>Ottawa</td><td>✅ 同Carleton</td></tr><tr><td>McMater</td><td>✅ ece有项目</td></tr></tbody></table></div></div></details>
<details class="tag-plugin folding" ><summary><span>新加坡选校</span></summary><div class="body"><div class="table-container"><table><thead><tr><th>学校</th><th>assessment (2023年)</th></tr></thead><tbody><tr><td>NUS</td><td>❌ 强comittee且要GRE</td></tr><tr><td>SMU</td><td>➖ 要GRE (不知道是不是强committee, 或许可以试着套一下)</td></tr><tr><td>NTU</td><td>✅ 要GRE, 但强committee, 语言可以waive</td></tr><tr><td>SUTD</td><td>✅ cs和ece都有项目</td></tr></tbody></table></div></div></details>
<details class="tag-plugin folding" ><summary><span>澳洲选校</span></summary><div class="body"><div class="table-container"><table><thead><tr><th>学校</th><th>assessment (2023年)</th></tr></thead><tbody><tr><td>新西兰的学校</td><td>❌ 硕士学历要求</td></tr><tr><td>澳洲八大</td><td>✅ 因为和北半球相反, 2月入学是澳洲的主学期, 所以机会会更多一些</td></tr></tbody></table></div></div></details>
<h2 id="套词和面试"><a href="#套词和面试" class="headerlink" title="套词和面试"></a>套词和面试</h2><p>套词的时候需要准备自己的 CV 和 成绩单. 之前找ra工作的时候都准备过这些. ps. 北邮的成绩单是真tmd贵 <span class="tag-plugin emoji"><img no-lazy="" class="inline" src="https://gcore.jsdelivr.net/gh/cdn-x/emoji/aru-l/0390.gif" style="height:3em"/></span>, 早知道基本用不上纸质成绩单就不开了, 直接电子成绩单就够够的了.</p>
<p>套词信的模板参照了寄托的一篇文章 <a href="https://bbs.gter.net/thread-1699797-1-1.html">Link</a>, 我觉得最主要的就是去看老师的研究方向和 Funding, 读组里的论文然后去联系老师, 套词信不用太长. 我从8月底开始选择感兴趣的老师发邮件套词, 一共发出了13封套词信, 收到7个回复. 其中1封养鱼信, 3个比较正面的回复 (约面试or要RP), 3个拒. </p>
<ul>
<li>Waterloo CS 养鱼回复</li>
<li>SUTD CS 约面试</li>
<li>Adelaide CS 约面试</li>
<li>Macquarie CS 要RP</li>
<li>Auckland CS 学历拒, 新西兰的PhD需要Master学位</li>
<li>Massey CS 同上</li>
<li>NTU CS 没hc</li>
</ul>
<p>本来应该多套一些的, 但是9月份自己的精神状态不是特别好<span class="tag-plugin emoji"><img no-lazy="" class="inline" src="https://gcore.jsdelivr.net/gh/cdn-x/emoji/aru-l/8110.gif" style="height:3em"/></span>, 压力非常大, 而且大多数项目的申请ddl是9月底, 我还要预留时间写RP, 各种statement和填申请系统. 当时觉得自己的bg去申请直博竞争力没有很大, 直到今天写总结的时候才发现自己套词回复率这么高.</p>
<p>说下Adelaide的面试, 先做了一个15min的pre, 讲了最近的工作. 然后和老师讨论了下我的研究方向, 又问了几个问题. 一个是神经网络在某个节点进行泰勒展开(我: ?) 当时学机器学习课程的时候我都没有学过这一段, 然后直接蒙蔽. 后面的问题是法律领域的自然语言处理问题, 文本应该怎么处理, 如何解决few-shot的问题. 因为之前的demo做了医学领域的nlp, 就把相关论文的methods尝试用到法律领域去回答了; few-shot 问题我想到的是生成对抗网络加 pseudo labels.</p>
<p>最后套词的结果有两个口头offer: Adelaide的老师给了自己项目的funding, SUTD的老师让我拿学校的奖. 因为这个时候感觉时间已经很紧张了, 所以先准备填系统等有没有反套.</p>
<h2 id="申请"><a href="#申请" class="headerlink" title="申请"></a>申请</h2><h3 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h3><p><strong>Research Proposal</strong>: 我写了之后改的不多, 拿给阿大的老师看了下没问题就过了</p>
<p><strong>Statement of Purpose</strong>: SUTD要求一个3000words的SOP, 我真的<span class="tag-plugin emoji"><img no-lazy="" class="inline" src="https://gcore.jsdelivr.net/gh/cdn-x/emoji/aru-l/6510.gif" style="height:3em"/></span> 我自己写了大概2300字左右, 拿到fiverr上找了一个老哥改. 这个<a href="https://www.fiverr.com/musihality?source=order_page_user_stamp_link">老哥</a>的团队在一亩三分地上也有帖子, 主要的优势就是比较快, 适合我这种着急要sop的选手. 后续其他学校的SOP也是在他返稿的基础上改的.</p>
<p><strong>Passport</strong>: 不知道为啥卡的这么严, 尽量找小地方申请.</p>
<p><strong>Reference Letter</strong>: 中科院两位老师的牛推, 还有本科给我上数据挖掘课的于老师. 感谢各位老师!</p>
<h3 id="申请系统"><a href="#申请系统" class="headerlink" title="申请系统"></a>申请系统</h3><p>项目数量: 6</p>
<ul>
<li>2022-9-15 Adelaide cs phd申请系统提交;</li>
<li>2022-9-20 SUTD cs phd申请系统提交;</li>
<li>2022-9-20 Waterloo cs phd, ece msc, syde msc提交申请;</li>
<li>2022-9-22 Waterloo 发学生ID, 可以上传文件了;</li>
<li>2022-9-22 McMaster ece masc申请系统提交;</li>
</ul>
]]></content>
      <categories>
        <category>留学</category>
      </categories>
  </entry>
  <entry>
    <title>2022年的书籍/影视/游戏/音乐总结</title>
    <url>/202212/2022%E5%B9%B4%E4%B9%A6%E5%BD%B1%E6%B8%B8%E9%9F%B3%E9%80%9F%E8%AF%84/</url>
    <content><![CDATA[<p>书籍 11本, 电影/电视剧 26部.<br><span id="more"></span></p>
<div class="tag-plugin grid" bg="block"><div class="cell" index="0"><center>    <b>电影/电视剧</b>    <div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>想见你 ⭐⭐⭐⭐⭐</span></div>    <div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>进击的巨人S1-2 ⭐⭐⭐⭐⭐</span></div>    <div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>甄嬛传 ⭐⭐⭐⭐⭐</span></div>    <div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>寻梦环游记 ⭐⭐⭐⭐⭐-</span></div>    <div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>逍遥法外 ⭐⭐⭐⭐+</span></div>    <div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>开端 ⭐⭐⭐⭐+</span></div>    <div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>怪奇物语S1-4 ⭐⭐⭐⭐</span></div>    <div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>死亡笔记 ⭐⭐⭐⭐</span></div>    <div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>鱿鱼游戏 ⭐⭐⭐⭐</span></div>    <div class="tag-plugin checkbox" color="green" symbol="plus"><input type="checkbox" checked="true"/><span>我们与恶的距离 ⭐⭐⭐⭐</span></div>    <div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>僵尸校园 ⭐⭐⭐⭐</span></div>    <div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>心灵奇旅 ⭐⭐⭐⭐</span></div>    <div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>爱在黎明破晓前 ⭐⭐⭐⭐</span></div>    <div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>顶楼S1-2 ⭐⭐⭐⭐</span></div>    <div class="tag-plugin checkbox" color="green" symbol="plus"><input type="checkbox" checked="true"/><span>回来的女儿 ⭐⭐⭐⭐-</span></div>    <div class="tag-plugin checkbox" color="red" symbol="times"><input type="checkbox" checked="true"/><span>命运航班 ⭐⭐⭐+</span></div>    <div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>信条 ⭐⭐⭐+</span></div>    <div class="tag-plugin checkbox" color="red" symbol="times"><input type="checkbox" checked="true"/><span>还有明天 ⭐⭐⭐</span></div>    <div class="tag-plugin checkbox" color="red" symbol="times"><input type="checkbox" checked="true"/><span>甜蜜家园 ⭐⭐+</span></div>    <div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>想见你影版 ⭐⭐+</span></div>    <div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>尸战朝鲜 ⭐⭐</span></div></center></div><div class="cell" index="1"><center><b>书籍</b><div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>哈利波特1-5 ⭐⭐⭐⭐⭐</span></div><div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>蛤蟆先生去看心理医生 ⭐⭐⭐⭐+</span></div><div class="tag-plugin checkbox" color="green" symbol="plus"><input type="checkbox" checked="true"/><span>拖延心理学 ⭐⭐⭐⭐</span></div><div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>被讨厌的勇气 ⭐⭐⭐⭐</span></div><div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>坏小孩 ⭐⭐⭐+</span></div><div class="tag-plugin checkbox" color="red" symbol="times"><input type="checkbox" checked="true"/><span>计算广告 ⭐⭐⭐+</span></div><div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>阿德勒心理学 ⭐⭐⭐</span></div></center><br><center><b>游戏</b><div class="tag-plugin checkbox" color="green" symbol="plus"><input type="checkbox" checked="true"/><span>明日方舟 ⭐⭐⭐⭐+</span></div><div class="tag-plugin checkbox" color="green" symbol="plus"><input type="checkbox" checked="true"/><span>塞尔达传说 ⭐⭐⭐⭐+</span></div><div class="tag-plugin checkbox" ><input type="checkbox" checked="true"/><span>凯娜精神之桥 ⭐⭐⭐⭐-</span></div><div class="tag-plugin checkbox" color="green" symbol="plus"><input type="checkbox" checked="true"/><span>原神 ⭐⭐⭐⭐-</span></div><div class="tag-plugin checkbox" color="green" symbol="plus"><input type="checkbox" checked="true"/><span>宝可梦传说 阿尔宙斯 ⭐⭐⭐</span></div><div class="tag-plugin checkbox" color="red" symbol="times"><input type="checkbox" checked="true"/><span>第五人格 ⭐⭐</span></div></center><br><center><b>音乐播放次数榜单</b><div class="tag-plugin checkbox" ><input type="radio" checked="true"/><span>Free Loop - Daniel Powter</span></div><div class="tag-plugin checkbox" ><input type="radio" checked="true"/><span>Stay this way - fromis_9</span></div><div class="tag-plugin checkbox" ><input type="radio" checked="true"/><span>LOVE DIVE - IVE</span></div><div class="tag-plugin checkbox" ><input type="radio" checked="true"/><span>Shoot! - POP!CORN</span></div><div class="tag-plugin checkbox" ><input type="radio" checked="true"/><span>TOMEBOY - (G)I-DLE</span></div><div class="tag-plugin checkbox" ><input type="radio" checked="true"/><span>Running Up That Hill - Kate Bush</span></div><div class="tag-plugin checkbox" ><input type="radio" checked="true"/><span>Hype Boy - NewJeans</span></div><div class="tag-plugin checkbox" ><input type="radio" checked="true"/><span>Honey - 王心凌</span></div><div class="tag-plugin checkbox" ><input type="radio" checked="true"/><span>LE VOYA9E - Kep1er</span></div><div class="tag-plugin checkbox" ><input type="radio" checked="true"/><span>DM - fromis_9</span></div></center></div></div>
<h2 id="短评"><a href="#短评" class="headerlink" title="短评"></a>短评</h2><div class="tag-plugin tabs" align="center"id="tab_1"><div class="nav-tabs"><div class="tab active"><a href="#tab_1-1">书</a></div><div class="tab"><a href="#tab_1-2">影</a></div><div class="tab"><a href="#tab_1-3">游</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_1-1"><details class="tag-plugin folding"  open><summary><span>哈利波特 1-5</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐⭐⭐<br>Review: 今年跟着喜马拉雅听书又重新听了一遍, 前四部依然非常上头. 感觉电影的情节真的安排得太赶了, 读原著会更爽一些.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>阿德勒心理学</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐<br>Review: 在 PageOne 读的纸质书, 插画形式讲解阿德勒心理学. 已经读过「被讨厌的勇气」, 觉得这本书就像一本知识点总结.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>被讨厌的勇气</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐⭐<br>Review: 用Kindle读的, 阿德勒心理学有可取之处, 这本书讲的也非常好. 其中最重要的「课题划分」概念对于当时的我来说意义非凡. 之后可能会重读一遍, 因为第一次读还有很多东西没有完全理解.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>蛤蟆先生去看心理医生</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐⭐+<br>Review: 用Kindle读的, 虽然这本书的知识性不如上面一本, 但是这本书知识讲解得鞭辟入里, 代入感非常强 (又有柳林风声的背景). 其中「儿童, 成人, 家长」状态的概念对我的影响很大.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>坏小孩</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐+<br>Review: 在喜马拉雅听的有声书. 不知道是不是因为我读书习惯越来越差了, 我觉得文字内容并没有那么有趣, 甚至有些无聊(相比改编的电视剧). 不过这本书写的孩子并不是传统意义的天真善良的刻板印象, 很有新意.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>拖延心理学</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="green">Ongoing</a><br>Stars: ⭐⭐⭐⭐<br>Review: 在 PageOne 看了一会儿纸质书, 之后购入准备慢慢看. 书的内容对我非常有启发性, 特别是对于不在上班/上学的, 有大量空闲时间的我来说, 详尽地解释了拖延的原因和自我管理的方法, 我觉得这本书真的是大部分人的必读书.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>计算广告</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="red">Abandoned</a><br>Stars: ⭐⭐⭐+<br>Review: 可以速度一遍过一下基础概念. 这本书有点过时了, 不如去找网上的一些文档.</p></div></details></div><div class="tab-pane" id="tab_1-2"><details class="tag-plugin folding"  open><summary><span>开端</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐⭐+<br>Review: 无限流的影视佳作. 说实话我感觉白敬亭演的不好, 但是也没有太影响观感吧. (演员不要上综艺, 不然大家容易带入不进去.)</p></div></details>

<details class="tag-plugin folding"  open><summary><span>想见你</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐⭐⭐<br>Review: 值得五星的电视剧. 第三次刷了, 这一次是陪对象看的, 对象看的超级上头hhh.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>想见你影版</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐+<br>Review: 逻辑线很好, 剪辑稀烂. 我觉得主要是剧版太牛了吧, 影版想超越真的太难了.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>进击的巨人S1-2</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐⭐⭐<br>Review: 和对象一起看的第三遍, 刚看完第二季, 说实话我真不觉得结局有那么烂(我感觉就是oc而已…)</p></div></details>

<details class="tag-plugin folding"  open><summary><span>怪奇物语S1-4</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐⭐<br>Review: 设定很赞, 每季主线流畅, 最后大家聚集在一起很热血. 最新一部 Run! Max 太牛了.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>还有明天</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="red">Abandoned</a><br>Stars: ⭐⭐⭐<br>Review: 开头还挺好看的,越往后就感觉情节越老套. 编剧没有好好打磨人物.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>甄嬛传</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐⭐⭐<br>Review: 卓越的国产剧, 没有无意义的镜头.</p></div></details>


<details class="tag-plugin folding"  open><summary><span>死亡笔记</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐⭐<br>Review: 年初时候看的, 当时还担心这个动漫太压抑了. 开头太惊艳了, L 死后的故事有点赶. 是一部不能否认的好作品. Misamisa的恋爱脑还是让人有点不喜欢, 但是看到结局也接受了.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>僵尸校园</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐⭐<br>Review: 和对象一起看的, 我觉得是合格的丧尸剧, 虽然爱情线有点莫名其妙了. 超级喜欢这种封闭空间逃难/逃杀的片.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>尸战朝鲜</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐<br>Review: 讲真有点无聊的. 主要是韩国的那个皇帝也太寒酸了.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>甜蜜家园</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="red">Abandoned</a><br>Stars: ⭐⭐+<br>Review: 看剧评感觉这部剧还是不错的, 但是我第一季快看完了, 仍然感觉没有进入主线, 剧情太拖沓了. 难以接受.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>心灵奇旅</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐⭐<br>Review: 虽然讲述的道理没有那么深刻, 但是其他的一切真的很完美了. 生活本身就是生活的意义.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>寻梦环游记</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐⭐⭐-<br>Review: 一部讨论了生与死的电影, 对我来说是很少接触的题材. 很喜欢.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>命运航班</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="red">Abandoned</a><br>Stars: ⭐⭐⭐+<br>Review: 设定太棒了, 但是剧情也太太太太拖沓了.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>顶楼S1-2</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐⭐-<br>Review: 爽剧, 真的是够爽了.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>逍遥法外</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐⭐+<br>Review: 年初又重刷了一遍. 对我来说是一部好剧, 也是我的美剧启蒙.很难得的是没有烂尾.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>爱在黎明破晓前</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐⭐<br>Review: 年初和对象一起看的. 是我年轻三岁会喜欢的电影.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>信条</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐+<br>Review: 我总感觉这个剧在故弄玄虚, 好像要讲一个很高深的设定但是又不想让观众搞明白的感觉. 仍记得当时我在电影院睡着的场景. 我在电影院一共就睡着两次, 一次是这一部另一次是柯南绀青之拳.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>披荆斩棘的哥哥</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐+<br>Review: 综艺如果往艺术品的方向做就违背初衷了. 我觉得综艺最重要的是接地气, 能引发观众共鸣.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>我们与恶的距离</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="green">Ongoing</a><br>Stars: ⭐⭐⭐⭐<br>Review: 设定就很棒了, 导演也很用心. 但是看剧时候的我太浮躁了, 总觉得看不下去.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>鱿鱼游戏</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐⭐<br>Review: 套用爽剧模板但是很有趣.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>回来的女儿</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="green">Ongoing</a><br>Stars: ⭐⭐⭐⭐-<br>Review: 我个人看悬疑剧更看重悬疑而不是逻辑, 这部剧还是挺好的踩到我的爽点上了. 无论是开头的孙悟空还是文文和妈妈睡觉的场景, 都让我感觉有爽到.</p></div></details></div><div class="tab-pane" id="tab_1-3"><details class="tag-plugin folding"  open><summary><span>凯娜精神之桥</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="blue">Finished</a><br>Stars: ⭐⭐⭐⭐-<br>Review: 场景很赞, 但是感觉通关一遍就不想玩了. 我之后渐渐发觉自己还是喜欢社区属性强的游戏.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>塞尔达传说</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="green">Ongoing</a><br>Stars: ⭐⭐⭐⭐+<br>Review: 把地图开完了, 水神兽打完. 最喜欢的设定是关于武器使用的设定.(投掷武器是真的爽) 神庙设计的也非常棒, 很喜欢.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>宝可梦传说 阿尔宙斯</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="green">Ongoing</a><br>Stars: ⭐⭐⭐<br>Review: 说实话有点无聊. 一上来就给个图鉴然你去肝是怎样.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>第五人格</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="red">Abandoned</a><br>Stars: ⭐⭐<br>Review: 结合 LOL 最近说国服气氛不好, 我觉得PVP游戏国内的氛围真的 太差了, 也是因为大家的竞争观念, 想要赢的想法太强了吧. 没法好好享受游戏.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>原神</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="green">Ongoing</a><br>Stars: ⭐⭐⭐⭐-<br>Review: 我一直觉得原神是一款很好的游戏. 但是对于老玩家来说, 玩法太单一了, 新出的卡牌也没什么意思. 今年从56级升到57级就也不想继续玩了. 如果原神再没有啥好玩的常驻新模式, 会渐渐没落的吧.</p></div></details>

<details class="tag-plugin folding"  open><summary><span>明日方舟</span></summary><div class="body"><p>Status: <a class="tag-plugin tag" color="green">Ongoing</a><br>Stars: ⭐⭐⭐⭐+<br>Review: 下半年刚入坑. 塔防中的神中神. 这一年策划没有作妖, 社区氛围也非常好. 二创也都太有意思了. 肉鸽设计的真的很棒.</p></div></details></div></div></div>
]]></content>
  </entry>
  <entry>
    <title>2022年个人OKR核验</title>
    <url>/202212/2022%E5%B9%B4%E4%B8%AA%E4%BA%BAOKR%E6%A0%B8%E9%AA%8C/</url>
    <content><![CDATA[<p>写于 2022.12.25.</p>
<p>现在的我正在中关村东路租的小房间里写下2022年的回顾与展望. 这个小房间刚搬进来的时候我还万分不满, 但现在住久了也渐渐习惯了, 书桌旁边就有一扇大窗户, 能够享受白天的阳光, 真的是一件很美好的事情. </p>
<p>我好像已经很久很久没有写过类似总结归纳的东西了, 很久没有在关心自己的状态. 过去一段时间的日程管理也仅仅是记录学习/工作上的事情. 好像我不敢写总结, 是因为害怕面对自己. </p>
<p>我突然想到, &lt;想见你&gt;里面黄雨萱跟陈思源讲的道理, “大人之所以是大人, 是因为他们知道什么事情比较重要.” 为了那件重要的事情, 就可以忽略其他不重要的事情. 在乎方方面面(维护一个完美的人设)是很累的, 找准最主要的事情然后针对它去努力就可以了, 其他的都可以不用在乎.</p>
<h2 id="年度OKR核验12-26-2022-4-30-修订版本"><a href="#年度OKR核验12-26-2022-4-30-修订版本" class="headerlink" title="年度OKR核验12.26 (2022.4.30 修订版本)"></a>年度OKR核验12.26 (2022.4.30 修订版本)</h2><div class="tag-plugin note" color="blue"><div class="body"><p><b>O: 【事业发展】<s>对广告行业和NLP领域有深入的了解，能够独立负责项目。申请NUS或NTU博士并拿到offer.</s> 申请PhD或Master项目并拿到Offer.<br>Rv: 【90%】 了解计算广告行业的大框架, 在NLP领域有了很大的进步, 申请过程虽不是一帆风顺但自己也努力取得了成果. </b><br><s>KR1: 了解广告行业知识和现状（看完《计算广告》和相关网文），对小米广告（浏览器和内容中心）内部框架有一个清晰的认知（看完小米商业平台部的文档）；每月复盘自己的工作内容，对工作负责。</s></p><p>KR1: 了解NLP学术知识和企业应用现状，积累能写入简历的科研经历(以cv为导向), 发表论文一篇.<br>Rv1: 【85%】 基本达成, EMNLP2022 Demo track非一作一篇. 没有一作的文章有点遗憾.</p><p>KR2: 语言ielts &gt;= 6.5; GRE &gt;= 320 + 3.5 （英语成绩够用就好，有这个时间不如花在科研上）<br>Rv2: 【100%】 ielts分数超出预期, GRE暂时不需要就没有考了.</p><p>KR: 完成推荐信等, 联系导师套词, 争取拿到博士机会. 期间了解新加坡读博的各种政策, 整理.<br>Rv3: 【100%】 Good Job.</p></div></div>
<div class="tag-plugin note" color="green"><div class="body"><p><b>O: 【内心成长】追求心理健康和稳定，用理论框架梳理解释情绪和行为.<br>Rv: 【99%】对自己过去一年内心的成长感到十分的钦佩. 勇敢面对自己和自己的选择, 没有丧失同理心.</b></p><p>KR1: 定期看心理医生、按时吃药，争取减药or停药。<br>Rv1: 【90%】 Good Job.</p><p>KR2: 定期整理自己的情绪和领悟到的东西, 情绪以事业服务, 勇敢一些, 无需获得他人的认可. <s>看心理学方面的书籍并思考，记录关键笔记。如《被讨厌的勇气》、《蛤蟆先生去看心理医生》、《津巴多普通心理学》、《乌合之众》、《自卑与超越》、《社会性动物》。能够对生活中常见的问题或困扰自己的问题做出心理学角度的解释。</s><br>Rv2: 【70%】 用理论框架梳理生活情绪, 能够站在比较高的位置观察自己的心态.</p></div></div>
<div class="tag-plugin note" color="yellow"><div class="body"><p><b>O: 【身体健康】保持运动习惯，注重形象管理，身材变好，体脂降低。<br>Rv: 【60%】勉强及格. 下半年做的不是太好, 虽然有客观原因, 但是仍然没有坚持健康管理.</b></p><p>KR1: 个人护理。坚持好好洗脸和护肤，定期面膜护理，减糖。<br>Rv1: 【75%】前三个季度都做的不错, 最后一个季度甜食吃的太多。</p><p>KR2: 健康饮食。限制零食的购买和食用。不加餐，加餐只吃健康食品。<br>Rv2: 【60%】前半年做的很好, 后半年由于身体原因和疫情原因属实是放纵了.</p><p>KR: 运动。每周至少运动2三次，没有时间的话就只做有氧(游泳)。每周至少一次力量训练。<br>Rv3: 【50%】学会了蛙泳. 5月之前做的很好, 后半年有少量有氧, 完全舍弃了力量运动. 疫情和身体原因都是借口.</p></div></div>
<div class="tag-plugin note" color="orange"><div class="body"><p><b>O: 【技艺才情】寻求多变<br>Rv: 【75%】做的好. 能够达到75%真的超过我的预期了. 没想到自己这么棒.</b></p><p>KR1: 视频制作/vlog。提高作品质量，不盲目追求投稿打卡。一年发布一条十分优质的视频内容。不以核心数据作为视频质量的评价指标.<br>Rv1: 【75%】视频拍摄技巧/录音技巧/视频剪辑软件的使用(pr, 剪映, fcp) 都更加熟练, 技术方面取得了很大的进步. 但是有非常多的idea没有付诸现实. 原因: 没有考虑目标的可达成性, 没有合理制定目标和时间节点. 截至Dec. 26, 累计播放12.3万, 累计粉丝1472. 个人觉得最优秀的视频是拆花的视频, 最受欢迎的是化妆刷.</p><p>KR2: 游泳。学会蛙泳和自由泳。<br>Rv2: 【70%】Good Job. 学会了蛙泳.</p></div></div>
<h2 id="一些感想"><a href="#一些感想" class="headerlink" title="一些感想"></a>一些感想</h2><p>回顾过去的2022, 它不像过去的年份那样平淡, 这一年里发生的事情都太激烈了, 每有一件新事情出现我的情绪就被震撼一次, 所以我对之前发生的事情记忆力就没有那么深刻. 留学 收到3份口头 Offer, 4份 Condition offer, 因为敏感背景被加澳 admission officer 拒2次, 被新加坡拒签1次, 收到小米和中科院的Offer, 雅思考出成绩. 这一年的情绪一直在被这些事情牵动着, 也没有想象中那么稳定. 在新的一年, 我希望自己能够坚定自己目标而不被这些事情的结果影响. 同时制定计划的时候也不应该把不能预料结果的事情算进去. 不能制定 “如果A那么我就做B” 这样的计划. </p>
<ul>
<li><p>在同理心和钝感之间平衡, 不要过多得揣测别人话中莫须有的「深意」.</p>
</li>
<li><p>只有留给自己充分的休息时间, 才能更高效率的工作.</p>
</li>
<li><p>对话时降低语速, 注意表达时的眼神和神态控制, 去掉「然后」的口癖, 用停顿或动作来代替.</p>
</li>
<li><p>避免假性高效, 根据重要性等级为每件事情设置分数, 为自己创造深度工作的时间.</p>
</li>
<li><p>项目管理流程强化: 对交付信息- 主动汇报关键节点 - 复盘.</p>
</li>
<li><p>焦虑控制四象限. 焦虑原因: 想要证明成绩/获得认可.</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>雅思备考经验</title>
    <url>/202208/ielts/</url>
    <content><![CDATA[<p>备考时间大约40天 (最后10天全职备考), 最后出分 6.5 (6.5), 记录一下自己的备考流程和经验.</p>
<span id="more"></span>
<p>bg: 六级分数530</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Listening</th>
<th>Reading</th>
<th>Writing</th>
<th>Speaking</th>
</tr>
</thead>
<tbody>
<tr>
<td>6.5</td>
<td>7.0</td>
<td>6.5</td>
<td>6.5</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Overall"><a href="#Overall" class="headerlink" title="Overall"></a>Overall</h2><p>备考用到的材料包括:</p>
<ul>
<li>听力: 何琼网课, 王陆语料库</li>
<li>阅读: 刘洪波阅读真经</li>
<li>写作: Simon网课, Vince网课, 某宝的批改</li>
<li>口语: B站雅思口语9分安, 杨帅口语网课</li>
<li>真题: 剑 6, 13, 14, 16, 17</li>
</ul>
<p>机考听阅抽到的题目难度比剑17稍微简单一点点, 但是出现了很多少见的题型.</p>
<p>听力出现了 <code>no more than 2/3 words</code> 的填空题, Section3和Section4的题目形式换了一下.</p>
<p>阅读出现了17道匹配题, 还有一个 <code>no more than 3 words</code> 的简答题. (这个题型在我刷到的剑雅里都没出现过)</p>
<p>写作大作文抽到了比例相对较小的 problem / solution 类似的题目. 问题是现有的商家用来促销的手段有哪些, 其中哪个最effective.</p>
<p>口语 Part1 抽到了 <code>Advertisement</code>, Part2 抽到了没准备的题目 <code>Traffic Jam</code>, Part3 问了七八个题目, 超时了好久.</p>
<h2 id="Listening"><a href="#Listening" class="headerlink" title="Listening"></a>Listening</h2><ul>
<li>何琼听力网课</li>
</ul>
<p>看了何琼听力网课的内容, 非常有用, 但是有些细节的做题方法有点旧了.</p>
<p>比如Section1填空题的答案不仅出现在对话的回答里, 而且也会出现在对话的问题中. 在剑17里填空题想要得到答案已经不能仅仅靠定位词了, 需要对对话情景比较了解. 需要准备一下何琼的场景词. </p>
<p>关于Section2和Section3的选择题, 我感觉何琼的方法已经不太好用了, 最好的方法还是做题然后精听或者听写. 剑17听力选择题的干扰项太变态了. </p>
<ul>
<li>王陆语料库</li>
</ul>
<p>因为自己的备考时间不太够, 所以最后没有用上, 但是备考时间充足的话我一定会老实用她的语料库听写.</p>
<p><code>experience</code>, <code>february</code>, <code>journalism</code> 都拼写错了, 0.5分就这样没了(哭).</p>
<h2 id="Reading"><a href="#Reading" class="headerlink" title="Reading"></a>Reading</h2><p>没花太多时间在阅读上, 了解了刘洪波的做题方法后主要就是至少每两天一套题保持手感. </p>
<p>剑6 用来训练做题方法.</p>
<p>剑13 - 16的分数在7.5到8.5之间浮动, 剑17的分数差不多都是7.0</p>
<p>Tips: 剑17已经不再能通过简单的同义替换做题了, 需要理解文章内容.</p>
<h2 id="Writing"><a href="#Writing" class="headerlink" title="Writing"></a>Writing</h2><p>Simon的小作文网课, 看完了之后把每节课的handout都完成, 写了六七篇的样子.</p>
<p>Simon的大作文网课看完了, 但是最后没有采用, 还是用了B站<code>Vince9120</code>的写作逻辑. 写了两篇找某宝批改, 一篇6一篇5.</p>
<p>Tips: </p>
<ul>
<li>大作文的逻辑框架可以采用Simon的, 但是观点的展开一定要用Vince的三种方法. Simon的 <code>Listing</code> 的展开方式也被某宝批改的两位老师声讨了, 所以练习的两篇文章分数都比较低. </li>
<li>考场上时间不够的话不要再展开新观点了. 我最后半分钟的时候想到了一个很好的exemplify <code>It is the good taste rather than low price makes CocaCola one of the best beverages.</code>但是没有展开, 那一段的逻辑最后都没顺明白. </li>
</ul>
<h2 id="Speaking"><a href="#Speaking" class="headerlink" title="Speaking"></a>Speaking</h2><p>考前把 Part1 和 Part2 的题目都串了一遍, 我用的杨帅整理的题库. </p>
<p>但是考试还是抽到新题了(悲). 没有准备过的新题, 我都没想到我能说够两分钟还被考官打断. (考官是一位白叔, 口语很舒服. 为了让我听清楚, 问问题的时候 key words 都是0.1倍速在讲)</p>
<p>推荐B站<code>雅思口语9分安</code>的公开课, 他讲的扩充的方法非常有用, 让 Part2 比较容易能讲到 2min .</p>
<p>避雷杨帅整理的题库, 还是要在雅思哥上看本季的题目. 考试的时候不要怯场讲话就会流利很多.</p>
<p>杨帅的 <code>filler words</code> 和每日练三句都是好的备考素材.</p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>雅思</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年2月产品实习面经</title>
    <url>/202202/pm%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<p>一共面了6个部门的产品实习 (字节Pico, 字节飞书, 滴滴地图事业部, Momenta, 小米互部, 小冰算法), 拿到两个offer最后选择了小米.</p>
<span id="more"></span>
<div class="table-container">
<table>
<thead>
<tr>
<th>Job Positions</th>
<th>Enterprise</th>
<th>Final Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>VR和AR产品经理实习生</td>
<td>字节Pico</td>
<td>一面挂</td>
</tr>
<tr>
<td>地图点产品经理实习生</td>
<td>滴滴地图事业部</td>
<td>三面oc</td>
</tr>
<tr>
<td>产品架构实习生</td>
<td>Momenta</td>
<td>一面挂</td>
</tr>
<tr>
<td>商业平台产品经理实习生</td>
<td>小米互联网业务部</td>
<td>二面oc</td>
</tr>
<tr>
<td>算法产品经理实习生</td>
<td>红棉小冰</td>
<td>一面挂</td>
</tr>
<tr>
<td>测试产品经理实习生</td>
<td>字节飞书</td>
<td>一面挂</td>
</tr>
</tbody>
</table>
</div>
<p>面试中简历挖掘和业务问题基本是五五开，简历挖掘部分不再赘述.</p>
<h2 id="字节Pico"><a href="#字节Pico" class="headerlink" title="字节Pico"></a>字节Pico</h2><p>方向：vr and ar<br>2月9日投递简历，安排在2月11日一面。一共1h40min，给我面麻了</p>
<ul>
<li>一面<br>1、自我介绍<br>2、来聊一聊你曾经的项目，你想先聊哪一个？<br>（选择了小猴启蒙的用户增长运营，因为和产品岗位更加相关。）<br>3、向我介绍一下这段实习你做了什么？（共分成了三点进行描述，微信平台数据跟踪、裂变活动策划、其他渠道向微信引流）<br>4、详细介绍你在其中做了什么事情？（在裂变活动策划中，ab test 制定新的微信推送sop，制定了稳定时间频率的；在微信平台数据跟踪中，通过漏斗分析数据，中间还提问了各种细节）<br>5、介绍一下区块链项目你在其中做的内容？（介绍）你觉得如果不用区块链能够解决这个问题吗？（可，把农民工的工资让开发方质押在银行）你觉得你的这个想法为什么没有人实施呢？（我这个问题说不出个所以然，减分点）<br>6、你的职业规划是什么？（想来体验一下产品，再决定自己未来的职业道路规划）<br>7、你对ar/mr有了解吗？（整个由两部分组成：硬件和内容。介绍了我体验过的两个产品，但是忘记爱奇艺那个产品的名字了，是一个挺大的减分点吧）<br>8、你对未来ar、mr的畅想？（ar野生动物园导览）<br>9、现场做一个产品调研，调研一下arkit，向我介绍一下它？（这个问题说的太笼统了，在我看网页的过程中面试官给我细化了一些sdk，我看了一下哪些sdk然后向面试官进行介绍，面试官也给我讲了很多相关的技术介绍）<br>10、你平时玩游戏吗？（玩，巫师三 凯娜精神之桥）你觉得游戏中哪些最吸引你？（我最后选了“双人成行”，我觉得他比较牛逼的地方是两个人的游戏交互形式非常的多）如果你自己要做一个游戏，你该怎么借鉴双人成行呢？（我说的非常的不清楚）<br>11、关于实习的时间<br>12、反问环节，我问了pico的具体业务（</li>
</ul>
<p>总结：其实整个过程还是聊的很愉快的，但是后续我觉得自己其实是非常缺少“产品逻辑”，整个面试过程中聊的都是自己的直观体验，而没有从产品的角度去看待问题。这就是自己的不足。应该更多的了解产品岗位的视角是怎样的，从更专业的角度去剖析各种产品。</p>
<p>业务反馈被挂原因：对ar和vr的了解不够。</p>
<h2 id="滴滴地图事业部"><a href="#滴滴地图事业部" class="headerlink" title="滴滴地图事业部"></a>滴滴地图事业部</h2><p>主要方向：地图点<br>共三面, oc，每一面都有30min，2.16一面；2.17二面；2.18三面</p>
<ul>
<li>一面<br>1、简历项目挖掘，关于学而思小猴的那一段用户增长运营经历<br>2、如果你的mentor让你去给她买一杯咖啡，你会怎么做？（用pm项目管理的思路去答）<br>3、在学校里最让你有成就感的一件事（3rd人工智能论坛）项目如何推进（项目管理），如果遇到不同意见如何说服？（pm沟通）<br>4、如何快速估计出北京的公交车站点数（开放问题，采样思路随便说说）</li>
</ul>
<p>面试官是一个非常和蔼的姐姐，面完当场告诉我通过了，准备二面</p>
<ul>
<li>二面<br>1、简历挖掘，关于区块链的项目，如何从pm的角度思考产品的可行性<br>2、竞品分析：滴滴和高德打车流程的异同。<br>（1）都是自动推荐周围上车点，没有给用户提示<br>（2）下车点的选择大同小异（滴滴 添加途经点， 高德可以对调出发和到达）<br>（3）打车界面（高德有价格筛选、应答率、多平台支持） 应答速度还是滴滴更快<br>我还讲了一下关于高德的助老打车，无论是app还是小程序，用户路径都比滴滴的要好。</li>
</ul>
<p>二面面试官觉得问题不大，说三面不出差错就没大问题。</p>
<ul>
<li>三面<br>1、对上车点和下车点的异同分析<br>2、为什么打车软件从高德换到了滴滴<br>3、高德和滴滴的分析（问的好笼统）<br>最后向我介绍了地图事业部的业务</li>
</ul>
<h2 id="momenta-产品架构"><a href="#momenta-产品架构" class="headerlink" title="momenta 产品架构"></a>momenta 产品架构</h2><p>方向：产品系统架构 一面挂<br>明显地感觉出来对面不想说话 kpi面 互相介绍了一下就没了</p>
<h2 id="小米-商业平台"><a href="#小米-商业平台" class="headerlink" title="小米 商业平台"></a>小米 商业平台</h2><p>方向：adpm<br>一共两面，oc</p>
<ul>
<li><p>一面<br>简历挖掘；关于广告的兴趣；职业规划</p>
</li>
<li><p>二面<br>广告计费方式的考察；简历挖掘；然后就是leader向我介绍工作内容了<br>最后问了广告的一些算法（我懵了，还好没瞎编，后来知道leader也是cs出身的）</p>
</li>
</ul>
<h2 id="小冰"><a href="#小冰" class="headerlink" title="小冰"></a>小冰</h2><p>方向：算法pm（听说小冰的pm数量比rd多很多，，）<br>一面挂. 因为当时已经拿了滴滴offer，小米的offer也觉得停稳，小冰和字节飞书就面着玩儿了</p>
<ul>
<li>一面</li>
</ul>
<p>1、简历挖掘<br>2、nlp的算法问我了解多少（<br>3、在一个充满机器人的群聊（只有用户一个真人），发现这个用户非常喜欢说晚安，该如何构建用户场景？<br>（用户画像建立-群聊场景-功能性建立）</p>
<h2 id="字节飞书"><a href="#字节飞书" class="headerlink" title="字节飞书"></a>字节飞书</h2><p>我之前真的超想去飞书，在字节做校园大使的时候就觉得飞书真的好用，大三的时候投简历被挂了。今年飞书toB业务开展比较缺人，，然而我面试的时候懈怠了，又是一面挂。</p>
<p>方向：测试软件的pm<br>简历挖掘 + 问了些软工课程里的东西，关于测试的内容。<br>如何测试微信朋友圈发送图片的功能</p>
<p>其实这个方向离我的预想差的太远了，我以为是toC体验的方向</p>
]]></content>
      <categories>
        <category>产品</category>
      </categories>
      <tags>
        <tag>产品</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>博客内容归档和英文博客</title>
    <url>/202111/%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E5%BD%92%E6%A1%A3%E5%92%8C%E8%8B%B1%E6%96%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>从2019年开始尝试搭建自己的博客，到现在已经本科毕业。这三年的时间虽然没有坚持更新博客，但是一直在坚持记录。无论是理论知识的学习、Debug的记录，还是读书健身笔记和感慨万千时的随笔，他们都散落在各种在线笔记软件和手机的备忘录中。</p>
<p>随着时间的推移，我对博客的认识也发生了很多变化。“记录”对我来说仍然具有非常大的意义，但是“博客”最重要的价值不应该是“记录”，而是“分享”——传递有价值的信息。我把平时的日常生活和学习经历记录在各种笔记中，过一段时间再去回顾和整理，选取其中有价值的东西去分享。</p>
<p>过去的一年再次参加了美赛，加入了几个和区块链有关的项目，也完成了不少专利和论文。更多的时间忙于运用知识，以需求为导向迫使自己进行广泛而不深刻的学习。对我来说真正有价值的输入变少了，输出和表达的欲望也降低了很多。</p>
<p>我在原先的博客域名之下又建立了一个英文博客<a href="https://enblog.crocodilezs.top/">BLOG-EN</a>，旨在整理自己过去一年经历的各种项目。同时也将原博客中的内容进行整理归档，便于自己和访客的查阅。</p>
<span id="more"></span>
<h2 id="课程设计与实验"><a href="#课程设计与实验" class="headerlink" title="课程设计与实验"></a>课程设计与实验</h2><p><a href="/201911/Linux开发环境及应用作业%2020191031/" itemprop="url"> Linux文本处理作业 </a> &emsp;&emsp;<br><a href="/categories/操作系统/" itemprop="url"> 《30天自制操作系统》实验合辑 </a> &emsp;&emsp;<br><a href="/201909/周宇洋_「学生宿舍管理系统」实验报告/" itemprop="url"> 学生宿舍管理系统Python开发 </a> &emsp;&emsp;<br><a href="/201911/KNN与Naive_Bayes代码实现/" itemprop="url"> KNN和朴素贝叶斯的代码实现 </a> &emsp;&emsp;<br><a href="/201911/Price_Suggestion_Chanllenge/" itemprop="url"> 商品价格预测挑战 </a> &emsp;&emsp;<br><a href="/201911/Fisher算法&SVM&K-Means及其优化/" itemprop="url"> Fisher算法 &amp; SVM &amp; K-Means的实现和优化 </a> &emsp;&emsp;<br><a href="/201910/FINDS算法和ID3算法/" itemprop="url"> FINDS算法和ID3算法 </a> &emsp;&emsp;<br><a href="/201904/插入排序归并排序和快速排序/" itemprop="url"> 算法设计之排序 </a> &emsp;&emsp;<br><a href="/201904/循环赛赛程安排/" itemprop="url"> 算法设计之循环赛赛程安排 </a> &emsp;&emsp;</p>
<h2 id="展示和汇报"><a href="#展示和汇报" class="headerlink" title="展示和汇报"></a>展示和汇报</h2><p><a href="/201904/基于链接内容的社区发现（一）/" itemprop="url"> 基于链接内容的社区发现（一） </a> &emsp;&emsp;<br><a href="/201904/基于链接内容的社区发现（二）/" itemprop="url"> 基于链接内容的社区发现（二） </a> &emsp;&emsp;</p>
<h2 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h2><p><a href="/201908/「迁移学习简明手册」学习笔记（1）/" itemprop="url"> 《迁移学习简明手册》学习笔记 </a> &emsp;&emsp;<br><a href="/201909/实验室苦逼搬砖暑假生活纪实/" itemprop="url"> 用户对齐（实验室搬砖纪实） </a> &emsp;&emsp;</p>
<h2 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h2><p><a href="/202005/《苏东坡传》摘录/" itemprop="url"> 《苏东坡传》 </a> &emsp;&emsp;<br><a href="/202002/祭亡妻程氏文/" itemprop="url"> 《祭亡妻程氏文》 </a> &emsp;&emsp; </p>
]]></content>
  </entry>
  <entry>
    <title>《苏东坡传》摘录</title>
    <url>/202005/%E3%80%8A%E8%8B%8F%E4%B8%9C%E5%9D%A1%E4%BC%A0%E3%80%8B%E6%91%98%E5%BD%95/</url>
    <content><![CDATA[<p>今年五月份读完的这本书，暑假开始的时候决定把读书笔记和读后感整理放在博客上。关于《苏东坡传》的文章一共有两篇，这是第一篇，内容为读书时的摘录。第二篇如下：  </p>
<p>人生到处知何似， 应似飞鸿踏雪泥， 泥上偶然留指爪， 鸿飞那复计东西。</p>
<p>拿西洋作家为例，李白可以媲美雪莱或拜伦，是一个燃烧自己展现出瞬间壮景的文学彗星。杜甫就象米尔顿，是一个热心的哲学家和老好人，以贴切、渊博的古典比喻写出了丰富的作品。苏东坡永远年轻。他性格比较象萨克莱，政治和诗词的盛名则象雨果，同时又具有约翰生博士那份动人的本质。不知怎么约翰生博士的痛风病直到今天还叫我们感动，米尔顿的瞎眼却不尽然。如果约翰生同时又兼有甘斯伯劳的特色，而且象波普用诗词批评政治，又象史维夫特吃过那么多苦而没有史维夫特的尖酸味儿，我们就能找出一个英国的类比了。苏东坡的道精神由于遭受许多困难而更醇美，却没有变酸。今天我们爱他，只因为他吃苦吃得太多了。</p>
<p>苏东坡在面对痛苦时展现出了超常的淡然，他像是一个已经预知了自己一生的人。我最爱他的地方是他面对所有事情的坦诚。  </p>
<p>今年五月份读完的这本书，暑假开始的时候决定把读书笔记和读后感整理放在博客上。关于《苏东坡传》的文章一共有两篇，这是第一篇，内容为读书时的摘录。第二篇如下：</p>
<span id="more"></span>
<hr>
<p>我们可以检视一幕幕已经终了的情节，眼见许多事情因外在事变和内在性格的必然性而自然发展。  </p>
<p>王安石热衷社会改革，自然觉得任何手段都没有错，甚至不惜清除异己。神圣的目标向来是最危险的。<strong>一旦目标神圣化，实行的手段必然日渐卑鄙。</strong>这种发展趋势逃不过苏东坡敏锐的心灵，甚至有点违背他的幽默感。他的行径和王安石不合；彼此的冲突决定了他一生的经历，也决定了宋朝的命运。  </p>
<p>“文章如精金美玉”，苏东坡写信给谢民师说，“市有定价，非人所能以口舌贵贱也”。</p>
<p><strong>构成永恒特质的“真诚性”</strong>究竟是什么呢？苏东坡清清楚楚表达了他对写作和文体的意见。“大略如行云流水。初无定质。但常行于所当行，常止于不可不止。文理自然，姿态横生。孔子曰，言之不文，行之不远。又曰，词达而已矣，夫言止于达意，则疑若不文，是大不然。求物之妙，如系风捕影，能使是物了然于心者，盖千万人而不一遇也。而况能使了然于口与手乎。是之谓词达。词至于能达，则文不可胜用矣。杨雄好为艰深之词。以文浅易之说，若正言之，则人人知之矣。此正所谓雕虫篆刻者。”苏东坡为文体下定义，正好贴切地描述了他自己写文章的过程，动笔收笔都象“行云流水”，揭露出文章和修辞的一切奥秘。什么时候进行，什么时候结束都没有一定的规矩。<strong>如果作家的思绪很美，只要他能忠实、诚恳、妥当表达，魅力和美感自然存在。</strong>这些不是硬放人作品的东西，词达而造成的单纯、自然和某一种自由感正是好文章的秘诀。这些特质具备了，文体不虚浮空洞，就可以写出真诚的文学作品。  </p>
<p>“生平最快乐的时刻”，有一天苏东坡对他的朋友说，“就是写作时笔端能表达一切思想的脉络。我自忖道‘人间自乐莫过于此’”。  </p>
<p>他曾一度坚称，给人快慰的力量便是文学本身的报酬。  </p>
<p>当时有一位作家说，文士不怕刑罚，不爱晋升，也不贪生怕死，只怕欧阳修的意见。欧阳修对一位同事说，“读苏东坡的信，我全身喜极流汗。我应当退隐，使这个青年出人头地。”想想这句话对苏东坡有多大的影响!  </p>
<p>日月何促促， 尘世苦局束。  </p>
<p>我简直想说，苏东坡的精神代表“火”，他一生和水灾、旱灾奋斗，每到一地就忙着修建供水系统、水运系统和水井。火的象征很恰当，因为他活力充沛；换句话说，他的脾气和一生都象烈焰，到处给人生机和温暖，也一路烧毁了某些东西。</p>
<p><em>我没有懂作者这里说的烧毁的是什么东西</em>  </p>
<p>人生到处知何似， 应似飞鸿踏雪泥， 泥上偶然留指爪， 鸿飞那复计东西。 这是东坡的佳作之一，飞鸿象征人类的精神。事实上这本书所写的苏东坡生来事略只是一个伟大心灵偶尔留下的足迹，真正的苏东坡是一个幻鸟般的灵魂，说不定今天还在星宿间梦游呢。  </p>
<p>她要他当心那些表现太露骨的泛泛之交，以及他根据“世间无恶人”理论而交上的朋友。他的麻烦就出在这儿；他无法看出别人的错处。他太太对他说：“当心那些朋友。太快建立的友情不会长久的。”东坡承认，她的话总是应验，我想她这方面的智慧是来自中国<strong>“君子之交淡如水”的古训——没有令人兴奋的味道，却永远不会生厌。</strong>诚挚的友情从来不表现太多。真正的好友不常写信，因为全心信任彼此的友谊，根本不必写。分别几年又重逢，友情依然如故。   </p>
<p>坑上架着一个小木板桥，百英尺下有激流飞过，四周是直立的峡谷。章惇自己很勇敢，对苏轼一鞠躬，他走过木板桥，在对面峭壁上留几个字。苏东坡拒绝了，章惇独自过桥，泰然自若。他拢拢长袍，抓住一根吊索，沿峭壁到溪流对岸写了六个字：“苏轼章惇来游”。然后若无其事走回来。苏东坡拍拍朋友的背说，“有一天你会杀人。” “为什么？”章惇问道。 苏东坡答道，“能将自己性命玩弄于股掌之上，也就能杀人。”苏东坡的预言到底对不对，我们以后就知道了。  </p>
<p>这不是中国第一次试行国家资本主义，却是最后的一次。在中国四千年的历史中，曾四度试行极权主义、国家资本主义、社会主义，以及剧烈的社会革命，每一次都惨败而终。最成功的是法家商鞍的右派极权主义，他的理论由兴建长城的秦始皇（公元前三世纪）有效推行。早期法家理论最重要的两大原则就是教战与重农。两者其实是同一回事，因为商鞍相信农夫是最好的军人，所有中产阶级的商人和贸易家都该尽量受到压制。大家都知道，根据这一教条而建立发展的强大军事系统使秦国统一了全中国；但是此一政治理论刚遍行全国，不到几年就完全崩溃。  </p>
<p>王安石的怪习惯是不是伪装，我们无法断定；<strong>不过一个人的行为如果太过份，大家难免怀疑他有自我宣传的意味。</strong>  </p>
<p>王安石说，他宁愿谈谈尧舜的贤臣。“在上等人才眼中，诸葛亮根本不值得一提。” 诸葛亮的政治天才在于一步步走向既定的目标，这位急功自信的财政鬼才觉得很不对胃口。  </p>
<p>好官知道这些贷款对人民不利，确定他们付不出本利会下狱坐牢。他们遵守政府的明文规定，宣布贷款完全出于“自愿”，心中打算有一天会因“阻碍新政”而丢官。  </p>
<p>王安石认为，控制文人的思想更属必要。他和古代的王莽，近代的希特勒一样，具有“一个国家、一个信仰、一个领袖”的信念〔他像希特勒，遭到反对就大发雷霆；现代精神病学家可以把他列为妄想狂。  </p>
<p>无论古今中外，人民爱不爱某一政权唯有等这个专制政府失势才能判断。  </p>
<p>郑侠终日站在宫门边，看到成群难民由东北逃来，挤满京师的街道。郑侠知道图画比言辞更有力，就把这些可怜的农民画下来，献给皇上。有一张画描写难民饥寒交迫，在大风雨中流浪。另一张描写半裸的男女正在吃草根树皮，还有人拴着铁链搬砖负柴来缴税。皇帝看到这些图画，不禁掉下泪来，精采的献图——我们以后会谈到——加上一颗彗星出现。圣山发生土崩，皇帝终于废除了许多“新法”。  </p>
<p>司马光学问和品德都冠绝当代，从头到尾为原则而争。他和王安石代表相反的政策立场。  </p>
<p>过了两个月老相富弼辞职，临行警告说，<strong>治斗争总是好人输，奸小一定会爬到高位。因为好人争原则，坏人争权利，最后双方都各得其所，好人去职，坏人留下来。</strong>他预言这样下去国家不久就会陷入纷乱。</p>
<p>苏东坡的九千字“上皇帝书”非常重要，可以代表他的政治哲学，也显出他个人的脾气和文风，充满机智、学问和大无畏的勇气。义愤的争论夹着冷静、简明的推理。有时候沮丧、严苛、挑剔、直爽无比；有时候却徐徐辩论，引经（孔孟）据典，引史例来支持他的理论。内容巧妙、诚挚、有力，对世事满怀激动和悲哀。  </p>
<p>苏东坡认为，好政府要靠异议的健全作用来维持。民主就根据各党异议的原则而存在。我相信苏东坡若生在现代，一定反对联合国安理会的否决权，认为不民主。他知道盘古开天以来，没有两个人看法完全一样，除了民主就是专制。我从来没有发现一个反对民主的人在家、在国、在世界政局上不是暴君。  </p>
<p>若使言无不同，意无不合，更唱迭和，何者非贤。  </p>
<p>孔子曾说，人应该“驱郑声，远佞人”。有一天王安石和惠卿谈话，他弟弟安国在外面吹笛子。宰相对弟弟大叫说，“你能不能驱郑声？”他弟弟回答说，“你能不能远佞人？”  </p>
<p>两兄弟政治观点始终相同，立场也一致，但是性格却完全不一样。子由性安稳，实事求是，保守，不爱多说话；东坡性豪放，开朗，多嘴多舌，天真而不计一切后果。朋友同伴都觉得子由很可靠，东坡开朗的天才，他的嘲弄和恶作剧却常常使人害怕。  </p>
<p>苏东坡最大的缺点就是喜欢在宾客面前或者作品中坦白说出他的想法，十分不利。子由十分了解他的哥哥。子由把手放在他的嘴上，叫他从此沉默些，后来东坡出狱，子由也曾做过同样的暗示。  </p>
<p>风中飞蓬正是苏东坡一生最好的象征，从此他就成为政治风暴中的海燕，直到老死从未在一个地方住过三年以上。  </p>
<p>这里是他的第二故乡，不只因为此地有美丽的山丘、森林、湖泊、大海、热闹的市街和壮观的寺庙，也因为当地人民都很喜欢他，他度过了这一生中最幸福的日子。居民有南方人快乐的天性，有诗歌有美人，他们敬爱这位年轻的名诗人，欣赏他冲动、热情和无忧无虑的个性。美景启发了他的灵感，此外柔婉的魅力更抚慰了他的心灵。杭州赢得他的青睐，他也赢得杭州人民的爱戴。他担任杭州通判（助理官员），没有机会为人民多尽力，但是诗人的身份已经足够了；他被捕的时候，杭州人纷纷在街上设龛拜祭，替他解灾。他走了以后，南国的美景和温情一直令他魂牵梦系。他知道他会回来，十八年后他再度回来当太守，对本城建树极多，在杭州人心目中留下了不朽的回忆，大家都说他是杭州人。在他死后千年的今天。你走上西湖，登上孤山岛或凤山，或者在湖滨的一家饭店喝茶，你会听到杭州本籍的店主一再提到“苏东坡——苏东坡。”你若点明东坡是四川人，他可不高兴。咦，他认为苏东坡生在那儿，除了京师从来没到过别的地方哩!  </p>
<p>苏东坡几乎相信他前生曾住在这儿。他自己的诗词和同代人的杂记都有记载。有一天他拜访寿星院，一进大门就觉得景物很熟悉。他告诉同伴，他知道有九十二级石阶通向忏堂。结果完全正确。他还向同伴描述后殿的建筑、庭院和木石。我们不必相信这些转生的故事，不过社会若相信神鬼和轮回，总有很多这一类的说法，就象鬼故事，没有人能证明是真是假。  </p>
<p>游这些山往往要一整天，他常在傍晚回来，街灯都亮了。穿过灯火通明、人潮汹涌的小河塘夜市，他往往半醉才回家，想起一些诗句然后又忘掉一些： 睡眼忽惊矍， 繁灯闹河塘。 <strong>市人拍手笑， 状如失林莺。</strong> 始悟山野姿， 异趣难自强。 人生安为笑， 吾策殊未良。  </p>
<p>这些家船都精雕细琢，船头有笕嘴。湖上还有其它船只专卖食品给游客。有人卖栗子、瓜子、莲藕、甜食、炸鸡和海鲜。有人专供茶水。有些船上载着艺人，照例贴近游客的小船，为大家表演歌唱、杂耍，并供应吊索和其他射猎的游戏。他们身边就是澄蓝的湖水，周长十英里左右。远处白云栖在山顶上，山峰若隐若现。云霞使山峰千变万化，多采多姿，山峰给云霞一个栖息的所在。有时候天冷欲雪，雾气盖满山脚。隔着雾气，游人可以看见零零落落的的亭台楼阁，瞥见远山模糊的棱线。睛天湖水清爽极了，水中鱼儿历历可数，苏东坡曾以两行愉快的诗句描写船夫的黄头巾与青山的背景相映照，画面十分动人： 映山黄帽螭头舫， 夹道青烟鹊尾炉。  </p>
<p>他常常借一张和尚的躺椅，搬到附近竹林中；完全卸下官吏的尊严，脱下衣衫，赤身露体睡午觉。小和尚用敬畏的眼光偷看这位大学者，看到了别人无权一窥的场向。他看见——也许是自以为看见——苏东坡背上有七粒黑痣，排列的方位很象北斗七星。老和尚说，可见他是天廷派下来的神灵，暂时在人间作客而已  </p>
<p><strong>苏东坡眼中感官的生活和灵性的生活是同一回事，以诗意哲学化的人生观看来并没有什么冲突。有了诗，他热爱今生，不可能变成禁欲的和尚。有了哲学，他十分明智，也不会沉沦在“魔鬼”手中。他不会弃绝青山绿水，也不会弃绝美人、诗歌和酒肉。但是他有深度，不可能披上纨绔子弟肤浅、愤世嫉俗的外衣。</strong>  </p>
<p>苏东坡身为通判，有一次曾裁决一件与和尚有关的案子。灵隐寺有一位和尚名叫了然，常到红灯区走动，爱上一个名叫秀奴的少女。后来他床头金尽，衣衫槛楼，秀奴就不肯见他了。有一天晚上他喝醉酒又去找那个女孩，吃了闭门羹，就强闯进去，将她打死。于是他被控杀人。官吏审问他，发现他臂上刺了两行诗：“但愿生同极乐国，免教今世苦相思。”调查完毕，证物送到苏东坡手中。苏东坡忍不住写下这一首词： 这个秃奴，修行忒煞，云山顶上空持戒。只因迷恋玉楼人，鹑衣百结浑无奈。 毒手伤心，花容粉碎，色空空色今安在，臂间刺道苦相思，这回还了相思债。 和尚被送到刑场处决。  </p>
<p>苏太太聪明贤慧，不想用错方法，把丈夫逼到妓女怀中。此外她知道她丈夫是一个妻子或皇帝都无法阻挡的人，她采取明智的作风——充分信任他。  </p>
<p>苏东坡个性复杂多变，很难了解。他是大哲学家，不可能变成清教徒，但他又是儒家子弟，不可能变成酒鬼。<strong>他了解生命，珍惜生命，不会把时光完全浪费在醇酒美人身上。他是自然诗人，怀有特殊健全的神秘人生观，往往和自然的了解密切融合。我相信任何一个人和自然、四季、雨、雪、山、谷那么接近，接受它的治疗，一定不会心思闭塞，具有封闭的人生观。</strong>  </p>
<p>这是苏东坡最沮丧的时期，说也奇怪，诗人最悲哀的时候却写出了最好的作品。照中国的标准，他在这段期间达到诗词的成熟期。愤怒与尖酸都过去了，只留下满心安详与去意。  </p>
<p>韩琦和欧阳修已逝。富弼和范镇辞官归隐。司马光潜心著作。张方平沉迷酒杯，东坡的弟弟明哲保身，一句话也不说。东坡不够圆滑。<strong>一个人亲眼看到百性受苦，这只是该不该忘掉一切后果表达心中感慨的问题。也许他从来没有考虑过。</strong>  </p>
<p><strong>现在苏东坡很受欢迎，不仅因为他对抗洪水成功，也因为他亲身关切狱囚的健康和利益，当时很少太守这么做。他亲自去看犯人，第一次派狱医照顾病患。苏东坡指出，法律虽禁止地方官鞭死囚犯，对囚犯病死或失于照顾而死，却没有明文规定。囚犯也是百姓。他遂赢得囚犯亲友的感激。</strong>  </p>
<p><em>每一个人都是平等的。</em>  </p>
<p>套一句苏东坡自己的话，他始终如蝇在食，吐之乃已，到目前为止还平安无事。但是他“吐”一百次，终于被捉了。  </p>
<p>苏东坡笑着对他们说了一个故事： 真宗时代，皇帝四处探访隐居的大学者，有人推荐杨朴。杨朴不愿入京，却被押到朝中见皇帝。 “听说你会写诗”皇帝说。 “不，我不会。”杨朴想掩饰自己的才华，不愿从政。 “朋友们送你出来，有没有人写诗给你？”皇帝又问。 “没有，”杨朴说，“只有臣妻写了一首。” “请问诗中写什么？”陛下问他。 于是杨朴把妻子送行的诗念给皇帝听。全诗如下： 更休落魄贪酒杯， 且莫猖狂爱咏诗。 今日捉将官里去， 这回断送老头皮。 苏太太听到这个故事，热泪盈眶，却忍不住笑出来。这个故事出现在东坡的笔记中，不知道是不是他临时杜撰的。  </p>
<p><em>幽默</em>  </p>
<p>外在的工作与责任隐藏了一个人的本性。去掉这些时势和传统的陷阱，真我就出现了。<strong>苏东坡回到百姓群中，有如水里的海豹；在陆地上摇鳍摆尾的海豹只是半只海豹而已。</strong>  </p>
<p>解放的生活使他的心灵产生蜕变，又反映到作品中。刻薄的讽刺、尖锐的笔锋、一切激情与愤怒都过去了，代之而起的是光辉、温暖、亲切、宽容的幽默感，绝对醇美，完全成熟。<strong>哲学的价值就是教人笑自己。就我所知，动物只有猩猩会笑，但是我相信只有人才会笑自己。</strong>不知道这能不能称为神祗的笑容。希腊诸神充满人性的错误和缺点，他们一定常常有机会自嘲一番；但是基督教的上帝或天使太完美了，不可能这样做。把这种自嘲的特色称为堕落人类独一的美德，该算是一大恭维吧。  </p>
<p>任何情况下，幸福都是一种秘密。但是研究苏东坡的作品，就不难探出他幸福的奥秘了。   这位慷慨的天才对世人的贡献远超过他从世上收取的一切，他到处捕捉诗意的片刻，化为永恒，使我们大家都充实不少。  </p>
<p>归去来兮，吾归何处……人生底事，来往如梭，待闲看秋风，洛水清波，好在堂前细柳，应念我莫剪柔柯。仍传语江南父老，时与晒鱼蓑。  </p>
<p><strong>到了南京，苏东坡去看王安石，后者现在已是疲惫的病老头了。他们一起谈诗论佛。双方都是大诗人，佛家弟子，有不少话可说。传说有一次两人比诗，同韵同题，苏东坡赢了。王安石中途放弃。谈话中苏东坡不免责备王安石招来战祸，迫害学者。</strong>  </p>
<p>事实上，奢华的日子和简朴的日子在幸福方面倒没有什么差别。只有不配作高官的人才羡慕高官的荣宠。通常不想作官的人为当局一心争取，想作官的人却又不够资格。一旦“官愿”满足了，做大官的乐趣不见得胜过成功的铁匠。  </p>
<p>乐事可慕，苦事可畏，皆是未至时心尔。及苦乐既至，以身履之。求畏慕者初不可得况，既过之后复有何物。  </p>
<p>当时的知识分子只有两条路可走，不是做官就是自甘淡泊——淡泊通常代表贫穷。当然人可以以潜心学术，得到永远的声名；但是对许多人来说，不朽的声名就算有把握，也只是空腹的自我安慰罢了。  </p>
<p>这些年来苏东坡不断在策论中说，“独立思考”和“公正无私”是好大臣的重要条件。但是独立思考和意见公正却是党人最讨厌的。  </p>
<p><strong>诗、书、画最主要的材料就是两种液体：酒和墨；他们有上好美酒，上好名墨，还有最好的毛笔和最珍贵的纸张。</strong>  </p>
<p>把中国书法当做一种抽象画，也许最能解释其中的特性。中国书法和抽象画的问题其实非常相似。判断中国书法的好坏，批评家完全不管文字的意思，只把它视为抽象的构图。它是抽象画，因为它并不描绘任何可辨的物体，与一般绘画不同。中国字是由线条所构成，线条组合千变万化，书法就是把这些字完美凑出来，而且要和同一行、同一页的其它字体相配合。中国字是由最复杂的成份所构成，不免呈现一切构图的问题，包括轴线、轮廓、组织、对比、平衡、比例等等，尤其注重整体的统一概念。 一切艺术的问题都是节奏的问题，无论绘画、雕刻或音乐都是一样。既然美感就是动感，每一种形式都有隐含的韵律。就连建筑方面亦然，哥德式的教堂仿佛在沉思。美学上甚至可以用“冲”、“扫”、“粗鲁”等人格的形容词，这些都是韵律的观念。  </p>
<p>这种动作的韵律美观念改变了一切技术家对线条、质量、表面、构图和材料的看法。若属于力学而非静态的美，一切全是平衡的直线画，像工程师的蓝图一般，那就不值得考虑了。相反的艺术家必须寻找扭曲不平的树枝线条，只因为弯曲扭转才能显出生命和运动。这种不平均的线条我们很容易看出生命和动作，其中敏感的压力、休止和扫动以及树枝偶然的哗啦声都仔细保存下来。国画和书法可以说有一项基本原则，除非必要——譬如画书桌和茶几——千万别用均衡的线条。构图的概念也变了。中国艺术家绝不以静态的安排、线面的对比为满足，因为这些线面都是死的。画家因此强调活线条，这是国画技巧和其它绘画的一大差别。  </p>
<p>为了培养活线条的基础，书法家便回头观察大自然。自然的线条总让人想起动作，变化永无止尽。善跑的灵堤猎犬结实光滑，自有一种美姿；而爱尔兰小诜多毛矮胖，又另是一番风味。我们可以欣赏小鹿的灵巧，同时又爱慕狮掌强大的肌力。小鹿身材优美，不仅因为轮廓匀称，也因为它让人想起跳跃的动作，狮掌优美则因为让人想起飞扑，就是这种飞扑和跳跃的功能使线条具有活生生的协调感。若追求这种韵律美，我们可以欣赏大象庞然的身躯，小蛇扭曲的张力，甚至长颈鹿枯瘦笨拙的动作。所以自然的韵律永远充满机能，只因为线条和轮廓都是生长过程的结果，具有一定的作用。借自然丰富的韵律，才能极度锻炼我们的鉴赏眼光。中国书法家挥笔时想模仿的就是这种自然的律动，也只有最敏感的画笔才能模摹出来。有些笔触稳定而圆熟，令人想起狮掌的威力；有些令人想起马足的肌力，节骨分明。有些想表现明快的清爽感，字体有肩、有腰、有支架，正如完美的女性，或者像中国批评家所说的“如美人鬓带鲜花”。有些想效法枯藤难摹的雅姿，末端形成温文安定的小卷，用几片细叶加以平衡。别忘枯藤的平衡最完美，因为末端弯曲的角度和形状要看藤蔓整个的重量——茎株的支持点和残叶在哪一边而定。  </p>
<p>在八大山人的鱼鸟或石涛的兰花中也许更能看出印象派艺术的极端例证。无论画鱼画鸡画鸟，八大山人的画可以说是用最少线条、最少墨汁来表现最多的韵味。大艺术家只花几分钟，迅速泼墨完成一张鱼、马或人像图；不是成功就是失败，万一失败他就把纸条揉成一团，丢入字纸篓中，从头来起。  </p>
<p>我前面已说过，在位党和反对党也没有明确的权责。多数党统治的机能并不存在。于是政治游戏便成为个人之间的斗争，比西方更剧烈。<strong>但是东西方的政治规则完全一样：爬到顶端的一定是庸才。</strong>  </p>
<p>第一，好政客要会说一大堆话，却不透露任何消息。好官决不肯定什么，只用否定。只要学会“无可奉告”、“你说得对”等至理名言，好官就可以无往而不利。第二、他应该施惠于朋友。第三、他应该小心不得罪人。一个人如果不随便说话，爱用文雅、细柔、愉快的低语，又很喜欢施小惠给人家，他就算不位极人臣，也不会失势。他到死都有官做。  </p>
<p>苏东坡逃避政治，政治却在追逐他。他和司马光政见不合——<strong>独立的心灵永远不会完全一致</strong>——但是他到京师半年，司马光就去世了。苏东坡陷入显赫遭忌的地位。  </p>
<p>他维护意见不一的原则。信中指出，<strong>“若上之所可，不问其是非，下亦可之。上之所否，不问其曲直，下亦否之”</strong>，对国家并没有好处。君主和大臣应该互相提供意见，如果百官唯唯诺诺，就变成孔子所谓“足以丧邦”的跟屁虫了。  </p>
<p>当时政府最大的间题——中国每一朝代都是如此——就是冗官充斥。文人太多，官位太少，在“学而优则仕”的中国社会成为经常存在的弊端。除非现在能改变此一观念，否则教育普及就能把国家拖垮。我们要如何提供四亿五千万知识分子的官位呢？如果公职制度严格遵行，用人惟才，则考中的人数自然有限，素质也会提高。但是苏东坡时代已盛行亲族主义。  </p>
<p>事实上他已决心离开朝廷。他说君子如麟凤难求，小人<strong>“易进如蛆蝇，腥膻所聚，瞬息千万”</strong>。  </p>
<p>“聚蚊成雷，积羽成舟，寡不胜众也”。  </p>
<p>苏东坡对于这种零碎、没有组织的救病工作并不满意，他由政府基金拨出两千缗，自己又捐了五十两金子，在城中心众安桥建了一座公立医院。就我所知，这个“安乐坊”是中国最早的公立医院。三年内曾医过一千个病人，主管医院的道士由政府赠以紫袍和金钱。后来医院搬到湖边，改名“安济坊”，苏东坡离开后还继续看病。  </p>
<p>太后死前十天，范纯仁和苏子由等六位大臣进去看她。 “我大概无法复原了，”太后说，“不能长期看着你们。你们要尽力侍候小皇帝。” 大臣即将告退，太后指名要范纯仁留下来。于是哲宗叫别人退开，只剩范纯仁和吕大防。 朝中传闻太后谋反，要立自己的儿子为帝，太后问道，“皇上年幼，神宗托老身治国。九年里你们可曾看我特别照顾高家？” “没有，”吕大防说，“太后未曾厚待娘家，一切以邦国为重。” “正是如此，”太后含泪说，“所以老身临死才见不到自己的儿子和女儿。”她并没有派儿子在京师做官。 “太后必能康复，”吕大防说，“请听医生的劝告。您现在不该说这些事情。” “不，”太后说，“今天当你们的面，我要对皇上说几句话。我知道我死后很多大臣会愚弄他。孙子，你该当心。”她转向吕大防和范纯仁说：“我觉得老身死后，你们还是辞官归隐吧，小皇帝会用新人。” 她问侍从宫中有没有请大臣吃饭，她对吕大防和范纯仁说：“现在去用餐吧。明年此日，请记得老身。”  </p>
<p>一个王朝的悲剧在于皇后们有必要接连生出善良、聪明、能干的儿子、孙子和曾孙，皇室才能长保权位——这是生物学上人类从来没有听过的不保险假设。天才不生天才，迟早贤明的君主会生出邪恶、昏庸的后代。  </p>
<p>中国历史上若有一个时期可以称得上残暴与混乱的时代，那就是蔡京手下的政府了。他替皇帝建设精美的乐园，在中国历史中写下最可怕的一页，因为皇家乐园也用不着国人付出那么多悲惨的代价呀。园中每一块异石，每一朵奇花都曾牺牲几条人命。读到徽宗和大臣们赞美这个花园、假山、清溪、异石的诗句，我们不禁脊骨发冷，感受到中国文学史上从未有过的悲剧。悲剧在于作者并不知道这些。  </p>
<p>章惇劝皇帝挖司马光的坟墓，打烂棺材，鞭尸示众，以警告所有不忠的臣民。在小皇帝心目中，司马光变成元祐时代奸诈、不忠、邪恶的象征。上朝的时候大家都表示赞成，只有许将不说话。小皇帝打量他，退朝后叫他留下来。  </p>
<p>他转念一想：<strong>“此间有什么歇不得处。由是心若挂钩之鱼忽得解脱。若人悟此，当恁么时也不妨熟歇。”</strong>  </p>
<p>他又恢复了自然的本性。他在广州曾买了一些檀香，现在他常关门静坐，享受奇特的异香，反省自己以往的错误。有时午后小睡一回，凉爽的江风吹进窗口，房顶的鸟鸦打断他的幽梦，他突然觉得自己卸下一切责任。他看到大江的光影射入他房中。真美，他暗自说，美得像清空的明月。他不懂为什么有人喜欢云中的翳月。他觉得晴空是光明磊落的象征。  </p>
<p>苏东坡写过一篇酒颂。就是不解杯中乐趣的人读到他描写半痴半醉的幸福状态也会为之入迷： “浊醪有妙理赋 酒勿嫌浊，人当取醇。失忧心于昨梦，信妙理之疑神……仔人之生，以酒为命。常因既醉之适，人识此心之正。稻米无知，岂解穷理。麴栗有毒，安能发性，乃知神物之自然，盖与天工而相并。得时行道，我则师齐相之饮醇。远害全身，我则学徐公之中圣。湛若秋露，穆如春风。疑宿云之解驳，漏朝日之暾红。初体栗之失去，旋眼花之扫空……兀尔坐忘，浩然天纵。如如不动而体无碍，了了常知而心不用。座中客满。惟忧百種之空。身后名轻，但觉一杯之重。今夫明月之珠，不可以襦，夜光之璧，不可以哺。刍肉饱我而不我觉，布帛袄我而不我娱。惟此君独游万物之表，盖天下不可一日而无。在醉常醒，孰是狂人之乐。得意忘味，始知至道之腴。”  </p>
<p>她是虔诚的佛教徒，临死还念着《金刚经》的一道偈/jié/语： <strong>一切有为法， 如梦幻泡影。 如露亦如电， 应作如是观。</strong> 根据她的遗嘱，苏东坡将她安葬在城西丰湖边的山脚上，靠近一座亭台和几间佛寺。墓后有山溪瀑布流入湖中。  </p>
<p>玉骨那愁瘴雾，冰肌自有仙风。海仙时遣探花丛，倒挂绿毛么凤。 素面常嫌粉污，洗妆不退唇红。高情已逐晓云空，不与梨花同梦。  </p>
<p>苏东坡自以为晚年可以定居惠州，没想到突然被贬到海外。新居落成两个月，移居海南岛的命令就来了。有人记载说，他写了两行诗描述他在春风中小睡，聆听屋后庙院钟声的情景。章惇读到这段诗，就说：“原来苏东坡那么惬意。”于是颁布了移居的命令。  </p>
<p>但是他不屈的灵魂和人生观不容许他失去生活的乐趣：“尚有此身付与造物者，听其运转流行坎止无不可者。故人知之，免忧热。”他写信给一位朋友说。  </p>
<p>“吾始至南海，环视天水无际，凄然伤之曰‘何时得出此岛也’。已而思之：天地在积水中，九洲在大浪海中，中国在少海中。有生孰不在岛者。譬如注水于地，小草浮其上，一蚁抱草叶求活，已而水干，遇他蚁而泣日‘不意尚能相见尔’。小蚁岂知瞬间竟得全哉？思及此事甚妙。与诸友人小饮后记之。” 苏东坡也许是倔强，也许是真的掌握了自己。至少他从未失去幽默感。  </p>
<p>苏东坡曾经对他弟弟说：“我上可以陪玉皇大帝，下可陪卑田院乞儿。在我眼中天下没有一个不是好人。”现在他和默默无闻的穷学者、农夫农妇交往。他和这些纯朴小民谈话不必有戒心，自由自在，最能表现自己。家里一天没有客人他就不自在，别人不来他就出去拜访邻居。和黄州时期一样，他与高官、平民、学者、农夫杂处。聊天总是他发言；他天生爱说话。但是他也希望别人开口。他带着海南种的大犬“乌嘴”到处闲逛。他和村民坐在槟榔树下，想畅谈一番。无知的穷农夫能对他说什么呢？农夫对这位大学者敬畏万分，“我们不知道要谈什么。”苏东坡说：“那就谈鬼吧，说几个鬼故事来听听。”对方会说他们没听过什么好的鬼故事，他说：“没关系，就谈你们听过的好了。”后来苏过告诉朋友，他父亲如果一天没看到客人，就好像有什么不对劲似的。  </p>
<p>小屋完成后的两年半期间，苏东坡过着无忧无虑却十分贫穷的生活。他有两位妙友，一个是替他转信的广州道士何德顺，另一位是四处游荡，送他食物、药物、米、泡菜、书本的小学者（吴复古）。  </p>
<p>他写了不少有关药草的笔记，我要特别谈谈荨麻治风湿的办法，荨麻含有荨麻素和黄体素，像毒藤似的，碰到皮肤就会肿痛。照他的说法，把荨麻敷在风湿起始的肿痛关节上，全身各处的酸痛都会停止。他还热烈信仰苍耳。苍耳到处都有，对人无害，不管吃多久怎么吃都可以（含有脂肪，少量树胶、维他命C1和耳醣）。他写下苍耳白粉碾制的办法，把叶灰用温火烧二十四小时就成了。白粉吃下去据说可以美化皮肤，“满肌如玉’。有些笔记谈到蔓菁、芦菔和苦荠，苏东坡称为‘葛天氏之遗民”的美食，价值高，味道又好吃。  </p>
<p>他请子由写序，在一封信中说：“然吾于渊明，岂独好其诗也哉。如其为人，实有感焉。”很多崇拜苏东坡的人也会这样说。  </p>
<p><strong>徽宗继位时，国家的命脉已经腐蚀削弱。有个性、有才华、有正义感的君子是文明社会的珍贵产物，需要长时间培养茁壮。司马光、欧阳修、范纯仁、吕公著的时代过去了，那一代的人已经分别下狱、流放、病死、老死或被杀。独立批评，勇敢思考写作的气氛已经僵化，整个政治生命都污染了。苏东坡师徒因言论而受罪，不愿意再入政坛，何况政风又对他们不利。皇帝一声命令，不可能马上有一群正直、博学、大无畏的学者出现朝中。己尝了八年权力滋味的大批政客更不可能放弃权位。</strong>  </p>
<p>显然神宗皇后和她婆婆一样，善于感受国家的利益，她们具有单纯的女性本能，会判断好人坏人。<strong>批评家和历史家迷恋优美的文辞和抽象的特征，善于研究某一时期深奥的问题和政策，却忘记我们看人最后总逃不过“好”、“坏”这两个形容词。总括一个人的事迹和个性，“好人”就是最高的赞美。苏东坡服侍的太后们似乎从来不管政府领袖的问题和政策。当然章惇是一个坚强果断的人。惠卿是雄辩家。蔡京生气勃勃、精明能干。但太后一概把他们归类成坏人。</strong>  </p>
<p>他本来想等福建大船，苦等不来，就随吴复古、苏过和爱犬（乌嘴）渡海，一行人到雷州去找秦观。吴复古又失去踪影。苏东坡和吴复古一生游遍全中国，不同的是苏东坡被别人的命令赶来赶去，吴复古却是自愿飘泊。追忆往事，苏东坡似乎恨不能和他的朋友交换际遇。那样一定快乐得多，也自由得多。  </p>
<p>他在广州受到热诚的招待。他到海南岛第二年，有人传说他死了。有一位朋友在宴席上开玩笑说： “我以为你死了。” 苏东坡说：“不错，我死了，在地府半路上碰到章惇，我又决定折回来。”  </p>
<p>大家庭有不少小孩和年轻的妇女，他们就乘船到南雄。<strong>没走多远，吴复古和一群和尚追上他们，陪老苏畅游了几天。然后吴复古突然病倒去世，一切都那么简单。苏东坡问他临终有什么交代。吴复古笑笑合上了眼睛。</strong>  </p>
<p>苏东坡最初和最终的乐趣都是写作。他把自己在南方所写的诗文拿给钱世雄看，眼睛闪闪发光，似乎忘记了一切。有时候他还能写短简和题跋，其中包括一篇桂酒颂，他知道好友会仔细珍藏，就把这篇文章送给钱世雄。  </p>
<p><strong>苏东坡缓缓低语：“西天也许存在，不过设法到那儿也没有用。”钱世雄站在旁边，就对他说：“尤其这个时候，你一定要试试看。”苏东坡最后一句话是“试就不对了”。那就是他的道家哲学，解脱在于自然而不自觉的善行。</strong>  </p>
<p>由尘世的标准来说，苏东坡的一生相当坎坷不幸。有一次孔子的门生问起两个为信念而饿死的古圣人。门生问孔子，伯夷叔齐死前有没有悔意。孔子说：“他们求仁而得仁，为什么要后悔呢？” 苏东坡今生的“浩然之气”己经用光。人生不过是性灵的生活，而性灵是控制人类事迹和个性的力量，与生俱来，只能靠生命和际遇和环境来表现。正如苏东坡的描写：<strong>“浩然之气不依形而立，不恃力而行，不待生而存，不随生而亡矣。故在天为星辰，在地为河岳，幽则为鬼神，而明则复为人。此理之常，无足怪者。”</strong>  </p>
<p><strong>读到苏东坡的生平，我们等于追察人类心智和性灵暂时显现在地球上的生命。苏东坡死了，他的名字只是一段回忆，但是他却为我们留下了他灵魂的欢欣和心智的乐趣，这些都是不可磨灭的宝藏。</strong></p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>苏东坡</tag>
      </tags>
  </entry>
  <entry>
    <title>《祭亡妻程氏文》 苏洵</title>
    <url>/202002/%E7%A5%AD%E4%BA%A1%E5%A6%BB%E7%A8%8B%E6%B0%8F%E6%96%87/</url>
    <content><![CDATA[<p>与子相好，相期百年。不知中道，弃我而先。</p>
<p>东坡刚考中准备做官的时候，他的母亲去世了，她临死还没有听到京师的好消息。《苏东坡传》中林语堂先生引了苏洵的《祭亡妻程氏文》的一段话：“我归旧庐，无不改移。魂兮未泯，不日来归。”</p>
<p>昨晚读到这里的时候有被触动。今天去找来了原文查词典把文章理顺了。</p>
<p>呜呼！与子相好，相期百年，不知中道，弃我而先。  </p>
<p>我徂京师，不远当还；嗟子之去，曾不须臾。子去不返，我怀永哀。反复求思，意子复回。  </p>
<p>人亦有言，死生短长，苟皆不欲，尔避谁当，我独悲子。  </p>
<p>生逢百殃，有子六人，今谁在堂？唯轼与辙，仅存不亡。咻呴抚摩，既冠既昏，教以学问，畏其无闻。昼夜孜孜，孰知子勤？  </p>
<p>提携东去，出门迟迟。今往不捷，后何以归？二子告我，母氏劳苦，今不汲汲，奈后将悔。大寒酷热，崎岖在外。亦既荐名，试于南宫。文字炜炜，叹惊群公。二子喜跃，我知母心，非官实好，要以文称。  </p>
<p>我今西归，有以藉口。故乡千里，期母寿考。归来空堂，哭不见人。伤心故物，感涕殷勤。  </p>
<p>嗟予老矣，四海一身。自子之逝，内失良朋。孤居终日，有过谁箴？  </p>
<p>昔予少年，游荡不学，子虽不言，耿耿不乐。我知子心，忧我泯没，感叹折节，以至今日！ 呜呼死矣！不可再得。  </p>
<p>安镇之乡，里名可龙，隶武阳县，在州北东。有蟠其丘，惟子之坟。凿为二室，期与子同。骨肉归土，魂无不之。我归旧庐，无不改移。魂兮未泯，不日来归。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
  </entry>
  <entry>
    <title>《极简欧洲史》读书笔记</title>
    <url>/202002/%E6%9E%81%E7%AE%80%E6%AC%A7%E6%B4%B2%E5%8F%B2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/11/EG6KiIgvJp5sq4m.png" alt=""></p>
<p>从2019年年底到2020年年初我一直在读的这本书——《极简欧洲史》，我应该不会向身边的人推荐这本书，因为这是一本比较枯燥的历史课本。唯一能让我对历史提起兴趣的描写性语言少之又少。在我读到大概三分之二的时候就想放弃，然而最后还是因为微职的读书小组坚持读下来了。这本书越往后节奏越快，到后面快要变成了流水账。不过通过这本书我也做了非常多的思考：像我这样对历史毫无兴趣的理科生还需不需要读历史？有没有更舒服的、更有趣地了解历史的方式？</p>
<span id="more"></span>
<blockquote>
<p>本书的内容原本是授课用的讲义，目的是让澳大利亚的大学生对欧洲历史有个初步的认识。但身为老师的我并不是从最前面开始，按部就班讲到最后。我的做法是先为学生很快地做个概论，再回头补充细节。<br>——《极简欧洲史》引言</p>
</blockquote>
<p>既然整本书都只是知识性的，那这本书的读书笔记应该是一份复习提纲。然而我并没有按照书的逻辑做摘录，而是仅仅把其中触动我的一些文字摘录了出来。现在回去看，这些摘录并不是关于“历史”的，而是关于“人”的。</p>
<blockquote>
<p>在雅典，死刑通常都是立刻执行，这次却往后推迟了，因为宗教庆典的关系。苏格拉底大可趁机潜逃，说不定那些官员还暗自希望他逃之夭夭，但他却拒绝逃跑。他问：“既然我不能永远活着，那又何必苟且偷生？活着不是目的，好好活着才是。我曾在雅典的法治下过着很好的生活，如今我已准备好接受惩罚。”直到最后一刻，他还是充满了哲学思辨。直到他的镣铐被取下，他还在发表高论，说痛苦和享乐只是一线之隔。<br>他被判处服毒芹汁自绝，必须在一日将尽时服下毒药，他的弟子求他晚点再喝，现在太阳还没下山呢！苏格拉底回复道，要是他这样偷生，自己看了都觉得荒谬，他平静地接过毒药一饮而尽，全无半点神伤，很快就药效发作而亡。</p>
<p>“他该受到什么报应，”鲁克丽丝说，“我交由你们决定。至于我，虽然失节非我之过，但我要接受自己的惩罚。失贞的女人应该得到什么报应，我绝不会首开避脱的先例。”话声甫落，她便从衣袍中掏出一把刀刺入心脏，应声倒下，就此香销玉殒。她的父亲和丈夫哀恸欲绝。两人只能呆立着无助地哭泣，但布鲁图斯拔出鲁克丽丝胸前染血的刀，举着它高喊：“我要对这位烈女的血发誓：在她被暴君蹧蹋之前，没有人比她更为贞洁，我也对上帝发誓，我要借助刀剑、烈火以及所有能让我更强大的东西，追捕骄傲者塔克文、邪恶的王后及其所有的子女，绝不让他们任何人再登上罗马的王座。”</p>
<p>拿破仑是启蒙运动之子，深信革命所揭橥的诸多原则，却不相信人民有权统治自己。自1789年之后，法国在这个志业上可说是节节落败，拿破仑的政见因此非常吸引人。他是独裁者中最有魅力的一个，他不准任何团体享有特权，所有国民一律得到平等对待，国家提供所有孩童受教育的机会，所有职务都要公开选才。他延揽各方人才进入政府，无论是保王派还是共和派，雅各宾恐怖政权的支持者还是反对者，完全不计较他们过去在革命中扮演的角色。他只交给他们一个使命：创立一个有理性、有秩序的政府体制。</p>
<p>你一定会喜欢这些平民百姓。他们很脏很臭，看来很不讨喜，因为他们一年到头无分寒暑地日夜操劳，形容憔悴、伤痕累累、营养不良、疾病缠身。那为什么你还会喜欢他们？<br>因为他们的命运很容易追踪；百年复百年，他们做的都是同样的事，几乎所有的人都在耕种。</p>
</blockquote>
<p>历史是枯燥的，但历史河流中的每个人都是鲜活的。我们可以通过面对死亡时平淡和毅然的苏格拉底去了解雅典的法庭；通过坚贞的鲁克莉丝了解罗马共和政体的开启；通过飒爽的拿破仑了解法国的革命。当我们从人的角度切入历史的时候，我们可以收获更多的共鸣。《中国的历史精神》里说“历史便即是人生”，因为历史确实是由无数的人生构成的。历史本身就是我们人生整个过往的经验。</p>
<p>当我发现人物对于历史的重要性之后，也明确了自己想要了解历史的一个更好的途径应该是人物传记。所以也从自己最喜欢的苏轼开始读《苏东坡传》，上一周的读书时间也比较开心，不仅仅是因为苏轼本身就是一个很有意思的人，林语堂的文风也比较轻松诙谐。苏轼身上的纯真相当感染人，也对我自己面对选择的态度有挺大的触动。希望这周能把《苏东坡传》读完吧。</p>
<p>以古为鉴，可知兴替；以人为鉴，可正德身。</p>
<div style="text-align:right">——唐太宗</div>


<!-- more -->]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>极简欧洲史</tag>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title>Price Suggestion Chanllenge</title>
    <url>/201911/Price_Suggestion_Chanllenge/</url>
    <content><![CDATA[<h2 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p>考虑到网上销售的产品数量，产品定价在规模上变得更加困难。服装有很强的季节性定价趋势，受品牌影响很大，而电子产品价格根据产品规格波动。如何根据以往信息进行合理定价，有效地帮助商家进行商品的销售是一个有意义的问题。</p>
<span id="more"></span>
<h3 id="分析目标"><a href="#分析目标" class="headerlink" title="分析目标"></a>分析目标</h3><p>通过给出的商品描述、商品类别和品牌信息，并结合训练数据中的商品价格来给新商品定价格。Eg ：<br><img src="image/1-1.png" alt=""></p>
<p>显然 <code>Versace</code> 的衣服价格上应该远高于美特斯邦威的衣服，并且在商品描述中，可以发现两者描述有细微差别。 </p>
<blockquote>
<p>本 project 旨在对文本信息进行分析，提取文本信息中重要信息，推导出和价格之间的潜在关系 </p>
</blockquote>
<h3 id="数据字段分析"><a href="#数据字段分析" class="headerlink" title="数据字段分析"></a>数据字段分析</h3><p><img src="image/1-2.png" alt=""></p>
<h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><ul>
<li><code>train.csv</code> 训练集 （含price）</li>
<li><code>test.csv</code> 测试集 (不含price) ; <code>label_test.csv</code> 测试集 中对应的 <code>price</code></li>
<li><code>f_test.csv</code> 最终的评价数据集 （不含 <code>price</code> ）</li>
</ul>
<h3 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h3><p>评价的使用的是 <code>Mean Squared Logarithmic Error</code>: 计算的方式如下</p>
<script type="math/tex; mode=display">MSLE = \cfrac{1}{n}\sum_{i=1}^n(log(p_i+1)-log(\alpha_i+1))^2</script><p>其中$n$代表测试集的样本数；$p_i$代表的是预测的商品价格值；$\alpha_i$代表实际的销售价格。</p>
<h3 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h3><p>提交的最后文件内容为：  </p>
<ul>
<li>最终代码文件（请写清楚使用了那些库，以及相应库的版本，可使用 <code>pip list</code> 命令查看版本，确保能顺利运行）</li>
<li>在 <code>f_test.csv</code>数据集上的结果</li>
<li>分析文档<br>请不要是简单的代码粘贴，加入分析过程<br>将你对于数据的理解记录下来，简单来说，缺失值处理这种基本操作<br>写出你的尝试的各种方法，为了解决rank太低的情况下分数太低<br>写一份同学负责哪一部分代码，每一部分没有区别，主要是为了给代码风格打分。  </li>
</ul>
<h3 id="提交结果文件格式"><a href="#提交结果文件格式" class="headerlink" title="提交结果文件格式"></a>提交结果文件格式</h3><ul>
<li>结果文件名为</li>
<li>提交格式<ul>
<li>第一行为 test_id \t price 的表头</li>
<li>接下来的每行为id \t predict_price</li>
</ul>
</li>
</ul>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p><em>这次实验难度很大，我们所有参考资料均在实验报告的末尾注明</em></p>
<h3 id="一、样例代码的学习"><a href="#一、样例代码的学习" class="headerlink" title="一、样例代码的学习"></a>一、样例代码的学习</h3><p>首先尝试了给出的样例代码，了解了解决这个问题的大致思路。解决这个价格预测问题的主要过程是：导入数据和数据探索、数据预处理、模型构建、价格预测和测评。</p>
<h4 id="导入数据和数据探索"><a href="#导入数据和数据探索" class="headerlink" title="导入数据和数据探索"></a>导入数据和数据探索</h4><p>导入数据和初步了解数据<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data = pd.read_csv(<span class="string">&#x27;../data/4/train.csv&#x27;</span>, sep=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">test_data = pd.read_csv(<span class="string">&#x27;../data/4/test.csv&#x27;</span>,sep=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">train_data.info()</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;</span><br><span class="line">RangeIndex: 300000 entries, 0 to 299999</span><br><span class="line">Data columns (total 8 columns):</span><br><span class="line">train_id             300000 non-null int64</span><br><span class="line">name                 300000 non-null object</span><br><span class="line">item_condition_id    300000 non-null int64</span><br><span class="line">category_name        298719 non-null object</span><br><span class="line">brand_name           171929 non-null object</span><br><span class="line">price                300000 non-null float64</span><br><span class="line">shipping             300000 non-null int64</span><br><span class="line">item_description     300000 non-null object</span><br><span class="line">dtypes: float64(1), int64(3), object(4)</span><br><span class="line">memory usage: 18.3+ MB</span><br></pre></td></tr></table></figure></p>
<h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><p>首先处理属性，训练数据首先要删去<code>price</code>，再去掉没有用处的 <code>train_id</code> 或者 <code>test_id</code>。通过观察上面的数据属性可知 <code>category_name</code> 和 <code>brand_name</code>有数据缺失，样例代码直接用 <code>missing</code>填充。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">featureProcessing</span>(<span class="params">df</span>):</span><br><span class="line">    <span class="comment"># delete the data that will not be used</span></span><br><span class="line">    df = df.drop([<span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;test_id&#x27;</span>, <span class="string">&#x27;train_id&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># deal with the missing value with a default value</span></span><br><span class="line">    df[<span class="string">&#x27;category_name&#x27;</span>] = df[<span class="string">&#x27;category_name&#x27;</span>].fillna(<span class="string">&#x27;missing&#x27;</span>).astype(<span class="built_in">str</span>)</span><br><span class="line">    df[<span class="string">&#x27;brand_name&#x27;</span>] = df[<span class="string">&#x27;brand_name&#x27;</span>].fillna(<span class="string">&#x27;missing&#x27;</span>).astype(<span class="built_in">str</span>)</span><br><span class="line">    df[<span class="string">&#x27;item_description&#x27;</span>] = df[<span class="string">&#x27;item_description&#x27;</span>].fillna(<span class="string">&#x27;No&#x27;</span>)</span><br><span class="line">    <span class="comment"># convert the data : int -&gt; str</span></span><br><span class="line">    df[<span class="string">&#x27;shipping&#x27;</span>] = df[<span class="string">&#x27;shipping&#x27;</span>].astype(<span class="built_in">str</span>)</span><br><span class="line">    df[<span class="string">&#x27;item_condition_id&#x27;</span>] = df[<span class="string">&#x27;item_condition_id&#x27;</span>].astype(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure></p>
<h4 id="模型构建"><a href="#模型构建" class="headerlink" title="模型构建"></a>模型构建</h4><p>首先做模型的输入，通过<code>CountVectorizer</code> 和 <code>TfidfVectorizer</code>生成词频的矩阵， <code>Tfidf</code> 的效果更优，因为考虑了各词在所有字段钟出现的次数，生成的词频矩阵是带有权重的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vectorizer = FeatureUnion([</span><br><span class="line">    (<span class="string">&#x27;name&#x27;</span>, CountVectorizer(ngram_range=(<span class="number">1</span>, <span class="number">2</span>), max_features=<span class="number">50000</span>, preprocessor=build_preprocessor_1(<span class="string">&#x27;name&#x27;</span>))),</span><br><span class="line">    (<span class="string">&#x27;category_name&#x27;</span>, CountVectorizer(token_pattern=<span class="string">&#x27;.+&#x27;</span>, preprocessor=build_preprocessor_1(<span class="string">&#x27;category_name&#x27;</span>))),</span><br><span class="line">    (<span class="string">&#x27;brand_name&#x27;</span>, CountVectorizer(token_pattern=<span class="string">&#x27;.+&#x27;</span>, preprocessor=build_preprocessor_1(<span class="string">&#x27;brand_name&#x27;</span>))),</span><br><span class="line">    (<span class="string">&#x27;shipping&#x27;</span>, CountVectorizer(token_pattern=<span class="string">&#x27;\d+&#x27;</span>, preprocessor=build_preprocessor_1(<span class="string">&#x27;shipping&#x27;</span>))),</span><br><span class="line">    (<span class="string">&#x27;item_condition_id&#x27;</span>, CountVectorizer(token_pattern=<span class="string">&#x27;\d+&#x27;</span>, preprocessor=build_preprocessor_1(<span class="string">&#x27;item_condition_id&#x27;</span>))),</span><br><span class="line">    (<span class="string">&#x27;item_description&#x27;</span>, TfidfVectorizer(ngram_range=(<span class="number">1</span>, <span class="number">3</span>),max_features=<span class="number">100000</span>, preprocessor=build_preprocessor_1(<span class="string">&#x27;item_description&#x27;</span>))),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>利用岭回归，实现价格预测。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ridgeClassify</span>(<span class="params">train_data, train_label</span>):</span><br><span class="line">    ridgeClf = Ridge(</span><br><span class="line">        solver=<span class="string">&#x27;auto&#x27;</span>,</span><br><span class="line">        fit_intercept=<span class="literal">True</span>,</span><br><span class="line">        alpha=<span class="number">0.5</span>,</span><br><span class="line">        max_iter=<span class="number">500</span>,</span><br><span class="line">        normalize=<span class="literal">False</span>,</span><br><span class="line">        tol=<span class="number">0.05</span>)</span><br><span class="line">    <span class="comment"># 训练</span></span><br><span class="line">    ridgeClf.fit(train_data, train_label)</span><br><span class="line">    <span class="keyword">return</span> ridgeClf</span><br></pre></td></tr></table></figure><br>通过对数据集的了解和对样例代码的学习，我们了解到优化这个问题的答案有三个角度可以入手：</p>
<ol>
<li>数据预处理：怎样处理缺失值？数据该怎样结合？</li>
<li>形成词频矩阵时进行优化：调整 <code>CountVectorizer</code> 和 <code>TfidfVectorizer</code> 的参数</li>
<li>模型的选择和优化：尝试岭回归之外的模型、调整模型参数。</li>
</ol>
<h3 id="二、尝试更多的模型"><a href="#二、尝试更多的模型" class="headerlink" title="二、尝试更多的模型"></a>二、尝试更多的模型</h3><p>在上面的样例代码中，利用岭回归模型得到的结果是3.01左右。经过之前课上的提示和网上的资料查找，我们准备再去尝试一下 <code>MLP</code>模型和 <code>Lgmb</code>模型。在粗略的尝试了两个模型之后我们决定进一步利用 <code>MLP</code> 进行下一步的优化。</p>
<h4 id="MLP"><a href="#MLP" class="headerlink" title="MLP"></a><code>MLP</code></h4><p><code>MLP</code> 模型的结果如下：<br><img src="image/2-2.png" alt=""></p>
<h4 id="LGBM"><a href="#LGBM" class="headerlink" title="LGBM"></a><code>LGBM</code></h4><p><code>Lgbm</code> 模型的结果如下：<br><img src="image/2-1.png" alt=""></p>
<h4 id="MLP-和-LGBM-结合"><a href="#MLP-和-LGBM-结合" class="headerlink" title="MLP 和 LGBM 结合"></a><code>MLP</code> 和 <code>LGBM</code> 结合</h4><ol>
<li>特征处理</li>
</ol>
<ul>
<li>导入数据集</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读文件</span></span><br><span class="line">   train = pd.read_csv(<span class="string">&#x27;data/train.csv&#x27;</span>, sep=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">   test = pd.read_csv(<span class="string">&#x27;data/test.csv&#x27;</span>, sep=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">   <span class="comment"># 训练数据和测试数据一起处理</span></span><br><span class="line">   df = pd.concat([train, test], axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>缺失值处理</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对缺失值进行处理</span></span><br><span class="line">   df[<span class="string">&#x27;category_name&#x27;</span>] = df[<span class="string">&#x27;category_name&#x27;</span>].fillna(<span class="string">&#x27;MISS&#x27;</span>).astype(<span class="built_in">str</span>)</span><br><span class="line">   df[<span class="string">&#x27;brand_name&#x27;</span>] = df[<span class="string">&#x27;brand_name&#x27;</span>].fillna(<span class="string">&#x27;missing&#x27;</span>).astype(<span class="built_in">str</span>)</span><br><span class="line">   df[<span class="string">&#x27;item_description&#x27;</span>] = df[<span class="string">&#x27;item_description&#x27;</span>].fillna(<span class="string">&#x27;No&#x27;</span>)</span><br><span class="line">   <span class="comment">#数据类型处理</span></span><br><span class="line">   df[<span class="string">&#x27;shipping&#x27;</span>] = df[<span class="string">&#x27;shipping&#x27;</span>].astype(<span class="built_in">str</span>)</span><br><span class="line">   df[<span class="string">&#x27;item_condition_id&#x27;</span>] = df[<span class="string">&#x27;item_condition_id&#x27;</span>].astype(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>特征向量化</li>
</ul>
<p>使用 <code>sklearn</code> 库中的 <code>CountVectorizer</code> 类将文本特征进行向量化处理，并使用 <code>FeatureUnion</code> 进行特征联合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vectorizer = FeatureUnion([</span><br><span class="line">        (<span class="string">&#x27;name&#x27;</span>, CountVectorizer(</span><br><span class="line">            ngram_range=(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">            max_features=<span class="number">100000</span>,</span><br><span class="line">            preprocessor=build_preprocessor(<span class="string">&#x27;name&#x27;</span>))),</span><br><span class="line">        (<span class="string">&#x27;category_name&#x27;</span>, CountVectorizer(</span><br><span class="line">            token_pattern=<span class="string">&#x27;.+&#x27;</span>,</span><br><span class="line">            preprocessor=build_preprocessor(<span class="string">&#x27;category_name&#x27;</span>))),</span><br><span class="line">        (<span class="string">&#x27;brand_name&#x27;</span>, CountVectorizer(</span><br><span class="line">            token_pattern=<span class="string">&#x27;.+&#x27;</span>,</span><br><span class="line">            preprocessor=build_preprocessor(<span class="string">&#x27;brand_name&#x27;</span>))),</span><br><span class="line">        (<span class="string">&#x27;shipping&#x27;</span>, CountVectorizer(</span><br><span class="line">            token_pattern=<span class="string">&#x27;\d+&#x27;</span>,</span><br><span class="line">            preprocessor=build_preprocessor(<span class="string">&#x27;shipping&#x27;</span>))),</span><br><span class="line">        (<span class="string">&#x27;item_condition_id&#x27;</span>, CountVectorizer(</span><br><span class="line">            token_pattern=<span class="string">&#x27;\d+&#x27;</span>,</span><br><span class="line">            preprocessor=build_preprocessor(<span class="string">&#x27;item_condition_id&#x27;</span>))),</span><br><span class="line">        (<span class="string">&#x27;item_description&#x27;</span>, TfidfVectorizer(</span><br><span class="line">            ngram_range=(<span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line">            max_features=<span class="number">200000</span>,</span><br><span class="line">            preprocessor=build_preprocessor(<span class="string">&#x27;item_description&#x27;</span>),</span><br><span class="line">            stop_words=<span class="string">&#x27;english&#x27;</span>)),</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure>
<ol>
<li>模型构建</li>
</ol>
<p>对特征分别使用岭回归模型，<code>Lgbm</code> 模型和 <code>mlp</code> 模型进行训练，在本地测试得到的解分别为3.01，3.00，0.26</p>
<ul>
<li>岭回归模型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ridge_classify</span>(<span class="params">train_data,train_label</span>):</span><br><span class="line">    <span class="comment">#模型</span></span><br><span class="line">    model = Ridge(</span><br><span class="line">            solver=<span class="string">&#x27;auto&#x27;</span>,</span><br><span class="line">            fit_intercept=<span class="literal">True</span>,</span><br><span class="line">            alpha=<span class="number">0.4</span>,</span><br><span class="line">            max_iter=<span class="number">100</span>,</span><br><span class="line">            normalize=<span class="literal">False</span>,</span><br><span class="line">            tol=<span class="number">0.05</span>)</span><br><span class="line">    <span class="comment">#训练</span></span><br><span class="line">    model.fit(train_data, train_label)</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>
<ul>
<li><code>lgbm</code>模型 </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lgbm_classify</span>(<span class="params">train_data,train_label</span>):</span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.75</span>,</span><br><span class="line">        <span class="string">&#x27;application&#x27;</span>: <span class="string">&#x27;regression&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="string">&#x27;num_leaves&#x27;</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="string">&#x27;verbosity&#x27;</span>: -<span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;metric&#x27;</span>: <span class="string">&#x27;RMSE&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    train_X, valid_X, train_y, valid_y = train_test_split(train_data, train_label, test_size=<span class="number">0.1</span>, random_state=<span class="number">144</span>)</span><br><span class="line">    d_train = lgb.Dataset(train_X, label=train_y)</span><br><span class="line">    d_valid = lgb.Dataset(valid_X, label=valid_y)</span><br><span class="line">    watchlist = [d_train, d_valid]</span><br><span class="line"></span><br><span class="line">    model = lgb.train(params, train_set=d_train, num_boost_round=<span class="number">2200</span>, valid_sets=watchlist, \</span><br><span class="line">                      early_stopping_rounds=<span class="number">50</span>, verbose_eval=<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mlp</code> 模型</li>
</ul>
<p><code>MLP</code> 模型由两个全连接层和一个dropout层组成，本质上就是一个多隐藏层的网络</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mlp_model</span>(<span class="params">train_data,train_label,row_train</span>):</span><br><span class="line">    model = Sequential()</span><br><span class="line">    <span class="comment"># 全连接层</span></span><br><span class="line">    model.add(Dense(<span class="number">64</span>, input_shape=(row_train,), activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    <span class="comment"># DropOut层</span></span><br><span class="line">    model.add(Dropout(<span class="number">0.4</span>))</span><br><span class="line">    <span class="comment"># 全连接层+分类器</span></span><br><span class="line">    model.add(Dense(<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mean_squared_logarithmic_error&#x27;</span>,</span><br><span class="line">                  optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">                  metrics=[<span class="string">&#x27;accuracy&#x27;</span>]</span><br><span class="line">                  )</span><br><span class="line"></span><br><span class="line">    model.fit(train_data, train_label,</span><br><span class="line">              batch_size=<span class="number">300</span>,</span><br><span class="line">              epochs=<span class="number">1</span>,</span><br><span class="line">              )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model.predict(X_test)</span><br></pre></td></tr></table></figure>
<h3 id="三、形成词频矩阵时进行优化"><a href="#三、形成词频矩阵时进行优化" class="headerlink" title="三、形成词频矩阵时进行优化"></a>三、形成词频矩阵时进行优化</h3><p>在样例代码中我们尝试了将所有 <code>CountVectorizer</code> 替换为 <code>TdidfVectorizer</code>，然后利用岭模型进行预测，但是结果并没有优化很多，仅仅到2.9而已。<br>在后面利用 <code>MLP</code>时完全舍弃了 <code>CountVectorizer</code> 只利用  <code>TdidfVectorizer</code>。</p>
<h3 id="四、优化数据预处理过程"><a href="#四、优化数据预处理过程" class="headerlink" title="四、优化数据预处理过程"></a>四、优化数据预处理过程</h3><p>我们对上面基本已经完善的 <code>MLP</code> 进行优化的方式是<strong>尝试不同特征的组合</strong>。</p>
<h4 id="数据属性分析（详见Price-Suggestion-Challenge1-ipynb）"><a href="#数据属性分析（详见Price-Suggestion-Challenge1-ipynb）" class="headerlink" title="数据属性分析（详见Price Suggestion Challenge1.ipynb）"></a>数据属性分析（详见<code>Price Suggestion Challenge1.ipynb</code>）</h4><p>首先对属性进行分析：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">item_condition_id    300000 non-null int64</span><br><span class="line">shipping             300000 non-null int64</span><br><span class="line"></span><br><span class="line">name                 300000 non-null object</span><br><span class="line">category_name        298719 non-null object</span><br><span class="line">brand_name           171929 non-null object</span><br><span class="line">item_description     300000 non-null object</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><code>item_condition_id</code> 和 <code>shipping</code> 直接作为输入考虑，而 <code>name</code>, <code>category_name</code>, <code>brand_name</code>, <code>item_description</code> 考虑不同的组合进行尝试。</p>
<p>在此之前，我们找到了一个数据可视化的实例教程，对数据的属性进行分析。<br>通过详细观察数据得到最优的输入组合：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train.head()</span><br></pre></td></tr></table></figure><br><img src="image/1-3.png" alt=""></p>
<ol>
<li><p><code>price</code><br>通过数据可视化后的观察我们得知为什么要对 <code>price</code> 做 <code>log1p</code> 处理，这样使 <code>price</code> 分布更优。<br><img src="image/1-4.png" alt=""></p>
</li>
<li><p><code>category_name</code><br>尝试对该属性进行拆分，分成各种子类并查看相应数据。<br><img src="image/1-5.png" alt=""></p>
</li>
<li><p><code>item_description</code><br><img src="image/1-6.png" alt=""></p>
</li>
</ol>
<h4 id="不同的输入组合"><a href="#不同的输入组合" class="headerlink" title="不同的输入组合"></a>不同的输入组合</h4><ol>
<li>在样例代码中只是简单地将各个属性结合在一起进行文本分析，即<code>name</code> + <code>item_condition_id</code> + <code>category_name</code> + <code>brand_name</code> + <code>shipping</code> + <code>item_description</code>（6个输入）</li>
<li>尝试<code>name</code>, <code>item_condition_id</code>, <code>shipping</code>,<code>category_name</code> + <code>item_description</code>, <code>brand_name</code>（5个输入）</li>
<li>尝试<code>name</code>, <code>item_condition_id</code>, <code>shipping</code>, <code>category_name</code> + <code>brand_name</code> + <code>item_description</code>（4个输入）</li>
<li>尝试<code>name</code>, <code>item_condition_id</code>, <code>shipping</code>, <code>name</code> + <code>category_name</code> + <code>brand_name</code> + <code>item_description</code>  （4个输入）</li>
</ol>
<p>四种组合作为输入的结果非常相近，除了组合1<code>MSLE</code>在0.4左右，组合2和3 在0.21 左右，组合4最终能跑到0.17左右。组合4实际上加大了<code>name</code>的权重，让最终结果更好。</p>
<h2 id="最终源码及实验结果"><a href="#最终源码及实验结果" class="headerlink" title="最终源码及实验结果"></a>最终源码及实验结果</h2><ol>
<li><p>数据预处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据处理</span></span><br><span class="line"><span class="comment"># 属性共有8个，删去price，train_id对结果没有影响。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_preprocess</span>(<span class="params">df</span>):</span><br><span class="line">    df[<span class="string">&#x27;name&#x27;</span>] = df[<span class="string">&#x27;name&#x27;</span>].fillna(<span class="string">&#x27;&#x27;</span>) + <span class="string">&#x27; &#x27;</span> + df[<span class="string">&#x27;brand_name&#x27;</span>].fillna(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    df[<span class="string">&#x27;text&#x27;</span>] = (df[<span class="string">&#x27;item_description&#x27;</span>].fillna(<span class="string">&#x27;&#x27;</span>) + <span class="string">&#x27; &#x27;</span> + df[<span class="string">&#x27;name&#x27;</span>] + <span class="string">&#x27; &#x27;</span> + df[<span class="string">&#x27;category_name&#x27;</span>].fillna(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> df[[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;text&#x27;</span>, <span class="string">&#x27;shipping&#x27;</span>, <span class="string">&#x27;item_condition_id&#x27;</span>]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fit_predict</span>(<span class="params">xs, y_train</span>):</span><br><span class="line">    X_train, X_test = xs</span><br><span class="line">    <span class="comment"># 配置tf.Session的运算方式，比如gpu运算或者cpu运算</span></span><br><span class="line">    config = tf.ConfigProto(</span><br><span class="line">        <span class="comment"># 设置多个操作并行运算的线程数</span></span><br><span class="line">        intra_op_parallelism_threads=<span class="number">1</span>, use_per_session_threads=<span class="number">1</span>, inter_op_parallelism_threads=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># Session提供了Operation执行和Tensor求值的环境。</span></span><br><span class="line">    <span class="keyword">with</span> tf.Session(graph=tf.Graph(), config=config) <span class="keyword">as</span> sess, timer(<span class="string">&#x27;fit_predict&#x27;</span>):</span><br><span class="line">        ks.backend.set_session(sess)</span><br><span class="line">        model_in = ks.Input(shape=(X_train.shape[<span class="number">1</span>],), dtype=<span class="string">&#x27;float32&#x27;</span>, sparse=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># ks.layers.Dense 表示输出空间的维度</span></span><br><span class="line">        <span class="comment"># Dense全连接层，相当于直接添加一层</span></span><br><span class="line">        <span class="comment"># activation 是按逐个元素计算的激活函数</span></span><br><span class="line">        out = ks.layers.Dense(<span class="number">192</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(model_in)</span><br><span class="line">        out = ks.layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(out)</span><br><span class="line">        out = ks.layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(out)</span><br><span class="line">        out = ks.layers.Dense(<span class="number">1</span>)(out)</span><br><span class="line">        model = ks.Model(model_in, out)</span><br><span class="line">        model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mean_squared_error&#x27;</span>, optimizer=ks.optimizers.Adam(lr=<span class="number">3e-3</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">with</span> timer(<span class="string">f&#x27;epoch <span class="subst">&#123;i + <span class="number">1</span>&#125;</span>&#x27;</span>):</span><br><span class="line">                model.fit(x=X_train, y=y_train, batch_size=<span class="number">2</span> ** (<span class="number">11</span> + i), epochs=<span class="number">1</span>, verbose=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> model.predict(X_test)[:, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>训练模型并预测结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    vectorizer = make_union(<span class="comment"># 把所有的transformers组装成一个FeatureUnion. n_jobs表示可以同时进行</span></span><br><span class="line">        <span class="comment"># FunctionTransformer 实现自定义转换，validate=False 时没有输入验证</span></span><br><span class="line">        <span class="comment"># TfidfVectorizer函数，仅考虑按照词频排列前max_feature位的词，token_pattern=&#x27;\w+&#x27;至少匹配一位的词</span></span><br><span class="line">        make_pipeline(FunctionTransformer(itemgetter(<span class="string">&#x27;name&#x27;</span>), validate=<span class="literal">False</span>), TfidfVectorizer(max_features=<span class="number">100000</span>, token_pattern=<span class="string">&#x27;\w+&#x27;</span>)),</span><br><span class="line">        make_pipeline(FunctionTransformer(itemgetter(<span class="string">&#x27;text&#x27;</span>), validate=<span class="literal">False</span>), TfidfVectorizer(max_features=<span class="number">100000</span>, token_pattern=<span class="string">&#x27;\w+&#x27;</span>)),</span><br><span class="line">        make_pipeline(FunctionTransformer(itemgetter([<span class="string">&#x27;shipping&#x27;</span>, <span class="string">&#x27;item_condition_id&#x27;</span>]), validate=<span class="literal">False</span>),</span><br><span class="line">                      FunctionTransformer(to_records, validate=<span class="literal">False</span>), DictVectorizer()),</span><br><span class="line">        n_jobs=<span class="number">4</span>)</span><br><span class="line">    <span class="comment"># StandardScaler()进行数据标准化。保存训练集中的参数（均值、方差）直接使用其对象转换测试集数据。</span></span><br><span class="line">    y_scaler = StandardScaler()</span><br><span class="line">    <span class="comment"># with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。</span></span><br><span class="line">    <span class="keyword">with</span> timer(<span class="string">&#x27;process train&#x27;</span>):</span><br><span class="line">        train = pd.read_csv(<span class="string">&#x27;train.csv&#x27;</span>, sep=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        test = pd.read_csv(<span class="string">&#x27;test.csv&#x27;</span>, sep=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="comment"># 删去&#x27;price&#x27;属性</span></span><br><span class="line">        train = train[train[<span class="string">&#x27;price&#x27;</span>] &gt; <span class="number">0</span>].reset_index(drop=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 将price数据进行标准化</span></span><br><span class="line">        y_train = y_scaler.fit_transform(np.log1p(train[<span class="string">&#x27;price&#x27;</span>].values.reshape(-<span class="number">1</span>, <span class="number">1</span>)))</span><br><span class="line">        X_train = vectorizer.fit_transform(data_preprocess(train)).astype(np.float32)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;X_train: <span class="subst">&#123;X_train.shape&#125;</span> of <span class="subst">&#123;X_train.dtype&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> timer(<span class="string">&#x27;process valid&#x27;</span>):</span><br><span class="line">        X_test = vectorizer.transform(data_preprocess(test)).astype(np.float32)</span><br><span class="line">    <span class="keyword">with</span> ThreadPool(processes=<span class="number">4</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        Xb_train, Xb_test = [x.astype(np.<span class="built_in">bool</span>).astype(np.float32) <span class="keyword">for</span> x <span class="keyword">in</span> [X_train, X_test]]</span><br><span class="line">        xs = [[Xb_train, Xb_test], [X_train, X_test]] * <span class="number">2</span></span><br><span class="line">        <span class="comment"># 预测模型</span></span><br><span class="line">        y_pred = np.mean(pool.<span class="built_in">map</span>(partial(fit_predict, y_train=y_train), xs), axis=<span class="number">0</span>)</span><br><span class="line">    y_pred = np.expm1(y_scaler.inverse_transform(y_pred.reshape(-<span class="number">1</span>, <span class="number">1</span>))[:, <span class="number">0</span>])</span><br><span class="line">    <span class="comment"># print(type(y_pred))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出预测结果到csv</span></span><br><span class="line">    test_id = np.array(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(y_pred)))</span><br><span class="line">    dataframe = pd.DataFrame(&#123;<span class="string">&#x27;test_id&#x27;</span>: test_id, <span class="string">&#x27;price&#x27;</span>: y_pred&#125;)</span><br><span class="line">    dataframe.to_csv(<span class="string">&quot;res.csv&quot;</span>, index=<span class="literal">False</span>, sep=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(&#x27;Valid MSLE: &#123;:.4f&#125;&#x27;.format(mean_squared_log_error(valid[&#x27;price&#x27;], y_pred)))</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最终实验结果达到了0.179。</p>
<h2 id="在MLP模型下的其他优化方向"><a href="#在MLP模型下的其他优化方向" class="headerlink" title="在MLP模型下的其他优化方向"></a>在<code>MLP</code>模型下的其他优化方向</h2><ol>
<li>可以观察到在<code>item_desciption</code> 的词云中，有诸如<code>shipping</code> 和<code>free</code>等词，这些词可能代表着免运费等含义，与<code>shipping</code>属性有一定的重复，将它作为特征词训练模型会造成干扰。</li>
<li>单个关键词可能包含的信息不全面，关键词之间可能有很大的关联。</li>
<li>在最终的模型中<code>MLP</code>采用了四层感知机，感知机的层数和每层的输入规模还可以做进一步调参。</li>
</ol>
<h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><p>这次实验的难度非常大，不知道从何入手。</p>
<p>在仔细研究了课程中给的样例代码和数据可视化分析的内容之后，对数据集和预测的方法都有了初步的了解。  </p>
<p>因为对<code>MLP</code>，<code>Lightgbm</code>等模型非常不熟悉，所以从输入的角度入手，在不同属性的组合之处进行尝试，得到了最终的较为优秀的结果。  </p>
<p>在之后的学习中应该更加深入地学习和了解模型，尽量能够自己独立完成创建模型，而不是修改其他已经写好的模型。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1].<a href="https://ahmedbesbes.com/how-to-mine-newsfeed-data-and-extract-interactive-insights-in-python.html">https://ahmedbesbes.com/how-to-mine-newsfeed-data-and-extract-interactive-insights-in-python.html</a></p>
<p>[2].  <a href="https://github.com/pjankiewicz/mercari-solution">https://github.com/pjankiewicz/mercari-solution</a></p>
<p>[3].<a href="https://www.kaggle.com/thykhuely/mercari-interactive-eda-topic-modelling">https://www.kaggle.com/thykhuely/mercari-interactive-eda-topic-modelling</a></p>
<p>[4].<a href="https://wklchris.github.io/Py3-pandas.html#统计信息dfdescribe-svalue_counts--unique">https://wklchris.github.io/Py3-pandas.html#%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AFdfdescribe-svalue_counts—unique</a></p>
<p>[5].<a href="https://zh.wikipedia.org/wiki/多层感知器">https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E5%99%A8</a></p>
<p>[6].<a href="https://blog.csdn.net/weixin_39807102/article/details/81912566">https://blog.csdn.net/weixin_39807102/article/details/81912566</a></p>
<p>[7].<a href="https://github.com/maiwen/NLP">https://github.com/maiwen/NLP</a></p>
<p>[8]. <a href="https://zh.wikipedia.org/wiki/正则表达式">https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F</a></p>
<p>[9].<a href="https://blog.csdn.net/u012609509/article/details/72911564">https://blog.csdn.net/u012609509/article/details/72911564</a></p>
<p>[10]. <a href="https://www.kaggle.com/tunguz/more-effective-ridge-lgbm-script-lb-0-44823">https://www.kaggle.com/tunguz/more-effective-ridge-lgbm-script-lb-0-44823</a></p>
<p>[11]. <a href="https://qiita.com/kazuhirokomoda/items/1e9b7ebcacf264b2d814">https://qiita.com/kazuhirokomoda/items/1e9b7ebcacf264b2d814</a></p>
<p>[12]. <a href="https://www.jianshu.com/p/c532424541ad">https://www.jianshu.com/p/c532424541ad</a></p>
<p>[13]. <a href="https://www.jiqizhixin.com/articles/2017-11-13-7">https://www.jiqizhixin.com/articles/2017-11-13-7</a></p>
]]></content>
      <categories>
        <category>数据科学导论</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux开发环境及应用作业1</title>
    <url>/201911/Linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8%E4%BD%9C%E4%B8%9A%2020191031/</url>
    <content><![CDATA[<h2 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h2><p>从因特网上搜索相关Web网页，处理网页<code>html</code>数据，从中提取出当前时间点北京各监测站的 PM2.5浓度，输出格式如下。要求：写出各个处 理步骤，并给出解释。<br>2018-03-15 13:00:00,海淀区万柳,73<br>2018-03-15 13:00:00,昌平镇,67<br>2018-03-15 13:00:00,奥体中心,66<br>2018-03-15 14:00:00,海淀区万柳,73<br>2018-03-15 14:00:00,昌平镇,73<br>2018-03-15 14:00:00,奥体中心,75</p>
<span id="more"></span>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="数据搜集"><a href="#数据搜集" class="headerlink" title="数据搜集"></a>数据搜集</h3><p>北京各监测站的<code>PM2.5</code>指数的数据来源网站：<a href="http://www.86pm25.com/city/beijing.html">http://www.86pm25.com/city/beijing.html</a><br><img src="https://s2.ax1x.com/2019/10/31/K5rmkV.jpg" alt=""></p>
<h3 id="数据整理及汇总"><a href="#数据整理及汇总" class="headerlink" title="数据整理及汇总"></a>数据整理及汇总</h3><p>先展示实现该操作的指令和最后的结果：<br><img src="https://s2.ax1x.com/2019/10/31/K5rl6J.jpg" alt=""><br><img src="https://s2.ax1x.com/2019/10/31/K5rQl4.jpg" alt=""><br><img src="https://s2.ax1x.com/2019/10/31/K5rJTx.jpg" alt=""></p>
<p>下面详细解释指令：</p>
<ol>
<li>首先利用<tr>标签把数据分成单独的行，<code>sed -e &#39;s/&lt;tr/\n&lt;tr/g&#39;</code></li>
<li>其次删掉html文件中的所有标签<code>-e &#39;s/&lt;[^&lt;&gt;]*&gt;/ /g</code>，把所有标签都换成了空格。</li>
<li>我先在html文件中寻找日期和时间，发现时间的那一行有“更新”的字样，于是建立awk文件，此时发现“更新”后面中文的冒号紧跟着日期，没发把日期分离开，于是先在中文冒号后面添加空格。顺便把日期和时间的格式改成标准的输出的格式。<code>-e &#39;s/：/： /g&#39; -e &#39;s/[年月]/-/g&#39; -e &#39;s/日//g -e &#39;s/时/:00:00/g&#39;</code><br><img src="https://s2.ax1x.com/2019/10/31/K5rrnA.jpg" alt=""></li>
<li>此时可以把时间和日期抽离出来了。在建立的awk文件中输入<code>/更新/ &#123;data = $2; time = $3&#125;</code></li>
<li>得到日期和时间 之后，我们去找监测站和pm2.5指数，发现在这些数据最后都有$m^3$单位在，于是在awk文件中添加<code>/m3/&#123;printf(&quot;%s %s,%s,%s\n&quot;,date, time, $1, $3);&#125;</code><br><img src="https://s2.ax1x.com/2019/10/31/K5rs0I.jpg" alt=""></li>
<li>最后把单位删掉，并输出到csv文件中即可。<code>awk -f flow.awk | sed -e &#39;s/[ug/m3]//g&#39; &gt; flow.csv</code></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>文本处理</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络前向传播和反向传播算法推导</title>
    <url>/201911/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%9A%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h2 id="一、目标"><a href="#一、目标" class="headerlink" title="一、目标"></a>一、目标</h2><ol>
<li>推导具有单隐层的神经网络的前向传播和反向传播算法，并进行编程（可以使用<code>sklearn</code>中的神经网络）。<ul>
<li>探讨10，30，100，300，1000，不同隐藏节点数对网络性能的影响。</li>
<li>探讨不同学习率和迭代次数对网络性能的影响。</li>
<li>改变数据的标准化方法，探讨对训练的影响。</li>
</ul>
</li>
<li>查阅资料说明什么是<code>Hebb</code>学习规则</li>
</ol>
<span id="more"></span>
<h2 id="二、推导单隐层神经网络的前向传播和反向传播算法"><a href="#二、推导单隐层神经网络的前向传播和反向传播算法" class="headerlink" title="二、推导单隐层神经网络的前向传播和反向传播算法"></a>二、推导单隐层神经网络的前向传播和反向传播算法</h2><p>参考资料：<a href="https://blog.csdn.net/Lucky_Go/article/details/89738286">https://blog.csdn.net/Lucky_Go/article/details/89738286</a><br><img src="image4\reduction1.jpg" alt=""><br><img src="image4\reduction2.jpg" alt=""><br><img src="image4\reduction3.jpg" alt=""><br><img src="image4\reduction4.jpg" alt=""></p>
<h2 id="三、算法实现"><a href="#三、算法实现" class="headerlink" title="三、算法实现"></a>三、算法实现</h2><p>参考资料：<a href="https://blog.csdn.net/zsx17/article/details/89342506">https://blog.csdn.net/zsx17/article/details/89342506</a></p>
<p>因为网上神经网络的代码基本都是用<code>tensorflow</code>实现的，这里是直接调库。在完成了作业的基本要求之后我也尝试了自己实现单隐层神经网络的代码（在实验报告的后部分）。</p>
<h3 id="1-载入数据"><a href="#1-载入数据" class="headerlink" title="1. 载入数据"></a>1. 载入数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、载入数据</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> tensorflow.examples.tutorials.mnist.input_data <span class="keyword">as</span> input_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取mnist数据</span></span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">&#x27;MNIST_data/&#x27;</span>, one_hot=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-建立模型"><a href="#2-建立模型" class="headerlink" title="2. 建立模型"></a>2. 建立模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2.建立模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.1 构建输入层</span></span><br><span class="line">x = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">784</span>], name=<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">y = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">10</span>], name=<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.2 构建隐藏层</span></span><br><span class="line"><span class="comment"># 隐藏层神经元数量(随意设置）</span></span><br><span class="line">H1_NN = <span class="number">256</span></span><br><span class="line"><span class="comment"># 权重</span></span><br><span class="line">W1 = tf.Variable(tf.random_normal([<span class="number">784</span>, H1_NN]))</span><br><span class="line"><span class="comment"># 偏置项</span></span><br><span class="line">b1 = tf.Variable(tf.zeros([H1_NN]))</span><br><span class="line"></span><br><span class="line">Y1 = tf.nn.relu(tf.matmul(x, W1) + b1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.3 构建输出层</span></span><br><span class="line">W2 = tf.Variable(tf.random_normal([H1_NN, <span class="number">10</span>]))</span><br><span class="line">b2 = tf.Variable(tf.zeros([<span class="number">10</span>]))</span><br><span class="line"></span><br><span class="line">forward = tf.matmul(Y1, W2) + b2</span><br><span class="line">pred = tf.nn.softmax(forward)</span><br></pre></td></tr></table></figure>
<h3 id="3-训练模型"><a href="#3-训练模型" class="headerlink" title="3. 训练模型"></a>3. 训练模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3.训练模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.1 定义损失函数</span></span><br><span class="line"><span class="comment"># tensorflow提供了下面的函数，用于避免log(0)值为Nan造成数据不稳定</span></span><br><span class="line">loss_function = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=forward, labels=y))</span><br><span class="line"><span class="comment"># # 交叉熵损失函数</span></span><br><span class="line"><span class="comment"># loss_function = tf.reduce_mean(-tf.reduce_sum(y*tf.log(pred), reduction_indices=1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.2 设置训练参数</span></span><br><span class="line">train_epochs = <span class="number">40</span>  <span class="comment"># 训练轮数</span></span><br><span class="line">batch_size = <span class="number">50</span>  <span class="comment"># 单次训练样本数(批次大小)</span></span><br><span class="line"><span class="comment"># 一轮训练的批次数</span></span><br><span class="line">total_batch = <span class="built_in">int</span>(mnist.train.num_examples / batch_size)</span><br><span class="line">display_step = <span class="number">1</span>  <span class="comment"># 显示粒数</span></span><br><span class="line">learning_rate = <span class="number">0.01</span>  <span class="comment"># 学习率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.2 选择优化器</span></span><br><span class="line">optimizer = tf.train.AdamOptimizer(learning_rate).minimize(loss_function)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.3定义准确率</span></span><br><span class="line">correct_prediction = tf.equal(tf.argmax(y, <span class="number">1</span>), tf.argmax(pred, <span class="number">1</span>))</span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.4 模型的训练</span></span><br><span class="line"><span class="comment"># 记录训练开始的时间</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">startTime = time()</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(train_epochs):</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> <span class="built_in">range</span>(total_batch):</span><br><span class="line">        <span class="comment"># 读取批次训练数据</span></span><br><span class="line">        xs, ys = mnist.train.next_batch(batch_size)</span><br><span class="line">        <span class="comment"># 执行批次训练</span></span><br><span class="line">        sess.run(optimizer, feed_dict=&#123;x: xs, y: ys&#125;)</span><br><span class="line">    <span class="comment"># 在total_batch批次数据训练完成后，使用验证数据计算误差和准确率，验证集不分批</span></span><br><span class="line">    loss, acc = sess.run([loss_function, accuracy], feed_dict=&#123;x: mnist.validation.images, y: mnist.validation.labels&#125;)</span><br><span class="line">    <span class="comment"># 打印训练过程中的详细信息</span></span><br><span class="line">    <span class="keyword">if</span> (epoch + <span class="number">1</span>) % display_step == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;训练轮次：&#x27;</span>, <span class="string">&#x27;%02d&#x27;</span> % (epoch + <span class="number">1</span>),</span><br><span class="line">              <span class="string">&#x27;损失：&#x27;</span>, <span class="string">&#x27;&#123;:.9f&#125;&#x27;</span>.<span class="built_in">format</span>(loss),</span><br><span class="line">              <span class="string">&#x27;准确率：&#x27;</span>, <span class="string">&#x27;&#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(acc))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;训练结束&#x27;</span>)</span><br><span class="line"><span class="comment"># 显示总运行时间</span></span><br><span class="line">duration = time() - startTime</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;总运行时间为：&quot;</span>, <span class="string">&quot;&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(duration))</span><br></pre></td></tr></table></figure>
<h3 id="4-模型评估"><a href="#4-模型评估" class="headerlink" title="4. 模型评估"></a>4. 模型评估</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4.评估模型</span></span><br><span class="line">accu_test = sess.run(accuracy,</span><br><span class="line">                     feed_dict=&#123;x: mnist.test.images, y: mnist.test.labels&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;测试集准确率：&#x27;</span>, accu_test)</span><br></pre></td></tr></table></figure>
<h3 id="5-应用模型"><a href="#5-应用模型" class="headerlink" title="5. 应用模型"></a>5. 应用模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 5.应用模型</span></span><br><span class="line">prediction_result = sess.run(tf.argmax(pred, <span class="number">1</span>), feed_dict=&#123;x: mnist.test.images&#125;)</span><br><span class="line"><span class="comment"># 查看预测结果的前10项</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;前10项的结果：&quot;</span>, prediction_result[<span class="number">0</span>:<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.1找出预测错误的样本</span></span><br><span class="line">compare_lists = prediction_result == np.argmax(mnist.test.labels, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(compare_lists)</span><br><span class="line">err_lists = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(compare_lists)) <span class="keyword">if</span> compare_lists[i] == <span class="literal">False</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;预测错误的图片：&#x27;</span>, err_lists)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;预测错误图片的总数：&#x27;</span>, <span class="built_in">len</span>(err_lists))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个输出错误分类的函数</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_predict_errs</span>(<span class="params">labels,  <span class="comment"># 标签列表</span></span></span><br><span class="line"><span class="params">                       prediction</span>):  <span class="comment"># 预测值列表</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    compare_lists = (prediction == np.argmax(labels, <span class="number">1</span>))</span><br><span class="line">    err_lists = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(compare_lists)) <span class="keyword">if</span> compare_lists[i] == <span class="literal">False</span>]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> err_lists:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;index=&#x27;</span> + <span class="built_in">str</span>(x) + <span class="string">&#x27;标签值=&#x27;</span>, np.argmax(labels[x]), <span class="string">&#x27;预测值=&#x27;</span>, prediction[x])</span><br><span class="line">        count = count + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;总计：&quot;</span> + <span class="built_in">str</span>(count))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print_predict_errs(labels=mnist.test.labels, prediction=prediction_result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_images_labels_prediction</span>(<span class="params">images,  <span class="comment"># 图像列表</span></span></span><br><span class="line"><span class="params">                                  labels,  <span class="comment"># 标签列表</span></span></span><br><span class="line"><span class="params">                                  predication,  <span class="comment"># 预测值列表</span></span></span><br><span class="line"><span class="params">                                  index,  <span class="comment"># 从第index个开始显示</span></span></span><br><span class="line"><span class="params">                                  num=<span class="number">10</span></span>):  <span class="comment"># 缺省一次显示10幅</span></span><br><span class="line">    fig = plt.gcf()  <span class="comment"># 获取当前图表，get current figure</span></span><br><span class="line">    fig.set_size_inches(<span class="number">10</span>, <span class="number">12</span>)  <span class="comment"># 设为英寸，1英寸=2.53厘米</span></span><br><span class="line">    <span class="keyword">if</span> num &gt; <span class="number">25</span>:</span><br><span class="line">        num = <span class="number">25</span>  <span class="comment"># 最多显示25个子图</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num):</span><br><span class="line">        ax = plt.subplot(<span class="number">5</span>, <span class="number">5</span>, i + <span class="number">1</span>)  <span class="comment"># 获取当前要处理的子图</span></span><br><span class="line">        <span class="comment"># 显示第index图像</span></span><br><span class="line">        ax.imshow(np.reshape(images[index], (<span class="number">28</span>, <span class="number">28</span>)), cmap=<span class="string">&#x27;binary&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建该图上显示的title</span></span><br><span class="line">        title = <span class="string">&#x27;label=&#x27;</span> + <span class="built_in">str</span>(np.argmax(labels[index]))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(predication) &gt; <span class="number">0</span>:</span><br><span class="line">            title += <span class="string">&quot;,predict=&quot;</span> + <span class="built_in">str</span>(predication[index])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 显示图上的title信息</span></span><br><span class="line">        ax.set_title(title, fontsize=<span class="number">10</span>)</span><br><span class="line">        ax.set_xticks([])  <span class="comment"># 不显示坐标轴</span></span><br><span class="line">        ax.set_yticks([])</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plot_images_labels_prediction(mnist.test.images,</span><br><span class="line">                              mnist.test.labels,</span><br><span class="line">                              prediction_result, <span class="number">10</span>, <span class="number">25</span>)</span><br><span class="line">plot_images_labels_prediction(mnist.test.images,</span><br><span class="line">                              mnist.test.labels,</span><br><span class="line">                              prediction_result, <span class="number">610</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<h3 id="6-结果展示"><a href="#6-结果展示" class="headerlink" title="6. 结果展示"></a>6. 结果展示</h3><p>上面的代码中隐层节点个数为256个，学习率为0.01，迭代次数为40次。训练结果如下：</p>
<p><img src="image4\256-0.01-40.jpg" alt=""></p>
<p>部分分类图像如下所示：</p>
<p><img src="image4\256-0.01-40-1.jpg" alt=""></p>
<p><img src="image4\256-0.01-40-2.jpg" alt=""></p>
<h2 id="四、算法调优"><a href="#四、算法调优" class="headerlink" title="四、算法调优"></a>四、算法调优</h2><p>在上面的模型中隐层结点数为256，学习率为0.01，迭代次数为40次。</p>
<p>下面分别从隐层节点数、学习率和迭代次数三个角度进行调优。</p>
<h3 id="1-隐层节点数"><a href="#1-隐层节点数" class="headerlink" title="1. 隐层节点数"></a>1. 隐层节点数</h3><p>将隐层节点数设为10，得到的结果如下图所示：</p>
<p><img src="image4\10-0.01-40.jpg" alt=""></p>
<p>将隐层节点设为30，100，300，1000的效果不再具体展示，效果如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">隐层节点个数</th>
<th style="text-align:center">总运行时间/s</th>
<th style="text-align:center">预测错误的图片数</th>
<th style="text-align:center">准确率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">46.29</td>
<td style="text-align:center">736</td>
<td style="text-align:center">0.9264</td>
</tr>
<tr>
<td style="text-align:center">30</td>
<td style="text-align:center">43.46</td>
<td style="text-align:center">528</td>
<td style="text-align:center">0.9472</td>
</tr>
<tr>
<td style="text-align:center">100</td>
<td style="text-align:center">59.06</td>
<td style="text-align:center">343</td>
<td style="text-align:center">0.9657</td>
</tr>
<tr>
<td style="text-align:center">256</td>
<td style="text-align:center">84.48</td>
<td style="text-align:center">249</td>
<td style="text-align:center">0.9751</td>
</tr>
<tr>
<td style="text-align:center">300</td>
<td style="text-align:center">76.64</td>
<td style="text-align:center">269</td>
<td style="text-align:center">0.9731</td>
</tr>
<tr>
<td style="text-align:center">1000</td>
<td style="text-align:center">302.27</td>
<td style="text-align:center">240</td>
<td style="text-align:center">0.976</td>
</tr>
</tbody>
</table>
</div>
<p>由表可知，准确率随着隐层节点个数的增加而增加，增加速率逐步减少。</p>
<h3 id="2-学习率"><a href="#2-学习率" class="headerlink" title="2. 学习率"></a>2. 学习率</h3><p>学习率分别为0.005，0.01， 0.02， 0.1，隐层节点数选择256，迭代次数选择40。分类结果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">学习率</th>
<th style="text-align:center">总运行时间/s</th>
<th style="text-align:center">预测错误的图片数</th>
<th style="text-align:center">准确率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0.005</td>
<td style="text-align:center">78.81</td>
<td style="text-align:center">231</td>
<td style="text-align:center">0.9769</td>
</tr>
<tr>
<td style="text-align:center">0.01</td>
<td style="text-align:center">84.48</td>
<td style="text-align:center">249</td>
<td style="text-align:center">0.9751</td>
</tr>
<tr>
<td style="text-align:center">0.02</td>
<td style="text-align:center">69.72</td>
<td style="text-align:center">446</td>
<td style="text-align:center">0.9554</td>
</tr>
<tr>
<td style="text-align:center">0.1</td>
<td style="text-align:center">73.87</td>
<td style="text-align:center">2561</td>
<td style="text-align:center">0.7439</td>
</tr>
</tbody>
</table>
</div>
<p>由表可知，准确率随着学习率的增加而降低。在学习率低于0.01时，图片分类的准确率提升的速率较小。</p>
<h3 id="3-迭代次数"><a href="#3-迭代次数" class="headerlink" title="3. 迭代次数"></a>3. 迭代次数</h3><p>迭代次数分别为20，40，100，隐层节点数选择256，学习率选择0.01。分类结果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">迭代次数</th>
<th style="text-align:center">总运行时间/s</th>
<th style="text-align:center">预测错误的图片数</th>
<th style="text-align:center">准确率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">37.12</td>
<td style="text-align:center">307</td>
<td style="text-align:center">0.9693</td>
</tr>
<tr>
<td style="text-align:center">40</td>
<td style="text-align:center">84.48</td>
<td style="text-align:center">249</td>
<td style="text-align:center">0.9751</td>
</tr>
<tr>
<td style="text-align:center">100</td>
<td style="text-align:center">184.39</td>
<td style="text-align:center">239</td>
<td style="text-align:center">0.9761</td>
</tr>
</tbody>
</table>
</div>
<p>由表可知，迭代次数对总运行时间的影响率很大，准确率随着迭代次数的增加而增加，但对准确率起决定因素的还是隐层的节点个数以及学习率。</p>
<h3 id="4-改变数据标准化方法"><a href="#4-改变数据标准化方法" class="headerlink" title="4. 改变数据标准化方法"></a>4. 改变数据标准化方法</h3><h4 id="最大-最小规范化"><a href="#最大-最小规范化" class="headerlink" title="最大-最小规范化"></a>最大-最小规范化</h4><h4 id="Z-score规范化"><a href="#Z-score规范化" class="headerlink" title="Z-score规范化"></a><code>Z-score</code>规范化</h4><h2 id="五、Hebb学习规则"><a href="#五、Hebb学习规则" class="headerlink" title="五、Hebb学习规则"></a>五、<code>Hebb</code>学习规则</h2><p>参考资料：<a href="https://baike.baidu.com/item/Hebb学习规则/3061563?fr=aladdin">https://baike.baidu.com/item/Hebb%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%99/3061563?fr=aladdin</a></p>
<p><code>Hebb</code>学习规则是一个无监督学习规则，这种学习的结果是使网络能够提取训练集的统计特性，从而把输入信息按照它们的相似性程度划分为若干类。这一点与人类观察和认识世界的过程非常吻合，人类观察和认识世界在相当程度上就是在根据事物的统计特征进行分类。<code>Hebb</code>学习规则只根据神经元连接间的激活水平改变权值，因此这种方法又称为相关学习或并联学习。</p>
<p>无监督学习规则<br> 唐纳德·赫布（1904-1985）是加拿大著名生理心理学家。<code>Hebb</code>学习规则与“条件反射”机理一致，并且已经得到了神经细胞学说的证实。<br> 巴甫洛夫的条件反射实验：每次给狗喂食前都先响铃，时间一长，狗就会将铃声和食物联系起来。以后如果响铃但是不给食物，狗也会流口水。<br> 受该实验的启发，Hebb的理论认为在同一时间被激发的神经元间的联系会被强化。比如，铃声响时一个神经元被激发，在同一时间食物的出现会激发附近的另一个神经元，那么这两个神经元间的联系就会强化，从而记住这两个事物之间存在着联系。相反，如果两个神经元总是不能同步激发，那么它们间的联系将会越来越弱。<br> <code>Hebb</code>学习律可表示为：<br>$W<em>{ij}(t+1)=W</em>{ij}(t)+a⋅y<em>i⋅y_j$<br>$W</em>{ij}(t+1)=W_{ij}(t)+a⋅y_i⋅y_j$</p>
<p> 其中$W<em>{ij}$表示神经元$j$到神经元$i$的连接权，$y_i$与$y_j$表示两个神经元的输出，$a$是表示学习速率的常数，如果$y_i$与$y_j$同时被激活，即$y_i$与$y_j$同时为正，那么$W</em>{ij}$将增大。如果$y<em>i$被激活，而$y_j$处于抑制状态，即$y_i$为正$y_j$为负，那么$W</em>{ij}$将变小。</p>
<p><img src="https://images2015.cnblogs.com/blog/520787/201510/520787-20151021081107630-1544768706.png" alt=""></p>
<h2 id="六、-自己实现单隐层神经网络"><a href="#六、-自己实现单隐层神经网络" class="headerlink" title="六、 自己实现单隐层神经网络"></a>六、 自己实现单隐层神经网络</h2><p>参考资料：<a href="https://blog.csdn.net/hellozhxy/article/details/81055391">https://blog.csdn.net/hellozhxy/article/details/81055391</a></p>
<p>网络结构的函数定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">layer_sizes</span>(<span class="params">X, Y</span>):</span><br><span class="line">    n_x = X.shape[<span class="number">0</span>] <span class="comment"># size of input layer</span></span><br><span class="line">    n_h = <span class="number">4</span> <span class="comment"># size of hidden layer</span></span><br><span class="line">    n_y = Y.shape[<span class="number">0</span>] <span class="comment"># size of output layer</span></span><br><span class="line">    <span class="keyword">return</span> (n_x, n_h, n_y)</span><br></pre></td></tr></table></figure>
<p>参数初始化函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_parameters</span>(<span class="params">n_x, n_h, n_y</span>):</span><br><span class="line">    W1 = np.random.randn(n_h, n_x)*<span class="number">0.01</span></span><br><span class="line">    b1 = np.zeros((n_h, <span class="number">1</span>))</span><br><span class="line">    W2 = np.random.randn(n_y, n_h)*<span class="number">0.01</span></span><br><span class="line">    b2 = np.zeros((n_y, <span class="number">1</span>)) </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">assert</span> (W1.shape == (n_h, n_x))    </span><br><span class="line">    <span class="keyword">assert</span> (b1.shape == (n_h, <span class="number">1</span>))    </span><br><span class="line">    <span class="keyword">assert</span> (W2.shape == (n_y, n_h))    </span><br><span class="line">    <span class="keyword">assert</span> (b2.shape == (n_y, <span class="number">1</span>))</span><br><span class="line">    parameters = &#123;<span class="string">&quot;W1&quot;</span>: W1, </span><br><span class="line">                  <span class="string">&quot;b1&quot;</span>: b1,                 </span><br><span class="line">                  <span class="string">&quot;W2&quot;</span>: W2,                  </span><br><span class="line">                  <span class="string">&quot;b2&quot;</span>: b2&#125;   </span><br><span class="line">                   </span><br><span class="line">    <span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure>
<p>前向传播计算函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward_propagation</span>(<span class="params">X, parameters</span>):</span><br><span class="line">    <span class="comment"># Retrieve each parameter from the dictionary &quot;parameters&quot;</span></span><br><span class="line">    W1 = parameters[<span class="string">&#x27;W1&#x27;</span>]</span><br><span class="line">    b1 = parameters[<span class="string">&#x27;b1&#x27;</span>]</span><br><span class="line">    W2 = parameters[<span class="string">&#x27;W2&#x27;</span>]</span><br><span class="line">    b2 = parameters[<span class="string">&#x27;b2&#x27;</span>]    </span><br><span class="line">    <span class="comment"># Implement Forward Propagation to calculate A2 (probabilities)</span></span><br><span class="line">    Z1 = np.dot(W1, X) + b1</span><br><span class="line">    A1 = np.tanh(Z1)</span><br><span class="line">    Z2 = np.dot(W2, Z1) + b2</span><br><span class="line">    A2 = sigmoid(Z2)    </span><br><span class="line">    <span class="keyword">assert</span>(A2.shape == (<span class="number">1</span>, X.shape[<span class="number">1</span>]))</span><br><span class="line">    cache = &#123;<span class="string">&quot;Z1&quot;</span>: Z1,                   </span><br><span class="line">             <span class="string">&quot;A1&quot;</span>: A1,                   </span><br><span class="line">             <span class="string">&quot;Z2&quot;</span>: Z2,                  </span><br><span class="line">             <span class="string">&quot;A2&quot;</span>: A2&#125;    </span><br><span class="line">    <span class="keyword">return</span> A2, cache</span><br></pre></td></tr></table></figure>
<p>计算损失函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute_cost</span>(<span class="params">A2, Y, parameters</span>):</span><br><span class="line">    m = Y.shape[<span class="number">1</span>] <span class="comment"># number of example</span></span><br><span class="line">    <span class="comment"># Compute the cross-entropy cost</span></span><br><span class="line">    logprobs = np.multiply(np.log(A2),Y) + np.multiply(np.log(<span class="number">1</span>-A2), <span class="number">1</span>-Y)</span><br><span class="line">    cost = -<span class="number">1</span>/m * np.<span class="built_in">sum</span>(logprobs)</span><br><span class="line">    cost = np.squeeze(cost)     <span class="comment"># makes sure cost is the dimension we expect.</span></span><br><span class="line">    <span class="keyword">assert</span>(<span class="built_in">isinstance</span>(cost, <span class="built_in">float</span>))    </span><br><span class="line">    <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure>
<p>反向传播函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backward_propagation</span>(<span class="params">parameters, cache, X, Y</span>):</span><br><span class="line">    m = X.shape[<span class="number">1</span>]    </span><br><span class="line">    <span class="comment"># First, retrieve W1 and W2 from the dictionary &quot;parameters&quot;.</span></span><br><span class="line">    W1 = parameters[<span class="string">&#x27;W1&#x27;</span>]</span><br><span class="line">    W2 = parameters[<span class="string">&#x27;W2&#x27;</span>]    </span><br><span class="line">    <span class="comment"># Retrieve also A1 and A2 from dictionary &quot;cache&quot;.</span></span><br><span class="line">    A1 = cache[<span class="string">&#x27;A1&#x27;</span>]</span><br><span class="line">    A2 = cache[<span class="string">&#x27;A2&#x27;</span>]    </span><br><span class="line">    <span class="comment"># Backward propagation: calculate dW1, db1, dW2, db2. </span></span><br><span class="line">    dZ2 = A2-Y</span><br><span class="line">    dW2 = <span class="number">1</span>/m * np.dot(dZ2, A1.T)</span><br><span class="line">    db2 = <span class="number">1</span>/m * np.<span class="built_in">sum</span>(dZ2, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    dZ1 = np.dot(W2.T, dZ2)*(<span class="number">1</span>-np.power(A1, <span class="number">2</span>))</span><br><span class="line">    dW1 = <span class="number">1</span>/m * np.dot(dZ1, X.T)</span><br><span class="line">    db1 = <span class="number">1</span>/m * np.<span class="built_in">sum</span>(dZ1, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    grads = &#123;<span class="string">&quot;dW1&quot;</span>: dW1,</span><br><span class="line">             <span class="string">&quot;db1&quot;</span>: db1,                      </span><br><span class="line">             <span class="string">&quot;dW2&quot;</span>: dW2,             </span><br><span class="line">             <span class="string">&quot;db2&quot;</span>: db2&#125;   </span><br><span class="line">    <span class="keyword">return</span> grads</span><br></pre></td></tr></table></figure>
<p>权值更新函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update_parameters</span>(<span class="params">parameters, grads, learning_rate = <span class="number">1.2</span></span>):</span><br><span class="line">    <span class="comment"># Retrieve each parameter from the dictionary &quot;parameters&quot;</span></span><br><span class="line">    W1 = parameters[<span class="string">&#x27;W1&#x27;</span>]</span><br><span class="line">    b1 = parameters[<span class="string">&#x27;b1&#x27;</span>]</span><br><span class="line">    W2 = parameters[<span class="string">&#x27;W2&#x27;</span>]</span><br><span class="line">    b2 = parameters[<span class="string">&#x27;b2&#x27;</span>]    </span><br><span class="line">    <span class="comment"># Retrieve each gradient from the dictionary &quot;grads&quot;</span></span><br><span class="line">    dW1 = grads[<span class="string">&#x27;dW1&#x27;</span>]</span><br><span class="line">    db1 = grads[<span class="string">&#x27;db1&#x27;</span>]</span><br><span class="line">    dW2 = grads[<span class="string">&#x27;dW2&#x27;</span>]</span><br><span class="line">    db2 = grads[<span class="string">&#x27;db2&#x27;</span>]    </span><br><span class="line">    <span class="comment"># Update rule for each parameter</span></span><br><span class="line">    W1 -= dW1 * learning_rate</span><br><span class="line">    b1 -= db1 * learning_rate</span><br><span class="line">    W2 -= dW2 * learning_rate</span><br><span class="line">    b2 -= db2 * learning_rate</span><br><span class="line">    parameters = &#123;<span class="string">&quot;W1&quot;</span>: W1, </span><br><span class="line">                  <span class="string">&quot;b1&quot;</span>: b1,            </span><br><span class="line">                  <span class="string">&quot;W2&quot;</span>: W2,   </span><br><span class="line">                  <span class="string">&quot;b2&quot;</span>: b2&#125;    </span><br><span class="line">    <span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure>
<p>最终的神经网络模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nn_model</span>(<span class="params">X, Y, n_h, num_iterations = <span class="number">10000</span>, print_cost=<span class="literal">False</span></span>):</span><br><span class="line">    np.random.seed(<span class="number">3</span>)</span><br><span class="line">    n_x = layer_sizes(X, Y)[<span class="number">0</span>]</span><br><span class="line">    n_y = layer_sizes(X, Y)[<span class="number">2</span>]    </span><br><span class="line">    <span class="comment"># Initialize parameters, then retrieve W1, b1, W2, b2. Inputs: &quot;n_x, n_h, n_y&quot;. Outputs = &quot;W1, b1, W2, b2, parameters&quot;.</span></span><br><span class="line">    parameters = initialize_parameters(n_x, n_h, n_y)</span><br><span class="line">    W1 = parameters[<span class="string">&#x27;W1&#x27;</span>]</span><br><span class="line">    b1 = parameters[<span class="string">&#x27;b1&#x27;</span>]</span><br><span class="line">    W2 = parameters[<span class="string">&#x27;W2&#x27;</span>]</span><br><span class="line">    b2 = parameters[<span class="string">&#x27;b2&#x27;</span>]    </span><br><span class="line">    <span class="comment"># Loop (gradient descent)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_iterations):        </span><br><span class="line">    <span class="comment"># Forward propagation. Inputs: &quot;X, parameters&quot;. Outputs: &quot;A2, cache&quot;.</span></span><br><span class="line">        A2, cache = forward_propagation(X, parameters)        </span><br><span class="line">        <span class="comment"># Cost function. Inputs: &quot;A2, Y, parameters&quot;. Outputs: &quot;cost&quot;.</span></span><br><span class="line">        cost = compute_cost(A2, Y, parameters)        </span><br><span class="line">        <span class="comment"># Backpropagation. Inputs: &quot;parameters, cache, X, Y&quot;. Outputs: &quot;grads&quot;.</span></span><br><span class="line">        grads = backward_propagation(parameters, cache, X, Y)        </span><br><span class="line">        <span class="comment"># Gradient descent parameter update. Inputs: &quot;parameters, grads&quot;. Outputs: &quot;parameters&quot;.</span></span><br><span class="line">        parameters = update_parameters(parameters, grads, learning_rate=<span class="number">1.2</span>)        </span><br><span class="line">        <span class="comment"># Print the cost every 1000 iterations</span></span><br><span class="line">        <span class="keyword">if</span> print_cost <span class="keyword">and</span> i % <span class="number">1000</span> == <span class="number">0</span>:            </span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;Cost after iteration %i: %f&quot;</span> %(i, cost))    </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Finds算法和ID3算法</title>
    <url>/201910/FINDS%E7%AE%97%E6%B3%95%E5%92%8CID3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h2><ol>
<li>实现<code>FINDS</code>算法</li>
<li>实现<code>ID3</code>算法</li>
</ol>
<ul>
<li>不要调库自己写。如果有能力可以继续用课件里的数据集测试两个算法（用天气的4条记录测试<code>FINDS</code>，用贷款的15条记录测试<code>ID3</code>）给出训练误差测试误差等；  </li>
<li>再有能力可以使用更大的数据集测试算法。</li>
</ul>
<span id="more"></span>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="FINDS算法"><a href="#FINDS算法" class="headerlink" title="FINDS算法"></a><code>FINDS</code>算法</h3><ol>
<li>目标：寻找极大特殊假设。</li>
<li>从假设集合H中最特殊的假设开始。在该假设不能正确地划分一个正例的时候将其进行一般化。算法如下：<br><img src="https://s2.ax1x.com/2019/10/22/K3ymOH.jpg" alt="算法流程"></li>
<li><code>FINDS</code>算法是一种利用<code>more-general-than</code>的偏序结构来搜索假设空间的方法，这一搜索沿着偏序链，从较特殊的假设逐渐演变为较一般的假设。</li>
<li>算法<code>Python</code>实现：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string"> Created on 2019/10/21 21:02</span></span><br><span class="line"><span class="string"> FINDS</span></span><br><span class="line"><span class="string"> @Author  : Zhouy</span></span><br><span class="line"><span class="string"> @Blog    : www.crocodilezs.top</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create dataset</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CreateDataset</span>():</span><br><span class="line">    dataset = [[<span class="string">&#x27;Sunny&#x27;</span>, <span class="string">&#x27;Warm&#x27;</span>, <span class="string">&#x27;Normal&#x27;</span>, <span class="string">&#x27;Strong&#x27;</span>, <span class="string">&#x27;Warm&#x27;</span>, <span class="string">&#x27;Same&#x27;</span>, <span class="string">&#x27;Yes&#x27;</span>],</span><br><span class="line">               [<span class="string">&#x27;Sunny&#x27;</span>, <span class="string">&#x27;Warm&#x27;</span>, <span class="string">&#x27;High&#x27;</span>, <span class="string">&#x27;Strong&#x27;</span>, <span class="string">&#x27;Warm&#x27;</span>, <span class="string">&#x27;Same&#x27;</span>, <span class="string">&#x27;Yes&#x27;</span>],</span><br><span class="line">               [<span class="string">&#x27;Rainy&#x27;</span>, <span class="string">&#x27;Cold&#x27;</span>, <span class="string">&#x27;High&#x27;</span>, <span class="string">&#x27;Strong&#x27;</span>, <span class="string">&#x27;Warm&#x27;</span>, <span class="string">&#x27;Change&#x27;</span>, <span class="string">&#x27;No&#x27;</span>],</span><br><span class="line">               [<span class="string">&#x27;Sunny&#x27;</span>, <span class="string">&#x27;Warm&#x27;</span>, <span class="string">&#x27;High&#x27;</span>, <span class="string">&#x27;Strong&#x27;</span>, <span class="string">&#x27;Cold&#x27;</span>, <span class="string">&#x27;Change&#x27;</span>, <span class="string">&#x27;Yes&#x27;</span>]]</span><br><span class="line">    labels = [<span class="string">&#x27;Sky&#x27;</span>, <span class="string">&#x27;Temp&#x27;</span>, <span class="string">&#x27;Humidity&#x27;</span>, <span class="string">&#x27;Wind&#x27;</span>, <span class="string">&#x27;Water&#x27;</span>, <span class="string">&#x27;Forest&#x27;</span>, <span class="string">&#x27;OutdoorSport&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> dataset, labels</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find one version space by using FINDS</span></span><br><span class="line"><span class="comment"># &#x27;/&#x27; means null, and &#x27;*&#x27; means generalization</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FINDS</span>(<span class="params">dataset</span>):</span><br><span class="line">    constraint = [<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;/&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> dataset:</span><br><span class="line">        <span class="keyword">if</span> item[-<span class="number">1</span>] == <span class="string">&#x27;Yes&#x27;</span>:</span><br><span class="line">            <span class="comment"># only go through positive instances</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(item)-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span>(item[i] != constraint[i] <span class="keyword">and</span> constraint[i] != <span class="string">&#x27;*&#x27;</span>):</span><br><span class="line">                    <span class="keyword">if</span>(constraint[i] == <span class="string">&#x27;/&#x27;</span>):</span><br><span class="line">                        constraint[i] = item[i]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        constraint[i] = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> constraint</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    dataset, labels = CreateDataset()</span><br><span class="line">    constraint = FINDS(dataset)</span><br><span class="line">    <span class="built_in">print</span>(constraint)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a><code>ID3</code>算法</h3><ol>
<li>决策树：决策树是一种常用的分类与回归方法。决策树的模型为树形结构，在针对分类问题时，实际上就是针对输入数据的各个特征对实例进行分类的过程，即通过树形结构的模型，在每一层级上对特征值进行判断，进而到达决策树叶子节点，即完成分类过程。<br><strong>决策树的本质是概念学习。</strong></li>
<li><p>信息熵（香浓熵）、条件熵和信息增益的概念</p>
<ul>
<li>信息量：一件事发生的概率越小，我们说它所蕴含的信息量越大。<br><img src="https://s2.ax1x.com/2019/10/22/K36VNq.jpg" alt="信息量"></li>
<li>信息熵：信息熵就是所有可能发生的事件的信息量的期望<br><img src="https://s2.ax1x.com/2019/10/22/K36EEn.jpg" alt="信息熵"></li>
<li>条件熵：表示在X给定条件下，Y的条件概率分布的熵对X的数学期望。<br>![条件熵(<a href="https://s2.ax1x.com/2019/10/22/K36FBj.jpg">https://s2.ax1x.com/2019/10/22/K36FBj.jpg</a>)</li>
<li>信息增益：当我们用另一个变量X对原变量Y分类后，原变量Y的不确定性就会减小了(即熵值减小)。而熵就是不确定性，不确定程度减少了多少其实就是信息增益。这就是信息增益的由来，所以信息增益定义如下：<br><img src="https://s2.ax1x.com/2019/10/22/K36kHs.jpg" alt="信息增益"></li>
</ul>
</li>
<li><p>算法’python’实现:<br>(用课件上的贷款数据集一直没法成功分类，于是参考了csdn博客的另一个数据集合代码)</p>
</li>
</ol>
<p><code>myTrees.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string"> Created on 2019/10/22 11:59</span></span><br><span class="line"><span class="string"> myTrees</span></span><br><span class="line"><span class="string"> @Author  : Zhouy</span></span><br><span class="line"><span class="string"> @Blog    : www.crocodilezs.top</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createDataSet</span>():</span><br><span class="line">    dataSet = [[<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;no&#x27;</span>]]</span><br><span class="line">    labels = [<span class="string">&#x27;no surfacing&#x27;</span>,<span class="string">&#x27;flippers&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> dataSet, labels</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多数表决器</span></span><br><span class="line"><span class="comment"># 列中相同值数量最多为结果</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">majorityCnt</span>(<span class="params">classList</span>):</span><br><span class="line">    classCounts = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> classList:</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">not</span> <span class="keyword">in</span> classCounts.keys()):</span><br><span class="line">            classCounts[value] = <span class="number">0</span></span><br><span class="line">        classCounts[value] += <span class="number">1</span></span><br><span class="line">    sortedClassCount = <span class="built_in">sorted</span>(classCounts.iteritems(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分数据集</span></span><br><span class="line"><span class="comment"># dataSet:原始数据集</span></span><br><span class="line"><span class="comment"># axis:进行分割的指定列索引</span></span><br><span class="line"><span class="comment"># value:指定列中的值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">splitDataSet</span>(<span class="params">dataSet, axis, value</span>):</span><br><span class="line">    retDataSet = []</span><br><span class="line">    <span class="keyword">for</span> featDataVal <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">if</span> featDataVal[axis] == value:</span><br><span class="line">            <span class="comment"># 下面两行去除某一项指定列的值，很巧妙有没有</span></span><br><span class="line">            reducedFeatVal = featDataVal[:axis]</span><br><span class="line">            reducedFeatVal.extend(featDataVal[axis + <span class="number">1</span>:])</span><br><span class="line">            retDataSet.append(reducedFeatVal)</span><br><span class="line">    <span class="keyword">return</span> retDataSet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算香农熵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calcShannonEnt</span>(<span class="params">dataSet</span>):</span><br><span class="line">    <span class="comment"># 数据集总项数</span></span><br><span class="line">    numEntries = <span class="built_in">len</span>(dataSet)</span><br><span class="line">    <span class="comment"># 标签计数对象初始化</span></span><br><span class="line">    labelCounts = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> featDataVal <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="comment"># 获取数据集每一项的最后一列的标签值</span></span><br><span class="line">        currentLabel = featDataVal[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 如果当前标签不在标签存储对象里，则初始化，然后计数</span></span><br><span class="line">        <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys():</span><br><span class="line">            labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">        labelCounts[currentLabel] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 熵初始化</span></span><br><span class="line">    shannonEnt = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># 遍历标签对象，求概率，计算熵</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts.keys():</span><br><span class="line">        prop = labelCounts[key] / <span class="built_in">float</span>(numEntries)</span><br><span class="line">        shannonEnt -= prop * log(prop, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> shannonEnt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选出最优特征列索引</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chooseBestFeatureToSplit</span>(<span class="params">dataSet</span>):</span><br><span class="line">    <span class="comment"># 计算特征个数，dataSet最后一列是标签属性，不是特征量</span></span><br><span class="line">    numFeatures = <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 计算初始数据香农熵</span></span><br><span class="line">    baseEntropy = calcShannonEnt(dataSet)</span><br><span class="line">    <span class="comment"># 初始化信息增益，最优划分特征列索引</span></span><br><span class="line">    bestInfoGain = <span class="number">0.0</span></span><br><span class="line">    bestFeatureIndex = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFeatures):</span><br><span class="line">        <span class="comment"># 获取每一列数据</span></span><br><span class="line">        featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">        <span class="comment"># 将每一列数据去重</span></span><br><span class="line">        uniqueVals = <span class="built_in">set</span>(featList)</span><br><span class="line">        newEntropy = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">            subDataSet = splitDataSet(dataSet, i, value)</span><br><span class="line">            <span class="comment"># 计算条件概率</span></span><br><span class="line">            prob = <span class="built_in">len</span>(subDataSet) / <span class="built_in">float</span>(<span class="built_in">len</span>(dataSet))</span><br><span class="line">            <span class="comment"># 计算条件熵</span></span><br><span class="line">            newEntropy += prob * calcShannonEnt(subDataSet)</span><br><span class="line">        <span class="comment"># 计算信息增益</span></span><br><span class="line">        infoGain = baseEntropy - newEntropy</span><br><span class="line">        <span class="keyword">if</span> (infoGain &gt; bestInfoGain):</span><br><span class="line">            bestInfoGain = infoGain</span><br><span class="line">            bestFeatureIndex = i</span><br><span class="line">    <span class="keyword">return</span> bestFeatureIndex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 决策树创建</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createTree</span>(<span class="params">dataSet, labels</span>):</span><br><span class="line">    <span class="comment"># 获取标签属性，dataSet最后一列，区别于labels标签名称</span></span><br><span class="line">    classList = [example[-<span class="number">1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    <span class="comment"># 树极端终止条件判断</span></span><br><span class="line">    <span class="comment"># 标签属性值全部相同，返回标签属性第一项值</span></span><br><span class="line">    <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == <span class="built_in">len</span>(classList):</span><br><span class="line">        <span class="keyword">return</span> classList[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 只有一个特征（1列）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> majorityCnt(classList)</span><br><span class="line">    <span class="comment"># 获取最优特征列索引</span></span><br><span class="line">    bestFeatureIndex = chooseBestFeatureToSplit(dataSet)</span><br><span class="line">    <span class="comment"># 获取最优索引对应的标签名称</span></span><br><span class="line">    bestFeatureLabel = labels[bestFeatureIndex]</span><br><span class="line">    <span class="comment"># 创建根节点</span></span><br><span class="line">    myTree = &#123;bestFeatureLabel: &#123;&#125;&#125;</span><br><span class="line">    <span class="comment"># 去除最优索引对应的标签名，使labels标签能正确遍历</span></span><br><span class="line">    <span class="keyword">del</span> (labels[bestFeatureIndex])</span><br><span class="line">    <span class="comment"># 获取最优列</span></span><br><span class="line">    bestFeature = [example[bestFeatureIndex] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    uniquesVals = <span class="built_in">set</span>(bestFeature)</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniquesVals:</span><br><span class="line">        <span class="comment"># 子标签名称集合</span></span><br><span class="line">        subLabels = labels[:]</span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        myTree[bestFeatureLabel][value] = createTree(splitDataSet(dataSet, bestFeatureIndex, value), subLabels)</span><br><span class="line">    <span class="keyword">return</span> myTree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取分类结果</span></span><br><span class="line"><span class="comment"># inputTree:决策树字典</span></span><br><span class="line"><span class="comment"># featLabels:标签列表</span></span><br><span class="line"><span class="comment"># testVec:测试向量  例如：简单实例下某一路径 [1,1]  =&gt; yes（树干值组合，从根结点到叶子节点）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify</span>(<span class="params">inputTree, featLabels, testVec</span>):</span><br><span class="line">    <span class="comment"># 获取根结点名称，将dict转化为list</span></span><br><span class="line">    firstSide = <span class="built_in">list</span>(inputTree.keys())</span><br><span class="line">    <span class="comment"># 根结点名称String类型</span></span><br><span class="line">    firstStr = firstSide[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 获取根结点对应的子节点</span></span><br><span class="line">    secondDict = inputTree[firstStr]</span><br><span class="line">    <span class="comment"># 获取根结点名称在标签列表中对应的索引</span></span><br><span class="line">    featIndex = featLabels.index(firstStr)</span><br><span class="line">    <span class="comment"># 由索引获取向量表中的对应值</span></span><br><span class="line">    key = testVec[featIndex]</span><br><span class="line">    <span class="comment"># 获取树干向量后的对象</span></span><br><span class="line">    valueOfFeat = secondDict[key]</span><br><span class="line">    <span class="comment"># 判断是子结点还是叶子节点：子结点就回调分类函数，叶子结点就是分类结果</span></span><br><span class="line">    <span class="comment"># if type(valueOfFeat).__name__==&#x27;dict&#x27;: 等价 if isinstance(valueOfFeat, dict):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(valueOfFeat, <span class="built_in">dict</span>):</span><br><span class="line">        classLabel = classify(valueOfFeat, featLabels, testVec)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        classLabel = valueOfFeat</span><br><span class="line">    <span class="keyword">return</span> classLabel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将决策树分类器存储在磁盘中，filename一般保存为txt格式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">storeTree</span>(<span class="params">inputTree, filename</span>):</span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line">    fw = <span class="built_in">open</span>(filename, <span class="string">&#x27;wb+&#x27;</span>)</span><br><span class="line">    pickle.dump(inputTree, fw)</span><br><span class="line">    fw.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将瓷盘中的对象加载出来，这里的filename就是上面函数中的txt文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grabTree</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line">    fr = <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> pickle.load(fr)</span><br></pre></td></tr></table></figure>
<p><code>treePlotter.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string"> Created on 2019/10/22 12:00</span></span><br><span class="line"><span class="string"> treePlotter</span></span><br><span class="line"><span class="string"> @Author  : Zhouy</span></span><br><span class="line"><span class="string"> @Blog    : www.crocodilezs.top</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">decisionNode = <span class="built_in">dict</span>(boxstyle=<span class="string">&quot;sawtooth&quot;</span>, fc=<span class="string">&quot;0.8&quot;</span>)</span><br><span class="line">leafNode = <span class="built_in">dict</span>(boxstyle=<span class="string">&quot;round4&quot;</span>, fc=<span class="string">&quot;0.8&quot;</span>)</span><br><span class="line">arrow_args = <span class="built_in">dict</span>(arrowstyle=<span class="string">&quot;&lt;-&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取树的叶子节点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getNumLeafs</span>(<span class="params">myTree</span>):</span><br><span class="line">    numLeafs = <span class="number">0</span></span><br><span class="line">    <span class="comment"># dict转化为list</span></span><br><span class="line">    firstSides = <span class="built_in">list</span>(myTree.keys())</span><br><span class="line">    firstStr = firstSides[<span class="number">0</span>]</span><br><span class="line">    secondDict = myTree[firstStr]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">        <span class="comment"># 判断是否是叶子节点（通过类型判断，子类不存在，则类型为str；子类存在，则为dict）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(secondDict[</span><br><span class="line">                    key]).__name__ == <span class="string">&#x27;dict&#x27;</span>:  <span class="comment"># test to see if the nodes are dictonaires, if not they are leaf nodes</span></span><br><span class="line">            numLeafs += getNumLeafs(secondDict[key])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            numLeafs += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> numLeafs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取树的层数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getTreeDepth</span>(<span class="params">myTree</span>):</span><br><span class="line">    maxDepth = <span class="number">0</span></span><br><span class="line">    <span class="comment"># dict转化为list</span></span><br><span class="line">    firstSides = <span class="built_in">list</span>(myTree.keys())</span><br><span class="line">    firstStr = firstSides[<span class="number">0</span>]</span><br><span class="line">    secondDict = myTree[firstStr]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(secondDict[</span><br><span class="line">                    key]).__name__ == <span class="string">&#x27;dict&#x27;</span>:  <span class="comment"># test to see if the nodes are dictonaires, if not they are leaf nodes</span></span><br><span class="line">            thisDepth = <span class="number">1</span> + getTreeDepth(secondDict[key])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            thisDepth = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> thisDepth &gt; maxDepth: maxDepth = thisDepth</span><br><span class="line">    <span class="keyword">return</span> maxDepth</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plotNode</span>(<span class="params">nodeTxt, centerPt, parentPt, nodeType</span>):</span><br><span class="line">    createPlot.ax1.annotate(nodeTxt, xy=parentPt, xycoords=<span class="string">&#x27;axes fraction&#x27;</span>,</span><br><span class="line">                            xytext=centerPt, textcoords=<span class="string">&#x27;axes fraction&#x27;</span>,</span><br><span class="line">                            va=<span class="string">&quot;center&quot;</span>, ha=<span class="string">&quot;center&quot;</span>, bbox=nodeType, arrowprops=arrow_args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plotMidText</span>(<span class="params">cntrPt, parentPt, txtString</span>):</span><br><span class="line">    xMid = (parentPt[<span class="number">0</span>] - cntrPt[<span class="number">0</span>]) / <span class="number">2.0</span> + cntrPt[<span class="number">0</span>]</span><br><span class="line">    yMid = (parentPt[<span class="number">1</span>] - cntrPt[<span class="number">1</span>]) / <span class="number">2.0</span> + cntrPt[<span class="number">1</span>]</span><br><span class="line">    createPlot.ax1.text(xMid, yMid, txtString, va=<span class="string">&quot;center&quot;</span>, ha=<span class="string">&quot;center&quot;</span>, rotation=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plotTree</span>(<span class="params">myTree, parentPt, nodeTxt</span>):  <span class="comment"># if the first key tells you what feat was split on</span></span><br><span class="line">    numLeafs = getNumLeafs(myTree)  <span class="comment"># this determines the x width of this tree</span></span><br><span class="line">    depth = getTreeDepth(myTree)</span><br><span class="line">    firstSides = <span class="built_in">list</span>(myTree.keys())</span><br><span class="line">    firstStr = firstSides[<span class="number">0</span>]  <span class="comment"># the text label for this node should be this</span></span><br><span class="line">    cntrPt = (plotTree.xOff + (<span class="number">1.0</span> + <span class="built_in">float</span>(numLeafs)) / <span class="number">2.0</span> / plotTree.totalW, plotTree.yOff)</span><br><span class="line">    plotMidText(cntrPt, parentPt, nodeTxt)</span><br><span class="line">    plotNode(firstStr, cntrPt, parentPt, decisionNode)</span><br><span class="line">    secondDict = myTree[firstStr]</span><br><span class="line">    plotTree.yOff = plotTree.yOff - <span class="number">1.0</span> / plotTree.totalD</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(secondDict[</span><br><span class="line">                    key]).__name__ == <span class="string">&#x27;dict&#x27;</span>:  <span class="comment"># test to see if the nodes are dictonaires, if not they are leaf nodes</span></span><br><span class="line">            plotTree(secondDict[key], cntrPt, <span class="built_in">str</span>(key))  <span class="comment"># recursion</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># it&#x27;s a leaf node print the leaf node</span></span><br><span class="line">            plotTree.xOff = plotTree.xOff + <span class="number">1.0</span> / plotTree.totalW</span><br><span class="line">            plotNode(secondDict[key], (plotTree.xOff, plotTree.yOff), cntrPt, leafNode)</span><br><span class="line">            plotMidText((plotTree.xOff, plotTree.yOff), cntrPt, <span class="built_in">str</span>(key))</span><br><span class="line">    plotTree.yOff = plotTree.yOff + <span class="number">1.0</span> / plotTree.totalD</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># if you do get a dictonary you know it&#x27;s a tree, and the first element will be another dict</span></span><br><span class="line"><span class="comment"># 绘制决策树</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createPlot</span>(<span class="params">inTree</span>):</span><br><span class="line">    fig = plt.figure(<span class="number">1</span>, facecolor=<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">    fig.clf()</span><br><span class="line">    axprops = <span class="built_in">dict</span>(xticks=[], yticks=[])</span><br><span class="line">    createPlot.ax1 = plt.subplot(<span class="number">111</span>, frameon=<span class="literal">False</span>, **axprops)  <span class="comment"># no ticks</span></span><br><span class="line">    <span class="comment"># createPlot.ax1 = plt.subplot(111, frameon=False) #ticks for demo puropses</span></span><br><span class="line">    plotTree.totalW = <span class="built_in">float</span>(getNumLeafs(inTree))</span><br><span class="line">    plotTree.totalD = <span class="built_in">float</span>(getTreeDepth(inTree))</span><br><span class="line">    plotTree.xOff = -<span class="number">0.5</span> / plotTree.totalW</span><br><span class="line">    plotTree.yOff = <span class="number">1.0</span></span><br><span class="line">    plotTree(inTree, (<span class="number">0.5</span>, <span class="number">1.0</span>), <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制树的根节点和叶子节点（根节点形状：长方形，叶子节点：椭圆形）</span></span><br><span class="line"><span class="comment"># def createPlot():</span></span><br><span class="line"><span class="comment">#    fig = plt.figure(1, facecolor=&#x27;white&#x27;)</span></span><br><span class="line"><span class="comment">#    fig.clf()</span></span><br><span class="line"><span class="comment">#    createPlot.ax1 = plt.subplot(111, frameon=False) #ticks for demo puropses</span></span><br><span class="line"><span class="comment">#    plotNode(&#x27;a decision node&#x27;, (0.5, 0.1), (0.1, 0.5), decisionNode)</span></span><br><span class="line"><span class="comment">#    plotNode(&#x27;a leaf node&#x27;, (0.8, 0.1), (0.3, 0.8), leafNode)</span></span><br><span class="line"><span class="comment">#    plt.show()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">retrieveTree</span>(<span class="params">i</span>):</span><br><span class="line">    listOfTrees = [&#123;<span class="string">&#x27;no surfacing&#x27;</span>: &#123;<span class="number">0</span>: <span class="string">&#x27;no&#x27;</span>, <span class="number">1</span>: &#123;<span class="string">&#x27;flippers&#x27;</span>: &#123;<span class="number">0</span>: <span class="string">&#x27;no&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;yes&#x27;</span>&#125;&#125;&#125;&#125;,</span><br><span class="line">                   &#123;<span class="string">&#x27;no surfacing&#x27;</span>: &#123;<span class="number">0</span>: <span class="string">&#x27;no&#x27;</span>, <span class="number">1</span>: &#123;<span class="string">&#x27;flippers&#x27;</span>: &#123;<span class="number">0</span>: &#123;<span class="string">&#x27;head&#x27;</span>: &#123;<span class="number">0</span>: <span class="string">&#x27;no&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;yes&#x27;</span>&#125;&#125;, <span class="number">1</span>: <span class="string">&#x27;no&#x27;</span>&#125;&#125;&#125;&#125;</span><br><span class="line">                   ]</span><br><span class="line">    <span class="keyword">return</span> listOfTrees[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># thisTree = retrieveTree(0)</span></span><br><span class="line"><span class="comment"># createPlot(thisTree)</span></span><br><span class="line"><span class="comment"># createPlot()</span></span><br><span class="line"><span class="comment"># myTree = retrieveTree(0)</span></span><br><span class="line"><span class="comment"># numLeafs =getNumLeafs(myTree)</span></span><br><span class="line"><span class="comment"># treeDepth =getTreeDepth(myTree)</span></span><br><span class="line"><span class="comment"># print(u&quot;叶子节点数目：%d&quot;% numLeafs)</span></span><br><span class="line"><span class="comment"># print(u&quot;树深度：%d&quot;%treeDepth)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>testTrees_3.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string"> Created on 2019/10/22 12:00</span></span><br><span class="line"><span class="string"> testTrees_3</span></span><br><span class="line"><span class="string"> @Author  : Zhouy</span></span><br><span class="line"><span class="string"> @Blog    : www.crocodilezs.top</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> myTrees <span class="keyword">as</span> mt</span><br><span class="line"><span class="keyword">import</span> treePlotter <span class="keyword">as</span> tp</span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">dataSet, labels = mt.createDataSet()</span><br><span class="line"><span class="comment">#copy函数：新开辟一块内存，然后将list的所有值复制到新开辟的内存中</span></span><br><span class="line">labels1 = labels.copy()</span><br><span class="line"><span class="comment">#createTree函数中将labels1的值改变了，所以在分类测试时不能用labels1</span></span><br><span class="line">myTree = mt.createTree(dataSet,labels1)</span><br><span class="line"><span class="comment">#保存树到本地</span></span><br><span class="line">mt.storeTree(myTree,<span class="string">&#x27;myTree.txt&#x27;</span>)</span><br><span class="line"><span class="comment">#在本地磁盘获取树</span></span><br><span class="line">myTree = mt.grabTree(<span class="string">&#x27;myTree.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">u&quot;决策树结构：%s&quot;</span>%myTree)</span><br><span class="line"><span class="comment">#绘制决策树</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">u&quot;绘制决策树：&quot;</span>)</span><br><span class="line">tp.createPlot(myTree)</span><br><span class="line">numLeafs =tp.getNumLeafs(myTree)</span><br><span class="line">treeDepth =tp.getTreeDepth(myTree)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">u&quot;叶子节点数目：%d&quot;</span>% numLeafs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">u&quot;树深度：%d&quot;</span>%treeDepth)</span><br><span class="line"><span class="comment">#测试分类 简单样本数据3列</span></span><br><span class="line">labelResult =mt.classify(myTree,labels,[<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">u&quot;[1,1] 测试结果为：%s&quot;</span>%labelResult)</span><br><span class="line">labelResult =mt.classify(myTree,labels,[<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">u&quot;[1,0] 测试结果为：%s&quot;</span>%labelResult)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>FindS</tag>
        <tag>ID3</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统基础实验一、Linux环境和GCC工具链</title>
    <url>/201910/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
    <content><![CDATA[<h1 id="Linux操作系统概述和实验环境介绍"><a href="#Linux操作系统概述和实验环境介绍" class="headerlink" title="Linux操作系统概述和实验环境介绍"></a><code>Linux</code>操作系统概述和实验环境介绍</h1><h2 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h2><p><code>OS</code>是管理和控制计算机硬件与软件资源的计算机程序，是直接在“裸机”上的最基本的系统软件。</p>
<h2 id="Linux的应用"><a href="#Linux的应用" class="headerlink" title="Linux的应用"></a><code>Linux</code>的应用</h2><ol>
<li>服务器端：Linux非常稳定，特别适合大型企业生产环境。</li>
<li>作为网络平台的后端服务器被使用。</li>
<li>作为应用服务器、数据库服务器被使用：解决海量数据、高并发的问题；</li>
<li>作为嵌入式操作系统被使用：智能控制、自动化、物联网等领域。</li>
</ol>
<span id="more"></span>
<h2 id="Linux历史"><a href="#Linux历史" class="headerlink" title="Linux历史"></a><code>Linux</code>历史</h2><p>追溯到<code>UNIX</code><br>简单地说，<code>Linux</code>是对<code>UNIX</code>的重新实现。世界各地的<code>Linux</code>开发人员借鉴了<code>UNIX</code>的技术和用户界面，并且融入了很多独创的技术。<code>Linux</code>不属于<code>BSD</code>和<code>AT&amp;T</code>风格的<code>UNIX</code>中的任何一种。因此，严格来说，<code>Linux</code>是有别于<code>UNIX</code>的另一种操作系统。</p>
<h2 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a><code>Linux</code>简介</h2><p><code>Linux</code>发现行版本举例：<code>Ubuntu</code>、<code>redhat</code></p>
<h2 id="操作系统的三个部分"><a href="#操作系统的三个部分" class="headerlink" title="操作系统的三个部分"></a>操作系统的三个部分</h2><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><p>操作系统五大管理功能一般都由操作系统内核负责。</p>
<h3 id="外壳"><a href="#外壳" class="headerlink" title="外壳"></a>外壳</h3><ul>
<li>外壳程序负责接收用户操作，提供与 用户的交互界面。</li>
<li>一般操作系统提供给用户的界面主要有两种：文本界面、<code>GUI</code>图形界面。<h3 id="管理工具和附属软件"><a href="#管理工具和附属软件" class="headerlink" title="管理工具和附属软件"></a>管理工具和附属软件</h3></li>
</ul>
<h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><ol>
<li><code>CPU</code>的控制与管理：处理器管理</li>
<li>内存的分配与管理：存储器管理</li>
<li>外部设备的控制与管理：设备管理</li>
<li>文件管理</li>
<li>作业管理和控制：用户接口</li>
</ol>
<h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a><code>Shell</code></h2><ol>
<li>外壳程序对用户的输入命令进行解释，为用户提供一种通过操作系统使用计算机的操作环境。</li>
<li><code>Windows</code>的图形界面，由一个成为<code>Explorer</code>的模块解释用户的输入。</li>
<li>如<code>DOS</code>的命令行界面，<code>Command.com</code>是对命令输入进行解释的外壳程序(<code>Linux</code>的<code>Shell</code>)</li>
<li>Shell命令：从命令行输入语句，每输入一次就能得到一次响应，这些语句就是<code>shell</code>命令。</li>
<li><code>Shell</code>程序：又称<code>Shell</code>脚本。（把一系列的<code>shell</code>命令，按照一定的语法规则和控制结构，组织在一个文件中，然后由内核来一条接一条地解释和执行这些命令，这个文件就是shell程序，类似<code>DOS</code>/<code>Winsows</code>中的。bat批处理文件。）</li>
<li>[username@computername ~]$<br>user name为当前用户名，computername 为当前计算机名 ，$表示当前用户是一般用户。 <h2 id="ssh-secure-shell"><a href="#ssh-secure-shell" class="headerlink" title="ssh secure shell"></a><code>ssh</code> secure shell</h2>把<code>Linux</code>终端搬到<code>Windows</code>下，连接到BUPT1.<h2 id="Shell常用命令"><a href="#Shell常用命令" class="headerlink" title="Shell常用命令"></a><code>Shell</code>常用命令</h2><h3 id="目录操作命令"><a href="#目录操作命令" class="headerlink" title="目录操作命令"></a>目录操作命令</h3>目录操作命令能够对当前的目录进行查看、创建、删除，以及显示当前工作目录和改变当前目录等操作。</li>
</ol>
<div note="class info">
    1. /etc - 系统所需的重要配置和管理文件<br />
    2. /dev - 存放device file（装置文件）<br />
    3. /boot - 存放系统激活的相关文件，不可任意删除。<br />
    4. /home - 登陆用户的主目录<br />
    5. /lib - 存放系统激活时需要的系统函数库<br />
    6. /usr/lib - 存放一些应用程序的共享函数库<br />
    7. /mnt - 系统默认的挂载点(mount point)
    8. /proc - 虚拟文件系统，不占用硬盘空间，目录下的文件均放置于内存中<br />
    9. /root - 系统管理用户root的主目录<br />
    10. /bin - 存放一些系统启动时所需的普通程序和系统程序<br />
    11. /tmp - 存放临时文件
    12. /var - 存放被系统修改过的数据。
</div>

<p>常用的目录操作命令包括：</p>
<ol>
<li>pwd 打印当前工作目录</li>
<li>cd 改变当前所在目录</li>
<li>ls 查看当前目录下的内容</li>
<li>dir 类似ls命令</li>
<li>mkdir 创建目录</li>
<li>rmdir 删除空目录</li>
</ol>
<h3 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h3><ul>
<li>在命令行环境下对文件进行操作将比在图形环境下操作文件更加快捷和高效</li>
<li>文件操作主要包括：搜索文件、复制和移动文件、删除文件以及合并文件内容</li>
</ul>
<p>常用文件操作命令：  </p>
<ul>
<li><code>cat</code>  </li>
<li><code>more</code>  </li>
<li><code>less</code>  </li>
<li><code>head</code></li>
<li><code>tail</code></li>
<li><code>cp</code></li>
<li><code>mv</code></li>
<li><code>rm</code></li>
<li><code>find</code></li>
<li><code>touch</code></li>
<li><code>ln</code></li>
</ul>
<h3 id="使用帮助命令"><a href="#使用帮助命令" class="headerlink" title="使用帮助命令"></a>使用帮助命令</h3><ol>
<li><code>man 命令名</code> </li>
<li><code>whatis 命令名</code>  </li>
<li><code>help 命令名</code>：适用于部分命令</li>
</ol>
<h2 id="Vi编辑器"><a href="#Vi编辑器" class="headerlink" title="Vi编辑器"></a>Vi编辑器</h2><h3 id="Vi简介"><a href="#Vi简介" class="headerlink" title="Vi简介"></a><code>Vi</code>简介</h3><ul>
<li><code>Vi</code>编辑器是<code>Visual interface</code>的简称，它可以执行输出、删除、查找、替换、块操作等众多文本操作</li>
<li><code>Vi</code>不是一个排版程序，只是一个文本编辑程序。</li>
<li>是全屏幕文本编辑器，没有菜单，只有命令。</li>
</ul>
<h3 id="Vi的基本概念"><a href="#Vi的基本概念" class="headerlink" title="Vi的基本概念"></a><code>Vi</code>的基本概念</h3><ol>
<li>命令行模式（command mode）<br>控制屏幕光标的移动、字符、字或行的删除、移动复制某区段及进入<code>Insert mode</code>下，或者到<code>last line mode</code>。</li>
<li>插入模式（Insert mode）<br>只有在<code>Insert mode</code>下，才可以做文字输入，按ESC键可回到命令行模式。</li>
<li>底行模式(last line mode)<br>将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号。</li>
</ol>
<div class="note info">
    $ vi test.txt<br />
    即可进入vi（打开或新建文件）
</div>

<p>操作：</p>
<ol>
<li>命令行模式 —-&gt;(i)  插入模式</li>
<li>插入模式  —-&gt;（ESC）  命令行模式</li>
<li>如果处于「插入模式」，就只能一直输入文字，如果发现输错了字想用光标往回移动将该字删除，就得先回到「命令行模式」</li>
<li>在「命令行模式」下，按下：进入底行模式<br><code>: w filename</code><br><code>: wq</code><br><code>: q!</code></li>
</ol>
<h2 id="GCC工具链"><a href="#GCC工具链" class="headerlink" title="GCC工具链"></a><code>GCC</code>工具链</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol>
<li><code>GCC</code>编译器能将<code>C</code>和<code>C++</code>语言源程序、汇编程序编译、链接成可执行文件。</li>
<li>使用<code>GCC</code>编译器时，编译过程可以被细分为四个阶段：<ul>
<li>预处理(Pre-Processing)</li>
<li>编译(Compiling)</li>
<li>汇编(Assembling)</li>
<li>链接(Linking)</li>
</ul>
</li>
</ol>
<h3 id="GDB的概述"><a href="#GDB的概述" class="headerlink" title="GDB的概述"></a><code>GDB</code>的概述</h3><p><code>GDB</code>是一款GNU开发组织并发布的UNIX/Linux下的程序调试工具。它使你能够在程序运行时观察程序的内部结构和内存的使用情况。以下是<code>GDB</code>提供的一些功能：</p>
<ol>
<li>监视程序中变量的值</li>
<li>设置断点以使程序在指定的代码行上停止运行</li>
<li>能逐行执行代码</li>
</ol>
<h2 id="Objdump简介"><a href="#Objdump简介" class="headerlink" title="Objdump简介"></a><code>Objdump</code>简介</h2><p><code>Objdump</code>是以一种可阅读的格式让你更多地了解二进制文件可能带有地附加信息。<br>对于想进一步了解系统地程序员，这个命令没有没有更多意义，对于想进一步了解系统的程序员，应该掌握这种工具，至少你可以自己写写<code>shellcode</code>了，或者看看人家给的<code>exploit</code>中的<code>shellcode</code>是什么东西。<br><strong>把C语言源代码编译链接生成的可执行程序反汇编后得到对应的汇编代码，可以帮助我们理解C语言和汇编语言之间的对应关系。非常有助于深入理解C语言</strong></p>
<div class="note warning">
    至此，已经完成了计算机系统基础第一次实验的理论部分，其中有太多的东西还需要自己去实践、接下来开始实验！
</div>]]></content>
      <categories>
        <category>计算机系统基础</category>
      </categories>
  </entry>
  <entry>
    <title>KNN与Naive_Bayes代码实现</title>
    <url>/201911/KNN%E4%B8%8ENaive_Bayes%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h2><p>采用Python实现分类算法：</p>
<ul>
<li>不得借助现成的工具包调库，例如SKlearn</li>
<li>至少实现k-近邻，朴素贝叶斯，逻辑回归，决策树与支持向量机中的其中一个算法。k-临近，朴素贝叶斯相对较简单，逻辑回归，决策树与支持向量机相对较难。</li>
<li>对breast cancer数据集调用编写的函数进行分类演示。</li>
<li>能力强的可以多实现几种算法</li>
</ul>
<span id="more"></span>
<h2 id="算法实现——kNN"><a href="#算法实现——kNN" class="headerlink" title="算法实现——kNN"></a>算法实现——kNN</h2><p>利用breast_cancer中的数据，实现kNN算法。  </p>
<ol>
<li>导入数据集，并分为训练集和测试集</li>
<li>实现kNN算法<ul>
<li>对每一个测试集中的实例，计算它距离训练集中的点的距离</li>
<li>根据选定的k值，选择距离最近的k个点数量更多的“标签”</li>
</ul>
</li>
<li>算法效果测试，测试算法的精确度，和SKlearn提供的kNN算法进行比较。</li>
</ol>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> neighbors</span><br><span class="line"></span><br><span class="line">datasets = datasets.load_breast_cancer()</span><br><span class="line">X = datasets.data;</span><br><span class="line">y = datasets.target;</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.3</span>, random_state = <span class="number">0</span>)</span><br><span class="line">k = <span class="number">5</span></span><br><span class="line"><span class="comment"># print(datasets.DESCR)</span></span><br><span class="line"><span class="comment"># malignant - 0, benign - 1</span></span><br><span class="line">y_predict = []</span><br></pre></td></tr></table></figure>
<h3 id="kNN算法实现"><a href="#kNN算法实现" class="headerlink" title="kNN算法实现"></a>kNN算法实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knn</span>(<span class="params">X_train, y_train, X_test, y_predict</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    对测试集的数据进行预测，得到的结果与y_test比较。用欧式距离进行计算。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> test_data <span class="keyword">in</span> X_test:</span><br><span class="line">        first_k_instance = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X_train)):</span><br><span class="line">            distance = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> attributes_no <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X_train[<span class="number">0</span>])):</span><br><span class="line">                distance += (test_data[attributes_no] - X_train[i][attributes_no]) ** <span class="number">2</span></span><br><span class="line">            Euclid_distance = distance ** <span class="number">0.5</span></span><br><span class="line">            <span class="comment">#print(Euclid_distance)</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; k:</span><br><span class="line">                first_k_instance.append((i, Euclid_distance))</span><br><span class="line">            <span class="keyword">elif</span> Euclid_distance &lt; first_k_instance[k-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                first_k_instance[k-<span class="number">1</span>] = (i, Euclid_distance)</span><br><span class="line">            first_k_instance = <span class="built_in">sorted</span>(first_k_instance, key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>]) </span><br><span class="line">            <span class="comment">#print(first_k_instance)</span></span><br><span class="line">        <span class="comment"># 现在得到了距离测试点最近的k个点，用多数表决器来判断测试点是良性还是恶性</span></span><br><span class="line">        benign = <span class="number">0</span></span><br><span class="line">        malignant = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> instance <span class="keyword">in</span> first_k_instance:</span><br><span class="line">            <span class="keyword">if</span> y_train[instance[<span class="number">0</span>]] == <span class="number">0</span>:</span><br><span class="line">                malignant += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                benign += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> malignant &gt;= benign:</span><br><span class="line">            y_predict.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y_predict.append(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="精确度计算函数"><a href="#精确度计算函数" class="headerlink" title="精确度计算函数"></a>精确度计算函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">y_predict, y_test</span>):</span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_predict)):</span><br><span class="line">        <span class="keyword">if</span> y_predict[i] == y_test[i]:</span><br><span class="line">            correct += <span class="number">1</span></span><br><span class="line">    accuracy_rate = correct / <span class="built_in">len</span>(y_predict)</span><br><span class="line">    <span class="keyword">return</span> correct, accuracy_rate</span><br></pre></td></tr></table></figure>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    knn(X_train, y_train, X_test, y_predict)</span><br><span class="line">    correct, accuracy_rate = accuracy(y_predict, y_test)</span><br><span class="line">    <span class="built_in">print</span>(y_predict)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kNN模型测试集预测的准确率为：%.3f&quot;</span> % accuracy_rate);</span><br><span class="line">    KNN = neighbors.KNeighborsClassifier(n_neighbors = <span class="number">5</span>)</span><br><span class="line">    KNN.fit(X_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sklearn库中kNN模型预测的准确率为：%.3f&quot;</span> % KNN.score(X_test, y_test));</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<pre><code>[0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1]
kNN模型测试集预测的准确率为：0.947
sklearn库中kNN模型预测的准确率为：0.947
</code></pre><p>通过实验结果可以发现，我们实现的kNN与SKlearn中提供的kNN效果一致。<br>我们可以通过设置k的值和转换寻找相似样本的策略（将欧式距离替换为匹配系数或Jaccard等），进一步优化精确度。</p>
<h2 id="算法实现——Naive-Bayes"><a href="#算法实现——Naive-Bayes" class="headerlink" title="算法实现——Naive_Bayes"></a>算法实现——Naive_Bayes</h2><p>利用breast_cancer中的数据，实现Naive_Bayes算法。  </p>
<ol>
<li>导入数据集，并分为训练集和测试集</li>
<li>实现Naive Bayes算法<ul>
<li>把连续的属性划分区间，计算正例和反例落在每个属性的每个区间的个数</li>
<li>计算概率值，预测测试集的标签</li>
</ul>
</li>
<li>算法效果测试，测试算法的精确度，和SKlearn提供的Naive Bayes算法进行比较。</li>
</ol>
<h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><h3 id="导入数据-1"><a href="#导入数据-1" class="headerlink" title="导入数据"></a>导入数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load datasets</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> naive_bayes</span><br><span class="line"></span><br><span class="line">datasets = datasets.load_breast_cancer()</span><br><span class="line">X = datasets.data;</span><br><span class="line">y = datasets.target;</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.3</span>, random_state = <span class="number">0</span>)</span><br><span class="line"><span class="comment">#print(datasets.DESCR)</span></span><br><span class="line"><span class="comment">#malignant - 0, benign - 1</span></span><br><span class="line">y_predict = []</span><br></pre></td></tr></table></figure>
<p>由于30个属性全部都是连续值，我们使用朴素贝叶斯的时候需要将属性的值的范围分为几个区间，计算实例落在该区间的概率。这里每个属性我都以平均值作为间隔来划分区间。<br><img src="2-1.jpg" alt=""></p>
<h3 id="对每个连续的属性划分区间并统计个数"><a href="#对每个连续的属性划分区间并统计个数" class="headerlink" title="对每个连续的属性划分区间并统计个数"></a>对每个连续的属性划分区间并统计个数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">distribution</span>(<span class="params">X_train, y_train</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    先把区间分好，然后再计算概率。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#===============区间划分====================#</span></span><br><span class="line">    attributes_max_min_mean = []</span><br><span class="line">    <span class="comment"># 记录所有属性的最大值、最小值和平均值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X_train[<span class="number">0</span>])):</span><br><span class="line">        <span class="comment">#属性循环</span></span><br><span class="line">        <span class="comment">#section = [max, min, mean]</span></span><br><span class="line">        section = [X_train[<span class="number">0</span>][i], X_train[<span class="number">0</span>][i], <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> instance <span class="keyword">in</span> X_train:</span><br><span class="line">            <span class="comment">#训练样例循环</span></span><br><span class="line">            <span class="keyword">if</span> instance[i] &gt; section[<span class="number">0</span>]:</span><br><span class="line">                section[<span class="number">0</span>] = instance[i]</span><br><span class="line">            <span class="keyword">if</span> instance[i] &lt; section[<span class="number">1</span>]:</span><br><span class="line">                section[<span class="number">1</span>] = instance[i]</span><br><span class="line">            section[<span class="number">2</span>] += instance[i]</span><br><span class="line">        section[<span class="number">2</span>] /= <span class="built_in">len</span>(X_train)</span><br><span class="line">        attributes_max_min_mean.append(section)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#=========计算每个属性落在每个区间的样例个数=========#</span></span><br><span class="line">    instance_distribution = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X_train[<span class="number">0</span>])):</span><br><span class="line">        <span class="comment">#属性循环</span></span><br><span class="line">        smaller_benign = <span class="number">0</span></span><br><span class="line">        larger_benign = <span class="number">0</span></span><br><span class="line">        smaller_malignant = <span class="number">0</span></span><br><span class="line">        larger_malignant = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X_train)):</span><br><span class="line">            <span class="comment">#训练样例循环</span></span><br><span class="line">            <span class="keyword">if</span> X_train[j][i] &gt; attributes_max_min_mean[i][<span class="number">2</span>]:</span><br><span class="line">                <span class="keyword">if</span> y_train[j] == <span class="number">1</span>:</span><br><span class="line">                    larger_benign += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    larger_malignant +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> y_train[j] == <span class="number">1</span>:</span><br><span class="line">                smaller_benign += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                smaller_malignant += <span class="number">1</span>   </span><br><span class="line">        instance_distribution.append([smaller_benign, larger_benign, smaller_malignant, larger_malignant])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> instance_distribution, attributes_max_min_mean</span><br></pre></td></tr></table></figure>
<h3 id="实现朴素贝叶斯"><a href="#实现朴素贝叶斯" class="headerlink" title="实现朴素贝叶斯"></a>实现朴素贝叶斯</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Naive_Bayes</span>(<span class="params">X_test, y_predict, instance_distribution,attributes_max_min_mean</span>):</span><br><span class="line">    <span class="keyword">for</span> test_data <span class="keyword">in</span> X_test:</span><br><span class="line">        <span class="comment">#测试样例循环</span></span><br><span class="line">        <span class="comment">#训练集中良性和恶性肿瘤的数量</span></span><br><span class="line">        malignant = instance_distribution[<span class="number">0</span>][<span class="number">2</span>] + instance_distribution[<span class="number">0</span>][<span class="number">3</span>]</span><br><span class="line">        benign = instance_distribution[<span class="number">0</span>][<span class="number">0</span>] + instance_distribution[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="comment">#概率初始化，下面计算每个属性的概率</span></span><br><span class="line">        p_xc0 = <span class="number">1</span></span><br><span class="line">        p_xc1 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X_train[<span class="number">0</span>])):</span><br><span class="line">            <span class="comment"># 属性循环</span></span><br><span class="line">            <span class="keyword">if</span> test_data[i] &gt; attributes_max_min_mean[i][<span class="number">2</span>]:</span><br><span class="line">                p_xc0 *= instance_distribution[i][<span class="number">3</span>] / malignant</span><br><span class="line">                p_xc1 *= instance_distribution[i][<span class="number">1</span>] / benign</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p_xc0 *= instance_distribution[i][<span class="number">2</span>] / malignant</span><br><span class="line">                p_xc1 *= instance_distribution[i][<span class="number">0</span>] / benign</span><br><span class="line">        p0 = p_xc0 * malignant / (malignant + benign)</span><br><span class="line">        p1 = p_xc1 * benign / (malignant + benign)</span><br><span class="line">        <span class="keyword">if</span> p0 &gt; p1:</span><br><span class="line">            y_predict.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y_predict.append(<span class="number">1</span>)      </span><br></pre></td></tr></table></figure>
<h3 id="计算精确度"><a href="#计算精确度" class="headerlink" title="计算精确度"></a>计算精确度</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">y_predict, y_test</span>):</span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_predict)):</span><br><span class="line">        <span class="keyword">if</span> y_predict[i] == y_test[i]:</span><br><span class="line">            correct += <span class="number">1</span></span><br><span class="line">    accuracy_rate = correct / <span class="built_in">len</span>(y_predict)</span><br><span class="line">    <span class="keyword">return</span> correct, accuracy_rate</span><br></pre></td></tr></table></figure>
<h3 id="主函数-1"><a href="#主函数-1" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    instance_distribution, attributes_max_min_mean = distribution(X_train, y_train)</span><br><span class="line">    Naive_Bayes(X_test, y_predict, instance_distribution, attributes_max_min_mean)</span><br><span class="line">    correct, accuracy_rate = accuracy(y_predict, y_test)</span><br><span class="line">    <span class="built_in">print</span>(y_predict)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Naive Bayes模型测试集预测的准确率为：%.3f&quot;</span> % accuracy_rate);</span><br><span class="line">    bayes = naive_bayes.GaussianNB()</span><br><span class="line">    bayes.fit(X_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sklearn库中Naive Bayes模型预测的准确率为：%.3f&quot;</span> % bayes.score(X_test, y_test));</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<pre><code>[0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1]
Naive Bayes模型测试集预测的准确率为：0.930
sklearn库中Naive Bayes模型预测的准确率为：0.924
</code></pre><p>通过实验结果可以发现，我们实现的朴素贝叶斯比SKlearn提供的朴素贝叶斯效果更好。<br>我们可以通过尝试各属性不同的区间划分，进一步优化精确度。而SKlearn提供的朴素贝叶斯效果不好的原因可能就是将连续值转换为离散值的区间划分没有做好。</p>
]]></content>
      <categories>
        <category>数据科学导论</category>
      </categories>
  </entry>
  <entry>
    <title>Fisher算法&amp;SVM&amp;K-Means及其优化</title>
    <url>/201911/Fisher%E7%AE%97%E6%B3%95&amp;SVM&amp;K-Means%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="fisher算法及其实现"><a href="#fisher算法及其实现" class="headerlink" title="fisher算法及其实现"></a><code>fisher</code>算法及其实现</h2><ol>
<li>请实现<code>fisher</code>算法，并采用自己随机生成2类数据（每类100个）的方式，验证自己的算法。<br><a href="https://blog.csdn.net/pengjian444/article/details/71138003">参考资料:https://blog.csdn.net/pengjian444/article/details/71138003</a></li>
</ol>
<span id="more"></span>
<h3 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_multilabel_classification</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x, y = make_multilabel_classification(n_samples=<span class="number">200</span>, n_features=<span class="number">2</span>,</span><br><span class="line">                                      n_labels=<span class="number">1</span>, n_classes=<span class="number">1</span>,</span><br><span class="line">                                      random_state=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据类别分类</span></span><br><span class="line">index1 = np.array([index <span class="keyword">for</span> (index, value) <span class="keyword">in</span> <span class="built_in">enumerate</span>(y) <span class="keyword">if</span> value == <span class="number">0</span>])  <span class="comment"># 获取类别1的indexs</span></span><br><span class="line">index2 = np.array([index <span class="keyword">for</span> (index, value) <span class="keyword">in</span> <span class="built_in">enumerate</span>(y) <span class="keyword">if</span> value == <span class="number">1</span>])  <span class="comment"># 获取类别2的indexs</span></span><br><span class="line"></span><br><span class="line">c_1 = x[index1]   <span class="comment"># 类别1的所有数据(x1, x2) in X_1</span></span><br><span class="line">c_2 = x[index2]  <span class="comment"># 类别2的所有数据(x1, x2) in X_2</span></span><br></pre></td></tr></table></figure>
<p><a href="http://lijiancheng0614.github.io/scikit-learn/modules/generated/sklearn.datasets.make_multilabel_classification.html#sklearn.datasets.make_multilabel_classification">make_multilabel_classification方法参数说明</a><br><code>n_samples</code>:样本的数量。<br><code>n_features</code>：样本的特征，这里是在二维平面中的点，所以为2.<br><code>n_labels</code>：每个实例的平均标签数。<br><code>n_classes</code>：分类问题的分类数。<br><code>random_state</code>：设置随机数种子，保证每次产生相同的数据。</p>
<p><a href="https://www.runoob.com/python/python-func-enumerate.html">enumerate()函数说明</a><br><code>enumerate()</code>函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p>
<h3 id="fisher算法实现"><a href="#fisher算法实现" class="headerlink" title="fisher算法实现"></a>fisher算法实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cal_cov_and_avg</span>(<span class="params">samples</span>):</span><br><span class="line">    u1 = np.mean(samples, axis=<span class="number">0</span>)</span><br><span class="line">    cov_m = np.zeros((samples.shape[<span class="number">1</span>], samples.shape[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> samples:</span><br><span class="line">        t = s - u1</span><br><span class="line">        cov_m += t * t.reshape(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> cov_m, u1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fisher</span>(<span class="params">c_1, c_2</span>):</span><br><span class="line">    cov_1, u1 = cal_cov_and_avg(c_1)</span><br><span class="line">    cov_2, u2 = cal_cov_and_avg(c_2)</span><br><span class="line">    s_w = cov_1 + cov_2</span><br><span class="line">    u, s, v = np.linalg.svd(s_w)  <span class="comment"># 奇异值分解</span></span><br><span class="line">    s_w_inv = np.dot(np.dot(v.T, np.linalg.inv(np.diag(s))), u.T)</span><br><span class="line">    <span class="keyword">return</span> np.dot(s_w_inv, u1 - u2)</span><br></pre></td></tr></table></figure>
<p><code>np.mean</code>：计算制定轴上的平均值。<br><code>np.zeros</code>：给定形状和类型确定的数组，并用0填充。</p>
<h3 id="判定类别"><a href="#判定类别" class="headerlink" title="判定类别"></a>判定类别</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">judge</span>(<span class="params">sample, w, c_1, c_2</span>):</span><br><span class="line">    u1 = np.mean(c_1, axis=<span class="number">0</span>)</span><br><span class="line">    u2 = np.mean(c_2, axis=<span class="number">0</span>)</span><br><span class="line">    center_1 = np.dot(w.T, u1)</span><br><span class="line">    center_2 = np.dot(w.T, u2)</span><br><span class="line">    pos = np.dot(w.T, sample)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(pos - center_1) &lt; <span class="built_in">abs</span>(pos - center_2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w = fisher(c_1, c_2)  <span class="comment"># 调用函数，得到参数w</span></span><br><span class="line">out = judge(c_1[<span class="number">1</span>], w, c_1, c_2)   <span class="comment"># 判断所属的类别</span></span><br><span class="line"><span class="comment"># print(out)</span></span><br></pre></td></tr></table></figure>
<h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.scatter(c_1[:, <span class="number">0</span>], c_1[:, <span class="number">1</span>], c=<span class="string">&#x27;#99CC99&#x27;</span>)</span><br><span class="line">plt.scatter(c_2[:, <span class="number">0</span>], c_2[:, <span class="number">1</span>], c=<span class="string">&#x27;#FFCC00&#x27;</span>)</span><br><span class="line">line_x = np.arange(<span class="built_in">min</span>(np.<span class="built_in">min</span>(c_1[:, <span class="number">0</span>]), np.<span class="built_in">min</span>(c_2[:, <span class="number">0</span>])),</span><br><span class="line">                   <span class="built_in">max</span>(np.<span class="built_in">max</span>(c_1[:, <span class="number">0</span>]), np.<span class="built_in">max</span>(c_2[:, <span class="number">0</span>])),</span><br><span class="line">                   step=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">line_y = - (w[<span class="number">0</span>] * line_x) / w[<span class="number">1</span>]</span><br><span class="line">plt.plot(line_x, line_y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<pre><code>&lt;Figure size 640x480 with 1 Axes&gt;
</code></pre><h2 id="SVM优化对偶问题的详细推导过程"><a href="#SVM优化对偶问题的详细推导过程" class="headerlink" title="SVM优化对偶问题的详细推导过程"></a><code>SVM</code>优化对偶问题的详细推导过程</h2><ol>
<li>请给出<code>SVM</code>优化对偶问题的详细推导过程；并给出只有2维特征情况下的，对偶问题的优化求解过程（可以采用<code>lagrange</code>方法，也可以采用其他方法。）<br><a href="https://zhuanlan.zhihu.com/p/49331510">参考资料：https://zhuanlan.zhihu.com/p/49331510</a>  </li>
</ol>
<p><img src="https://s2.ax1x.com/2019/10/08/uWyoX4.png" alt=""><br><img src="https://s2.ax1x.com/2019/10/08/uWy4pT.png" alt=""><br><img src="https://s2.ax1x.com/2019/10/08/uWyIcF.png" alt=""><br><img src="https://s2.ax1x.com/2019/10/08/uWy51U.png" alt=""><br><img src="https://s2.ax1x.com/2019/10/08/uWyfhV.png" alt=""></p>
<h2 id="SVM算法的实现"><a href="#SVM算法的实现" class="headerlink" title="SVM算法的实现"></a><code>SVM</code>算法的实现</h2><ol>
<li>请实现<code>SVM</code>算法；并采用自己随机生成2类线性可分数据（每类100个）的方式验证自己的算法。<br><a href="https://www.jb51.net/article/131580.htm">参考资料：https://www.jb51.net/article/131580.htm</a></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line">  </span><br><span class="line">np.random.seed(<span class="number">0</span>) </span><br><span class="line">x = np.r_[np.random.randn(<span class="number">100</span>,<span class="number">2</span>)-[<span class="number">2</span>,<span class="number">2</span>],np.random.randn(<span class="number">100</span>,<span class="number">2</span>)+[<span class="number">2</span>,<span class="number">2</span>]] <span class="comment">#正态分布来产生数字,20行2列*2 </span></span><br><span class="line">y = [<span class="number">0</span>]*<span class="number">100</span>+[<span class="number">1</span>]*<span class="number">100</span> <span class="comment">#100个class0，100个class1 </span></span><br><span class="line">  </span><br><span class="line">clf = svm.SVC(kernel=<span class="string">&#x27;linear&#x27;</span>) </span><br><span class="line">clf.fit(x,y) </span><br><span class="line">  </span><br><span class="line">w = clf.coef_[<span class="number">0</span>] <span class="comment">#获取w </span></span><br><span class="line">a = -w[<span class="number">0</span>]/w[<span class="number">1</span>] <span class="comment">#斜率 </span></span><br><span class="line"><span class="comment">#画图划线 </span></span><br><span class="line">xx = np.linspace(-<span class="number">5</span>,<span class="number">5</span>) <span class="comment">#(-5,5)之间x的值 </span></span><br><span class="line">yy = a*xx-(clf.intercept_[<span class="number">0</span>])/w[<span class="number">1</span>] <span class="comment">#xx带入y，截距 </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#画出与点相切的线 </span></span><br><span class="line">b = clf.support_vectors_[<span class="number">0</span>] </span><br><span class="line">yy_down = a*xx+(b[<span class="number">1</span>]-a*b[<span class="number">0</span>]) </span><br><span class="line">b = clf.support_vectors_[-<span class="number">1</span>] </span><br><span class="line">yy_up = a*xx+(b[<span class="number">1</span>]-a*b[<span class="number">0</span>]) </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;W:&quot;</span>,w) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a:&quot;</span>,a) </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;support_vectors_:&quot;</span>,clf.support_vectors_) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;clf.coef_:&quot;</span>,clf.coef_) </span><br><span class="line">  </span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">4</span>)) </span><br><span class="line">plt.plot(xx,yy) </span><br><span class="line">plt.plot(xx,yy_down) </span><br><span class="line">plt.plot(xx,yy_up) </span><br><span class="line">plt.scatter(clf.support_vectors_[:,<span class="number">0</span>],clf.support_vectors_[:,<span class="number">1</span>],s=<span class="number">80</span>) </span><br><span class="line">plt.scatter(x[:,<span class="number">0</span>],x[:,<span class="number">1</span>],c=y,cmap=plt.cm.Paired) <span class="comment">#[:，0]列切片，第0列 </span></span><br><span class="line">  </span><br><span class="line">plt.axis(<span class="string">&#x27;tight&#x27;</span>) </span><br><span class="line">  </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<pre><code>W: [0.95070185 1.15607502]
a: -0.8223530762163854
support_vectors_: [[-0.51174781 -0.10411082]
 [ 0.16323595 -0.66347205]
 [ 2.39904635 -0.77259276]
 [ 0.66574153  0.65328249]
 [-0.25556423  0.97749316]]
clf.coef_: [[0.95070185 1.15607502]]
</code></pre><p><img src="output_12_1.png" alt="png"></p>
<h2 id="k-means算法的实现"><a href="#k-means算法的实现" class="headerlink" title="k-means算法的实现"></a><code>k-means</code>算法的实现</h2><ol>
<li>请实现<code>k-means</code>的算法；并采用自己随机生成3类数据（每类100个）的方式，验证自己的算法。<br><a href="https://cloud.tencent.com/developer/article/1465020">参考资料1:https://cloud.tencent.com/developer/article/1465020</a><br><a href="https://blog.csdn.net/weixin_42029738/article/details/81978038">参考资料2:https://blog.csdn.net/weixin_42029738/article/details/81978038</a>  </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    K-Means clustering algorithms</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(__doc__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> MiniBatchKMeans, KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances_argmin</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_blobs</span><br><span class="line"></span><br><span class="line"><span class="comment"># #############################################################################</span></span><br><span class="line"><span class="comment"># Generate sample data</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">45</span></span><br><span class="line">centers = [[<span class="number">1</span>, <span class="number">1</span>], [-<span class="number">1</span>, -<span class="number">1</span>], [<span class="number">1</span>, -<span class="number">1</span>]] <span class="comment"># 初始化3个中心</span></span><br><span class="line">n_clusters = <span class="built_in">len</span>(centers) <span class="comment"># 聚类的数目为3</span></span><br><span class="line"><span class="comment"># 产生10000组二维数据，以上面三个点为中心，以(-10,10)为边界，数据集的标准差是0.7</span></span><br><span class="line">X, labels_true = make_blobs(n_samples=<span class="number">10000</span>, centers=centers, cluster_std=<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># #############################################################################</span></span><br><span class="line"><span class="comment"># Compute clustering with Means</span></span><br><span class="line"></span><br><span class="line">k_means = KMeans(init=<span class="string">&#x27;k-means++&#x27;</span>, n_clusters=<span class="number">3</span>, n_init=<span class="number">10</span>)</span><br><span class="line">t0 = time.time()</span><br><span class="line">k_means.fit(X)</span><br><span class="line"><span class="comment"># 使用k-means对300组数据集训练算法的时间消耗</span></span><br><span class="line">t_batch = time.time() - t0</span><br><span class="line"></span><br><span class="line"><span class="comment"># #############################################################################</span></span><br><span class="line"><span class="comment"># Plot result</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">8</span>, <span class="number">3</span>))</span><br><span class="line">fig.subplots_adjust(left=<span class="number">0.02</span>, right=<span class="number">0.98</span>, bottom=<span class="number">0.05</span>, top=<span class="number">0.9</span>)</span><br><span class="line">colors = [<span class="string">&#x27;#4EACC5&#x27;</span>, <span class="string">&#x27;#FF9C34&#x27;</span>, <span class="string">&#x27;#4E9A06&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># We want to have the same colors for the same cluster from the</span></span><br><span class="line"><span class="comment"># MiniBatchKMeans and the KMeans algorithm. Let&#x27;s pair the cluster centers per</span></span><br><span class="line"><span class="comment"># closest one.</span></span><br><span class="line">k_means_cluster_centers = np.sort(k_means.cluster_centers_, axis=<span class="number">0</span>)</span><br><span class="line">k_means_labels = pairwise_distances_argmin(X, k_means_cluster_centers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># KMeans</span></span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> k, col <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(n_clusters), colors):</span><br><span class="line">    my_members = k_means_labels == k</span><br><span class="line">    cluster_center = k_means_cluster_centers[k]</span><br><span class="line">    ax.plot(X[my_members, <span class="number">0</span>], X[my_members, <span class="number">1</span>], <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">            markerfacecolor=col, marker=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    ax.plot(cluster_center[<span class="number">0</span>], cluster_center[<span class="number">1</span>], <span class="string">&#x27;o&#x27;</span>, markerfacecolor=col,</span><br><span class="line">            markeredgecolor=<span class="string">&#x27;k&#x27;</span>, markersize=<span class="number">6</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;KMeans&#x27;</span>)</span><br><span class="line">ax.set_xticks(())</span><br><span class="line">ax.set_yticks(())</span><br><span class="line">plt.text(-<span class="number">3.5</span>, <span class="number">1.8</span>,  <span class="string">&#x27;train time: %.2fs\ninertia: %f&#x27;</span> % (</span><br><span class="line">    t_batch, k_means.inertia_))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<pre><code>    K-Means clustering algorithms
</code></pre><p><img src="output_14_1.png" alt="png"></p>
<h2 id="k-means算法的改进"><a href="#k-means算法的改进" class="headerlink" title="k-means算法的改进"></a><code>k-means</code>算法的改进</h2><ol>
<li>请给出三种<code>k-means</code>算法在大数据量时的改进方法，并分析改进的结果。<br>改进方法包括：<ol>
<li><code>k-means++</code>（改变中心点的选取方法）</li>
<li><code>elkan K-Means</code>（减少不必要的距离计算）</li>
<li><code>ISODATA</code>算法（在运行过程中根据实际情况调整聚类中心数k）</li>
<li><code>Mini Batch k-means</code>算法（采用部分样本，舍弃一些精确度大大加快收敛速度）</li>
</ol>
</li>
</ol>
<p>其中1和4改进方法给出了源码和对比。</p>
<h3 id="k-means-（改变中心点的选择方法）"><a href="#k-means-（改变中心点的选择方法）" class="headerlink" title="k-means++（改变中心点的选择方法）"></a><code>k-means++</code>（改变中心点的选择方法）</h3><p><a href="https://blog.csdn.net/github_39261590/article/details/76910689">参考资料1:https://blog.csdn.net/github_39261590/article/details/76910689</a><br><a href="https://www.cnblogs.com/yszd/p/9672885.html">参考资料2:https://www.cnblogs.com/yszd/p/9672885.html</a><br><code>k-means++</code>算法选择初始seeds的基本思想就是：<strong>初始的聚类中心之间的相互距离要尽可能的远。</strong>  </p>
<p>算法步骤：</p>
<ol>
<li>从输入的数据点集合中随机选择一个点作为第一个聚类中心</li>
<li>对于数据集中的每一个点x，计算它与最近聚类中心(指已选择的聚类中心)的距离D(x)</li>
<li>选择一个新的数据点作为新的聚类中心，选择的原则是：D(x)较大的点，被选取作为聚类中心的概率较大</li>
<li>重复2和3直到k个聚类中心被选出来</li>
<li>利用这k个初始的聚类中心来运行标准的k-means算法</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> sklearn.datasets <span class="keyword">as</span> ds</span><br><span class="line"><span class="keyword">import</span> matplotlib.colors</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> MiniBatchKMeans</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">expand</span>(<span class="params">a, b</span>):</span><br><span class="line">    d = (b - a) * <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">return</span> a-b, b+d</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    N = <span class="number">400</span></span><br><span class="line">    centers = <span class="number">4</span></span><br><span class="line">    data, y = ds.make_blobs(N, n_features=<span class="number">2</span>, centers=centers, random_state=<span class="number">2</span>)</span><br><span class="line">    data2, y2 = ds.make_blobs(N, n_features=<span class="number">2</span>, centers=centers, cluster_std=(<span class="number">1</span>, <span class="number">2.5</span>, <span class="number">0.5</span>, <span class="number">2</span>), random_state=<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 按行拼接numpy数组</span></span><br><span class="line">    data3 = np.vstack((data[y == <span class="number">0</span>][:], data[y == <span class="number">1</span>][:<span class="number">50</span>], data[y == <span class="number">2</span>][:<span class="number">20</span>], data[y == <span class="number">3</span>][:<span class="number">5</span>]))</span><br><span class="line">    y3 = np.array([<span class="number">0</span>] * <span class="number">100</span> + [<span class="number">1</span>] * <span class="number">50</span> + [<span class="number">2</span>] * <span class="number">20</span> + [<span class="number">3</span>] * <span class="number">5</span>)</span><br><span class="line">    cls = KMeans(n_clusters=<span class="number">4</span>, init=<span class="string">&#x27;k-means++&#x27;</span>)</span><br><span class="line">    y_hat = cls.fit_predict(data)</span><br><span class="line">    y2_hat = cls.fit_predict(data2)</span><br><span class="line">    y3_hat = cls.fit_predict(data3)</span><br><span class="line">    </span><br><span class="line">    m = np.array(((<span class="number">1</span>, <span class="number">1</span>),(<span class="number">1</span>, <span class="number">3</span>)))</span><br><span class="line">    data_r = data.dot(m)</span><br><span class="line">    y_r_hat = cls.fit_predict(data_r)</span><br><span class="line">    </span><br><span class="line">    matplotlib.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">u&#x27;SimHei&#x27;</span>]</span><br><span class="line">    matplotlib.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line">    cm = matplotlib.colors.ListedColormap(<span class="built_in">list</span>(<span class="string">&#x27;rgbm&#x27;</span>))</span><br><span class="line">    plt.figure(figsize=(<span class="number">9</span>, <span class="number">10</span>), facecolor=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    plt.subplot(<span class="number">421</span>)</span><br><span class="line">    plt.title(<span class="string">u&#x27;原始数据&#x27;</span>)</span><br><span class="line">    plt.scatter(data[:, <span class="number">0</span>], data[:, <span class="number">1</span>], c=y, s=<span class="number">30</span>, cmap=cm, edgecolors=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">    x1_min, x2_min = np.<span class="built_in">min</span>(data, axis=<span class="number">0</span>)</span><br><span class="line">    x1_max, x2_max = np.<span class="built_in">max</span>(data, axis=<span class="number">0</span>)</span><br><span class="line">    x1_min, x1_max = expand(x1_min, x1_max)</span><br><span class="line">    x2_min, x2_max = expand(x2_min, x2_max)</span><br><span class="line">    plt.xlim((x1_min, x1_max))</span><br><span class="line">    plt.ylim((x2_min, x2_max))</span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">422</span>)</span><br><span class="line">    plt.title(<span class="string">u&#x27;KMeans++聚类&#x27;</span>)</span><br><span class="line">    plt.scatter(data[:, <span class="number">0</span>], data[:, <span class="number">1</span>], c=y_hat, s=<span class="number">30</span>, cmap=cm, edgecolors=<span class="string">&#x27;none&#x27;</span>)    </span><br><span class="line">    plt.xlim((x1_min, x1_max))</span><br><span class="line">    plt.ylim((x2_min, x2_max))</span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><img src="output_16_0.png" alt="png"></p>
<h3 id="elkan-k-means算法"><a href="#elkan-k-means算法" class="headerlink" title="elkan k-means算法"></a><code>elkan k-means</code>算法</h3><p><a href="https://blog.csdn.net/u014465639/article/details/71342072">参考资料:https://blog.csdn.net/u014465639/article/details/71342072</a><br><code>elkan K-Means</code>利用了两边之和大于等于第三边,以及两边之差小于第三边的三角形性质，来减少距离的计算。<br>第一种规律是对于一个样本点和两个质心。如果我们预先计算出了这两个质心之间的距离，则如果计算发现,我们立即就可以知道。此时我们不需要再计算,也就是说省了一步距离计算。<br>第二种规律是对于一个样本点和两个质心。我们可以得到。这个从三角形的性质也很容易得到。<br>利用上边的两个规律，elkan K-Means比起传统的K-Means迭代速度有很大的提高。但是如果我们的样本的特征是稀疏的，有缺失值的话，这个方法就不使用了，此时某些距离无法计算，则不能使用该算法。  </p>
<h3 id="ISODATA算法"><a href="#ISODATA算法" class="headerlink" title="ISODATA算法"></a><code>ISODATA</code>算法</h3><p><a href="https://blog.csdn.net/houston11235/article/details/8511379">参考资料1:https://blog.csdn.net/houston11235/article/details/8511379</a><br><a href="https://www.cnblogs.com/huadongw/p/4101422.html">参考资料2:https://www.cnblogs.com/huadongw/p/4101422.html</a><br>k-means 的一个缺点就是必须指定聚类的个数，这个有些时候并不太行得通。于是就要求最好这个类别的个数也可以改变，这就形成了 isodata 方法，通过设定一些类别分裂和合并的条件，在聚类的过程中自动增减类别的数目。当然这也带来了一个问题，就是这个条件有时候并不那么好给出。当然 isodata 在很多情况下还是可以得到比较靠谱的结果。  </p>
<h3 id="Mini-Batch-k-means（用一部分样本做传统的k-means，舍弃一部分精确度大大提高收敛速度）"><a href="#Mini-Batch-k-means（用一部分样本做传统的k-means，舍弃一部分精确度大大提高收敛速度）" class="headerlink" title="Mini Batch k-means（用一部分样本做传统的k-means，舍弃一部分精确度大大提高收敛速度）"></a><code>Mini Batch k-means</code>（用一部分样本做传统的k-means，舍弃一部分精确度大大提高收敛速度）</h3><p><a href="https://cloud.tencent.com/developer/article/1465020">参考资料1:https://cloud.tencent.com/developer/article/1465020</a><br>Mini Batch KMeans算法是一种能<strong>尽量保持聚类准确性下但能大幅度降低计算时间的聚类模型</strong>，采用小批量的数据子集减少计算时间，同时仍试图优化目标函数，这里所谓的Mini Batch是指每次训练算法时随机抽取的数据子集，采用这些随机选取的数据进行训练，大大的减少了计算的时间，减少的KMeans算法的收敛时间，但要比标准算法略差一点，建议当样本量大于一万做聚类时，就需要考虑选用Mini Batch KMeans算法。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Comparison of the K-Means and MiniBatchKMeans clustering algorithms</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(__doc__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> MiniBatchKMeans, KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances_argmin</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_blobs</span><br><span class="line"></span><br><span class="line"><span class="comment"># #############################################################################</span></span><br><span class="line"><span class="comment"># Generate sample data</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">45</span></span><br><span class="line">centers = [[<span class="number">1</span>, <span class="number">1</span>], [-<span class="number">1</span>, -<span class="number">1</span>], [<span class="number">1</span>, -<span class="number">1</span>]] <span class="comment"># 初始化3个中心</span></span><br><span class="line">n_clusters = <span class="built_in">len</span>(centers) <span class="comment"># 聚类的数目为3</span></span><br><span class="line"><span class="comment"># 产生10000组二维数据，以上面三个点为中心，以(-10,10)为边界，数据集的标准差是0.7</span></span><br><span class="line">X, labels_true = make_blobs(n_samples=<span class="number">10000</span>, centers=centers, cluster_std=<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># #############################################################################</span></span><br><span class="line"><span class="comment"># Compute clustering with Means</span></span><br><span class="line"></span><br><span class="line">k_means = KMeans(init=<span class="string">&#x27;k-means++&#x27;</span>, n_clusters=<span class="number">3</span>, n_init=<span class="number">10</span>)</span><br><span class="line">t0 = time.time()</span><br><span class="line">k_means.fit(X)</span><br><span class="line"><span class="comment"># 使用k-means对300组数据集训练算法的时间消耗</span></span><br><span class="line">t_batch = time.time() - t0</span><br><span class="line"></span><br><span class="line"><span class="comment"># #############################################################################</span></span><br><span class="line"><span class="comment"># Compute clustering with MiniBatchKMeans</span></span><br><span class="line"></span><br><span class="line">mbk = MiniBatchKMeans(init=<span class="string">&#x27;k-means++&#x27;</span>, n_clusters=<span class="number">3</span>, batch_size=batch_size,</span><br><span class="line">                      n_init=<span class="number">10</span>, max_no_improvement=<span class="number">10</span>, verbose=<span class="number">0</span>)</span><br><span class="line">t0 = time.time()</span><br><span class="line">mbk.fit(X)</span><br><span class="line"><span class="comment"># 使用MiniBatchKMeans对300组数据集训练算法的时间消耗</span></span><br><span class="line">t_mini_batch = time.time() - t0</span><br><span class="line"></span><br><span class="line"><span class="comment"># #############################################################################</span></span><br><span class="line"><span class="comment"># Plot result</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">8</span>, <span class="number">3</span>))</span><br><span class="line">fig.subplots_adjust(left=<span class="number">0.02</span>, right=<span class="number">0.98</span>, bottom=<span class="number">0.05</span>, top=<span class="number">0.9</span>)</span><br><span class="line">colors = [<span class="string">&#x27;#4EACC5&#x27;</span>, <span class="string">&#x27;#FF9C34&#x27;</span>, <span class="string">&#x27;#4E9A06&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># We want to have the same colors for the same cluster from the</span></span><br><span class="line"><span class="comment"># MiniBatchKMeans and the KMeans algorithm. Let&#x27;s pair the cluster centers per</span></span><br><span class="line"><span class="comment"># closest one.</span></span><br><span class="line">k_means_cluster_centers = np.sort(k_means.cluster_centers_, axis=<span class="number">0</span>)</span><br><span class="line">mbk_means_cluster_centers = np.sort(mbk.cluster_centers_, axis=<span class="number">0</span>)</span><br><span class="line">k_means_labels = pairwise_distances_argmin(X, k_means_cluster_centers)</span><br><span class="line">mbk_means_labels = pairwise_distances_argmin(X, mbk_means_cluster_centers)</span><br><span class="line">order = pairwise_distances_argmin(k_means_cluster_centers,</span><br><span class="line">                                  mbk_means_cluster_centers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># KMeans</span></span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> k, col <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(n_clusters), colors):</span><br><span class="line">    my_members = k_means_labels == k</span><br><span class="line">    cluster_center = k_means_cluster_centers[k]</span><br><span class="line">    ax.plot(X[my_members, <span class="number">0</span>], X[my_members, <span class="number">1</span>], <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">            markerfacecolor=col, marker=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    ax.plot(cluster_center[<span class="number">0</span>], cluster_center[<span class="number">1</span>], <span class="string">&#x27;o&#x27;</span>, markerfacecolor=col,</span><br><span class="line">            markeredgecolor=<span class="string">&#x27;k&#x27;</span>, markersize=<span class="number">6</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;KMeans&#x27;</span>)</span><br><span class="line">ax.set_xticks(())</span><br><span class="line">ax.set_yticks(())</span><br><span class="line">plt.text(-<span class="number">3.5</span>, <span class="number">1.8</span>,  <span class="string">&#x27;train time: %.2fs\ninertia: %f&#x27;</span> % (</span><br><span class="line">    t_batch, k_means.inertia_))</span><br><span class="line"></span><br><span class="line"><span class="comment"># MiniBatchKMeans</span></span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> k, col <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(n_clusters), colors):</span><br><span class="line">    my_members = mbk_means_labels == order[k]</span><br><span class="line">    cluster_center = mbk_means_cluster_centers[order[k]]</span><br><span class="line">    ax.plot(X[my_members, <span class="number">0</span>], X[my_members, <span class="number">1</span>], <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">            markerfacecolor=col, marker=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    ax.plot(cluster_center[<span class="number">0</span>], cluster_center[<span class="number">1</span>], <span class="string">&#x27;o&#x27;</span>, markerfacecolor=col,</span><br><span class="line">            markeredgecolor=<span class="string">&#x27;k&#x27;</span>, markersize=<span class="number">6</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;MiniBatchKMeans&#x27;</span>)</span><br><span class="line">ax.set_xticks(())</span><br><span class="line">ax.set_yticks(())</span><br><span class="line">plt.text(-<span class="number">3.5</span>, <span class="number">1.8</span>, <span class="string">&#x27;train time: %.2fs\ninertia: %f&#x27;</span> %</span><br><span class="line">         (t_mini_batch, mbk.inertia_))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialise the different array to all False</span></span><br><span class="line">different = (mbk_means_labels == <span class="number">4</span>)</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n_clusters):</span><br><span class="line">    different += ((k_means_labels == k) != (mbk_means_labels == order[k]))</span><br><span class="line"></span><br><span class="line">identic = np.logical_not(different)</span><br><span class="line">ax.plot(X[identic, <span class="number">0</span>], X[identic, <span class="number">1</span>], <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">        markerfacecolor=<span class="string">&#x27;#bbbbbb&#x27;</span>, marker=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">ax.plot(X[different, <span class="number">0</span>], X[different, <span class="number">1</span>], <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">        markerfacecolor=<span class="string">&#x27;m&#x27;</span>, marker=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;Difference&#x27;</span>)</span><br><span class="line">ax.set_xticks(())</span><br><span class="line">ax.set_yticks(())</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<pre><code>    Comparison of the K-Means and MiniBatchKMeans clustering algorithms
</code></pre><p><img src="output_20_1.png" alt="png"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Fisher</tag>
        <tag>SVM</tag>
        <tag>K-Means</tag>
      </tags>
  </entry>
  <entry>
    <title>写于10月15日——博客正式对外开放之际</title>
    <url>/201909/%E5%86%99%E4%BA%8E%E5%8D%9A%E5%AE%A2%E6%AD%A3%E5%BC%8F%E5%AF%B9%E5%A4%96%E5%BC%80%E6%94%BE%E4%B9%8B%E9%99%85/</url>
    <content><![CDATA[<p><img src="https://s2.ax1x.com/2019/10/15/KPwEYd.jpg" alt=""></p>
<div class="tag-plugin quot"><p class="content" type="text">If you can quite, then quite.<br /> If you can't quite, you're a writer. <div style=text-align:right>——R.A.Salvatore</div></p></div>
<span id="more"></span>
<p>经过四个月的磨叽，新的博客基本已经完善。<a href="www.crocodilezs.top">鳄鱼先生的水族馆</a><br>本来想着把原先<code>wordpress</code>博客的文章慢慢搬过来再向大家开放博客，但是仔细看看自己原来的那些文章，要么是没什么深度的书评和影评，要么是平淡的流水账。  </p>
<p>但是讲真话，看到自己以前的文字觉得很有成就感，因为那些文章的信息量虽然没那么高、有很多无意义的情绪宣泄，但是里面都有很有意思的闪光点，自己大一大二还真是一个有些自负的天马行空少年。如果这个学期还有时间，就把自己曾经的一些想法整理一下发到博客上来。  </p>
<p>下面就记录一下自己接触博客这个圈子以来的一些感触。</p>
<h1 id="我为什么要写博客？"><a href="#我为什么要写博客？" class="headerlink" title="我为什么要写博客？"></a>我为什么要写博客？</h1><p>表达自己的方式有太多了，微信朋友圈、微信公众平台、QQ空间、微博、知乎、百度贴吧…<br>但是我逐渐发现两个非常严重的问题，其一、这些社交平台上的原创信息都太多了，把自己的想法和感触发布出去真的就是石沉大海，少有人能注意到自己的想法，即使看到了，能让大家留下印象真的非常困难（微信公众平台最明显，随着微信公众平台的门槛降低，“写的比看的多”真的成为了现实）这是消息爆炸的必然结果，随着时间的累积，互联网上文字的平均价值一定会逐渐减少。<br>其二、即使在自己很有存在感的朋友圈和空间，发布的内容也只是自己即时的感慨和供大家取乐的段子，这些东西能够极大地满足我的虚荣心，也记录下了自己很多美好的瞬间。但是在这些平台发布一些长篇大论，就少有人阅读也很难引发深刻的共鸣。  </p>
<p><b>自己的文字越来越浮躁、信息量越来越低，最终在2017年12月，我开始接触博客。</b>  </p>
<p>博客对于我来说就像是信息海洋里属于自己的象牙舟——任缘分流，最后还回港口。</p>
<p>老狼就是一个不会被时间改变的人，你应该庆幸身边有这样的人。<br /><br>我是那种随时跟着时代改变的，但是如果你身边都是这样的人，大家都是弄潮儿，最后就不知道随波逐流到哪儿去了。<br /><br>那你身边有这么一个人呢，你在哪儿弄潮也好，还是劈波斩浪也好，你老能看见他。<br />你会知道，“哦，这个地方是我们出发的地方，这个地方是我们还要回去的地方。”</p>
<div style="text-align:right">——高晓松</div>


<h1 id="搭建博客的历史"><a href="#搭建博客的历史" class="headerlink" title="搭建博客的历史"></a>搭建博客的历史</h1><p>大一的时候根本不懂任何技术，经知乎大佬们安利最终决定自己买服务器用<code>wordpress</code>进行傻瓜操作。<br>买域名主机一气呵成，按照教程搭建好了自己的博客。<br><code>wordpress</code>也确实对小白很友好了，但是它有一个很严重的问题——慢，还有一个致命的问题——莫名其妙地自己的博客就会打不开。<br><code>wordpress</code>有很棒的地方比如说操作简单、文章可以带密码（有些文章只开放给特定人群），当然缺点就是可定制性太低了，博文内部的插件很少很少，不想现在的’hexo’<code>NeXT</code>主题非常灵活。<br>最终，在我又一次打不开自己博客的时候，我选择了放弃<code>wordpress</code>，放弃自己买的主机，准备转战其他的地方。</p>
<p><b>博客中国、博客大巴</b>这些老牌BSP（Blog Service Provider）已经半死不活了。博客园、CSDN的博客技术性又太强了。当时的我始终逃避自己码代码，虽然对<code>hexo</code>早有耳闻，但是总感觉技术性太强一直不愿尝试。<br>最后找到了一个发布轻博文的地方——网易lofter，然而lofter现在的用户流量也大不如前。无奈，我最终还是选择了<code>hexo</code>+<code>github</code>。现在真的可以说是真香了。  </p>
<p>搭建的过程真的非常非常艰辛，从六月份一直到现在，花了不知道多少时间和多少精力，从<code>git</code>的使用到前端的学习，从<code>markdown</code>进阶到<code>next</code>博文内嵌的插件，每一项都学的我要疯掉。最困难的就是<code>next</code>主题更新的速度太快，根本找不到什么新版本的指导教程，只能自己一点一点摸索，借鉴别人的博客。最终才把自己的主题写好。期间受到过很多大佬的博客的启发：  </p>
<ul>
<li><p>内容方面<br><a href="https://www.cnfeat.com/">陈素封的博客</a>：陈素封老师是我搭建博客期间最佩服的博主，他的文章信息量极大，让我获益匪浅。</p>
</li>
<li><p>技术方面<br><a href="https://bestzuo.cn/">Sanarous的博客</a>：最好看的主题没有之一，我的博客的博文字体和配色基本都是借鉴这位大佬的。他的博客搭建系列对我的技术和审美的提升都非常大。他的博客也是我见过的最优秀的博客。  </p>
</li>
</ul>
<p>下面的博客各有可取之处，在搭建的过程中也给了我莫大的帮助：</p>
<p><a href="https://lruihao.cn/">李瑞豪的博客</a><br><a href="https://asdfv1929.github.io/">asdfv1929’s blog</a><br><a href="https://xian6ge.cn/">贤柳阁</a><br><a href="https://yfzhou.coding.me/">Felix</a>：这个主题真的让人眼前一亮<br><a href="https://www.zhyong.cn/">YouForever</a><br><a href="https://linchao1002.github.io">Linchao’s Blog</a></p>
<h1 id="我的生活"><a href="#我的生活" class="headerlink" title="我的生活"></a>我的生活</h1><p>博客搭建的具体过程已经忘得差不多了，也不想再费尽心思地回想和记录。<br>目前自己博客的定位当然不会是一个单纯的技术博客，平时也会post自己的学习笔记、健身记录、书影观后感、游记、摄影和随笔。<br>可以说这是自己的一个个人品牌吧，在接下来的日子里要不断地完善。<br>陈素封老师在自己地一篇文章中提到过写博客的意义：</p>
<ol>
<li>提供持续学习的动力</li>
<li>积累更多的知识</li>
<li>提高将事情讲清楚的能力</li>
<li>分享带来的连锁反应</li>
<li>帮你找到志同道合的人</li>
<li>记录成长</li>
<li>培养持续做一件事的能力</li>
<li>讨论反思</li>
<li>搜寻你意想不到的东西</li>
<li>一个人在做一件属于自己的事</li>
<li>互联网的身份识别</li>
</ol>
<p>以上意义对我来说，最重要的应该是1、5、10、11，还有就是让自己沉淀下来，能够去把信息碎片整合、归纳、扩展，形成自己独树一帜的观点。这些是博客对于我的意义。</p>
<div style='display: none'>
我现在的日程轨迹自己也非常地满意：
晚上十一点开始清理滴答清单的每日Checklist，然后为第二天安排任务。滴答清单的具体使用方法参考了课程《跟邹小强学用滴答清单》，课程在网易云课堂上应该有。滴答清单我用了快半年了，这是我目前接触的最完美的时间管理类app，我需要的功能它全部都有，而且有产品自己的对时间管理的一些想法。“收集箱”的存在对我有很大的帮助。  
下面是我每晚的checklist：

<div class="note info">
    1. 信息门户<br />
    2. 北邮人论坛十大<br />
    3. 清理阅读清单<br />
    4. qq官方通知群<br />
    5. 清理滴答清单<br />
    6. 整理知识碎片<br />
    7. 计算机院公众号
</div>

<p>每日的打卡清单包括：</p>
<div class="note success">
    1. 查看今天花了多少钱<br />
    2. 健身（z1.2.3.5.6）<br />
    3. 坚持记录<br />
    4. 阅读<br />
    5. 不发脾气<br />
    6. 背单词<br />
    7. 吃早餐<br />
    8. 喝水
</div>

<p>每日的咨询获得包括：36氪、澎湃新闻、部分微信公众号、网易云课堂、北邮人论坛<br>收集的app：<b>pocket</b>（很优秀的app！）<br>晚上记录的app：<b>卡片日记</b>（记录app里界面我最喜欢的了，每天记录的时候心情最重要，所以日记软件的颜值要求应该是最高的~）<br>然后有时间的时候再根据卡片日记里的想法形成长篇大论发到博客。<br>&lt;/div&gt;</p>
<p>然而、然而、最近课程真的太忙了啊！专业分流就跟转专业了一样，前两年学的东西和现在的专业都脱轨了啊！<br>这几天累的不行，也好久都没写博客了。</p>
<p>今天写的这一篇的内容一定还有太多不完善的地方，日后再慢慢细化吧。</p>
]]></content>
      <categories>
        <category>参省乎己</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>关于细节</title>
    <url>/201909/2019-09-24-%E5%85%B3%E4%BA%8E%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<p>最近的生活中“细节”这个词出现了很多次。我们从小就被大人们叮嘱要“注意细节”，随着年龄的增长这个词很少再被人提起。这两天发生的一系列事情都让我回过头来重新关注这个词。  </p>
<p>近期让我重新注意到这个词的时候是在发给合伙人中秋茶话会的问卷时，标题后面“【复制】”两个字没有删掉，凤民学姐一句“要细心呐”让我突然楞了一下。上次听到这种提醒应该是在小学了。那个时候做错了自己本应该做对的题，会收到老师这样的提醒。  </p>
<p>我突然意识到自己在浮躁地做很多事情，这种做事的状态应该调整过来。自己想要做的事情太多，但是行动力没有预期的那么高，所以很多事情都没有做到百分百的完美。对于一个思想活跃的大学生来说，产生新鲜的想法是一件最廉价的事情，真正重要的是做事的行动力。现在的自己应该是有“做减法”的需求，一些事情要么就不做，要么就做到自己的百分之百。尤其是无法逃避的课程作业和课程设计，这些事情理应做到自己的最完美。  </p>
<p>在和李京老师的面谈中也提到了关于细节的一些问题。李京老师讲到的关于面试比赛的策划，项目组给出了106页的策划书——不管策划到底怎样，仅仅从策划书的量来看，就知道做这件事的人已经做到尽善尽美了。当我们在职场中或者在平时的学习生活中，我们不可能一上来就拥有很优越的机会，也不可能一下子就做出惊为天人的事情。那么我们的能力和出众点就体现在细节上，在细节上做到无可挑剔同样能给人留下很深的印象。“做好细节”能够让我们“被人注意到”。  </p>
<p>认真雕刻细节能够让我们给人留下很好的第一印象。今天欧老师在上课的时候提到免试研究生的复试，单单从一个学生的简历就能发现很多事情——那些认认真真琢磨简历的人至少说明他们把这件事情“放在心上”，这说明他们愿意把之后的时间投入到实验室，愿意和身边的同学交流等等。一份认真的简历能够表达很多东西。老师提醒我们，一定要注意细节，特别是在第一印象中的细节十分重要。  </p>
<p>今天在线上和一位快手的学长交流，他着重强调了“亮点”这个词，它可以是学历、专业、论文或者实践等等，重要的是我们要留意开始打造“个人品牌”。  </p>
<p>大厂不缺好学校的学生，比如快手一度清北比例高达40%，组里一半以上的清北中科院，但是永远缺乏岗位极度匹配的人。原因并非是大学的专业和研究方向不对口，也并非是高校的教育和职场脱节，而是我们一直是从大学的培养方案出发，去适应不同公司的需求；而非从岗位需求出发，面向岗位技能在大学中学习。这种培养方法是一把双刃剑，它虽然保证了对岗位的高度适应，但是也削弱了人的全面的能力，在社会飞速发展中，可能会随着职业的没落，这种培训方式的偏颇也就显现出来。  </p>
<p>我们也应该去尝试构建一种结果导向的培养方案，按照未来的需求在大学阶段集成能力，尤其是在大学专业划分模糊且行业发展迅速的时代。</p>
<p>今天：肝数据科学导论作业到3点，玩手机到4点。九点二十起床，马马虎虎听了课 （大数据技术基础），中午完了一会游戏，美美地吃了一顿，宿舍睡了一会儿，就去上课，没怎么认真听（数据科学导论）在研究博客地SEO。晚上看了好久的乐队的夏天。然后忙于各种琐事，一边学习一边聊天。</p>
<p>效率好低啊，明天还要写作业呢。</p>
]]></content>
      <categories>
        <category>参省乎己</category>
      </categories>
  </entry>
  <entry>
    <title>「学生宿舍管理系统」实验报告</title>
    <url>/201909/%E3%80%8C%E5%AD%A6%E7%94%9F%E5%AE%BF%E8%88%8D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E3%80%8D%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>使用<code>Python</code>语言，设计一个小型的学生宿舍管理系统，系统用户为宿舍管理员。</p>
<span id="more"></span>
<h2 id="功能要求"><a href="#功能要求" class="headerlink" title="功能要求"></a>功能要求</h2><ol>
<li>学生信息：学号、姓名、性别（男/女）、宿舍房间号、联系电话。</li>
<li>系统功能<ol>
<li>可按学号查找某一位学生的具体信息</li>
<li>可以录入新的学生信息</li>
<li>可以显示现有的所有学生信息</li>
</ol>
</li>
</ol>
<h2 id="程序要求"><a href="#程序要求" class="headerlink" title="程序要求"></a>程序要求</h2><ol>
<li>使用函数、列表、字典、字符串、条件循环等解决问题；</li>
<li>程序规模在80~200行左右。</li>
</ol>
<hr>
<h2 id="任务分析"><a href="#任务分析" class="headerlink" title="任务分析"></a>任务分析</h2><p>实现宿舍管理程序的三个功能。<br>添加的功能包括：可以利用学生的姓名进行查找。<br>错误处理：在功能选择、输入学号、姓名、性别、宿舍房间号、联系电话时都有可能出现数据格式不正确的情况，需要请求用户重新输入。在查找失败时，需要向用户提供查找失败信息。</p>
<h2 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h2><p>共有一个主函数和三个模块函数：</p>
<ol>
<li><code>search_stu</code>可按照学号查找某一位学生的具体信息。（这里做了一个功能拓展，可以通过学生姓名来进行查找，如果有重名的同学都会查找出来）</li>
<li><code>add_stu</code>模块录入新的学生信息</li>
<li><code>show_all_students</code>显示现有的所有学生信息</li>
<li><code>main</code>函数进行功能选择</li>
</ol>
<h2 id="数据结构和关键算法"><a href="#数据结构和关键算法" class="headerlink" title="数据结构和关键算法"></a>数据结构和关键算法</h2><ol>
<li>导入<code>prettytable</code>模块，使输出结果更为美观。</li>
<li><code>stu_info</code>是一个$n * 5$ 的数组，其中$n$为学生数量</li>
</ol>
<hr>
<h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><h3 id="search-stu函数"><a href="#search-stu函数" class="headerlink" title="search_stu函数"></a><code>search_stu</code>函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search_stu</span>():</span><br><span class="line">    <span class="string">&quot;按照学号或姓名查找某一位学生的具体信息&quot;</span></span><br><span class="line">    find = -<span class="number">1</span></span><br><span class="line">    t = PrettyTable([<span class="string">&quot;学号&quot;</span>,<span class="string">&quot;姓名&quot;</span>,<span class="string">&quot;性别&quot;</span>,<span class="string">&quot;宿舍房间号&quot;</span>,<span class="string">&quot;联系电话&quot;</span>])</span><br><span class="line">    sea = <span class="built_in">input</span>(<span class="string">&quot;请输入要搜索的学号或姓名： &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> sea.isdigit() == <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(stu_info)):</span><br><span class="line">            <span class="keyword">if</span> stu_info[i][<span class="number">0</span>] == sea:</span><br><span class="line">                find = i</span><br><span class="line">                t.add_row(stu_info[i])</span><br><span class="line">    <span class="keyword">if</span> sea.isalpha() == <span class="literal">True</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(stu_info)):</span><br><span class="line">            <span class="keyword">if</span> stu_info[i][<span class="number">1</span>] == sea:</span><br><span class="line">                find = i</span><br><span class="line">                t.add_row(stu_info[i])</span><br><span class="line">    <span class="keyword">if</span> find == -<span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;抱歉，未查找到该学生。&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(t)</span><br></pre></td></tr></table></figure>
<h3 id="add-stu函数"><a href="#add-stu函数" class="headerlink" title="add_stu函数"></a><code>add_stu</code>函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_stu</span>():</span><br><span class="line">    <span class="string">&quot;录入新的学生信息&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">50</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;新增学生&quot;</span>)</span><br><span class="line">    num = <span class="built_in">input</span>(<span class="string">&quot;请输入学号： &quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> num.isdigit() != <span class="literal">True</span>:</span><br><span class="line">        num = <span class="built_in">input</span>(<span class="string">&quot;输入错误，请重新输入： &quot;</span>)</span><br><span class="line">    name = <span class="built_in">input</span>(<span class="string">&quot;请输入姓名： &quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> name.isalpha() != <span class="literal">True</span>:</span><br><span class="line">        name = <span class="built_in">input</span>(<span class="string">&quot;输入错误，请重新输入： &quot;</span>)</span><br><span class="line">    sex = <span class="built_in">input</span>(<span class="string">&quot;请输入性别：（男/女） &quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> sex != <span class="string">&quot;男&quot;</span> <span class="keyword">and</span> sex != <span class="string">&quot;女&quot;</span>:</span><br><span class="line">        sex = <span class="built_in">input</span>(<span class="string">&quot;输入错误，请重新输入： &quot;</span>)</span><br><span class="line">    room_no = <span class="built_in">input</span>(<span class="string">&quot;请输入房间号： &quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> room_no.isdigit() != <span class="literal">True</span>:</span><br><span class="line">        room_no = <span class="built_in">input</span>(<span class="string">&quot;输入错误，请重新输入： &quot;</span>)</span><br><span class="line">    tel = <span class="built_in">input</span>(<span class="string">&quot;请输入电话：&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> tel.isdigit() != <span class="literal">True</span>:</span><br><span class="line">        tel = <span class="built_in">input</span>(<span class="string">&quot;输入错误，请重新输入： &quot;</span>)</span><br><span class="line">    stu = [num, name, sex, room_no, tel]</span><br><span class="line">    stu_info.append(stu)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;添加&quot;</span>+num+<span class="string">&quot;成功&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="show-all-students函数"><a href="#show-all-students函数" class="headerlink" title="show_all_students函数"></a><code>show_all_students</code>函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show_all_students</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(stu_info)):</span><br><span class="line">        table.add_row(stu_info[i])</span><br><span class="line">    <span class="built_in">print</span>(table)</span><br></pre></td></tr></table></figure>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;欢迎使用【宿舍管理系统】&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;1.查找学生&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;2.新增学生&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;3.显示全部&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;0.退出系统&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">        instruct = <span class="built_in">input</span>(<span class="string">&quot;请选择希望执行的操作：&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> instruct == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">            search_stu()</span><br><span class="line">        <span class="keyword">elif</span> instruct == <span class="string">&quot;2&quot;</span>:</span><br><span class="line">            add_stu()</span><br><span class="line">        <span class="keyword">elif</span> instruct == <span class="string">&quot;3&quot;</span>:</span><br><span class="line">            show_all_students()</span><br><span class="line">        <span class="keyword">elif</span> instruct == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;欢迎再次使用【宿舍管理系统】&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;输入错误，请重新输入指令！&quot;</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><h3 id="功能2-录入学生信息"><a href="#功能2-录入学生信息" class="headerlink" title="功能2. 录入学生信息"></a>功能2. 录入学生信息</h3><p><img src="https://s2.ax1x.com/2019/09/23/uCWEmF.jpg" alt=""></p>
<h3 id="功能3-显示所有学生信息"><a href="#功能3-显示所有学生信息" class="headerlink" title="功能3.显示所有学生信息"></a>功能3.显示所有学生信息</h3><p><img src="https://s2.ax1x.com/2019/09/23/uCWZTJ.jpg" alt=""></p>
<h3 id="功能1-根据学号或姓名进行查找"><a href="#功能1-根据学号或姓名进行查找" class="headerlink" title="功能1. 根据学号或姓名进行查找"></a>功能1. 根据学号或姓名进行查找</h3><ol>
<li><p>根据学号查找<br><img src="https://s2.ax1x.com/2019/09/23/uCWVw4.jpg" alt=""></p>
</li>
<li><p>根据姓名查找<br><img src="https://s2.ax1x.com/2019/09/23/uCWkOU.jpg" alt=""></p>
</li>
</ol>
<div class="note success">
可见，重名的学生被查找出来
</div>

<h3 id="功能0-退出系统"><a href="#功能0-退出系统" class="headerlink" title="功能0. 退出系统"></a>功能0. 退出系统</h3><p><img src="https://s2.ax1x.com/2019/09/23/uCW1OO.jpg" alt=""></p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p><img src="https://s2.ax1x.com/2019/09/23/uCWmk9.jpg" alt="指令选择错误"></p>
<p><img src="https://s2.ax1x.com/2019/09/23/uCWuf1.jpg" alt="信息录入错误"></p>
<p><img src="https://s2.ax1x.com/2019/09/23/uCWMSx.md.jpg" alt="查找错误"></p>
]]></content>
      <categories>
        <category>数据科学导论</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>实验室苦逼搬砖暑假生活纪实</title>
    <url>/201909/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E8%8B%A6%E9%80%BC%E6%90%AC%E7%A0%96%E6%9A%91%E5%81%87%E7%94%9F%E6%B4%BB%E7%BA%AA%E5%AE%9E/</url>
    <content><![CDATA[<div class="note primary">
    记录一下自己暑假在实验室做的一些事情和收获吧。<br />
    虽然进步很小很缓慢，但总归是有的。
</div>

<h2 id="7月13日"><a href="#7月13日" class="headerlink" title="7月13日"></a>7月13日</h2><ol>
<li><p>关于论文的主要内容，学长进行了讲解：<br /><br> <strong>任务目标：</strong>通过迁移学习实现用户对齐问题，并将对齐结果与其他的用户对其方法进行比较：其中的方法包括“监督类型的”和“非监督类型的”，最终论文里要将我们的方法与其他至少三四种方法进行比较。</p>
 <span id="more"></span>
</li>
<li><p>下面的时间应该做到：<br> 0）熟悉各数据集，每个数据集经过哪个函数变成什么样子？<br> <code>myspace</code>文件夹中，<code>.node</code>文件前一个数字表示结点标号，后面的表示用户名。<br> <code>.edges</code>文件每一行的两个数字表示边连接的两个节点。<br> <code>aminer.tar.gz</code>,<code>flicker.tar.gz</code>,<code>lastfm.tar.gz</code>,<code>linkedin.tar,gz</code>,<code>livejournal.tar.gz</code>这五个压缩包都是上面形式的点和边<br> <code>aminer-linkedin.map.raw</code>文件，将<code>aminer.tar.gz</code>文件中的结点映射到<code>linkedin</code>上  </p>
<p> 1）<code>DRNE</code>（将图表示矩阵转化成向量）<br> 转化成的向量是什么格式？它是怎样表示矩阵的？它的输入和输出是怎样的？</p>
<p> 2）<code>wGAN</code>的一个变种函数（生成相应的对齐结果）<br> 它的输入和输出是怎样的？</p>
</li>
</ol>
<h2 id="7月14日"><a href="#7月14日" class="headerlink" title="7月14日"></a>7月14日</h2><p>非常艰难的一天，<code>DRNE</code>作者的<code>readme</code>文档写错了，指令是错误的，我第一次接触这个看不懂debug信息，学长也没发现。最后发邮件问原作者才知道<code>readme</code>中把<code>\</code>打成了<code>/</code>🤬<br>这一件事情花了我三天的时间，一开始以为自己的环境没搭建好，安装了各种库，利用<code>anaconda</code>创造了许多环境测试，我哭了。</p>
<ol>
<li><p>关于安装<code>tensorflow</code>的方法：<br> <a href="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/1-2-install/">莫凡Python</a><br> <a href="https://www.cnblogs.com/lvsling/p/8672404.html">ling’s bolg</a></p>
<p> <a href="https://www.jianshu.com/p/28e2ae6fbd75">安装时遇到的问题</a></p>
</li>
<li><p>上面这些乱七八糟的都不如直接<code>pip install</code>，觉得慢的话换成清华镜像资源<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a></p>
</li>
</ol>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/">pypi镜像使用帮助</a></p>
<h2 id="7月15日"><a href="#7月15日" class="headerlink" title="7月15日"></a>7月15日</h2><div class="note primary">
    学长又分配了两个任务，第一个是判断图是否为连通图。 <br /> 
    其实要是只有几个点倒简单，但是仅仅接触了一点`Python`就要写个几千点判断连通图的程序，我想到的第一点是效率会非常低。。。最后这个代码学长亲自写了。
</div>

<p>这里顺带复习了一下数据结构的东西</p>
<ol>
<li>邻接矩阵与邻接表<br> <a href="https://www.cnblogs.com/icode-girl/p/5273209.html">邻接矩阵</a></li>
<li>边表<br> 边集表，图的储存结构之一。边表由表头结点和表结点两部分组成，图中每个顶点均对应一个存储在数组中的表头结点。<br> 边表存储了以点为起点的边的信息，邻接表存储了以点为出发点的点的信息。 </li>
<li>edgelist边表中每行有两个数，表示这两个结点之间有边</li>
<li>python nx.has_path(G, source, target)用来判断是否为连通图</li>
<li>networkx库查阅资料：<br><a href="https://www.cnblogs.com/kaituorensheng/p/5423131.html">network资料</a><br>NetworkX是一个用Python语言开发的图论与复杂网络建模工具，内置了常用的图与复杂网络分析算法，可以方便的进行复杂网络数据分析、仿真建模等工作。networkx支持创建简单无向图、有向图和多重图（multigraph）；内置许多标准的图论算法，节点可为任意数据；支持任意的边值维度，功能丰富，简单易用。<br><a href="https://networkx.github.io/documentation/stable/tutorial.html">network官方文档</a>  </li>
</ol>
<p>发现文档里举的例子都是自己输入的个别的点，我可以先研究一下DRNE的代码，从里面得到一些有用的内容。</p>
<p>代码看不懂的地方，首先就是embedding：<br><a href="https://blog.csdn.net/songyunli1111/article/details/85100616">关于embedding</a></p>
<h2 id="7月16日"><a href="#7月16日" class="headerlink" title="7月16日"></a>7月16日</h2><ol>
<li>CONSNET数据集：<br> deepwalk-master先不用，做对比算法的<br> DRNE-master 用来做embedding的<br> GAN用来生成模型  </li>
<li>关于anaconda的使用：<br> Anaconda是一个方便的python包管理和环境管理软件，一般用来配置不同的项目环境。<br> 我们常常会遇到这样的情况，正在做的项目A和项目B分别基于python2和python3，而第电脑只能安装一个环境，这个时候Anaconda就派上了用场，它可以创建多个互不干扰的环境，分别运行不同版本的软件包，以达到兼容的目的。<br> Anaconda通过管理工具包、开发环境、Python版本，大大简化了你的工作流程。不仅可以方便地安装、更新、卸载工具包，而且安装时能自动安装相应的依赖包，同时还能使用不同的虚拟环境隔离不同要求的项目。<br> <a href="https://www.jianshu.com/p/742dc4d8f4c5">Anaconda入门</a></li>
</ol>
<h2 id="7月17日"><a href="#7月17日" class="headerlink" title="7月17日"></a>7月17日</h2><div class="note success">
    conda有一点好处是，如果你需要安装一个包，系统将自动检查这个包需要的前置包并且安装，比如你要安装TensorFlow，而TensorFlow会用到很多像前置包像pandas、matiplot等，如果你在单纯的python下没有安装pandas等包就直接安装TensorFlow，那么和有可能无法使用，而使用conda安装TensorFlow将会询问你并自动帮你把缺少的前置包安装好
</div>

<ol>
<li><p>使用anaconda先创建一个用于drne的环境<br> <img src="https://s2.ax1x.com/2019/09/28/u1d88U.png" alt=""><br> 安装以上环境<br> 其中添加的资源库都没有tensorflow == 1.2.0<br> 按照提示 </p>
 <blockquote><p>To search for alternate channels that may provide the conda package you’re looking for, navigate to <a href="https://anaconda.org">https://anaconda.org</a> and use the search bar at the top of the page.</p>
</blockquote>
<p> 去官网搜索资源即可下载</p>
<p> 环境安装完成</p>
</li>
<li><p>anaconda跑不出来，先学习anaconda的使用方法：<br> <a href="https://www.jianshu.com/p/eaee1fadc1e9">anaconda1</a></p>
<p> <a href="https://i.xdc.at/2017/08/13/add-anaconda-prompt-to-context-menu-of-explorer/">anaconda2</a></p>
<p> <a href="https://blog.csdn.net/c20081052/article/details/88839479">anaconda3</a></p>
</li>
</ol>
<h2 id="7月19日"><a href="#7月19日" class="headerlink" title="7月19日"></a>7月19日</h2><p>继续研究network库</p>
<h2 id="7月21日"><a href="#7月21日" class="headerlink" title="7月21日"></a>7月21日</h2><p>研读networkx的文档，在后面处理相关问题的时候会简单很多。<br>在学习图的过程中，遇到的问题：<br><img src="https://s2.ax1x.com/2019/09/28/u1wzTI.png" alt=""><br><img src="https://s2.ax1x.com/2019/09/28/u1wx0A.png" alt=""></p>
<p>最后一行输出，我记得莫凡python里有讲这个，关于迭代器的东西，然后搜索了一下，继续进行学习：<br><a href="https://blog.csdn.net/u014028063/article/details/80572234">Python迭代器</a></p>
<p><strong>任务：</strong><br>写一个可以将ground truth抽样的函数，给定一个列表，例如[0.3， 0.5， 0.7]，<br>0.3表示在groundtruth里面随机抽样30%，并生成名为new-gt-0.3.txt的文件，列表长度为多少，就生成多少个这样的文件。</p>
<h2 id="7月22日"><a href="#7月22日" class="headerlink" title="7月22日"></a>7月22日</h2><p>readme文档中AcrossNetworkEmbeddingData文件夹里的文件和实际文件夹里的不一样，是否有问题？</p>
<p>anchor users 定位用户</p>
<h2 id="7月23日"><a href="#7月23日" class="headerlink" title="7月23日"></a>7月23日</h2><p>读学长写的：</p>
<ol>
<li><p>连通图代码<br>numpy.zeros<br><a href="https://blog.csdn.net/qq_28618765/article/details/78085457">https://blog.csdn.net/qq_28618765/article/details/78085457</a></p>
</li>
<li><p>抽样代码<br>自己完成：数据转换代码<br>python open函数的参数<br><a href="https://www.runoob.com/python/python-func-open.html">https://www.runoob.com/python/python-func-open.html</a></p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/qq_33254870/article/details/81668297">https://blog.csdn.net/qq_33254870/article/details/81668297</a></p>
<p><a href="https://cloud.tencent.com/developer/ask/172682">https://cloud.tencent.com/developer/ask/172682</a></p>
<font color="FF0000">一定要系统地学一下python！要不然什么都不会，写起来效率太低了！！</font>

<p>怎样用csvreader读入用tab分隔的文件——直接用\t</p>
<p><a href="https://www.runoob.com/python/att-list-len.html">https://www.runoob.com/python/att-list-len.html</a></p>
<p>for while if后面都要有冒号</p>
<p>python的‘和’符号是 and</p>
<p>关于newline参数</p>
<h2 id="7月24日"><a href="#7月24日" class="headerlink" title="7月24日"></a>7月24日</h2><div class="note danger">
    把trans_result打成了tranns_result，出现问题，，，，，
    python也没有报错，还好自己发现了
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span>(i &lt; <span class="built_in">len</span>(trans_result)):</span><br><span class="line">		<span class="comment"># print(&quot;Delete process...&quot;)</span></span><br><span class="line">		<span class="keyword">if</span>(trans_result[i][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">or</span> trans_result[i][<span class="number">1</span>] == <span class="number">0</span>):</span><br><span class="line">			trans_result = np.delete(trans_result, i, axis = <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">else</span>:<span class="comment">#！！！！注意这里的else！！！否则会出错</span></span><br><span class="line">			i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<center>❤️ 🧡 💛 💚 💙 💜 </center>
<center>中间几天帮张老师查项目资料来着——关于“认知计算”和“意图推理”</center>

<h2 id="7月31日"><a href="#7月31日" class="headerlink" title="7月31日"></a>7月31日</h2><p>如何调出eclipse左边文件栏<br><a href="https://jingyan.baidu.com/article/a24b33cd3af41119ff002b7a.html"></a></p>
<p>anaconda prompt 切换到e盘：<br><a href="https://blog.csdn.net/c20081052/article/details/88839479"></a></p>
<p>drne配适自己的代码：<br>activate for_drne<br>e:</p>
<h2 id="8月4日"><a href="#8月4日" class="headerlink" title="8月4日"></a>8月4日</h2><p>coursera视频无法播放<br><a href="https://blog.csdn.net/qq_39521554/article/details/79039548">https://blog.csdn.net/qq_39521554/article/details/79039548</a></p>
<p>欧式距离</p>
<p><a href="https://www.cnblogs.com/kimkat/p/9938475.html">https://www.cnblogs.com/kimkat/p/9938475.html</a></p>
<p>测试程序（把程序拆成几小部分）</p>
<ol>
<li>np.linalg.norm(vec1 - vec2)</li>
<li>读入部分，怎样读出来两个向量</li>
</ol>
<p>python cookbook 真的能学到很多东西！！<br>挺有用！</p>
<p><a href="https://zhidao.baidu.com/question/115008008.html">https://zhidao.baidu.com/question/115008008.html</a></p>
<p><a href="https://www.cnblogs.com/bakari/p/4807847.html">https://www.cnblogs.com/bakari/p/4807847.html</a></p>
<h2 id="8月5日"><a href="#8月5日" class="headerlink" title="8月5日"></a>8月5日</h2><ol>
<li><p>查数据类型：<br><a href="https://www.cnblogs.com/carlber/p/9362584.html">https://www.cnblogs.com/carlber/p/9362584.html</a></p>
</li>
<li><p>列表最后有一个逗号，就会多出来一个空元素<br><a href="https://www.cnblogs.com/lostme/articles/8857083.html">https://www.cnblogs.com/lostme/articles/8857083.html</a></p>
</li>
<li><p>operands could not be broadcast together with shapes (2,) (250,)<br><a href="https://blog.csdn.net/Odyssues_lee/article/details/85244735">https://blog.csdn.net/Odyssues_lee/article/details/85244735</a></p>
</li>
<li><p>运行map（）后，报：map object at 0x02629E50解决方法与原因分析​​​​​​​<br><a href="https://blog.csdn.net/weixin_40807247/article/details/82797378">https://blog.csdn.net/weixin_40807247/article/details/82797378</a></p>
</li>
</ol>
<p><a href="https://www.cnblogs.com/hwd9654/p/5707920.html">https://www.cnblogs.com/hwd9654/p/5707920.html</a></p>
<ol>
<li><p>从字符串中提取数字：<br><a href="https://www.cnblogs.com/dancesir/p/11021829.html">https://www.cnblogs.com/dancesir/p/11021829.html</a></p>
</li>
<li><p>python中，“<filter object at 0x028A2050>”是什么意思？怎么解决？<br><a href="https://zhidao.baidu.com/question/329317296.html">https://zhidao.baidu.com/question/329317296.html</a></p>
</li>
<li><p>数据格式要求很严格：<br>3   2<br>5  4<br>7  6<br>9  7<br>tab和x个空格不一样</p>
</li>
<li><p>输出百分比：<br><a href="https://blog.csdn.net/u013553529/article/details/78567696">https://blog.csdn.net/u013553529/article/details/78567696</a></p>
</li>
</ol>
<h2 id="8月7日"><a href="#8月7日" class="headerlink" title="8月7日"></a>8月7日</h2><p>博客搭建<br><a href="https://blog.csdn.net/fangquan1980/article/details/80648171">https://blog.csdn.net/fangquan1980/article/details/80648171</a></p>
<p><a href="https://blog.csdn.net/zyupupup/article/details/85098366">https://blog.csdn.net/zyupupup/article/details/85098366</a></p>
<p><a href="https://blog.csdn.net/weixin_42419856/article/details/81141546">https://blog.csdn.net/weixin_42419856/article/details/81141546</a></p>
<p><a href="https://blog.csdn.net/lvsehaiyang1993/article/details/80881433">https://blog.csdn.net/lvsehaiyang1993/article/details/80881433</a></p>
<p><a href="http://zhangchunlei.com/blog/2014/12/01/modify-a-record-of-my-website-dns/">http://zhangchunlei.com/blog/2014/12/01/modify-a-record-of-my-website-dns/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On a Windows machine, you&#x27;ll want to run nslookup your-domain.com and ensure that the output does not include any of the deprecated IP addresses (207.97.227.XXX, 204.232.175.XX, or 199.27.73.XXX).</span><br><span class="line">If you&#x27;re on a Mac or Linux machine, simply paste this command into a terminal window, replacing your-domain.com with, your site&#x27;s domain. dig your-domain.com | grep -E &#x27;(207.97.227.245|204.232.175.78|199.27.73.133)&#x27; || echo &quot;OK&quot;. If you see the word &quot;OK&quot;, you&#x27;re all set.</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/a1023182899/article/details/77461567">https://blog.csdn.net/a1023182899/article/details/77461567</a></p>
<h2 id="8月8日"><a href="#8月8日" class="headerlink" title="8月8日"></a>8月8日</h2><p><a href="https://www.v2ex.com/amp/t/465570">https://www.v2ex.com/amp/t/465570</a></p>
<p>LINE（PALE中）<br>GAN<br>画圈</p>
<h2 id="8月11日"><a href="#8月11日" class="headerlink" title="8月11日"></a>8月11日</h2><p>xlrd模块：<br><a href="https://www.cnblogs.com/insane-Mr-Li/p/9092619.html">https://www.cnblogs.com/insane-Mr-Li/p/9092619.html</a></p>
<h2 id="8月13日"><a href="#8月13日" class="headerlink" title="8月13日"></a>8月13日</h2><ol>
<li><p>random.choices<br><a href="https://blog.csdn.net/lcqin111/article/details/83504029">https://blog.csdn.net/lcqin111/article/details/83504029</a></p>
</li>
<li><p>Cannot feed value of shape (256, 255) for Tensor ‘Placeholder:0’, which has shape ‘(?, 256)’<br><a href="http://www.mamicode.com/info-detail-2346029.html">http://www.mamicode.com/info-detail-2346029.html</a></p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4000</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------------training---------DDDDDD----------EPOCH：&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;-----------------------&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        mm = np.reshape(random.choices(f_d, f_g, k=<span class="number">256</span>))</span><br><span class="line">        nn = np.reshape(random.choices(t_d, t_g, k=<span class="number">256</span>))</span><br><span class="line">        rms_train1, loss1 = sess.run([model.rms_train_op1, model.loss_d], feed_dict=&#123;model.s: np.array(random.choices(f_d, f_g, k=<span class="number">256</span>)), model.t: np.array(random.choices(t_d, t_g, k=<span class="number">256</span>))&#125;)</span><br><span class="line">        <span class="keyword">for</span> every <span class="keyword">in</span> model.clip:</span><br><span class="line">            sess.run(every)</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>7.13<br>了解任务详情<br /></p>
<p>7.14<br>装相应的环境，跑DRNE，发现了文档的错误<br>DRNE在命令行窗口运行。<br>输入：edgelist<br>输出：.npy（需要再写程序转换为embedding）<br /></p>
<p>7.15<br>想要完成任务：判断是否为连通图<br>结果就是不行，，<br /></p>
<p>7.16<br>还在为DRNE的无脑错误 debug<br /></p>
<p>7.17<br>学习了anaconda的使用，还在跑DRNE，，<br /></p>
<p>7.18<br>DRNE，，<br /></p>
<p>7.19<br>完成一个可以将ground truth抽样的函数，例如[0.3, 0.5, 0.7]<br /></p>
<p>7.21<br>学习关于图的内容，不敢下手自己写代码<br /></p>
<p>7.22<br>开始跑IONE（java）<br /></p>
<p>7.23<br>数据转换代码，将cosnet数据集中的用户名转换成结点号<br /></p>
<p>7.24<br>删去edges里面没有在groundtruth中出现的记录，以此来缩小数据集<br /></p>
<p>7.25<br>用学长改过的代码跑ione<br /></p>
<p>7.31<br>用anaconda环境跑DRNE<br /></p>
<p>8.4<br>写计算距离，画圈的代码<br /></p>
<p>8.5<br>计算距离的代码，注意数据格式<br /></p>
<p>8.7<br>博客搭建<br /></p>
<p>8.8<br>跑PALE中的LINE，尝试WGAN<br /></p>
<p>8.11<br>跑学长改过的WGAN<br /></p>
<p>8.11<br>跑学长改过的WGAN完成，DRNE结果的npy转成txt<br /></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>迁移学习</tag>
        <tag>Anaconda</tag>
        <tag>DRNE</tag>
        <tag>IONE</tag>
        <tag>WGAN</tag>
        <tag>PALE</tag>
      </tags>
  </entry>
  <entry>
    <title>30天自制操作系统（27）</title>
    <url>/201905/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8827%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY27-LDT与库"><a href="#DAY27-LDT与库" class="headerlink" title="DAY27_LDT与库"></a>DAY27_LDT与库</h1><h2 id="1-先来修复bug"><a href="#1-先来修复bug" class="headerlink" title="1. 先来修复bug"></a>1. 先来修复bug</h2><p>bug：用nsct命令运行的应用程序，无论是按Shift+F1还是点击窗口的”x”按钮狗没有反应。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task_run(task, -1, 0);</span><br></pre></td></tr></table></figure></p>
<span id="more"></span>
<h2 id="2-应用程序运行时关闭命令行窗口"><a href="#2-应用程序运行时关闭命令行窗口" class="headerlink" title="2. 应用程序运行时关闭命令行窗口"></a>2. 应用程序运行时关闭命令行窗口</h2><ul>
<li>目标：在应用程序运行的时候无法关闭所对应的命令行窗口。</li>
<li>修改：1.让系统在按下”x”按钮的时候暂且将命令行窗口从画面上隐藏起来。（因为关闭命令行窗口会有延迟）<ol>
<li>当FIFO接收到从console.c发送的“关闭窗口”请求数据时所进行的处理，主要是释放指定的图层。</li>
</ol>
</li>
</ul>
<h2 id="3-保护应用程序-1"><a href="#3-保护应用程序-1" class="headerlink" title="3. 保护应用程序(1)"></a>3. 保护应用程序(1)</h2><p>破坏程序：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[FORMAT &quot;WCOFF&quot;] </span><br><span class="line">[INSTRSET &quot;i486p&quot;] </span><br><span class="line">[BITS 32] </span><br><span class="line">[FILE &quot;crack7.nas&quot;] </span><br><span class="line">    GLOBAL _HariMain </span><br><span class="line">[SECTION .text] </span><br><span class="line">_HariMain: </span><br><span class="line">     MOV AX,1005*8 </span><br><span class="line">     MOV DS,AX </span><br><span class="line">     CMP DWORD [DS:0x0004],&#x27;Hari&#x27; </span><br><span class="line">     JNE fin ; 不是应用程序，因此不执行任何操作</span><br><span class="line">     MOV ECX,[DS:0x0000] ; 读取该应用程序数据段的大小</span><br><span class="line">     MOV AX,2005*8 </span><br><span class="line">     MOV DS,AX </span><br><span class="line">crackloop: ; 整个用123填充</span><br><span class="line">     ADD ECX,-1 </span><br><span class="line">     MOV BYTE [DS:ECX],123 </span><br><span class="line">     CMP ECX,0 </span><br><span class="line">     JNE crackloop </span><br><span class="line">fin: ; 结束</span><br><span class="line">     MOV EDX,4 </span><br><span class="line">     INT 0x40</span><br></pre></td></tr></table></figure></p>
<h2 id="4-保护应用程序-2"><a href="#4-保护应用程序-2" class="headerlink" title="4. 保护应用程序(2)"></a>4. 保护应用程序(2)</h2><p>CPU为我们提供了解决方案，那就是LDT。<br>GDT: global descriptor table<br>LDT: local descriptor table<br>其中GDT中的段设置是供所有任务通用的，而LDT中的段设置只对某个应用程序有效。</p>
<h2 id="5-优化应用程序的大小"><a href="#5-优化应用程序的大小" class="headerlink" title="5. 优化应用程序的大小"></a>5. 优化应用程序的大小</h2><p>那么我们该怎么办呢？我们可以将这些函数做成不同的.obj文件，将_api_putchar等需要用到的函数和_api_openwin等不需要用到的函数分离开。</p>
<h2 id="6-库"><a href="#6-库" class="headerlink" title="6. 库"></a>6. 库</h2><p>如果像上一节那样，把函数拆分开来，并用连接器来进行连接的话，我们需要创建很多很多个.obj文件。当然，如果不拆分函数，而是做成一个大的.obj文件也可以（如同a_nask.obj），但这样的话应用程序没有引用的函数也会被包含进去，生成的应用程序文件就会像之前那样无端增大很多。<br>库：将很多个.obj文件打包成一个文件。<br>要创建一个库，我们首先需要.obj文件作为原材料，除此之外，我们还需要一个叫做库管理器的程序。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GOLIB = $(TOOLPATH)golib00.exe </span><br><span class="line"></span><br><span class="line">apilib.lib : Makefile $(OBJS_API) </span><br><span class="line"> $(GOLIB) $(OBJS_API) out:apilib.lib</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.bim : a.obj apilib.lib Makefile </span><br><span class="line">  $(OBJ2BIM) @$(RULEFILE) out:a.bim map:a.map a.obj apilib.lib</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void api_putchar(int c); </span><br><span class="line">void api_putstr0(char *s); </span><br><span class="line">void api_putstr1(char *s, int l); </span><br><span class="line">void api_end(void); </span><br><span class="line">int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title); </span><br><span class="line">void api_putstrwin(int win, int x, int y, int col, int len, char *str); </span><br><span class="line">void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col); </span><br><span class="line">void api_initmalloc(void); </span><br><span class="line">char *api_malloc(int size); </span><br><span class="line">void api_free(char *addr, int size); </span><br><span class="line">void api_point(int win, int x, int y, int col); </span><br><span class="line">void api_refreshwin(int win, int x0, int y0, int x1, int y1);</span><br><span class="line">void api_linewin(int win, int x0, int y0, int x1, int y1, int col); </span><br><span class="line">void api_closewin(int win); </span><br><span class="line">int api_getkey(int mode); </span><br><span class="line">int api_alloctimer(void); </span><br><span class="line">void api_inittimer(int timer, int data); </span><br><span class="line">void api_settimer(int timer, int time); </span><br><span class="line">void api_freetimer(int timer); </span><br><span class="line">void api_beep(int tone);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;apilib.h&quot;</span><br></pre></td></tr></table></figure>
<h2 id="7-整理make环境"><a href="#7-整理make环境" class="headerlink" title="7. 整理make环境"></a>7. 整理make环境</h2><p>整理操作系统、库、应用程序的文件和代码。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（26）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8826%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY26-为窗口移动提速"><a href="#DAY26-为窗口移动提速" class="headerlink" title="DAY26_为窗口移动提速"></a>DAY26_为窗口移动提速</h1><h2 id="1-提高窗口的移动速度-1"><a href="#1-提高窗口的移动速度-1" class="headerlink" title="1. 提高窗口的移动速度(1)"></a>1. 提高窗口的移动速度(1)</h2><p>导致窗口移动速度慢的原因有很多，其中之一就是sheet_refreshmap的速度太慢。这个函数在<br>sheet_slide中被调用了两次，如果能提高它的速度效果应该会很明显。</p>
<h2 id="2-提高窗口的移动速度-2"><a href="#2-提高窗口的移动速度-2" class="headerlink" title="2. 提高窗口的移动速度(2)"></a>2. 提高窗口的移动速度(2)</h2><span id="more"></span>
<p>sheet_refreshmap中有这样一句<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map[vy * ctl-&gt;xsize + vx] = sid;</span><br></pre></td></tr></table></figure></p>
<p>在汇编语言中，如果我们用16位寄存器代替8位寄存器来执行MOV指令的话，相邻的地址中也会同时写入数据，而如果用32位寄存器，仅1条指令就可以同时向相邻的4个地址写入值了。<br>更重要的是，即便是同时写入4个字节的值，只要指定地址是4的整数倍，指令的执行速度就<br>和1个字节的MOV是相同的。也就是说，速度说不定能提高到原来的4倍！</p>
<h2 id="3-提高窗口移动速度-3"><a href="#3-提高窗口移动速度-3" class="headerlink" title="3.提高窗口移动速度(3)"></a>3.提高窗口移动速度(3)</h2><p>于是我们首先想到了sheet_refreshsub，窗口移动的时候也调用了这个函数，因此通过修改它可以提高窗口移动的速度，此外其他一些地方也会调用这个函数。</p>
<h2 id="4-提高窗口移动速度-4"><a href="#4-提高窗口移动速度-4" class="headerlink" title="4.提高窗口移动速度(4)"></a>4.提高窗口移动速度(4)</h2><p>为什么明明已经放开了鼠标键，窗口却还在挪动呢？这是因为伴随图层移动所进行的绘图操<br>作非常消耗时间，导致系统来不及处理FIFO中的鼠标移动数据。那么我们可以在接收到鼠标移动数据后不立即进行绘图操作，但如果一直不绘图的话鼠标和窗口就静止不动了，那不就没意义了吗？我们可以等FIFO为空时再进行绘图操作嘛。</p>
<h2 id="5-启动时只打开一个命令行窗口"><a href="#5-启动时只打开一个命令行窗口" class="headerlink" title="5.启动时只打开一个命令行窗口"></a>5.启动时只打开一个命令行窗口</h2><p>一般都是先打开一个命令行窗口，然后根据需要增加。下面我们就将启动时显示的命令行窗口数量改为一个，并且实现可以随意启动新命令行窗口的功能吧。</p>
<hr>
<p>在Windows中，即便不在命令行中输入命令，只通过鼠标的操作也可以打开新的命令行窗口。不过鼠标点击开始菜单这种方式实现起来太难，我们还是做快捷键吧。</p>
<h2 id="6-增加更多的命令行窗口"><a href="#6-增加更多的命令行窗口" class="headerlink" title="6.增加更多的命令行窗口"></a>6.增加更多的命令行窗口</h2><h2 id="7-关闭命令行窗口-1"><a href="#7-关闭命令行窗口-1" class="headerlink" title="7. 关闭命令行窗口(1)"></a>7. 关闭命令行窗口(1)</h2><p>在Windows的命令行窗口中，输入“exit”命令就可以关闭当前窗口.<br>在关闭一个命令行窗口时系统需要做些什么事呢？首先需要将创建该窗口时所占用的内存<br>空间全部释放出来，然后还需要释放窗口的图层和任务结构。咦，问题来了，在创建任务时我们为命令行窗口准备了专用的栈，却没有将这个栈的地址保存起来，这样的话就无法执行释放操作了。怎么办呢？我们可以在TASK结构中添加一个cons_stack成员，用来保存栈的地址。</p>
<h2 id="8-关闭命令行窗口-2"><a href="#8-关闭命令行窗口-2" class="headerlink" title="8. 关闭命令行窗口(2)"></a>8. 关闭命令行窗口(2)</h2><p>实现用鼠标关闭命令行窗口的功能。当鼠标点击窗口上的“×”按钮时，向命令行窗口任务发送4这个数据，命令行窗口接收到这个数据后则开始执行exit命令的程序。</p>
<h2 id="9-start命令"><a href="#9-start命令" class="headerlink" title="9.start命令"></a>9.start命令</h2><p>Windows的命令行窗口里有一个start命令，它的功能是可以打开一个新的命令行窗口并运行指定的应用程序。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void cmd_start(struct CONSOLE *cons, char *cmdline, int memtotal) </span><br><span class="line">&#123; </span><br><span class="line"> struct SHTCTL *shtctl = (struct SHTCTL *) *((int *) 0x0fe4); </span><br><span class="line"> struct SHEET *sht = open_console(shtctl, memtotal); </span><br><span class="line"> struct FIFO32 *fifo = &amp;sht-&gt;task-&gt;fifo; </span><br><span class="line"> int i; </span><br><span class="line"> sheet_slide(sht, 32, 4); </span><br><span class="line"> sheet_updown(sht, shtctl-&gt;top); </span><br><span class="line"> /*将命令行输入的字符串逐字复制到新的命令行窗口中*/ </span><br><span class="line"> for (i = 6; cmdline[i] != 0; i++) &#123; </span><br><span class="line"> fifo32_put(fifo, cmdline[i] + 256); </span><br><span class="line"> &#125; </span><br><span class="line"> fifo32_put(fifo, 10 + 256); /*回车键*/ </span><br><span class="line"> cons_newline(cons); </span><br><span class="line"> return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="10-ncst命令"><a href="#10-ncst命令" class="headerlink" title="10. ncst命令"></a>10. ncst命令</h2><p>用start命令启动应用程序看起来很不错，但如果运行color这样的程序的话，我们并不希望真的新开一个命令行窗口出来，反倒是没有这个多余的窗口比较好。那么下面我们就来做一个不打开新命令行窗口的start命令吧，给它起个名字，叫做“no console start”，简称ncst命令。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（25）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8825%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY25-增加命令行窗口"><a href="#DAY25-增加命令行窗口" class="headerlink" title="DAY25_增加命令行窗口"></a>DAY25_增加命令行窗口</h1><h2 id="1-蜂鸣器发声"><a href="#1-蜂鸣器发声" class="headerlink" title="1.蜂鸣器发声"></a>1.蜂鸣器发声</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">蜂鸣器发声</span><br><span class="line">EDX=20 </span><br><span class="line">EAX=声音频率（单位是mHz，即毫赫兹）</span><br><span class="line">例如当EAX=4400000时，则发出440Hz的声音</span><br><span class="line">频率设为0则表示停止发声</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax) </span><br><span class="line">&#123; </span><br><span class="line"> （中略）</span><br><span class="line"> &#125; else if (edx == 20) &#123; </span><br><span class="line"> if (eax == 0) &#123; </span><br><span class="line"> i = io_in8(0x61); </span><br><span class="line"> io_out8(0x61, i &amp; 0x0d); </span><br><span class="line"> &#125; else &#123; </span><br><span class="line"> i = 1193180000 / eax; </span><br><span class="line"> io_out8(0x43, 0xb6); </span><br><span class="line"> io_out8(0x42, i &amp; 0xff);</span><br><span class="line"> io_out8(0x42, i &gt;&gt; 8); </span><br><span class="line"> i = io_in8(0x61); </span><br><span class="line"> io_out8(0x61, (i | 0x03) &amp; 0x0f); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-增加更多的颜色-1"><a href="#2-增加更多的颜色-1" class="headerlink" title="2.增加更多的颜色(1)"></a>2.增加更多的颜色(1)</h2><p>修改graphic.c<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void init_palette(void) </span><br><span class="line">&#123; </span><br><span class="line"> static unsigned char table_rgb[16 * 3] = &#123; </span><br><span class="line"> （中略）</span><br><span class="line"> &#125;; </span><br><span class="line"> unsigned char table2[216 * 3]; </span><br><span class="line"> int r, g, b; </span><br><span class="line"> set_palette(0, 15, table_rgb); </span><br><span class="line"> for (b = 0; b &lt; 6; b++) &#123; </span><br><span class="line"> for (g = 0; g &lt; 6; g++) &#123; </span><br><span class="line"> for (r = 0; r &lt; 6; r++) &#123; </span><br><span class="line"> table2[(r + g * 6 + b * 36) * 3 + 0] = r * 51; </span><br><span class="line"> table2[(r + g * 6 + b * 36) * 3 + 1] = g * 51; </span><br><span class="line"> table2[(r + g * 6 + b * 36) * 3 + 2] = b * 51; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> set_palette(16, 231, table2); </span><br><span class="line"> return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-增加更多的颜色-2"><a href="#3-增加更多的颜色-2" class="headerlink" title="3.增加更多的颜色(2)"></a>3.增加更多的颜色(2)</h2><p>我们可以用两种颜色交替排列，看上去就像这两种颜色混合在一起一样，这就是要点。颜色的混合方式我们考虑了下面3种（算上完全不混合的情况，一共有5种）。<br><img src="https://s2.ax1x.com/2019/04/28/El968s.jpg" alt="25.1"></p>
<h2 id="4-窗口初始位置"><a href="#4-窗口初始位置" class="headerlink" title="4. 窗口初始位置"></a>4. 窗口初始位置</h2><p>因此我们希望让窗口总是显示在画面的中央，而且显示窗口时的图层高度也不能总是固定为3，而是要判断当前画面中窗口的数量并自动显示在最上面。</p>
<h2 id="5-增加命令行窗口-1"><a href="#5-增加命令行窗口-1" class="headerlink" title="5. 增加命令行窗口(1)"></a>5. 增加命令行窗口(1)</h2><p>于是，我们这次只修改bootpack.c，将命令行窗口的相关变量（buf_cons、sht_cons、task_cons和cons）各准备2个，分别分给命令行1和命令行2。</p>
<h2 id="6-增加命令行窗口-2"><a href="#6-增加命令行窗口-2" class="headerlink" title="6.增加命令行窗口(2)"></a>6.增加命令行窗口(2)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec);</span><br></pre></td></tr></table></figure>
<p>这里的cons变量是用来判断“要向哪个命令行窗口输出字符”的关键。该变量的值是从内存地址0x0fec读取出来的，而无论从哪个任务读取这个内存地址中的值，得到的肯定都是同一个值，因此不管在哪个窗口中运行a.hrb，都只能在固定的其中一个窗口中显示字符。</p>
<h2 id="7-增加命令行窗口-3"><a href="#7-增加命令行窗口-3" class="headerlink" title="7. 增加命令行窗口(3)"></a>7. 增加命令行窗口(3)</h2><p>问题出在cmd_app身上<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set_segmdesc(gdt + 1003, finfo-&gt;size - 1, (int) p, AR_CODE32_ER + 0x60); </span><br><span class="line"> set_segmdesc(gdt + 1004, segsiz - 1, (int) q, AR_DATA32_RW + 0x60); </span><br><span class="line"> （中略）</span><br><span class="line"> start_app(0x1b, 1003 * 8, esp, 1004 * 8, &amp;(task-&gt;tss.esp0));</span><br><span class="line"> </span><br></pre></td></tr></table></figure></p>
<p>首先，color.hrb在某个窗口中被运行，启动程序一切顺利，然后显示窗口并绘图，接下来等待键盘输入并进入休眠状态。到这里为止没有任何问题。<br>然后我们在另外一个窗口中运行color.hrb，程序也顺利启动了，显示窗口并绘图，随后进入休眠状态。然而在这个时候，问题其实已经发生了。这是怎么回事呢？因为我们为color.hrb准备的1003号代码段和1004号数据段，被color2.hrb所用的段给覆盖掉了。<br>因此，当按下回车键唤醒color.hrb时，就会发生异常情况——明明应该去运行color.hrb的，结果却错误地运行了color2.hrb，这样当然会出错了。</p>
<h2 id="8-增加命令行窗口-4"><a href="#8-增加命令行窗口-4" class="headerlink" title="8.增加命令行窗口(4)"></a>8.增加命令行窗口(4)</h2><p>这次的修改也很简单，首先将原来task_cons[0]的地方改为key_wintask和shttask，这样一来，用键盘强制结束时会以当前输入窗口为对象，而用鼠标点击“×”按钮时会以被点击的窗口为对象。</p>
<h2 id="9-变得更像真正的操作系统-1"><a href="#9-变得更像真正的操作系统-1" class="headerlink" title="9.变得更像真正的操作系统(1)"></a>9.变得更像真正的操作系统(1)</h2><h2 id="10-变得更像真正的操作系统-2"><a href="#10-变得更像真正的操作系统-2" class="headerlink" title="10.变得更像真正的操作系统(2)"></a>10.变得更像真正的操作系统(2)</h2><p>这样肯定不行，因为命令行窗口任务的优先级比较低，只有当bootpack.c的HariMain休眠之后才会运行命令行窗口任务，而如果不运行这个任务的话，FIFO缓冲区就不会被初始化，这就相当于我们在向一个还没初始化的FIFO强行发送数据，于是造成fifo32_put混乱而导致重启。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（24）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8824%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY24-窗口操作"><a href="#DAY24-窗口操作" class="headerlink" title="DAY24_窗口操作"></a>DAY24_窗口操作</h1><h2 id="1-窗口切换-1"><a href="#1-窗口切换-1" class="headerlink" title="1.窗口切换(1)"></a>1.窗口切换(1)</h2><ul>
<li>目标：实现切换窗口顺序得功能。</li>
<li>先实现按下F11时，将最下面得那个窗口放到最上面。</li>
</ul>
<span id="more"></span>
<hr>
<p>修改bootpack.c<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">256</span> + <span class="number">0x57</span> &amp;&amp; shtctl-&gt;top &gt; <span class="number">2</span>) &#123; <span class="comment">/* F11 */</span> </span><br><span class="line">    sheet_updown(shtctl-&gt;sheets[<span class="number">1</span>], shtctl-&gt;top - <span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-窗口切换-2"><a href="#2-窗口切换-2" class="headerlink" title="2. 窗口切换(2)"></a>2. 窗口切换(2)</h2><p>我们需要按照从上到下得顺序，判断鼠标得位置落在哪个图层得范围内，并且还需要确保该位置不是透明色区域。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = shtctl-&gt;top - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123; </span><br><span class="line">     sht = shtctl-&gt;sheets[j]; </span><br><span class="line">     x = mx - sht-&gt;vx0; </span><br><span class="line">     y = my - sht-&gt;vy0; </span><br><span class="line">     <span class="keyword">if</span> (<span class="number">0</span> &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; sht-&gt;bysize) &#123; </span><br><span class="line">         <span class="keyword">if</span> (sht-&gt;buf[y * sht-&gt;bxsize + x] != sht-&gt;col_inv) &#123; </span><br><span class="line">             sheet_updown(sht, shtctl-&gt;top - <span class="number">1</span>); </span><br><span class="line">             <span class="keyword">break</span>; </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-移动窗口"><a href="#3-移动窗口" class="headerlink" title="3.移动窗口"></a>3.移动窗口</h2><p>当鼠标左键点击窗口时，如果点击位置位于窗口的标题栏区域，则进入“窗口移动模式”，使窗口的位置追随鼠标指针的移动，当放开鼠标左键时，退出“窗口移动模式”，返回通常模式。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mmx &lt; <span class="number">0</span>) &#123; </span><br><span class="line">     <span class="comment">/*如果处于通常模式*/</span> </span><br><span class="line">     <span class="comment">/*按照从上到下的顺序寻找鼠标所指向的图层*/</span> </span><br><span class="line">     <span class="keyword">for</span> (j = shtctl-&gt;top - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123; </span><br><span class="line">         sht = shtctl-&gt;sheets[j]; </span><br><span class="line">         x = mx - sht-&gt;vx0; </span><br><span class="line">         y = my - sht-&gt;vy0; </span><br><span class="line">         <span class="keyword">if</span> (<span class="number">0</span> &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; sht-&gt;bysize) &#123; </span><br><span class="line">            <span class="keyword">if</span> (sht-&gt;buf[y * sht-&gt;bxsize + x] != sht-&gt;col_inv) &#123; </span><br><span class="line">                sheet_updown(sht, shtctl-&gt;top - <span class="number">1</span>); </span><br><span class="line">                <span class="keyword">if</span> (<span class="number">3</span> &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize - <span class="number">3</span> &amp;&amp; <span class="number">3</span> &lt;= y &amp;&amp; y &lt; <span class="number">21</span>) &#123; </span><br><span class="line">                    mmx = mx; <span class="comment">/*进入窗口移动模式*/</span> </span><br><span class="line">                    mmy = my; </span><br><span class="line">                &#125; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">     <span class="comment">/*如果处于窗口移动模式*/</span> </span><br><span class="line">     x = mx - mmx; <span class="comment">/*计算鼠标的移动距离*/</span> </span><br><span class="line">     y = my - mmy; </span><br><span class="line">     sheet_slide(sht, sht-&gt;vx0 + x, sht-&gt;vy0 + y); </span><br><span class="line">     mmx = mx; <span class="comment">/*更新为移动后的坐标*/</span> </span><br><span class="line">     mmy = my; </span><br><span class="line">     &#125; </span><br><span class="line">     &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">     <span class="comment">/*没有按下左键*/</span> </span><br><span class="line">    mmx = <span class="number">-1</span>; <span class="comment">/*返回通常模式*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-用鼠标关闭窗口"><a href="#4-用鼠标关闭窗口" class="headerlink" title="4.用鼠标关闭窗口"></a>4.用鼠标关闭窗口</h2><h2 id="5-将输入切换到应用程序窗口"><a href="#5-将输入切换到应用程序窗口" class="headerlink" title="5.将输入切换到应用程序窗口"></a>5.将输入切换到应用程序窗口</h2><p>按下Tab键时将键盘输入切换到当前输入窗口下面一层的窗口中，若当前窗口为最下层，则切换到最上层窗口。</p>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (key_win == sht_win) &#123; <span class="comment">/*发送至任务A */</span> </span><br><span class="line"> <span class="keyword">if</span> (cursor_x &lt; <span class="number">128</span>) &#123; </span><br><span class="line"> <span class="comment">/*显示一个字符并将光标后移一位*/</span> </span><br><span class="line"> s[<span class="number">1</span>] = <span class="number">0</span>; </span><br><span class="line">putfonts8_asc_sht(sht_win, cursor_x, <span class="number">28</span>, COL8_000000, COL8_FFFFFF, s, <span class="number">1</span>); </span><br><span class="line"> cursor_x += <span class="number">8</span>;</span><br><span class="line"> &#125; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; <span class="comment">/*发送至命令行窗口*/</span> </span><br><span class="line"> fifo32_put(&amp;key_win-&gt;task-&gt;fifo, s[<span class="number">0</span>] + <span class="number">256</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (i == <span class="number">256</span> + <span class="number">0x0e</span>) &#123; <span class="comment">/*退格键*/</span> </span><br><span class="line"> <span class="keyword">if</span> (key_win == sht_win) &#123; <span class="comment">/*发送至任务A */</span> </span><br><span class="line"> <span class="keyword">if</span> (cursor_x &gt; <span class="number">8</span>) &#123; </span><br><span class="line"> <span class="comment">/*用空格擦除光标后将光标前移一位*/</span> </span><br><span class="line"> putfonts8_asc_sht(sht_win, cursor_x, <span class="number">28</span>, COL8_000000, COL8_FFFFFF, <span class="string">&quot; </span></span><br><span class="line"><span class="string"> &quot;</span>, <span class="number">1</span>); </span><br><span class="line"> cursor_x -= <span class="number">8</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; <span class="comment">/*发送至命令行窗口*/</span> </span><br><span class="line"> fifo32_put(&amp;key_win-&gt;task-&gt;fifo, <span class="number">8</span> + <span class="number">256</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (i == <span class="number">256</span> + <span class="number">0x1c</span>) &#123; <span class="comment">/*回车键*/</span> </span><br><span class="line"> <span class="keyword">if</span> (key_win != sht_win) &#123; <span class="comment">/*发送至命令行窗口*/</span> </span><br><span class="line"> fifo32_put(&amp;key_win-&gt;task-&gt;fifo, <span class="number">10</span> + <span class="number">256</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (i == <span class="number">256</span> + <span class="number">0x0f</span>) &#123; <span class="comment">/* Tab键*/</span> </span><br><span class="line"> cursor_c = keywin_off(key_win, sht_win, cursor_c, cursor_x); </span><br><span class="line"> j = key_win-&gt;height - <span class="number">1</span>; </span><br><span class="line"> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123; </span><br><span class="line"> j = shtctl-&gt;top - <span class="number">1</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> key_win = shtctl-&gt;sheets[j]; </span><br><span class="line"><span class="comment">/*到此结束*/</span> cursor_c = keywin_on(key_win, sht_win, cursor_c); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-用鼠标切换输入窗口"><a href="#6-用鼠标切换输入窗口" class="headerlink" title="6.用鼠标切换输入窗口"></a>6.用鼠标切换输入窗口</h2><p>目标：让操作系统可以通过简单的点击就能完成输入切换。  </p>
<h2 id="7-定时器API"><a href="#7-定时器API" class="headerlink" title="7.定时器API"></a>7.定时器API</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取定时器（alloc）</span><br><span class="line">EDX=16 </span><br><span class="line">EAX=定时器句柄（由操作系统返回）</span><br><span class="line"></span><br><span class="line">设置定时器的发送数据（init）</span><br><span class="line">EDX=17 </span><br><span class="line">EBX=定时器句柄</span><br><span class="line">EAX=数据</span><br><span class="line"></span><br><span class="line">定时器时间设定（set）</span><br><span class="line">EDX=18 </span><br><span class="line">EBX=定时器句柄</span><br><span class="line">EAX=时间</span><br><span class="line"></span><br><span class="line">释放定时器（free）</span><br><span class="line">EDX=19 </span><br><span class="line">EBX=定时器句柄</span><br></pre></td></tr></table></figure>
<h2 id="8-取消定时器"><a href="#8-取消定时器" class="headerlink" title="8.取消定时器"></a>8.取消定时器</h2><p>问题：<br>应用程序设置了一个1秒的定时器，当定时器到达指定时间时会产生超时，并向任务发送事先设置的数据。问题是，如果这时应用程序已经结束了，定时器的数据就会被发送到命令行窗口，而命令行窗口肯定是一头雾水。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>「迁移学习简明手册」学习笔记（1）</title>
    <url>/201908/%E3%80%8C%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C%E3%80%8D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h1 id="1-迁移学习的基本概念"><a href="#1-迁移学习的基本概念" class="headerlink" title="1.迁移学习的基本概念"></a>1.迁移学习的基本概念</h1><h2 id="1-2-迁移学习基本概念"><a href="#1-2-迁移学习基本概念" class="headerlink" title="1.2 迁移学习基本概念"></a>1.2 迁移学习基本概念</h2><ul>
<li>核心问题：找到新问题和原问题之间的相似性，才可以顺利地实现知识的迁移。</li>
<li>定义：迁移学习，是指利用数据、任务、或模型之间的相似性，将在旧领域学习过的模型，应用在新领域的一种学习过程。</li>
</ul>
<h2 id="1-3-为什么要迁移学习"><a href="#1-3-为什么要迁移学习" class="headerlink" title="1.3 为什么要迁移学习"></a>1.3 为什么要迁移学习</h2><p>这个表格包括了1.3的所有内容，可以只看这个表格：</p>
<p><img src="https://s2.ax1x.com/2019/04/24/EVv4IS.jpg" alt="1.3"></p>
<span id="more"></span>
<ul>
<li>1.大数据与少标注之间的矛盾</li>
<li>2.大数据与弱计算之间的矛盾</li>
<li>3.普适化模型与个性化需求之间的矛盾<br>机器学习的目标是构建一个尽可能通用的模型，而人们的个性化需求五花八门，短期内根本无法用一个通用的模型去满足。</li>
<li>4.特定应用的需求<br>推荐系统的冷启动问题：一个新的推荐系统，没有足够的用户数据，如何进行精准的推荐；一个崭新的图片标注系统，没有足够的标签，如何进行精准的服务？</li>
</ul>
<p><strong>针对以上问题，迁移学习是如何解决的呢？</strong></p>
<ul>
<li>1.迁移数据标注</li>
<li>2.模型迁移（将那些大公司在大数据上训练好的模型，迁移到我们的任务中）</li>
<li>3.自适应学习（对普适化模型进行灵活的调整，以便完成我们的任务）</li>
<li>4.相似领域知识迁移</li>
</ul>
<h2 id="1-4-与已有概念的区别和联系"><a href="#1-4-与已有概念的区别和联系" class="headerlink" title="1.4 与已有概念的区别和联系"></a>1.4 与已有概念的区别和联系</h2><h3 id="1-迁移学习和机器学习"><a href="#1-迁移学习和机器学习" class="headerlink" title="1.迁移学习和机器学习"></a>1.迁移学习和机器学习</h3><p>迁移学习属于机器学习的一类<br><img src="https://s2.ax1x.com/2019/04/24/EVxMQA.jpg" alt="2"></p>
<h3 id="2-迁移学习和多任务学习"><a href="#2-迁移学习和多任务学习" class="headerlink" title="2.迁移学习和多任务学习"></a>2.迁移学习和多任务学习</h3><p>多任务学习指多个相关的任务一起协同学习。</p>
<h3 id="3-迁移学习和终身学习"><a href="#3-迁移学习和终身学习" class="headerlink" title="3.迁移学习和终身学习"></a>3.迁移学习和终身学习</h3><p>终身学习是在已经学习好若干个任务之后，面对新的任务可以继续学习而不遗忘之前学习的任务。</p>
<h3 id="4-迁移学习和领域自适应"><a href="#4-迁移学习和领域自适应" class="headerlink" title="4.迁移学习和领域自适应"></a>4.迁移学习和领域自适应</h3><h3 id="5-迁移学习和增量学习"><a href="#5-迁移学习和增量学习" class="headerlink" title="5.迁移学习和增量学习"></a>5.迁移学习和增量学习</h3><p>增量学习侧重解决数据不断到来，模型不断更新的问题。</p>
<h3 id="6-迁移学习和自我学习"><a href="#6-迁移学习和自我学习" class="headerlink" title="6.迁移学习和自我学习"></a>6.迁移学习和自我学习</h3><p>自我学习指的是模型不断地从自身处进行更新</p>
<h3 id="7-迁移学习和协方差漂移"><a href="#7-迁移学习和协方差漂移" class="headerlink" title="7.迁移学习和协方差漂移"></a>7.迁移学习和协方差漂移</h3><p>协方差漂移指数据地边缘概率分布发生变化</p>
<h2 id="1-5-负迁移（“东施效颦”）"><a href="#1-5-负迁移（“东施效颦”）" class="headerlink" title="1.5 负迁移（“东施效颦”）"></a>1.5 负迁移（“东施效颦”）</h2><p>如果两个领域之间不存在相似性，或者基本不相似，那么就会大大损害迁移学习地效果。这时候，我们可以说出现了==负迁移(Negative Transfer)==  </p>
<ul>
<li>定义：在源域上学习到的知识，对于目标域上的学习产生负面作用。</li>
<li>产生负迁移的原因：<ul>
<li>数据问题</li>
<li>方法问题：源域和目标域是相似的，但是迁移学习的方法不够好。</li>
</ul>
</li>
<li>传递迁移学习：传统迁移学习好比是踩着一块石头过河，传递迁移学习就是踩着连续的两块石头。当两个领域不相似时，传递迁移学习却可以利用处于这两个领域之间的若干领域，将知识传递式的完成迁移。</li>
</ul>
<h1 id="2-迁移学习的研究领域"><a href="#2-迁移学习的研究领域" class="headerlink" title="2.迁移学习的研究领域"></a>2.迁移学习的研究领域</h1><p>机器学习可分为有监督、半监督和无监督的机器学习三大类。迁移学习也可以进行这样的分类。<br><img src="https://s2.ax1x.com/2019/04/24/EZVW1P.jpg" alt="t8"></p>
<p>分类的四个准则：按目标域有无标签分、按学习方法分、按特征分、按在线形式分</p>
<h2 id="2-1-按目标域标签分"><a href="#2-1-按目标域标签分" class="headerlink" title="2.1 按目标域标签分"></a>2.1 按目标域标签分</h2><ul>
<li>1.监督迁移学习 Supervised Transfer Learning</li>
<li>2.半监督迁移学习 Semi-Supervised Transfer Learning</li>
<li>3.无监督迁移学习 Unsupervised Transfer Learning  </li>
</ul>
<p>显然，少标签或无标签的问题（半监督和无监督迁移学习）<br>，是研究的热点和难点。</p>
<h2 id="2-2-按学习方法分类"><a href="#2-2-按学习方法分类" class="headerlink" title="2.2 按学习方法分类"></a>2.2 按学习方法分类</h2><ul>
<li>1.基于样本的迁移学习方法(Instance based Transfer Learning)<br>通过权重重用，对源域和目标域的样例进行迁移</li>
<li>2.基于==特征==的迁移学习方法(Feature based Transfer Leaning)<br>意思是说，假设源域和目标域的特征<br>原来不在一个空间，或者说它们在原来那个空间上不相似，那我们就想办法把它们变换到一个空间里面，那这些特征不就相似了？</li>
<li>3.基于==模型==的迁移学习方法(Model based Transfer Leaning)<br>构建参数共享的模型</li>
<li>4.基于关系的迁移学习方法(Relation based Transfer Learning)<br>挖掘和利用关系进行类比迁移</li>
</ul>
<h2 id="2-3-按特征分类"><a href="#2-3-按特征分类" class="headerlink" title="2.3 按特征分类"></a>2.3 按特征分类</h2><ul>
<li>1.同构迁移学习(Homogeneous Transfer Learning)</li>
<li>2.异构迁移学习(Heterogeneous Transfer Learning)<br>如果特征语义和维度都相同，那么就是同构；反之，如果特征完全不相同，那么就是异构。举个例子来说，不同图片的迁移，就可以认为是同构；而图片到文本的迁移，则是异构的。</li>
</ul>
<h2 id="2-4-按离线与在线形式分"><a href="#2-4-按离线与在线形式分" class="headerlink" title="2.4 按离线与在线形式分"></a>2.4 按离线与在线形式分</h2><ul>
<li>1.离线迁移学习(Offline Transfer Learning)</li>
<li>2.在线迁移学习(Online Transfer Learning)</li>
</ul>
<p>目前，绝大多数的迁移学习方法，都采用了离线方式。即，源域和目标域均是给定的，<br>迁移一次即可。这种方式的缺点是显而易见的：算法无法对新加入的数据进行学习，模型也无法得到更新。与之相对的，是在线的方式。即随着数据的动态加入，迁移学习算法也可以不断地更新。</p>
<h1 id="3-迁移学习的应用"><a href="#3-迁移学习的应用" class="headerlink" title="3.迁移学习的应用"></a>3.迁移学习的应用</h1><p>计算机视觉、文本分类、行为识别、自然语言处理、室内定位、视频监控、舆情分析、人机交互</p>
<h2 id="3-1-计算机视觉"><a href="#3-1-计算机视觉" class="headerlink" title="3.1 计算机视觉"></a>3.1 计算机视觉</h2><p>同一类图片，不同的拍摄角度、不同光照、不同背景，都会造成特征分布发生改变。因此，使用迁移学习构建跨领域的鲁棒分类器是十分重要的。</p>
<h2 id="3-2-文本分类"><a href="#3-2-文本分类" class="headerlink" title="3.2 文本分类"></a>3.2 文本分类</h2><p>由于文本数据有其领域特殊性，因此，在一个领域上训练的分类器，不能直接拿来作用到另一个领域上。这就需要用到迁移学习。例如，在电影评论文本数据集上训练好的分类器，不能直接用于图书评论的预测。这就需要进行迁移学习。</p>
<h2 id="3-3-时间序列"><a href="#3-3-时间序列" class="headerlink" title="3.3 时间序列"></a>3.3 时间序列</h2><p>行为识别 (Activity Recognition) 主要通过佩戴在用户身体上的传感器，研究用户的行<br>为。行为数据是一种时间序列数据。不同用户、不同环境、不同位置、不同设备，都会导致时间序列数据的分布发生变化。</p>
<h2 id="3-4-医疗健康"><a href="#3-4-医疗健康" class="headerlink" title="3.4 医疗健康"></a>3.4 医疗健康</h2><p>医疗领域研究的难点问题是，无法获取足够有效的医疗数据。</p>
<h1 id="4-基础知识"><a href="#4-基础知识" class="headerlink" title="4.基础知识"></a>4.基础知识</h1><h2 id="4-1迁移学习的问题形式化"><a href="#4-1迁移学习的问题形式化" class="headerlink" title="4.1迁移学习的问题形式化"></a>4.1迁移学习的问题形式化</h2><h3 id="4-1-1-领域"><a href="#4-1-1-领域" class="headerlink" title="4.1.1 领域"></a>4.1.1 领域</h3><p>领域(Domain)是进行学习的主体。领域主要由两部分构成：数据和生成这些数据的概率分布。源领域：有知识、有大量数据标注的领域；目标域：我们最终要赋予知识、赋予标注的对象。</p>
<h3 id="4-1-2-任务"><a href="#4-1-2-任务" class="headerlink" title="4.1.2 任务"></a>4.1.2 任务</h3><p>任务(Task)：学习的目标。由两部分组成：标签和标签对应的函数。</p>
<h3 id="4-1-3-迁移学习"><a href="#4-1-3-迁移学习" class="headerlink" title="4.1.3 迁移学习"></a>4.1.3 迁移学习</h3><p>领域自适应(Domain Adaptation)</p>
<h2 id="4-2-总体思路"><a href="#4-2-总体思路" class="headerlink" title="4.2 总体思路"></a>4.2 总体思路</h2><p>开发算法来最大限度地利用有标注地领域地知识，来辅助目标领域的知识获取和学习。<br>找到相似性 (不变量)，是进行迁移学习的核心。<br>度量工作的目标有两点：</p>
<ul>
<li>一是很好地度量两个领域的相似性，不仅定性地告诉我们它们是否相似，更定量地给<br>出相似程度。</li>
<li>二是以度量为准则，通过我们所要采用的学习手段，增大两个领域之间的相似性，从而完成迁移学习。</li>
</ul>
<p>一句话总结： ==相似性是核心，度量准则是重要手段。==</p>
<h2 id="4-3-度量准则"><a href="#4-3-度量准则" class="headerlink" title="4.3 度量准则"></a>4.3 度量准则</h2><p>核心：衡量两个数据域的差异。</p>
<h3 id="4-3-1-常见的几种距离"><a href="#4-3-1-常见的几种距离" class="headerlink" title="4.3.1 常见的几种距离"></a>4.3.1 常见的几种距离</h3><ul>
<li>1.欧式距离</li>
<li>2.闵科夫斯基距离</li>
<li>3.马氏距离</li>
</ul>
<h3 id="4-3-2-相似度"><a href="#4-3-2-相似度" class="headerlink" title="4.3.2 相似度"></a>4.3.2 相似度</h3><ul>
<li>1.余弦相似度</li>
<li>2.互信息</li>
<li>3.皮尔逊相关系数</li>
<li>4.Jaccard相关系数</li>
</ul>
<h3 id="4-3-3-KL散度与JS距离"><a href="#4-3-3-KL散度与JS距离" class="headerlink" title="4.3.3 KL散度与JS距离"></a>4.3.3 KL散度与JS距离</h3><h3 id="4-3-4-最大均值差异MMD-Maximun-mean-discrepancy"><a href="#4-3-4-最大均值差异MMD-Maximun-mean-discrepancy" class="headerlink" title="4.3.4 最大均值差异MMD(Maximun mean discrepancy)"></a>4.3.4 最大均值差异MMD(Maximun mean discrepancy)</h3><h3 id="4-3-5-Principle-Angle"><a href="#4-3-5-Principle-Angle" class="headerlink" title="4.3.5 Principle Angle"></a>4.3.5 Principle Angle</h3><h3 id="4-3-6-A-distance"><a href="#4-3-6-A-distance" class="headerlink" title="4.3.6 A-distance"></a>4.3.6 A-distance</h3><h3 id="4-3-7-Hilbert-Schmidt-Independence-Criterion"><a href="#4-3-7-Hilbert-Schmidt-Independence-Criterion" class="headerlink" title="4.3.7 Hilbert-Schmidt Independence Criterion"></a>4.3.7 Hilbert-Schmidt Independence Criterion</h3><h3 id="4-3-8-Wasserstein-Distance"><a href="#4-3-8-Wasserstein-Distance" class="headerlink" title="4.3.8 Wasserstein Distance"></a>4.3.8 Wasserstein Distance</h3><h2 id="4-4-迁移学习的理论保证"><a href="#4-4-迁移学习的理论保证" class="headerlink" title="4.4 迁移学习的理论保证"></a>4.4 迁移学习的理论保证</h2><p>这一部分有些难度。当自己提出的算法需要理论证明时，可以借鉴这一部分。</p>
<h1 id="5-迁移学习的基本方法"><a href="#5-迁移学习的基本方法" class="headerlink" title="5.迁移学习的基本方法"></a>5.迁移学习的基本方法</h1><p>四种基本方法：基于样本的迁移，基于模型的迁移，基于特征的迁移，以及基于关系的迁移。</p>
<h2 id="5-1-基于样本的迁移学习方法-Instance-based-Transfer-Learning"><a href="#5-1-基于样本的迁移学习方法-Instance-based-Transfer-Learning" class="headerlink" title="5.1 基于样本的迁移学习方法(Instance based Transfer Learning)"></a>5.1 基于样本的迁移学习方法(Instance based Transfer Learning)</h2><p><img src="https://s2.ax1x.com/2019/04/25/Ee9XWT.jpg" alt="t8"><br>如图，在迁移时，为了最大限度地和目标域相似，我们可以人为地提高源域中属于狗这个类别地样本权重。<br>优缺点：虽然实例权重法具有较好的理论支撑、容易推导泛化误差上界，但这类方法通常只在领域间分布差异较小时有效，因此对自然语言处理、计算机视觉等任务效果并不理想。</p>
<h2 id="5-2-基于特征迁移"><a href="#5-2-基于特征迁移" class="headerlink" title="5.2 基于特征迁移"></a>5.2 基于特征迁移</h2><p>通过特征变换的方式互相迁移，来减少源域和目标域之间地差距；或者将源域和目标域的数据特征变换到统一特征空间中，然后利用传统的机器学习方法进行分类识别。根据特征的同构和异构性，又可以分为同构和异构迁移学习。<br><img src="https://s2.ax1x.com/2019/04/25/EePN8K.jpg" alt="t15"><br>这类方法通常假设源域和目标域间有一些交叉的特征。</p>
<h2 id="5-3-基于模型学习"><a href="#5-3-基于模型学习" class="headerlink" title="5.3 基于模型学习"></a>5.3 基于模型学习</h2><p>基于模型的迁移方法 (Parameter/Model based Transfer Learning) 是指从源域和目标域中找到他们之间共享的参数信息，以实现迁移的方法。这种迁移方式要求的假设条件是：源域中的数据与目标域中的数据可以共享一些模型的参数。<br><img src="https://s2.ax1x.com/2019/04/25/EeFT3V.jpg" alt="t16"></p>
<h2 id="5-4-基于关系迁移"><a href="#5-4-基于关系迁移" class="headerlink" title="5.4 基于关系迁移"></a>5.4 基于关系迁移</h2><p>这种方法比较关注源域和目标域的样本之间的关系。<br>这些文章都借助于马尔科夫逻辑网络 (Markov Logic Net)来挖掘不同领域之间的关系相似性。<br>我们将重点讨论基于特征和基于模型的迁移学习方法，这也是目前绝大多数研究工作的热点。<br><img src="https://s2.ax1x.com/2019/04/25/EekS9x.jpg" alt="t17"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>迁移学习</tag>
      </tags>
  </entry>
  <entry>
    <title>30天自制操作系统（23）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8823%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY23-图形处理相关"><a href="#DAY23-图形处理相关" class="headerlink" title="DAY23_图形处理相关"></a>DAY23_图形处理相关</h1><h2 id="1-编写malloc"><a href="#1-编写malloc" class="headerlink" title="1.编写malloc"></a>1.编写malloc</h2><p>如果api_malloc只是调用操作系统中的memman_alloc，并将分配到的内存空间地址返回给应用程序的话，是行不通的，因为通过memman_alloc所获得的内存空间并不位于应用程序的数据段范围内，应用程序是无法进行读写操作的。如果应用程序在不知情的情况下执行了读写操作，将会产生异常并强制结束。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">memman初始化</span><br><span class="line">EDX=8 </span><br><span class="line">EBX=memman的地址</span><br><span class="line">EAX=memman所管理的内存空间的起始地址</span><br><span class="line">ECX=memman所管理的内存空间的字节数</span><br><span class="line">malloc</span><br><span class="line">EDX=9 </span><br><span class="line">EBX=memman的地址</span><br><span class="line">ECX=需要请求的字节数</span><br><span class="line">EAX=分配到的内存空间地址</span><br><span class="line">free</span><br><span class="line">EDX=10 </span><br><span class="line">EBX=memman的地址</span><br><span class="line">EAX=需要释放的内存空间地址</span><br><span class="line">ECX=需要释放的字节数</span><br></pre></td></tr></table></figure>
<h2 id="2-画点"><a href="#2-画点" class="headerlink" title="2.画点"></a>2.画点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在窗口中画点</span><br><span class="line">EDX =11 </span><br><span class="line">EBX =窗口句柄</span><br><span class="line">ESI =显示位置的x坐标</span><br><span class="line">EDI =显示位置的y坐标</span><br><span class="line">EAX =色号</span><br></pre></td></tr></table></figure>
<p>画星星<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title); </span><br><span class="line">void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col); </span><br><span class="line">void api_initmalloc(void); </span><br><span class="line">char *api_malloc(int size); </span><br><span class="line">void api_point(int win, int x, int y, int col); </span><br><span class="line">void api_end(void); </span><br><span class="line">int rand(void); /*产生0～32767之间的随机数*/ </span><br><span class="line">void HariMain(void) </span><br><span class="line">&#123; </span><br><span class="line"> char *buf; </span><br><span class="line"> int win, i, x, y; </span><br><span class="line"> api_initmalloc(); </span><br><span class="line"> buf = api_malloc(150 * 100);</span><br><span class="line">  win = api_openwin(buf, 150, 100, -1, &quot;stars&quot;); </span><br><span class="line"> api_boxfilwin(win, 6, 26, 143, 93, 0 /*黑色*/); </span><br><span class="line"> for (i = 0; i &lt; 50; i++) &#123; </span><br><span class="line"> x = (rand() % 137) + 6; </span><br><span class="line"> y = (rand() % 67) + 26; </span><br><span class="line"> api_point(win, x, y, 3 /*黄色*/); </span><br><span class="line"> &#125; </span><br><span class="line"> api_end(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-刷新窗口"><a href="#3-刷新窗口" class="headerlink" title="3.刷新窗口"></a>3.刷新窗口</h2><p>在所有的窗口绘图命令中设置一个“不自动刷新”的选项，然后再编写一个仅用来刷新的API<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">刷新窗口</span><br><span class="line">EDX = 12 </span><br><span class="line">EBX = 窗口句柄</span><br><span class="line">EAX = x0 </span><br><span class="line">ECX = y0 </span><br><span class="line">ESI = x1 </span><br><span class="line">EDI = y1</span><br></pre></td></tr></table></figure></p>
<h2 id="4-画直线"><a href="#4-画直线" class="headerlink" title="4.画直线"></a>4.画直线</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (i = 0; i &lt; len; i++) &#123; </span><br><span class="line"> api_point(win, x, y, col); </span><br><span class="line"> x += dx; </span><br><span class="line"> y += dy; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-关闭窗口"><a href="#5-关闭窗口" class="headerlink" title="5.关闭窗口"></a>5.关闭窗口</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关闭窗口</span><br><span class="line">EDX=14 </span><br><span class="line">EBX=窗口句柄</span><br></pre></td></tr></table></figure>
<h2 id="6-键盘输入API"><a href="#6-键盘输入API" class="headerlink" title="6.键盘输入API"></a>6.键盘输入API</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">键盘输入</span><br><span class="line">EDX = 15 </span><br><span class="line">EAX = 0……没有键盘输入时返回1，不休眠</span><br><span class="line"> = 1……休眠直到发生键盘输入</span><br><span class="line">EAX = 输入的字符编码</span><br></pre></td></tr></table></figure>
<h2 id="8-强制结束并关闭窗口"><a href="#8-强制结束并关闭窗口" class="headerlink" title="8.强制结束并关闭窗口"></a>8.强制结束并关闭窗口</h2><p>问题：在运行walk.hrb和lines.hrb时，如果不按回车键结束，而是按Shift+F1强制结束程序的话，窗口就会残留在画面上。<br>解决方法：在struct SHEET中添加一个用来存放task的成员，当应用程序结束时，查询所有的图层，如果图层的task为将要结束的应用程序任务，则关闭该图层。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（22）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8822%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY22-用C语言编写应用程序"><a href="#DAY22-用C语言编写应用程序" class="headerlink" title="DAY22_用C语言编写应用程序"></a>DAY22_用C语言编写应用程序</h1><h2 id="1-保护操作系统（5）"><a href="#1-保护操作系统（5）" class="headerlink" title="1.保护操作系统（5）"></a>1.保护操作系统（5）</h2><p>问题：在定时器上做手脚，光标闪烁变得异常缓慢，任务切换的速度也会变得缓慢。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[INSTRSET &quot;i486p&quot;] </span><br><span class="line">[BITS 32] </span><br><span class="line">    MOV AL,0x34 </span><br><span class="line">    OUT 0x43,AL </span><br><span class="line">    MOV AL,0xff</span><br><span class="line">    OUT 0x40,AL </span><br><span class="line">    MOV AL,0xff </span><br><span class="line">    OUT 0x40,AL</span><br><span class="line">    </span><br><span class="line">; 上述代码的功能与下面代码相当</span><br><span class="line">; io_out8(PIT_CTRL, 0x34); </span><br><span class="line">; io_out8(PIT_CNT0, 0xff); </span><br><span class="line">; io_out8(PIT_CNT0, 0xff); </span><br><span class="line"> </span><br><span class="line">    MOV EDX,4 </span><br><span class="line">    INT 0x40</span><br></pre></td></tr></table></figure></p>
<span id="more"></span>
<ul>
<li>执行CLI然后再HLT。由于不再产生定时器中断，任务切换也会停止，键盘和鼠标中断也停止响应。</li>
</ul>
<h2 id="2-帮助发现bug"><a href="#2-帮助发现bug" class="headerlink" title="2.帮助发现bug"></a>2.帮助发现bug</h2><p>CPU的异常处理功能，除了可以保护操作系统免遭应用程序的破坏，还可以帮助我们在编写应用程序时及早发现bug。</p>
<hr>
<p>对栈异常的处理：<br>要想让它发现bug，最好能知道引发异常的指令的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *inthandler0c(int *esp) </span><br><span class="line">&#123; </span><br><span class="line"> struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec); </span><br><span class="line"> struct TASK *task = task_now(); </span><br><span class="line"> char s[30]; /*这里！*/ </span><br><span class="line"> cons_putstr0(cons, &quot;\nINT 0C :\n Stack Exception.\n&quot;); </span><br><span class="line"> sprintf(s, &quot;EIP = %08X\n&quot;, esp[11]); /*这里！*/ </span><br><span class="line"> cons_putstr0(cons, s); /*这里！*/ </span><br><span class="line"> return &amp;(task-&gt;tss.esp0); /*强制结束程序*/ </span><br><span class="line">&#125; </span><br><span class="line">int *inthandler0d(int *esp) </span><br><span class="line">&#123; </span><br><span class="line"> struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec); </span><br><span class="line"> struct TASK *task = task_now(); </span><br><span class="line"> char s[30]; /*这里！*/ </span><br><span class="line"> cons_putstr0(cons, &quot;\nINT 0D :\n General Protected Exception.\n&quot;); </span><br><span class="line"> sprintf(s, &quot;EIP = %08X\n&quot;, esp[11]); /*这里！*/ </span><br><span class="line"> cons_putstr0(cons, s); /*这里！*/ </span><br><span class="line"> return &amp;(task-&gt;tss.esp0); /*强制结束程序*/ </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-强制结束应用程序"><a href="#3-强制结束应用程序" class="headerlink" title="3.强制结束应用程序"></a>3.强制结束应用程序</h2><ul>
<li>如何实现？<br>将某一个键设定为强制结束键，按一下就可以结束程序。<br>把强制结束处理写在其他的任务中，bootpack.c</li>
</ul>
<h2 id="4-用C语言显示字符串（1）"><a href="#4-用C语言显示字符串（1）" class="headerlink" title="4.用C语言显示字符串（1）"></a>4.用C语言显示字符串（1）</h2><p>已经做好了用来显示字符串的API，却没做可供C语言调用该API的函数。</p>
<h2 id="5-用C语言显示字符串（2）"><a href="#5-用C语言显示字符串（2）" class="headerlink" title="5.用C语言显示字符串（2）"></a>5.用C语言显示字符串（2）</h2><p>连接了.obj文件的bim2hrb认为“hello, world”这个字符串就应该存放在0x400这个地址中。<br>由bim2hrb生成的.hrb文件其实是由两个部分构成的。</p>
<ul>
<li>代码部分</li>
<li>数据部分</li>
</ul>
<p>修改console.c：</p>
<ul>
<li>文件中找不到“Hari”标志则报错。</li>
<li>数据段的大小根据.hrb文件中指定的值进行分配。</li>
<li>将.hrb文件中的数据部分先复制到数据段后再启动程序。</li>
</ul>
<h2 id="6-显示窗口"><a href="#6-显示窗口" class="headerlink" title="6.显示窗口"></a>6.显示窗口</h2><p>编写一个用来显示窗口的API<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EDX = 5 </span><br><span class="line">EBX = 窗口缓冲区</span><br><span class="line">ESI = 窗口在x轴方向上的大小（即窗口宽度）</span><br><span class="line">EDI = 窗口在y轴方向上的大小（即窗口高度）</span><br><span class="line">EAX = 透明色</span><br><span class="line">ECX = 窗口名称</span><br></pre></td></tr></table></figure></p>
<h2 id="7-在窗口中描绘字符和方"><a href="#7-在窗口中描绘字符和方" class="headerlink" title="7.在窗口中描绘字符和方"></a>7.在窗口中描绘字符和方</h2><p>显示字符的API：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EDX = 6 </span><br><span class="line">EBX = 窗口句柄</span><br><span class="line">ESI = 显示位置的x坐标</span><br><span class="line">EDI = 显示位置的y坐标</span><br><span class="line">EAX = 色号</span><br><span class="line">ECX = 字符串长度</span><br><span class="line">EBP = 字符串</span><br></pre></td></tr></table></figure></p>
<p>描绘方块的API：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EDX = 7 </span><br><span class="line">EBX = 窗口句柄</span><br><span class="line">EAX = x0 </span><br><span class="line">ECX = y0 </span><br><span class="line">ESI = x1 </span><br><span class="line">EDI = y1 </span><br><span class="line">EBP = 色号</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（21）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8821%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY21-保护操作系统"><a href="#DAY21-保护操作系统" class="headerlink" title="DAY21_保护操作系统"></a>DAY21_保护操作系统</h1><h2 id="1-攻克难题——字符串显示API"><a href="#1-攻克难题——字符串显示API" class="headerlink" title="1.攻克难题——字符串显示API"></a>1.攻克难题——字符串显示API</h2><ul>
<li>我们需要在API中做个改动，使其能够将应用程序传递的地址解释为代码段内地址。</li>
</ul>
<span id="more"></span>
<h2 id="2-用C语言编写应用程序"><a href="#2-用C语言编写应用程序" class="headerlink" title="2.用C语言编写应用程序"></a>2.用C语言编写应用程序</h2><p>要实现C语言编写应用程序，需要在应用程序方面创建一个api_putchar函数。注意，这个函数不是创建在操作系统中。api_putchar函数需要用C语言来调用，功能是向EDX和AL赋值，并调用INT 0x40。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[FORMAT &quot;WCOFF&quot;] ; 生成对象文件的模式</span><br><span class="line">[INSTRSET &quot;i486p&quot;] ; 表示使用486兼容指令集</span><br><span class="line">[BITS 32] ; 生成32位模式机器语言</span><br><span class="line">[FILE &quot;a_nask.nas&quot;] ; 源文件名信息</span><br><span class="line"> </span><br><span class="line">    GLOBAL _api_putchar </span><br><span class="line"></span><br><span class="line">[SECTION .text] </span><br><span class="line">_api_putchar: ; void api_putchar(int c); </span><br><span class="line">    MOV EDX,1 </span><br><span class="line">    MOV AL,[ESP+4] ; c </span><br><span class="line">    INT 0x40 </span><br><span class="line">    RET</span><br></pre></td></tr></table></figure>
<p>这里的api_putchar需要与a.c的编译结果进行连接，因此我们使用对象文件模式</p>
<h2 id="3-保护操作系统（1）"><a href="#3-保护操作系统（1）" class="headerlink" title="3.保护操作系统（1）"></a>3.保护操作系统（1）</h2><p>操作系统需要运行各种应用程序，而这些应用程序有可能是操作系统开发者编写的，也有可能是用户、别的软件开发商或者是某个自由软件作者出于善意编写的。<br>所谓对操作系统的破坏，严重程度也不同，比如擅自删除重要文件、使其他任务的运行产生异常，或者造成操作系统死机而不得不重新启动等等。</p>
<h2 id="4-保护操作系统（2）"><a href="#4-保护操作系统（2）" class="headerlink" title="4.保护操作系统（2）"></a>4.保护操作系统（2）</h2><p>我们需要为应用程序提供专用的内存空间，并且禁止别的应用程序访问。<br>要做到这一点，我们可以创建应用程序专用的数据段，并在应用程序运行期间，将DS和SS指向该段地址。<br>这次我们还使用了以句点（.）开头的标签名，这是一种被称为本地标签的特殊标签。它基本上和普通的标签功能一样，区别在于即使标签名和其他函数中的标签重复，系统也能将它们区分开来。</p>
<h2 id="5-对异常的支持"><a href="#5-对异常的支持" class="headerlink" title="5.对异常的支持"></a>5.对异常的支持</h2><p>接下来我们要实现强制结束程序的功能。<br>要想强制结束程序，只要在中断号0x0d中注册一个函数即可。<br>这是因为在x86架构规范中，当应用程序试图破坏操作系统，或者试图违背操作系统的设置时，就会自动产生0x0d中断，因此该中断也被称为“异常”。</p>
<h2 id="6-保护操作系统（3）"><a href="#6-保护操作系统（3）" class="headerlink" title="6.保护操作系统（3）"></a>6.保护操作系统（3）</h2><p>可能出现的问题：操作系统会指定应用程序的DS，因此破坏行为会发生异常，那么如果忽略操作系统指定的DS，而是用汇编语言直接将操作系统用的段地址存入DS的话，就又可以干坏事了。</p>
<h2 id="7-保护操作系统（4）"><a href="#7-保护操作系统（4）" class="headerlink" title="7.保护操作系统（4）"></a>7.保护操作系统（4）</h2><ul>
<li>想法：让应用程序无法使用操作系统的段地址。</li>
<li>具体做法：x86架构有这样的功能。<br>在段定义的地方，如果将访问权限加上0x60的话，就可以将段设置为应用程序用。<br>当CS中的段地址为应用程序用段地址时，CPU会认为“当前正在运行应用程序”，这时如果存入操作系统用的段地址就会产生异常。  </li>
</ul>
<hr>
<p>在启动应用程序的时候我们需要让“操作系统向应用程序的段执行far-CALL”<br>解决方案：可以使用RETF</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>基于链接内容的社区发现算法（二）</title>
    <url>/201904/%E5%9F%BA%E4%BA%8E%E9%93%BE%E6%8E%A5%E5%86%85%E5%AE%B9%E7%9A%84%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Robust-Detection-of-Link-Communities-in-Large-Social-Network-by-Exploiting-Link-Semantics"><a href="#Robust-Detection-of-Link-Communities-in-Large-Social-Network-by-Exploiting-Link-Semantics" class="headerlink" title="Robust Detection of Link Communities in Large Social Network by Exploiting Link Semantics"></a>Robust Detection of Link Communities in Large Social Network by Exploiting Link Semantics</h1><div class="note primary">这一部分没什么难点，ppt里写的都很清楚了。。</div>

<h3 id="三、试验"><a href="#三、试验" class="headerlink" title="三、试验"></a>三、试验</h3><h4 id="1-数据集"><a href="#1-数据集" class="headerlink" title="1.数据集"></a>1.数据集</h4><p>我们选择了两个数据集，包括美国安然能源公司内部的邮件内容（安然公司丑闻，加州能源危机）和Reddit新闻网站三天的的三个论坛的内容。如果用户A对用户B的帖子进行评论，就产生了一条从A到B的链接，链接内容为评论的内容。</p>
<span id="more"></span>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JUNd.md.png" alt="2.1"></p>
<p>那么如何判断我们社区发现的结果是正确的呢？<br>对于第一个数据集，伯克利大学的学生已经将这些用户节点分成了11个用户社区，我们可以直接将社区发现的结果与这十一个社区比对。对于第二个数据集，我们可以直接将发现的社区和三个论坛内容相比较。</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7J03t.png" alt="2.2"></p>
<h4 id="2-对比的方法"><a href="#2-对比的方法" class="headerlink" title="2.对比的方法"></a>2.对比的方法</h4><p>我们采取了8种最先进的社区发现算法，包括利用拓扑结构的、利用结点内容的、利用链接内容的、可重叠的、不可重叠的（可重叠的意思就是可以将一个用户结点放进多个社区里）等，如图：</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JBgP.png" alt="2.3"></p>
<h4 id="3-测评参数"><a href="#3-测评参数" class="headerlink" title="3.测评参数"></a>3.测评参数</h4><p>F-score和Jaccard similarity，用于测评相似度的两个参数，结果两个参数越大，说明社区发现的结果越好。</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JgEQ.png" alt="2.4"></p>
<h4 id="4-结果"><a href="#4-结果" class="headerlink" title="4.结果"></a>4.结果</h4><p><img src="https://s2.ax1x.com/2019/04/11/A7JDjf.md.png" alt="2.5"></p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7J5vV.png" alt="2.6"></p>
<h4 id="5-个例研究"><a href="#5-个例研究" class="headerlink" title="5.个例研究"></a>5.个例研究</h4><p>我们选择了Reddit网站2012年8月27号的数据集进行分析，与我们的方法对比的是SCI</p>
<p>SCI方法的结果如下：</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JyDS.png" alt="2.7"></p>
<p>我们的方法：<br><img src="https://s2.ax1x.com/2019/04/17/AxqfbT.jpg" alt="2.8"></p>
<p><img src="https://s2.ax1x.com/2019/04/17/Axq4VU.png" alt="2.9"></p>
<p>我们的方法还有一个好处，就是可以通过fai和Y找到社区的词云：</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JR4s.md.png" alt="2.10"></p>
<p>我们方法的应用建议：</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7Jh3q.png" alt="2.11"></p>
<h3 id="四、结论"><a href="#四、结论" class="headerlink" title="四、结论"></a>四、结论</h3><p><img src="https://s2.ax1x.com/2019/04/11/A7JfCn.md.png" alt="2.12"></p>
<p>这是文章的标题，下面我们对标题的关键词进行讨论和总结。<br>Robust:健壮性。在传统的方法中，当网络拓朴和话题群聚不重合的时候，方法的效率就会变得很低，而我们的方法将网络拓朴和话题群聚分开来讨论，具有一定的健壮性。</p>
<p>Detection of Link Communities：本论文的主要内容——社区发现。</p>
<p>Exploiting Link Semantics: 基于链接语义。</p>
]]></content>
      <categories>
        <category>社区发现</category>
      </categories>
      <tags>
        <tag>社区发现</tag>
      </tags>
  </entry>
  <entry>
    <title>基于链接内容的社区发现算法（一）</title>
    <url>/201904/%E5%9F%BA%E4%BA%8E%E9%93%BE%E6%8E%A5%E5%86%85%E5%AE%B9%E7%9A%84%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Robust-Detection-of-Link-Communities-in-Large-Social-Network-by-Exploiting-Link-Semantics"><a href="#Robust-Detection-of-Link-Communities-in-Large-Social-Network-by-Exploiting-Link-Semantics" class="headerlink" title="Robust Detection of Link Communities in Large Social Network by Exploiting Link Semantics"></a>Robust Detection of Link Communities in Large Social Network by Exploiting Link Semantics</h1><p><a href="https://www.aaai.org/ocs/index.php/AAAI/AAAI18/paper/viewPaper/17345">Robust Detection of Link Communities in Large Social Network by Exploiting Link Semantics </a></p>
<p>这篇论文是我加入张老师实验室读的第一篇论文，寒假里草草读了一遍，感叹了自己垃圾的英文水平，上周除了上课和作业基本没做什么，一直在研读这篇论文。很幸运的是上周关于这篇论文的汇报我做的非常精彩，也不枉自己上周那么辛苦的肝了。  </p>
<p>这篇博客用来记录自己研读时候的思考和整理。  </p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7J9ts.png" alt="1.1"></p>
<p>整个论文的整体内容我将从四个方面介绍。分别是社区发现算法的背景和现存的方法、论文提出的模型和方法、试验和结论与讨论。</p>
<span id="more"></span>
<h2 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h2><p><img src="https://s2.ax1x.com/2019/04/11/A7GvnS.png" alt="1.2">  </p>
<h3 id="1-1-社交网络的发展"><a href="#1-1-社交网络的发展" class="headerlink" title="1.1 社交网络的发展"></a>1.1 社交网络的发展</h3><ul>
<li>社交对于世界各地各领域的人们来讲都越来越重要。随着社交网络的发展，越来越多的信息开始在互联网中聚集。</li>
<li>对于这些大数据的分析能够让我们更加熟悉网络的深层结构、了解用户行为和未来趋势。</li>
<li>社交网络中的一个重要的问题便是社区发现，通过社区发现我们能够为用户提供个性化推荐和异常行为的识别。</li>
<li>所谓的“社区发现”，就是将出现在社交网络中的用户节点划分成不同的组别。每个组的用户结点都有着某些相同的特征。</li>
</ul>
<h3 id="1-2-现存的方法"><a href="#1-2-现存的方法" class="headerlink" title="1.2 现存的方法"></a>1.2 现存的方法</h3><p><img src="https://s2.ax1x.com/2019/04/11/A7Jipq.png" alt="1.3"></p>
<ul>
<li>我们通常用一个图来表示社交网络。其中的点表示用户结点，其中的边表示用户之间的联系。</li>
<li>最初人们社区发现的算法是根据网络的<font color="FF0000">拓扑结构</font>，即让我们划分后的各个社区间的边的数量最少，社区内部点之间的边尽可能的多</li>
<li>之后，社区发现的算法得到改进，我们通过节点内容进行社区划分，即使得同一个社区内的结点内容尽可能多的相似。通过结点内容进行社区发现能够大大提升我们社区发现的效率。</li>
<li>同时我们发现，用户之间的链接，即图中的边也含有大量的信息。</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JChn.png" alt="1.4"></p>
<p>这张图形象的表示了我们的方法和其他方法的区别。其中右边的图是基于结点内容进行社区发现的算法示意图，左边的图是我们基于链接内容进行社区发现的图。<br>我们可以看出现有的其他方法的问题：</p>
<ul>
<li>1.只考虑了节点内容。考虑节点内容进行社区发现在有些时候有很高的效率。以微博用户的社区发现为例，当我们提供的内容是用户简介时，基于节点内容进行社区发现是很可以的。但是当我们提供的内容是用户之间发送的消息时，这其实是一种“链接内容”，我们需要将链接内容转换成节点内容，比如用户A发送的所有消息算成用户A的节点内容。这时候势必导致社区划分的不准确。</li>
<li>2.假设网络拓扑社区和结点内容社区的用户结点是一样的。两个用户间联系紧密，构成一个拓扑社区，但是他们聊天的内容可能是很五花八门的，两个人可能被分到不同的节点内容社区中去，这个时候现有的方法社区发现的效率就会下降。</li>
<li>3.每个社区仅仅有一个话题。比如右边的图把Music和Movies混在一起当作一个话题，而我们的方法（左边）含有两个话题。</li>
<li>4.仅仅用单个词汇进行社区标签。有时候我们可能会不知所云。而我们的方法用句子进行标签，便于理解。</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JF10.png" alt="1.5"></p>
<h2 id="2-The-Model-and-Method"><a href="#2-The-Model-and-Method" class="headerlink" title="2.The Model and Method"></a>2.The Model and Method</h2><h3 id="2-1综述"><a href="#2-1综述" class="headerlink" title="2.1综述"></a>2.1综述</h3><p>详见图片  </p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JVnU.png" alt="1.6"></p>
<h3 id="2-2-详细分析"><a href="#2-2-详细分析" class="headerlink" title="2.2 详细分析"></a>2.2 详细分析</h3><p>我们先来看看我们进行社区发现需要考虑哪一些因素：</p>
<ul>
<li>拓扑角度：结点、链接</li>
<li>内容角度：单词、句子、话题</li>
<li>社区和话题群聚(topic cluster)</li>
</ul>
<h4 id="变量介绍"><a href="#变量介绍" class="headerlink" title="变量介绍"></a>变量介绍</h4><p>详见图片(难理解的内容都已经用中文进行注释)  </p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JkcV.md.png" alt="1.7"></p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JZBF.md.png" alt="1.8"></p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7Je74.md.png" alt="1.9"></p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JQ91.md.png" alt="1.10"></p>
<p>所有变量的详细关系如下图所示  </p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JnAJ.png" alt="1.11"></p>
<p>为了便于理解，我自己又画了一个图。</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JGnO.md.png" alt="1.12"></p>
<p>图左半部分就是根据拓扑结构进行社区发现，右半部分是根据节点内容进行社区发现。</p>
<p>现在，我们的模型已经建立起来了，我们的目标为以下三点：</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JKhR.png" alt="1.13"></p>
<h3 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h3><p>我们算法的整体思想是这样的：首先我们根据某标准把网络中的所有节点划分到不同的社区中（E-step），然后我们将提取每个社区中的关键词，来进行社区标注。（M-step）<br>我们再根据标注进行有监督的学习，对社区进行更精准的划分，以此来一遍遍迭代。  </p>
<p>下面我们运用了极大似然的思想进行EM算法。<br>E-step：</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JuN9.md.png" alt="1.14"></p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7J1c6.md.png" alt="1.15"></p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7Ja4A.md.png" alt="1.16"></p>
<p>我们进行期望化的变量是p，p代表着链接<i,j>被分配到哪个社区中。<br>现在p的取值是Jensen不等式的取等条件。</p>
<p>M-step：</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JJBD.png" alt="1.17"></p>
<p>下面我们要求式(3)的最大值，tau、 omega_ri、 y_rj都是可以通过直接求导求出来的。剩下的psai和fai的最大值我们再一次通过EM算法来求。引入变量p和h，运用JENSEN公式，p和h在取等条件时式子取到最大值。</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7JYHe.md.png" alt="1.18"></p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7Jw9I.md.png" alt="1.19"></p>
<p>下面我们给出整个算法的伪代码，看懂这个图整个算法的思路就差不多了。</p>
<p><img src="https://s2.ax1x.com/2019/04/11/A7Jsu8.png" alt="1.20"></p>
]]></content>
      <categories>
        <category>社区发现</category>
      </categories>
      <tags>
        <tag>社区发现</tag>
      </tags>
  </entry>
  <entry>
    <title>30天自制操作系统（20）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8820%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY20-API"><a href="#DAY20-API" class="headerlink" title="DAY20_API"></a>DAY20_API</h1><h3 id="1-程序整理"><a href="#1-程序整理" class="headerlink" title="1.程序整理"></a>1.程序整理</h3><p>目标：实现由应用程序对操作系统功能的调用（即API，也叫系统调用）。</p>
<h3 id="2-显示单个字符的API-1"><a href="#2-显示单个字符的API-1" class="headerlink" title="2.显示单个字符的API(1)"></a>2.显示单个字符的API(1)</h3><p>目标：显示单个字符的API。</p>
<span id="more"></span>
<ul>
<li>首先我们做一个测试用的应用程序，将要显示的字符编码存入AL寄存器，然后调用操作系<br>统的函数，字符就显示出来了。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[BITS 32] </span><br><span class="line">    MOV AL,&#x27;A&#x27; </span><br><span class="line">    CALL （cons_putchar的地址）</span><br><span class="line">fin: </span><br><span class="line">    HLT </span><br><span class="line">    JMP fin</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>bootpack.map文件<br>这是一个文本文件，用文本编辑器打开即可，其中应该可以找到这样一行：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00000BE3 : _asm_cons_putchar</span><br></pre></td></tr></table></figure><br>这就是_asm_cons_putchar的地址了，因此，我们将地址填在应用程序中.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[BITS 32] </span><br><span class="line">    MOV AL,&#x27;A&#x27; </span><br><span class="line">    CALL 0xbe3 </span><br><span class="line">fin: </span><br><span class="line">    HLT </span><br><span class="line">    JMP fin</span><br></pre></td></tr></table></figure>
<h3 id="3-显示单个字符的API-2"><a href="#3-显示单个字符的API-2" class="headerlink" title="3.显示单个字符的API(2)"></a>3.显示单个字符的API(2)</h3><ul>
<li>应用程序对API执行CALL的时候，千万不能忘记加上段号。</li>
</ul>
<h3 id="4-结束应用程序"><a href="#4-结束应用程序" class="headerlink" title="4.结束应用程序"></a>4.结束应用程序</h3><ul>
<li>C语言中没有用来执行far-CALL的命令，我们只好来创建一个farcall函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_farcall: ; void farcall(int eip, int cs); </span><br><span class="line">    CALL FAR [ESP+4] ; eip, cs </span><br><span class="line">    RET</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-不随操作系统版本而改变的-API"><a href="#5-不随操作系统版本而改变的-API" class="headerlink" title="5.不随操作系统版本而改变的 API"></a>5.不随操作系统版本而改变的 API</h3><h3 id="6-为应用程序自由命名"><a href="#6-为应用程序自由命名" class="headerlink" title="6.为应用程序自由命名"></a>6.为应用程序自由命名</h3><ul>
<li>目标：让系统支持其他应用程序名<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cons_runcmd</span><span class="params">(<span class="type">char</span> *cmdline, <span class="keyword">struct</span> CONSOLE *cons, <span class="type">int</span> *fat, <span class="type">unsigned</span> <span class="type">int</span> memtotal)</span> </span><br><span class="line">&#123; </span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cmdline, <span class="string">&quot;mem&quot;</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">        cmd_mem(cons, memtotal); </span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cmdline, <span class="string">&quot;cls&quot;</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">        cmd_cls(cons); </span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cmdline, <span class="string">&quot;dir&quot;</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">        cmd_dir(cons); </span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(cmdline, <span class="string">&quot;type &quot;</span>, <span class="number">5</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">        cmd_type(cons, fat, cmdline); </span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmdline[<span class="number">0</span>] != <span class="number">0</span>) &#123; <span class="comment">/*从此开始*/</span> </span><br><span class="line">     <span class="keyword">if</span> (cmd_app(cons, fat, cmdline) == <span class="number">0</span>) &#123; </span><br><span class="line">         <span class="comment">/*不是命令，不是应用程序，也不是空行*/</span> </span><br><span class="line">         putfonts8_asc_sht(cons-&gt;sht, <span class="number">8</span>, cons-&gt;cur_y, COL8_FFFFFF, COL8_000000, <span class="string">&quot;Bad command.&quot;</span>, </span><br><span class="line">         <span class="number">12</span>); </span><br><span class="line">         cons_newline(cons); </span><br><span class="line">         cons_newline(cons); </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; <span class="comment">/*到此结束 */</span> </span><br><span class="line">     <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="7-当心寄存器"><a href="#7-当心寄存器" class="headerlink" title="7.当心寄存器"></a>7.当心寄存器</h3><ul>
<li>命名只显示一个h</li>
<li>给_asm_cons_putchar添上2行代码，就是PUSHAD和POPAD。</li>
</ul>
<h3 id="8-用API显示字符"><a href="#8-用API显示字符" class="headerlink" title="8.用API显示字符"></a>8.用API显示字符</h3><ul>
<li>从实际的应用程序开发角度来说，能显示字符串的API远比只能显示单个字符的API要来的方便，因为一次显示一串字符的情况比一次只显示一个字符的情况多得多。</li>
<li>一般有两种方式：<ul>
<li>种是显示一串字符，遇到字符编码0则结束；</li>
<li>先指定好要显示的字符串的长度再显示。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">功能号 1……显示单个字符（AL = 字符编码）</span><br><span class="line">功能号 2……显示字符串 0（EBX = 字符串地址）</span><br><span class="line">功能号 3……显示字符串 1（EBX = 字符串地址，ECX = 字符串长度）</span><br></pre></td></tr></table></figure>
<ul>
<li>将_asm_cons_putchar改写成一个新的函数。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_asm_hrb_api:</span><br><span class="line">    STI</span><br><span class="line">    PUSHAD;</span><br><span class="line">    PUSHAD;</span><br><span class="line">    CALL _hrb_api</span><br><span class="line">    ADD ESP,32</span><br><span class="line">    POPAD</span><br><span class="line">    IRETD</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（19）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8819%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY19-应用程序"><a href="#DAY19-应用程序" class="headerlink" title="DAY19_应用程序"></a>DAY19_应用程序</h1><h3 id="1-type命令"><a href="#1-type命令" class="headerlink" title="1.type命令"></a>1.type命令</h3><ul>
<li>在Windows的命令行中，有一个叫做type的命令，输入“type 文件名”就会显示出文件的内容。</li>
</ul>
<span id="more"></span>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">磁盘映像中的地址 = clustno * 512 + 0x003e00</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>将s[0～10]这11个字节用空格的字符编码填充，然后读取cmdline[5～]并复制到s[0～]，在复制的同时，将其中的小写字母转换为大写字母。随后，当遇到句点时，则可以断定接下来的部分为扩展名，于是将复制的目标改为s[8～]。经过这样的转换，我们就得到了和磁盘内格式相同的文件名。</li>
<li>“寻找文件”这一段中，我们在磁盘中寻找与所输入的文件名相符的文件。如果成功找到指<br>定文件，则用break跳出for循环；如果找不到，则会在x到达224或者finfo[x].name[0]为0x00时结束循环。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* type命令*/</span> </span><br><span class="line"> <span class="comment">/*准备文件名*/</span> </span><br><span class="line"> <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">11</span>; y++) &#123; </span><br><span class="line">    s[y] = <span class="string">&#x27; &#x27;</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> y = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">for</span> (x = <span class="number">5</span>; y &lt; <span class="number">11</span> &amp;&amp; cmdline[x] != <span class="number">0</span>; x++) &#123; </span><br><span class="line">    <span class="keyword">if</span> (cmdline[x] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; y &lt;= <span class="number">8</span>) &#123; </span><br><span class="line">    y = <span class="number">8</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    s[y] = cmdline[x]; </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> &lt;= s[y] &amp;&amp; s[y] &lt;= <span class="string">&#x27;z&#x27;</span>) &#123; </span><br><span class="line">        <span class="comment">/*将小写字母转换成大写字母 */</span> </span><br><span class="line">        s[y] -= <span class="number">0x20</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    y++; </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">/*寻找文件*/</span> </span><br><span class="line"> <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">224</span>; ) &#123; </span><br><span class="line">    <span class="keyword">if</span> (finfo[x].name[<span class="number">0</span>] == <span class="number">0x00</span>) &#123; </span><br><span class="line">    <span class="keyword">break</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> ((finfo[x].type &amp; <span class="number">0x18</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">11</span>; y++) &#123; </span><br><span class="line">    <span class="keyword">if</span> (finfo[x].name[y] != s[y]) &#123; </span><br><span class="line">        <span class="keyword">goto</span> type_next_file; </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">break</span>; <span class="comment">/*找到文件*/</span> </span><br><span class="line"> &#125; </span><br><span class="line"> type_next_file: </span><br><span class="line"> x++; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (x &lt; <span class="number">224</span> &amp;&amp; finfo[x].name[<span class="number">0</span>] != <span class="number">0x00</span>) &#123; </span><br><span class="line">    <span class="comment">/*找到文件的情况*/</span> </span><br><span class="line">    y = finfo[x].size;</span><br><span class="line">    p = (<span class="type">char</span> *) (finfo[x].clustno * <span class="number">512</span> + <span class="number">0x003e00</span> + ADR_DISKIMG); </span><br><span class="line">    cursor_x = <span class="number">8</span>; </span><br><span class="line"> <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; y; x++) &#123; </span><br><span class="line">    <span class="comment">/*逐字输出*/</span> </span><br><span class="line">    s[<span class="number">0</span>] = p[x]; </span><br><span class="line">    s[<span class="number">1</span>] = <span class="number">0</span>; </span><br><span class="line">    putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, s, <span class="number">1</span>); </span><br><span class="line">     cursor_x += <span class="number">8</span>; </span><br><span class="line">    <span class="keyword">if</span> (cursor_x == <span class="number">8</span> + <span class="number">240</span>) &#123; <span class="comment">/*到达最右端后换行*/</span> </span><br><span class="line">    cursor_x = <span class="number">8</span>; </span><br><span class="line">    cursor_y = cons_newline(cursor_y, sheet); </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="comment">/*没有找到文件的情况*/</span> </span><br><span class="line"> putfonts8_asc_sht(sheet, <span class="number">8</span>, cursor_y, COL8_FFFFFF, COL8_000000, <span class="string">&quot;File </span></span><br><span class="line"><span class="string"> not found.&quot;</span>, <span class="number">15</span>); </span><br><span class="line"> cursor_y = cons_newline(cursor_y, sheet); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-type命令改良"><a href="#2-type命令改良" class="headerlink" title="2.type命令改良"></a>2.type命令改良</h3><ul>
<li><p>目标：实现对换行的支持。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x09……制表符：显示空格直到 x 被 4 整除为止</span><br><span class="line">0x0a……换行符：换行</span><br><span class="line">0x0d……回车符：忽略</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们这里所说的制表符也称为水平制表符（horizonal tab），因为对齐字符位置是在水平方向上移动。相对的，还有一种垂直制表符（vertical tab）</p>
</li>
<li>在Windows中换行的字符编码为“0x0d 0x0a”两个字节，而Linux中只有“0x0a”一个字节。<ul>
<li>字符编码0x0a原本代表折行（line feed）的意思，即只是移动到下一行。</li>
<li>0x0d，也就是回车符的文字编码，代表“让打印头（或者打字机的辊筒）回到行首”的意思，因此才被称为“回车”（carriage return）。</li>
</ul>
</li>
</ul>
<h3 id="3-对FAT的支持"><a href="#3-对FAT的支持" class="headerlink" title="3.对FAT的支持"></a>3.对FAT的支持</h3><ul>
<li>现在的type命令，肯定可以正确显示文件开头的512个字节的内容，但是如果遇到大于512个字节的文件，中间可能就会突然显示出其他文件的内容。</li>
<li>对于文件的下一段存放在哪里，在磁盘中是有记录的，我们只要分析这个记录，就可以正确读取文件内容了。</li>
<li>它位于从0柱面、0磁头、2扇区开始的9个扇区中，在磁盘映像中相当于0x000200～0x0013ff。这个记录被称为FAT，是“file allocation table”的缩写，翻译过来叫作“文件分配表”（即记录文件在磁盘中存放位置的表）。</li>
</ul>
<h3 id="4-代码整理"><a href="#4-代码整理" class="headerlink" title="4.代码整理"></a>4.代码整理</h3><ul>
<li>窗口相关函数 → window.c </li>
<li>命令行窗口相关函数 → console.c </li>
<li>文件相关函数 → file.c</li>
</ul>
<h3 id="5-第一个应用程序"><a href="#5-第一个应用程序" class="headerlink" title="5.第一个应用程序"></a>5.第一个应用程序</h3><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[BITS 32] </span><br><span class="line">fin: </span><br><span class="line"> HLT </span><br><span class="line"> JMP fin</span><br></pre></td></tr></table></figure></h2><ul>
<li>像type命令一样，我们用file_loadfile将文件的内容读到内存中</li>
<li>应用程序不知道自己被读到哪个内存地址，这里暂且由ORG0来生成。因此，为了应用程序能够顺利运行，我们需要为其创建一个内存段。</li>
<li>段创建好之后，接下来只要goto到该段中的程序，程序应该就会开始运行了。要goto到其他的内存段，在汇编语言中用farjmp指令。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">11</span>; y++) &#123; </span><br><span class="line">     s[y] = <span class="string">&#x27; &#x27;</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> s[<span class="number">0</span>] = <span class="string">&#x27;H&#x27;</span>; </span><br><span class="line"> s[<span class="number">1</span>] = <span class="string">&#x27;L&#x27;</span>; </span><br><span class="line"> s[<span class="number">2</span>] = <span class="string">&#x27;T&#x27;</span>; </span><br><span class="line"> s[<span class="number">8</span>] = <span class="string">&#x27;H&#x27;</span>; </span><br><span class="line"> s[<span class="number">9</span>] = <span class="string">&#x27;R&#x27;</span>; </span><br><span class="line"> s[<span class="number">10</span>] = <span class="string">&#x27;B&#x27;</span>; </span><br><span class="line"> <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">224</span>; ) &#123; </span><br><span class="line">     <span class="keyword">if</span> (finfo[x].name[<span class="number">0</span>] == <span class="number">0x00</span>) &#123; </span><br><span class="line">     <span class="keyword">break</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> ((finfo[x].type &amp; <span class="number">0x18</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">     <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">11</span>; y++) &#123; </span><br><span class="line">         <span class="keyword">if</span> (finfo[x].name[y] != s[y]) &#123; </span><br><span class="line">         <span class="keyword">goto</span> hlt_next_file; </span><br><span class="line">         &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">/*找到文件*/</span> </span><br><span class="line">     &#125; </span><br><span class="line">     hlt_next_file: </span><br><span class="line">     x++; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (x &lt; <span class="number">224</span> &amp;&amp; finfo[x].name[<span class="number">0</span>] != <span class="number">0x00</span>) &#123; </span><br><span class="line">     <span class="comment">/*找到文件的情况*/</span> </span><br><span class="line">     p = (<span class="type">char</span> *) memman_alloc_4k(memman, finfo[x].size); </span><br><span class="line">     file_loadfile(finfo[x].clustno, finfo[x].size, p, fat, (<span class="type">char</span> *) </span><br><span class="line">     (ADR_DISKIMG + <span class="number">0x003e00</span>)); </span><br><span class="line">     set_segmdesc(gdt + <span class="number">1003</span>, finfo[x].size - <span class="number">1</span>, (<span class="type">int</span>) p, AR_CODE32_ER); </span><br><span class="line">     farjmp(<span class="number">0</span>, <span class="number">1003</span> * <span class="number">8</span>); </span><br><span class="line">     memman_free_4k(memman, (<span class="type">int</span>) p, finfo[x].size); </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="comment">/*没有找到文件的情况*/</span> </span><br><span class="line">     putfonts8_asc_sht(sheet, <span class="number">8</span>, cursor_y, COL8_FFFFFF, COL8_000000, <span class="string">&quot;File </span></span><br><span class="line"><span class="string">     not found.&quot;</span>, <span class="number">15</span>); </span><br><span class="line">     cursor_y = cons_newline(cursor_y, sheet); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">/*到此结束*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>循环赛赛程安排</title>
    <url>/201904/%E5%BE%AA%E7%8E%AF%E8%B5%9B%E8%B5%9B%E7%A8%8B%E5%AE%89%E6%8E%92/</url>
    <content><![CDATA[<h2 id="一、问题重述"><a href="#一、问题重述" class="headerlink" title="一、问题重述"></a>一、问题重述</h2><p>设有n个运动员要进行网球循环赛。设计一个满足下列条件的比赛日程表：</p>
<ul>
<li>每个选手必须与其他n-1个选手各赛一次；</li>
<li>每个选手一天只能赛一次；</li>
<li>当n是偶数时，循环赛进行n-1天。</li>
<li>当n是奇数时，循环赛进行n天。</li>
</ul>
<span id="more"></span>
<h2 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h2><h4 id="1-当n是2的次幂时"><a href="#1-当n是2的次幂时" class="headerlink" title="1.当n是2的次幂时"></a>1.当n是2的次幂时</h4><p> $ n=2^k,k=1,2,3,4… $时，此时问题比较简单。按照==分治==的策略，可将所有参赛的选手分为两部分，$ n＝2k $个选手的比赛日程表可以通过为 $ n/2＝2k-1 $ 个选手设计的比赛日程表来决定。递归地执行这种分割，直到只剩下 2 个选手时，比赛日程表的制定就变得很简单：只要让这 2 个选手进行比赛就可以了。再逐步合并子问题的解即可得到原问题的解。<br> 示意图如下：</p>
<p><img src="https://s2.ax1x.com/2019/04/13/ALTauj.jpg" alt="1.1"></p>
<p>此时的分治算法如下所示:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void tourna(int n) //基本的分治算法</span><br><span class="line">&#123;</span><br><span class="line">    if(n==1)&#123;a[0][0]=1;return;&#125;</span><br><span class="line">    tourna(n/2); //分治</span><br><span class="line">    copy(n); //合并</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void copy(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int m=n/2;</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">        //由左上角小块的值算出对应的右上角小块的值</span><br><span class="line">        a[i][j+m]=a[i][j]+m;</span><br><span class="line">        //由右上角小块的值算出对应的左下角小块的值</span><br><span class="line">        a[i+m][j]=a[i][j+m];</span><br><span class="line">        //由左上角小块的值算出对应的右下角小块的值</span><br><span class="line">        a[i+m][j+m]=a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们用a[i][j]表示第i支队伍在第j天遇到的对手。</p>
<h4 id="2-当n不是2的次幂时"><a href="#2-当n不是2的次幂时" class="headerlink" title="2.当n不是2的次幂时"></a>2.当n不是2的次幂时</h4><p>下面讨论当n不是2的次幂时的情况。<br>我们发现当n为奇数时，每天必定有一支队伍轮空。此时我们==假定还有一只不存在的队伍与轮空的队伍比赛==，将我们的奇偶数情况的模型统一。此时n的赛程表与偶数n+1时的赛程表是相似的。<br>比如，当n=4时<br>| 0 | 1 | 2 | 3 |<br>|—-|—-|—-|—-|<br>| 1 | 0 | 3 | 2 |<br>| 2 | 3 | 0 | 1 |<br>| 3 | 2 | 1 | 0 |</p>
<p>当n=3时<br>| 0 | 1 | 2 | / |<br>|—-|—-|—-|—-|<br>| 1 | 0 | / | 2 |<br>| 2 | / | 0 | 1 |<br>| / | 2 | 1 | 0 |</p>
<p>(删去最后一行)其中“/”表示轮空。</p>
<p>综上，当遇到n为奇数的情况，我们便可以转化为偶数来考虑。</p>
<p>接下来我们遇到问题的难点==矩阵的合并==<br>当n/2为偶数时，合并比较容易，就像$ n=2^k $那样。<br>下面我们来考虑n/2为奇数的情况。<br>此时合并的过程我参考了<a href="https://www.cnblogs.com/zhuyijie/p/6465812.html">猪一戒的博客</a></p>
<p>我们考虑当n=6时的情况。<br>我们先将6个人分成2组，每组3个人（[0，1,2],[3,4,5]），然后发现3是个奇数，然后在每组中+1个虚拟人：X和Y；这样，每组就变成了4个人，然后将这4个人在除以2，我们就得到了一个两两组合的小的组。</p>
<p>首先来看[0，1]; [2,x]</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>2</th>
<th>x</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>将这两组合起来：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>x</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>x</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>x</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>x</td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>这里要得到3个选手的比赛安排，所以，我们将假想的X去掉，并将它的位置以/代替：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>/</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>/</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>/</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>然后我们也按照这个规律，安排[3,4,5]的日程，得到表格<br>| 3 | 4 | 5 | / |<br>|—-|—-|—-|—-|<br>| 4 | 3 | / | 5 |<br>| 5 | / | 3 | 4 |</p>
<p>我们得到了两个3x4的矩阵（其中第一列表示每个队伍，实际上只有三天），我们最终想得到6*6（其中第一列表示每个队伍，实际上只有五天）的矩阵。</p>
<p>我们先将上面两个矩阵合并</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>/</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>/</td>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>/</td>
<td>0</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>5</td>
<td>/</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>/</td>
<td>5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>/</td>
<td>3</td>
<td>4</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p> 前三天的比赛已经基本排完了，我们只需要在斜杠/的地方填上相应的比赛。很显然可以让每天轮空的两支队伍比赛。（在程序中没有斜杠表示，还是假想的队伍，方便进行监测）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>4</td>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>5</td>
<td>0</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>5</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>1</td>
<td>5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>上面的矩阵中[0,1,2]和[3,4,5]组内已经比完了，组间比了一次，剩下的只需要轮换两次即可得到后两天的比赛情况。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>4</td>
<td>2</td>
<td>5</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>5</td>
<td>0</td>
<td>1</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>5</td>
<td>0</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>1</td>
<td>5</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>于是我们便可以得到两个奇数矩阵的合并情况。</p>
<p>在程序中，我们的思路不是严格意义上的所谓的“合并”，而是“扩展”。比如对于“合并2个3x4的矩阵”，我们是“将1个3x4的矩阵扩展为6x6的矩阵”（因为这两个3x4的矩阵规格相同，排序顺序一样，所以只需要做一遍）</p>
<h2 id="三、代码展示"><a href="#三、代码展示" class="headerlink" title="三、代码展示"></a>三、代码展示</h2><p>（代码里有一些打印行号的printf语句，不知道为啥一去掉就过不了编译，所以没有删掉。。）<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&quot;Check.cpp&quot;</span><br><span class="line"></span><br><span class="line">void copy(int n, int **a)//偶数情况</span><br><span class="line">&#123;</span><br><span class="line">	//printf(&quot;当前行号%05d\n&quot;,__LINE__);</span><br><span class="line">	int m=n/2;</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">			//由左上角小块的值算出对应的右上角小块的值</span><br><span class="line">			a[i][j+m]=a[i][j]+m;</span><br><span class="line">			//由右上角小块的值算出对应的左下角小块的值</span><br><span class="line">			a[i+m][j]=a[i][j+m];</span><br><span class="line">			//由左上角小块的值算出对应的右下角小块的值</span><br><span class="line">			a[i+m][j+m]=a[i][j];</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void copyodd(int n, int **a) // n/2 为奇数时的合并算法</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;当前行号%05d\n&quot;,__LINE__);</span><br><span class="line">	int m=n/2;</span><br><span class="line">	int b[m];</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		b[i]=m+i;</span><br><span class="line">		b[m+i]=b[i];</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		//由左上角小块的值算出相应的左下角小块的值</span><br><span class="line">		for(int j=0;j&lt;m+1;j++)&#123;</span><br><span class="line">			if(a[i][j]&gt;=m)&#123;</span><br><span class="line">				a[i][j]=b[i];</span><br><span class="line">				a[m+i][j]=(b[i]+m)%n;</span><br><span class="line">			&#125;	else a[m+i][j]=a[i][j]+m;</span><br><span class="line">		&#125;</span><br><span class="line">		//由左上角小块的值算出相应的右上角和右下角小块的值</span><br><span class="line">		for(int j=1;j&lt;m;j++)&#123;</span><br><span class="line">			a[i][m+j]=b[i+j];</span><br><span class="line">			a[b[i+j]][m+j]=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void merge(int n, int **a) //合并算法</span><br><span class="line">&#123;</span><br><span class="line">	if((n/2)&gt;1 &amp;&amp; (n/2)%2 == 1) copyodd(n,a); //n/2 为奇数时,注意是 (n/2)%2 == 1，n别忘了/2 </span><br><span class="line">	else copy(n,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void tournament(int n, int **a) //循环赛算法</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;当前行号%05d\n&quot;,__LINE__);</span><br><span class="line">	if(n==1)&#123;a[0][0]=0;return;&#125;</span><br><span class="line">	if(n%2 == 1)	&#123;tournament(n+1,a);return;&#125; //n为奇数，分治</span><br><span class="line">	tournament(n/2,a); //n为偶数，分治</span><br><span class="line">	merge(n,a); //合并</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	</span><br><span class="line">	//创建数组</span><br><span class="line">	int **a;</span><br><span class="line">	a = (int**)malloc(sizeof(int*)*n);</span><br><span class="line">	</span><br><span class="line">	if(n%2==1)&#123;</span><br><span class="line">		for(int i=0; i&lt;n+1; i++)	a[i] = (int*)malloc(sizeof(int)*(n+1));</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		for(int i=0; i&lt;n; i++)	a[i] = (int*)malloc(sizeof(int)*n);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//生成循坏赛矩阵</span><br><span class="line">	tournament(n,a);</span><br><span class="line">	</span><br><span class="line">	//打印</span><br><span class="line">	printf(&quot;当前行号:%05d\n&quot;,__LINE__);</span><br><span class="line">	for(int i=0; i&lt;n; i++)&#123;</span><br><span class="line">		for(int j=1; j&lt;(n%2 == 1 ? n+1 : n); j++)&#123;</span><br><span class="line">			if(a[i][j]&lt;n)	printf(&quot;%d &quot;,a[i][j]);</span><br><span class="line">			else printf(&quot;x &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//检验程序</span><br><span class="line">	if(Check(a,n)==1) printf(&quot;This gametable is availuable.\n&quot;);</span><br><span class="line">	else printf(&quot;This gametable is unavailuable.\n&quot;);</span><br><span class="line">	if(n%2 ==1)&#123;</span><br><span class="line">		for(int i=0; i&lt;n; i++)	free(a[i]);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		for(int i=0; i&lt;n+1; i++)	free(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	free(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="四、测试程序"><a href="#四、测试程序" class="headerlink" title="四、测试程序"></a>四、测试程序</h2><p>测试程序对我们生成的矩阵进行检验。从两个角度进行。</p>
<ul>
<li>每个队伍都要和其他队伍进行一场比赛</li>
<li>每个队伍每天仅进行一场比赛</li>
</ul>
<p>测试程序代码如下<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Check(int **a, int n)</span><br><span class="line">&#123;</span><br><span class="line">	int column;</span><br><span class="line">	if(n%2==1) column=n+1;</span><br><span class="line">	else column=n;</span><br><span class="line">	int flag=0;</span><br><span class="line">	int check=1;//check为0说明不符合条件，停止检验。 </span><br><span class="line">	//检验每个队伍都与其他队伍比赛 </span><br><span class="line">	for(int i=0; i&lt;n&amp;&amp;check==1; i++)&#123;</span><br><span class="line">		for(int k=0; k&lt;n&amp;&amp;check==1; k++)&#123;</span><br><span class="line">			flag=0;</span><br><span class="line">			for(int j=0;j&lt;column&amp;&amp;flag==0;j++)&#123;</span><br><span class="line">				if(a[i][j] == k) flag=1;</span><br><span class="line">			&#125;</span><br><span class="line">			if(flag==0) check=0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//检验某天是否有队伍重复比赛</span><br><span class="line">	int times[n];</span><br><span class="line">	for(int j=1; j&lt;column&amp;&amp;check==1; j++)&#123;</span><br><span class="line">		for(int w=0; w&lt;n; w++) times[w]=0;</span><br><span class="line">		for(int i=0; i&lt;n&amp;&amp;check==1; i++)&#123;</span><br><span class="line">			times[a[i][j]]++;</span><br><span class="line">			if(times[a[i][j]]&gt;=2) check==0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	if(check==1) return 1;</span><br><span class="line">	else return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="五、实验结果"><a href="#五、实验结果" class="headerlink" title="五、实验结果"></a>五、实验结果</h2><ul>
<li>当n=6时</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/04/13/ALb4Vs.jpg" alt="1.2"></p>
<ul>
<li>当n=9时</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/04/13/ALb5an.jpg" alt="1.3"></p>
<p>测试结果均正确。</p>
<p><em>参考文献</em><br><em>[1]王民川,田永轩.分治法在循环赛日程表设计中的应用[J].光盘技术,2009(05):45-46.</em></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title>30天自制操作系统（18）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8818%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY18-dir命令"><a href="#DAY18-dir命令" class="headerlink" title="DAY18_dir命令"></a>DAY18_dir命令</h1><h3 id="1-控制光标闪烁-1"><a href="#1-控制光标闪烁-1" class="headerlink" title="1.控制光标闪烁(1)"></a>1.控制光标闪烁(1)</h3><ul>
<li>在Windows中，只有可以接受键盘输入的窗口有光标闪烁，而其他的窗口中是不显示光标的。</li>
<li>对HariMain进行改写</li>
</ul>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/*从此开始*/</span> <span class="keyword">if</span> (cursor_c &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">        boxfill8(sht_win-&gt;buf, sht_win-&gt;bxsize, cursor_c, cursor_x, <span class="number">28</span>, cursor_x + <span class="number">7</span>, <span class="number">43</span>); </span><br><span class="line">    <span class="comment">/*到此结束*/</span> &#125; </span><br><span class="line">         sheet_refresh(sht_win, cursor_x, <span class="number">28</span>, cursor_x + <span class="number">8</span>, <span class="number">44</span>); </span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">512</span> &lt;= i &amp;&amp; i &lt;= <span class="number">767</span>) &#123; <span class="comment">/*鼠标数据*/</span> </span><br><span class="line">     （中略）</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123; <span class="comment">/*光标用定时器*/</span> </span><br><span class="line">    <span class="comment">/*从此开始*/</span> <span class="keyword">if</span> (i != <span class="number">0</span>) &#123; </span><br><span class="line">         timer_init(timer, &amp;fifo, <span class="number">0</span>); <span class="comment">/*下次置0 */</span> </span><br><span class="line">     <span class="keyword">if</span> (cursor_c &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">        cursor_c = COL8_000000; </span><br><span class="line">     &#125; </span><br><span class="line">     &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">         timer_init(timer, &amp;fifo, <span class="number">1</span>); <span class="comment">/*下次置1 */</span> </span><br><span class="line">         <span class="keyword">if</span> (cursor_c &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">         cursor_c = COL8_FFFFFF; </span><br><span class="line">        &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     timer_settime(timer, <span class="number">50</span>); </span><br><span class="line">     <span class="keyword">if</span> (cursor_c &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">     boxfill8(sht_win-&gt;buf, sht_win-&gt;bxsize, cursor_c, cursor_x, <span class="number">28</span>, cursor_x + </span><br><span class="line">     <span class="number">7</span>, <span class="number">43</span>); </span><br><span class="line">     sheet_refresh(sht_win, cursor_x, <span class="number">28</span>, cursor_x + <span class="number">8</span>, <span class="number">44</span>); </span><br><span class="line">    <span class="comment">/*到此结束*/</span> &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-控制光标闪烁-2"><a href="#2-控制光标闪烁-2" class="headerlink" title="2.控制光标闪烁(2)"></a>2.控制光标闪烁(2)</h3><ul>
<li>实现命令行窗口中光标闪烁的控制。</li>
<li>像传递按键编码一样，我们可以使用FIFO来实现。</li>
<li>我们先将光标开始闪烁定义为2，停止闪烁定义为3。</li>
</ul>
<hr>
<h3 id="3-对回车键的支持"><a href="#3-对回车键的支持" class="headerlink" title="3.对回车键的支持"></a>3.对回车键的支持</h3><ul>
<li>应该对输入的字符进行判断，然后执行相应的命令<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/*从此开始*/</span> <span class="keyword">if</span> (i == <span class="number">256</span> + <span class="number">0x1c</span>) &#123; <span class="comment">/*回车键*/</span> </span><br><span class="line">     <span class="keyword">if</span> (key_to != <span class="number">0</span>) &#123; <span class="comment">/*发送至命令行窗口*/</span> </span><br><span class="line">        fifo32_put(&amp;task_cons-&gt;fifo, <span class="number">10</span> + <span class="number">256</span>); </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">/*到此结束*/</span> &#125; </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-对窗口滚动的支持"><a href="#4-对窗口滚动的支持" class="headerlink" title="4.对窗口滚动的支持"></a>4.对窗口滚动的支持</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void console_task(struct SHEET *sheet) </span><br><span class="line">&#123; </span><br><span class="line"> （中略）</span><br><span class="line"> int x, y;</span><br><span class="line">  （中略）</span><br><span class="line"> for (;;) &#123; </span><br><span class="line">     io_cli(); </span><br><span class="line">     if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; </span><br><span class="line">     （中略）</span><br><span class="line"> &#125; else &#123; </span><br><span class="line">    （中略）</span><br><span class="line"> if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /*键盘数据（通过任务A） */ </span><br><span class="line"> if (i == 8 + 256) &#123; </span><br><span class="line">     /*退格键*/ </span><br><span class="line">     （中略）</span><br><span class="line"> &#125; else if (i == 10 + 256) &#123; </span><br><span class="line">     /* Enter */ </span><br><span class="line">     /*用空格将光标擦除*/ </span><br><span class="line">     putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, &quot; &quot;, 1); </span><br><span class="line">/*从此开始 */ if (cursor_y &lt; 28 + 112) &#123; </span><br><span class="line"> cursor_y += 16; /*换行*/ </span><br><span class="line"> &#125; else &#123; </span><br><span class="line">     /*滚动*/ </span><br><span class="line">     for (y = 28; y &lt; 28 + 112; y++) &#123; </span><br><span class="line">     for (x = 8; x &lt; 8 + 240; x++) &#123; </span><br><span class="line">     sheet-&gt;buf[x + y * sheet-&gt;bxsize] = sheet-&gt;buf[x + (y + 16) * </span><br><span class="line">     sheet-&gt;bxsize]; </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> for (y = 28 + 112; y &lt; 28 + 128; y++) &#123; </span><br><span class="line">    for (x = 8; x &lt; 8 + 240; x++) &#123; </span><br><span class="line">        sheet-&gt;buf[x + y * sheet-&gt;bxsize] = COL8_000000; </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> sheet_refresh(sheet, 8, 28, 8 + 240, 28 + 128); </span><br><span class="line"> &#125; </span><br><span class="line"> /*显示提示符*/ </span><br><span class="line"> putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, &quot;&gt;&quot;, 1); </span><br><span class="line">/*到此为止*/ cursor_x = 16; </span><br><span class="line"> &#125; else &#123; </span><br><span class="line"> /*一般字符*/ </span><br><span class="line"> （中略）</span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> （中略）</span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-mem命令"><a href="#5-mem命令" class="headerlink" title="5.mem命令"></a>5.mem命令</h3><p>我们已经实现了屏幕滚动，现在该是到了让它执行命令的时候了。<br>mem命令就是memeory的缩写，也就是用来显示内存使用情况的命令。</p>
<hr>
<ul>
<li>介绍一下重点。首先我们添加了memtotal和memman两个变量，它们是执行mem命令所必需的。关于memtotal，我们采用和sheet相同的方法从HariMain传递过来，因此我们还要改写一下HariMain。</li>
<li>我们还添加了一个cmdline变量，也就是“命令行”（command line）的缩写。这个变量用来记录通过键盘输入的内容，在“键盘数据”处理的“一般字符”部分，将输入的内容顺次累积起来。</li>
</ul>
<h3 id="6-cls命令"><a href="#6-cls命令" class="headerlink" title="6.cls命令"></a>6.cls命令</h3><ul>
<li>这个命令的作用是清除屏幕上的内容，也就是“clear screen”（清屏）的缩写。顺便补充个小知识，在Linux中清屏命令是“clear”。<br>代码精简：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (c[0] == &#x27;m&#x27; &amp;&amp; c[1] == &#x27;e&#x27; &amp;&amp; c[2] == &#x27;m&#x27; &amp;&amp; c[3] == 0) &#123;</span><br></pre></td></tr></table></figure>
改成：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (strcmp(cmdline, &quot;mem&quot;) == 0) &#123;</span><br></pre></td></tr></table></figure>
strcmp这个函数，只要声明#include<string.h>即可使用，因此在bootpack.c中我们也要用它。</li>
</ul>
<h3 id="7-dir命令"><a href="#7-dir命令" class="headerlink" title="7. dir命令"></a>7. dir命令</h3><ul>
<li>我们的目标是制作可执行文件（比如.exe）来让它运行。</li>
<li>过在此之前，我们先来制作一个显示磁盘内文件名称的命令吧。</li>
<li>dir指令除了会显示文件名，还会显示文件的日期和大小。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（17）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8817%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY17-命令行窗口"><a href="#DAY17-命令行窗口" class="headerlink" title="DAY17_命令行窗口"></a>DAY17_命令行窗口</h1><h2 id="1-闲置任务"><a href="#1-闲置任务" class="headerlink" title="1.闲置任务"></a>1.闲置任务</h2><ul>
<li>即使不改写程序，也能自动在适当的LEVEL运行适当的任务，这样的操作系统才是优秀的操作系统</li>
<li>因此，一般情况下可以让任务休眠，但当所有LEVEL中都没有任务存在的时候，就需要HTL了。接下来我们就按照这个要求来改写mtask.c。</li>
<li>如果“所有LEVEL中都没有任务”就会出问题，那我们只要避免这种情况发生不就可以了吗？这类似于我们写定时器的时候所采用的“卫兵”的思路。</li>
</ul>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void task_idle(void) </span><br><span class="line">&#123; </span><br><span class="line">    for (;;) &#123; </span><br><span class="line">        io_hlt(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>综上所述，我们完全不需要对task_sleep等代码进行任何改动，只需在task_init中将这个闲置任务放在最下层LEVEL中就可以了。</li>
</ul>
<h2 id="2-创建命令行窗口"><a href="#2-创建命令行窗口" class="headerlink" title="2.创建命令行窗口"></a>2.创建命令行窗口</h2><h2 id="3-切换输入窗口"><a href="#3-切换输入窗口" class="headerlink" title="3.切换输入窗口"></a>3.切换输入窗口</h2><ul>
<li>目标：我们要让系统在按下“Tab”键的时候，将输入窗口切换到命令行窗口上去。</li>
<li>我们先改变窗口标题栏的颜色。</li>
</ul>
<h2 id="4-实现字符输入"><a href="#4-实现字符输入" class="headerlink" title="4.实现字符输入"></a>4.实现字符输入</h2><ul>
<li>要实现字符的输入，只要在键盘被按下的时候向console_task的FIFO发送数据即可。</li>
<li>我们还是把struct FIFO放到struct TASK里面去吧。基本上没有什么任务是完全用不到FIFO的，因此我们把它们绑定起来</li>
<li>在向命令行窗口发送键盘数据的时候，并不是直接发送从键盘接收到的原始数据，而是发送经过keytable[]转换后的值。究其原因，是由于这样做可以省去在命令行窗口任务中将按键编码转换成字符编码的步骤<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void console_task(struct SHEET *sheet) </span><br><span class="line">&#123; </span><br><span class="line"> struct TIMER *timer; </span><br><span class="line"> struct TASK *task = task_now(); </span><br><span class="line"> int i, fifobuf[128], cursor_x = 16, cursor_c = COL8_000000; </span><br><span class="line"> char s[2]; </span><br><span class="line"> fifo32_init(&amp;task-&gt;fifo, 128, fifobuf, task); </span><br><span class="line"> timer = timer_alloc(); </span><br><span class="line"> timer_init(timer, &amp;task-&gt;fifo, 1); </span><br><span class="line"> timer_settime(timer, 50); </span><br><span class="line"> /*显示提示符*/ </span><br><span class="line"> putfonts8_asc_sht(sheet, 8, 28, COL8_FFFFFF, COL8_000000, &quot;&gt;&quot;, 1); </span><br><span class="line"> for (;;) &#123; </span><br><span class="line">    io_cli(); </span><br><span class="line">    if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; </span><br><span class="line">        task_sleep(task); </span><br><span class="line">        io_sti(); </span><br><span class="line">    &#125; else &#123; </span><br><span class="line">        i = fifo32_get(&amp;task-&gt;fifo); </span><br><span class="line">             io_sti(); </span><br><span class="line">             if (i &lt;= 1) &#123; /*光标用定时器*/ </span><br><span class="line">                if (i != 0) &#123; </span><br><span class="line">                    timer_init(timer, &amp;task-&gt;fifo, 0); /*接下来置0 */ </span><br><span class="line">                    cursor_c = COL8_FFFFFF; </span><br><span class="line">                &#125; else &#123; </span><br><span class="line">                    timer_init(timer, &amp;task-&gt;fifo, 1); /*接下来置1 */ </span><br><span class="line">                    cursor_c = COL8_000000; </span><br><span class="line">                &#125; </span><br><span class="line">                timer_settime(timer, 50); </span><br><span class="line">             &#125; </span><br><span class="line">             if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /*键盘数据（通过任务A） */ </span><br><span class="line">                if (i == 8 + 256) &#123;</span><br><span class="line">                /*退格键*/ </span><br><span class="line">                if (cursor_x &gt; 16) &#123; </span><br><span class="line">                    /*用空白擦除光标后将光标前移一位*/ </span><br><span class="line">                    putfonts8_asc_sht(sheet, cursor_x, 28, COL8_FFFFFF, COL8_000000, &quot; &quot;, 1); </span><br><span class="line">                    cursor_x -= 8; </span><br><span class="line">                 &#125; </span><br><span class="line">             &#125; else &#123; </span><br><span class="line">                /*一般字符*/ </span><br><span class="line">                if (cursor_x &lt; 240) &#123; </span><br><span class="line">                    /*显示一个字符之后将光标后移一位 */ </span><br><span class="line">                    s[0] = i - 256; </span><br><span class="line">                    s[1] = 0; </span><br><span class="line">                    putfonts8_asc_sht(sheet, cursor_x, 28, COL8_FFFFFF, COL8_000000, s, 1); </span><br><span class="line">                    cursor_x += 8; </span><br><span class="line">                &#125; </span><br><span class="line">             &#125; </span><br><span class="line">             &#125; </span><br><span class="line">             /*重新显示光标*/ </span><br><span class="line">             boxfill8(sheet-&gt;buf, sheet-&gt;bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43); </span><br><span class="line">             sheet_refresh(sheet, cursor_x, 28, cursor_x + 8, 44); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5-符号的输入"><a href="#5-符号的输入" class="headerlink" title="5.符号的输入"></a>5.符号的输入</h2><ul>
<li>目标：实现！和%的输入</li>
<li>我们必须要处理shift键</li>
</ul>
<h2 id="6-大写字母和小写字母"><a href="#6-大写字母和小写字母" class="headerlink" title="6.大写字母和小写字母"></a>6.大写字母和小写字母</h2><ul>
<li>我们必须同时判断Shift键的状态和CapsLock的状态<ul>
<li>CapsLock 为 OFF &amp; Shift 键为 OFF → 小写英文字母</li>
<li>CapsLock 为 OFF &amp; Shift 键为 ON → 大写英文字母</li>
<li>CapsLock 为 ON &amp; Shift 键为 OFF → 大写英文字母</li>
<li>CapsLock 为 ON &amp; Shift 键为 ON → 小写英文字母</li>
</ul>
</li>
</ul>
<h2 id="7-对各种锁定键的支持"><a href="#7-对各种锁定键的支持" class="headerlink" title="7.对各种锁定键的支持"></a>7.对各种锁定键的支持</h2><ul>
<li>点亮/熄灭键盘上指示灯的方法</li>
<li>原理：<ul>
<li>对于NumLock和CapsLock等LED的控制，可采用下面的方法向键盘发送指令和数据。<ul>
<li>读取状态寄存器，等待 bit 1 的值变为 0。</li>
<li>向数据输出（0060）写入要发送的 1 个字节数据。</li>
<li>等待键盘返回 1 个字节的信息，这和等待键盘输入所采用的方法相同（用 IRQ等待或者用轮询状态寄存器 bit 1 的值直到其变为 0 都可以）。</li>
<li>返回的信息如果为 0xfa，表明 1 个字节的数据已成功发送给键盘。如为 0xfe则表明发送失败，需要返回第 1 步重新发送。</li>
</ul>
</li>
<li>要控制LED的状态，需要按上述方法执行两次，向键盘发送EDxx数据。其中，xx的bit 0代表ScrollLock，bit 1代表NumLock，bit2代表CapsLock（0表示熄灭，1表示点亮）。bit 3～7为保留位，置0即可。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define KEYCMD_LED 0xed </span><br><span class="line">void HariMain(void) </span><br><span class="line">&#123; </span><br><span class="line">     （中略）</span><br><span class="line">     struct FIFO32 fifo, keycmd; </span><br><span class="line">     int fifobuf[128], keycmd_buf[32]; </span><br><span class="line">     （中略）</span><br><span class="line">     int key_to = 0, key_shift = 0, key_leds = (binfo-&gt;leds &gt;&gt; 4) &amp; 7, keycmd_wait = -1; </span><br><span class="line">     （中略）</span><br><span class="line">     fifo32_init(&amp;keycmd, 32, keycmd_buf, 0); </span><br><span class="line">     （中略）</span><br><span class="line">     </span><br><span class="line">     /*为了避免和键盘当前状态冲突，在一开始先进行设置*/ </span><br><span class="line">     fifo32_put(&amp;keycmd, KEYCMD_LED); </span><br><span class="line">     fifo32_put(&amp;keycmd, key_leds); </span><br><span class="line">     </span><br><span class="line">     for (;;) &#123; </span><br><span class="line">         if (fifo32_status(&amp;keycmd) &gt; 0 &amp;&amp; keycmd_wait &lt; 0) &#123; /*从此开始*/ </span><br><span class="line">             /*如果存在向键盘控制器发送的数据，则发送它 */ </span><br><span class="line">             keycmd_wait = fifo32_get(&amp;keycmd); </span><br><span class="line">             wait_KBC_sendready(); </span><br><span class="line">             io_out8(PORT_KEYDAT, keycmd_wait); </span><br><span class="line">         &#125; /*到此结束*/ </span><br><span class="line">         io_cli(); </span><br><span class="line">         if (fifo32_status(&amp;fifo) == 0) &#123; </span><br><span class="line">             task_sleep(task_a); </span><br><span class="line">             io_sti(); </span><br><span class="line">         &#125; else &#123; </span><br><span class="line">             i = fifo32_get(&amp;fifo); </span><br><span class="line">             io_sti(); </span><br><span class="line">             if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /* 键盘数据 */ </span><br><span class="line">             （中略）</span><br><span class="line">            /*从此开始*/ if (i == 256 + 0x3a) &#123; /* CapsLock */ </span><br><span class="line">                 key_leds ^= 4; </span><br><span class="line">                 fifo32_put(&amp;keycmd, KEYCMD_LED); </span><br><span class="line">                 fifo32_put(&amp;keycmd, key_leds); </span><br><span class="line">             &#125; </span><br><span class="line">         if (i == 256 + 0x45) &#123; /* NumLock */ </span><br><span class="line">             key_leds ^= 2; </span><br><span class="line">             fifo32_put(&amp;keycmd, KEYCMD_LED); </span><br><span class="line">             fifo32_put(&amp;keycmd, key_leds); </span><br><span class="line">         &#125; </span><br><span class="line">         if (i == 256 + 0x46) &#123; /* ScrollLock */ </span><br><span class="line">             key_leds ^= 1; </span><br><span class="line">             fifo32_put(&amp;keycmd, KEYCMD_LED); </span><br><span class="line">             fifo32_put(&amp;keycmd, key_leds); </span><br><span class="line">         &#125; </span><br><span class="line">         if (i == 256 + 0xfa) &#123; /*键盘成功接收到数据*/ </span><br><span class="line">            keycmd_wait = -1; </span><br><span class="line">         &#125; </span><br><span class="line">         if (i == 256 + 0xfe) &#123; /*键盘没有成功接收到数据*/ </span><br><span class="line">            wait_KBC_sendready(); </span><br><span class="line">            io_out8(PORT_KEYDAT, keycmd_wait); </span><br><span class="line">            /*到此结束*/ &#125; </span><br><span class="line">         （中略）</span><br><span class="line">         &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; /*鼠标数据*/ </span><br><span class="line">         （中略）</span><br><span class="line">         &#125; else if (i &lt;= 1) &#123; /*光标用定时器*/ </span><br><span class="line">         （中略）</span><br><span class="line">         &#125; </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现方法：<ul>
<li>创建了一个叫keycmd的FIFO缓冲区，它不是用来接收中断请求的，而是用来管理由任务A向键盘控制器发送数据的顺序的。如果有数据要发送到键盘控制器，首先会在这个keycmd中累积起来。</li>
<li>keycmd_wait变量，用来表示向键盘控制器发送数据的状态。当keycmd_wait的值为-1时，表示键盘控制器处于通常状态，可以发送指令；当值不为-1时，表示键盘控制器正在等待发送的数据，这时要发送的数据被保存在keycmd_wait变量中。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（16）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8816%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY16-多任务（2）"><a href="#DAY16-多任务（2）" class="headerlink" title="DAY16_多任务（2）"></a>DAY16_多任务（2）</h1><h2 id="1-任务管理自动化"><a href="#1-任务管理自动化" class="headerlink" title="1.任务管理自动化"></a>1.任务管理自动化</h2><ul>
<li>充分做好多任务机制的基础上，再利用多任务逐步完善操作系统本身。</li>
<li>如果我们想要运行三个任务的话，就必须改写mt_taskswitch的代码。如果能像当初定时器和窗口背景的做法一样更好。</li>
</ul>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct TASKCTL *taskctl; </span><br><span class="line">struct TIMER *task_timer; </span><br><span class="line">struct TASK *task_init(struct MEMMAN *memman) </span><br><span class="line">&#123; </span><br><span class="line">     int i; </span><br><span class="line">     struct TASK *task; </span><br><span class="line">     struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT; </span><br><span class="line">     taskctl = (struct TASKCTL *) memman_alloc_4k(memman, sizeof (struct TASKCTL)); </span><br><span class="line">     for (i = 0; i &lt; MAX_TASKS; i++) &#123; </span><br><span class="line">         taskctl-&gt;tasks0[i].flags = 0; </span><br><span class="line">         taskctl-&gt;tasks0[i].sel = (TASK_GDT0 + i) * 8; </span><br><span class="line">         set_segmdesc(gdt + TASK_GDT0 + i, 103, (int) &amp;taskctl-&gt;tasks0[i].tss, AR_TSS32); </span><br><span class="line">     &#125; </span><br><span class="line">     task = task_alloc();</span><br><span class="line">     task-&gt;flags = 2; /*活动中标志*/ </span><br><span class="line">     taskctl-&gt;running = 1; </span><br><span class="line">     taskctl-&gt;now = 0; </span><br><span class="line">     taskctl-&gt;tasks[0] = task; </span><br><span class="line">     load_tr(task-&gt;sel); </span><br><span class="line">     task_timer = timer_alloc(); </span><br><span class="line">     timer_settime(task_timer, 2); </span><br><span class="line">     return task; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用task_init，会返回一个内存地址，意思是==现在正在运行的这个程序，已经变成一个任务了==。可能大家不是很能理解这个说法，在调用init之后，所有程序的运行都会被当成任务来进行管理，而调用init的这个程序，我们也要让它所属于某个任务，这样一来，通过调用任务的设置函数，就可以对任务进行各种控制，比如说修改优先级等。</li>
</ul>
<h2 id="2-让任务休眠"><a href="#2-让任务休眠" class="headerlink" title="2.让任务休眠"></a>2.让任务休眠</h2><ul>
<li>给每个任务==分配不同的时间==——休眠+唤醒</li>
<li><p>休眠：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void task_sleep(struct TASK *task) </span><br><span class="line">&#123; </span><br><span class="line">     int i; </span><br><span class="line">     char ts = 0; </span><br><span class="line">     if (task-&gt;flags == 2) &#123; /*如果指定任务处于唤醒状态*/ </span><br><span class="line">         if (task == taskctl-&gt;tasks[taskctl-&gt;now]) &#123; </span><br><span class="line">            ts = 1; /*让自己休眠的话，稍后需要进行任务切换*/ </span><br><span class="line">         &#125; </span><br><span class="line">         /*寻找task所在的位置*/ </span><br><span class="line">         for (i = 0; i &lt; taskctl-&gt;running; i++) &#123; </span><br><span class="line">             if (taskctl-&gt;tasks[i] == task) &#123; </span><br><span class="line">                 /*在这里*/ </span><br><span class="line">                 break; </span><br><span class="line">             &#125; </span><br><span class="line">         &#125; </span><br><span class="line">         taskctl-&gt;running--; </span><br><span class="line">         if (i &lt; taskctl-&gt;now) &#123; </span><br><span class="line">            taskctl-&gt;now--; /*需要移动成员，要相应地处理*/ </span><br><span class="line">         &#125; </span><br><span class="line">         /*移动成员*/ </span><br><span class="line">         for (; i &lt; taskctl-&gt;running; i++) &#123; </span><br><span class="line">            taskctl-&gt;tasks[i] = taskctl-&gt;tasks[i + 1]; </span><br><span class="line">         &#125; </span><br><span class="line">         task-&gt;flags = 1; /*不工作的状态*/ </span><br><span class="line">         if (ts != 0) &#123; </span><br><span class="line">            /*任务切换*/ </span><br><span class="line">            if (taskctl-&gt;now &gt;= taskctl-&gt;running) &#123; </span><br><span class="line">                /*如果now的值出现异常，则进行修正*/ </span><br><span class="line">                taskctl-&gt;now = 0; </span><br><span class="line">            &#125; </span><br><span class="line">            farjmp(0, taskctl-&gt;tasks[taskctl-&gt;now]-&gt;sel); </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>唤醒：</p>
<ul>
<li>在FIFO中添加用于记录要唤醒任务的信息的成员。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct FIFO32 &#123; </span><br><span class="line">    int *buf; </span><br><span class="line">    int p, q, size, free, flags; </span><br><span class="line">    struct TASK *task; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-增加窗口数量"><a href="#3-增加窗口数量" class="headerlink" title="3.增加窗口数量"></a>3.增加窗口数量</h2></li>
</ul>
</li>
<li>形成任务A、任务B0、任务B1和任务B2的格局。</li>
<li>任务B0～B2各自拥有自己的窗口，它们的功能都一样，即进行计数，这有点像在Windows中启动了一个应用程序及其2个副本的感觉。</li>
</ul>
<h2 id="4-设定任务优先级（1）"><a href="#4-设定任务优先级（1）" class="headerlink" title="4.设定任务优先级（1）"></a>4.设定任务优先级（1）</h2><ul>
<li>改写mtask.c、task_switch<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void task_switch(void) </span><br><span class="line">&#123; </span><br><span class="line">     struct TASK *task; </span><br><span class="line">     taskctl-&gt;now++; </span><br><span class="line">     if (taskctl-&gt;now == taskctl-&gt;running) &#123; </span><br><span class="line">        taskctl-&gt;now = 0; </span><br><span class="line">     &#125; </span><br><span class="line">     task = taskctl-&gt;tasks[taskctl-&gt;now]; </span><br><span class="line">     timer_settime(task_timer, task-&gt;priority); </span><br><span class="line">     if (taskctl-&gt;running &gt;= 2) &#123; </span><br><span class="line">        farjmp(0, task-&gt;sel); </span><br><span class="line">     &#125;</span><br><span class="line">     return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5-设定任务优先级（2）"><a href="#5-设定任务优先级（2）" class="headerlink" title="5.设定任务优先级（2）"></a>5.设定任务优先级（2）</h2><ul>
<li>在操作系统中有一些处理，即使牺牲其他任务的性能也必须要尽快完成，否则会引起用户的不满，就比如这次对鼠标的处理。对于这类任务，我们可以让它在处理结束后马上休眠，而优先级则可以设置得非常高。</li>
<li>我们需要设计一种架构，使得即便高优先级的任务同时运行，也能够区分哪个更加优先。<br><img src="https://s2.ax1x.com/2019/04/07/AhpVk8.jpg" alt="16.1"></li>
<li>这种架构的工作原理是，最上层的LEVEL 0中只要存在哪怕一个任务，则完全忽略LEVEL 1和LEVEL 2中的任务，只在LEVEL 0的任务中进行任务切换。当LEVEL 0中的任务全部休眠，或者全部降到下层LEVEL，也就是当LEVEL 0中没有任何任务的时候，接下来开始轮到LEVEL 1中的任务进行任务切换。当LEVEL 0和LEVEL 1中都没有任务时，那就该轮到LEVEL2 出场了。<br>在这种架构下，只要把音乐播放任务设置在LEVEL 0中，就可以保证获得比鼠标更高的优先级。</li>
</ul>
<hr>
<ul>
<li>task_now 用于返回现在活动中的struct TASK的内存地址<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct TASK *task_now(void) </span><br><span class="line">&#123; </span><br><span class="line"> struct TASKLEVEL *tl = &amp;taskctl-&gt;level[taskctl-&gt;now_lv]; </span><br><span class="line"> return tl-&gt;tasks[tl-&gt;now]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>task_add，用来向struct TASKLEVEL中添加一个任务<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void task_add(struct TASK *task) </span><br><span class="line">&#123; </span><br><span class="line"> struct TASKLEVEL *tl = &amp;taskctl-&gt;level[task-&gt;level]; </span><br><span class="line"> tl-&gt;tasks[tl-&gt;running] = task; </span><br><span class="line"> tl-&gt;running++; </span><br><span class="line"> task-&gt;flags = 2; /*活动中*/ </span><br><span class="line"> return; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>task_remove</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void task_remove(struct TASK *task) </span><br><span class="line">&#123; </span><br><span class="line">     int i; </span><br><span class="line">     struct TASKLEVEL *tl = &amp;taskctl-&gt;level[task-&gt;level]; </span><br><span class="line">     /*寻找task所在的位置*/ </span><br><span class="line">     for (i = 0; i &lt; tl-&gt;running; i++) &#123; </span><br><span class="line">         if (tl-&gt;tasks[i] == task) &#123; </span><br><span class="line">             /*在这里 */ </span><br><span class="line">             break; </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     tl-&gt;running--; </span><br><span class="line">     if (i &lt; tl-&gt;now) &#123; </span><br><span class="line">        tl-&gt;now--; /*需要移动成员，要相应地处理 */ </span><br><span class="line">     &#125; </span><br><span class="line">     if (tl-&gt;now &gt;= tl-&gt;running) &#123; </span><br><span class="line">         /*如果now的值出现异常，则进行修正*/ </span><br><span class="line">         tl-&gt;now = 0; </span><br><span class="line">     &#125; </span><br><span class="line">     task-&gt;flags = 1; /* 休眠中 */ </span><br><span class="line">     /* 移动 */ </span><br><span class="line">     for (; i &lt; tl-&gt;running; i++) &#123;</span><br><span class="line">        tl-&gt;tasks[i] = tl-&gt;tasks[i + 1]; </span><br><span class="line">     &#125; </span><br><span class="line">     return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>task_switchsub,用来在任务切换时决定接下来切换到哪个LEVEL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void task_switchsub(void) </span><br><span class="line">&#123; </span><br><span class="line">     int i; </span><br><span class="line">     /*寻找最上层的LEVEL */ </span><br><span class="line">     for (i = 0; i &lt; MAX_TASKLEVELS; i++) &#123; </span><br><span class="line">     if (taskctl-&gt;level[i].running &gt; 0) &#123; </span><br><span class="line">     break; /*找到了*/ </span><br><span class="line">     &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     taskctl-&gt;now_lv = i; </span><br><span class="line">     taskctl-&gt;lv_change = 0; </span><br><span class="line">     return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（15）</title>
    <url>/201904/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8815%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY15-多任务（1）"><a href="#DAY15-多任务（1）" class="headerlink" title="DAY15_多任务（1）"></a>DAY15_多任务（1）</h1><h2 id="1-挑战任务切换"><a href="#1-挑战任务切换" class="headerlink" title="1.挑战任务切换"></a>1.挑战任务切换</h2><ul>
<li><strong>多任务</strong>：多个应用程序同时运行的状态（也就是同时打开好几个窗口的状态）。</li>
<li>实际上这些程序==并没有在同时运行==，只是看上去好像是在同时运行一样。<br><img src="https://s2.ax1x.com/2019/04/07/Af2OaT.jpg" alt="15.1"></li>
</ul>
<span id="more"></span>
<ul>
<li>在一般的操作系统中，这个切换的动作每0.01～0.03秒就会进行一次。当然，切换的速度越快，让人觉得程序是在同时运行的效果也就越好。不过，CPU进行程序切换（我们称为“任务切换”）这个动作本身就需要消耗一定的时间，这个时间大约为0.0001秒左右，不同的CPU及操作系统所需的时间也有所不同。</li>
<li>CPU处理方式：当你向CPU发出任务切换的指令时，CPU会先把寄存器中的值全部写入内存中，这样做是为了当以后切换回这个程序的时候，可以从中断的地方继续运行。接下来，为了运行下一个程序，CPU会把所有寄存器中的值从内存中读取出来（当然，这个读取的地址和刚刚写入的地址一定是不同的，不然就相当于什么都没变嘛），这样就完成了一次切换。我们前面所说的任务切换所需要的时间，正是对内存进行写入和读取操作所消耗的时间。</li>
<li>TSS 任务状态段 task status segment</li>
<li>EIP 扩展指令指针寄存器 extended instruction pointer：CPU用来记录下一条需要执行的指令位于内存中哪个地址的寄存器，因此它才被称为“指令指针”。如果没有这个寄存器，记性不好的CPU就会忘记自己正在运行哪里的程序，于是程序就没办法正常运行了。每执行一条指令，EIP寄存器中的值就会自动累加，从而保证一直指向下一条指令所在的内存地址。</li>
</ul>
<h3 id="实际任务切换"><a href="#实际任务切换" class="headerlink" title="实际任务切换"></a>实际任务切换</h3><ul>
<li>创建两个TSS<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct TSS32 tss_a, tss_b;</span><br></pre></td></tr></table></figure></li>
<li>向它们的Idtr和iomap分别存入合适的值<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tss_a.ldtr = 0; </span><br><span class="line">tss_a.iomap = 0x40000000; </span><br><span class="line">tss_b.ldtr = 0; </span><br><span class="line">tss_b.iomap = 0x40000000;</span><br></pre></td></tr></table></figure></li>
<li><p>将它们两个在GDT中进行定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT; </span><br><span class="line"> </span><br><span class="line">set_segmdesc(gdt + 3, 103, (int) &amp;tss_a, AR_TSS32); </span><br><span class="line">set_segmdesc(gdt + 4, 103, (int) &amp;tss_b, AR_TSS32);</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们向TR寄存器存入3 * 8这个值，这是因为我们刚才把当前运行的任务定义为GDT的3号。</p>
</li>
<li>要进行任务切换，我们必须执行far模式的跳转指令</li>
</ul>
<hr>
<ul>
<li>在eip中，我们需要定义在切换到这个任务的时候，要从哪里开始运行。</li>
</ul>
<h2 id="2-任务切换进阶"><a href="#2-任务切换进阶" class="headerlink" title="2.任务切换进阶"></a>2.任务切换进阶</h2><ul>
<li>目标：从任务A切换到任务B，再切换回任务A</li>
</ul>
<h2 id="3-做个简单的多任务（1）"><a href="#3-做个简单的多任务（1）" class="headerlink" title="3.做个简单的多任务（1）"></a>3.做个简单的多任务（1）</h2><ul>
<li>目标：实现更快速的，来回交替的任务切换。这样我们就可以告别光标停住、鼠标卡死、键盘打不了字的情况，让两个任务看上去好像在同时运行一样。</li>
<li>把taskswitch写成一个函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_farjmp: ; void farjmp(int eip, int cs); </span><br><span class="line"> JMP FAR [ESP+4] ; eip, cs </span><br><span class="line"> RET</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-做个简单的多任务（2）"><a href="#4-做个简单的多任务（2）" class="headerlink" title="4.做个简单的多任务（2）"></a>4.做个简单的多任务（2）</h2><h2 id="5-提高运行速度"><a href="#5-提高运行速度" class="headerlink" title="5.提高运行速度"></a>5.提高运行速度</h2><ul>
<li>因为我们的程序每计1个数就在画面上显示一次，但1秒钟之内刷新100次以上的话，人眼根本就分辨不出来，所以我们不需要计1个数就刷新一次，只要每隔0.01秒刷新一次就足够了。</li>
</ul>
<h2 id="6-测试运行速度"><a href="#6-测试运行速度" class="headerlink" title="6.测试运行速度"></a>6.测试运行速度</h2><p>向task_b_main添加代码测试运行速度<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void task_b_main(struct SHEET *sht_back) </span><br><span class="line">&#123; </span><br><span class="line">     struct FIFO32 fifo; </span><br><span class="line">     struct TIMER *timer_ts, *timer_put, *timer_1s; </span><br><span class="line">     int i, fifobuf[128], count = 0, count0 = 0; </span><br><span class="line">     char s[12]; </span><br><span class="line">     （中略）</span><br><span class="line">     timer_1s = timer_alloc(); </span><br><span class="line">     timer_init(timer_1s, &amp;fifo, 100); </span><br><span class="line">     timer_settime(timer_1s, 100); </span><br><span class="line">     for (;;) &#123; </span><br><span class="line">         count++; </span><br><span class="line">         io_cli(); </span><br><span class="line">         if (fifo32_status(&amp;fifo) == 0) &#123; </span><br><span class="line">            io_sti(); </span><br><span class="line">         &#125; else &#123; </span><br><span class="line">             i = fifo32_get(&amp;fifo);</span><br><span class="line">             io_sti(); </span><br><span class="line">             if (i == 1) &#123; </span><br><span class="line">                （中略）</span><br><span class="line">             &#125; else if (i == 2) &#123; </span><br><span class="line">                （中略）</span><br><span class="line">             &#125; else if (i == 100) &#123; </span><br><span class="line">                 sprintf(s, &quot;%11d&quot;, count - count0); </span><br><span class="line">                 putfonts8_asc_sht(sht_back, 0, 128, COL8_FFFFFF, COL8_008484, s, 11); </span><br><span class="line">                 count0 = count; </span><br><span class="line">                 timer_settime(timer_1s, 100); </span><br><span class="line">            &#125; </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="7-多任务进阶"><a href="#7-多任务进阶" class="headerlink" title="7.多任务进阶"></a>7.多任务进阶</h2><ul>
<li>真正的多任务，是要做到在程序本身不知道的情况下进行任务切换。</li>
<li>果使用这样的设计，即便在程序中不进行任务切换的处理（比如忘记写了，或者因为bug没能正常切换之类的），也一定会正常完成切换。之前那种多任务的话，如果任务B因为发生bug而无法进行切换，那么当切换到任务B以后，其他的任务就再也无法运行了，这样会造成无论是按键盘还是动鼠标都毫无反应的悲剧。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>插入排序（Insert Sort）、归并排序（Merge Sort）和快速排序（Quick Sort）</title>
    <url>/201904/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="一、算法简介"><a href="#一、算法简介" class="headerlink" title="一、算法简介"></a>一、算法简介</h2><h4 id="1-插入排序算法（Insert-Sort-Algorithm）"><a href="#1-插入排序算法（Insert-Sort-Algorithm）" class="headerlink" title="1.插入排序算法（Insert Sort Algorithm）"></a>1.插入排序算法（Insert Sort Algorithm）</h4><ul>
<li><strong>直接插入排序(Straight Insertion Sort)的基本思想是</strong>：<br>把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次==从无序表中取==出第一个元素，将它==插入到有序表中==的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。</li>
<li><strong>我们需要做的工作只有两个：</strong>   <ul>
<li>取出无序区中的第1个数，并找出它在有序区对应的位置。  </li>
<li>将无序区的数据插入到有序区；若有必要的话，则对有序区中的相关数据进行移位。</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h4 id="2-归并排序算法（Merge-Sort-Algorithm）"><a href="#2-归并排序算法（Merge-Sort-Algorithm）" class="headerlink" title="2.归并排序算法（Merge Sort Algorithm）"></a>2.归并排序算法（Merge Sort Algorithm）</h4><ul>
<li><strong>归并排序的操作：</strong><br>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</li>
<li><strong>归并排序的应用场景：</strong><br>速度仅次于快速排序，为稳定排序算法，一般用于==对总体无序，但是各子项相对有序的数列==<h4 id="3-快速排序算法（Quick-Sort-Algorithm）"><a href="#3-快速排序算法（Quick-Sort-Algorithm）" class="headerlink" title="3.快速排序算法（Quick Sort Algorithm）"></a>3.快速排序算法（Quick Sort Algorithm）</h4></li>
<li><strong>快速排序的思想：</strong><br>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</li>
<li><strong>适用场景：</strong><br>快速排序是==不稳定的==。它不需要额外的存储空间。它的应用场景是大规模的数据排序，并且实际性能要好于归并排序。</li>
</ul>
<h2 id="二、程序"><a href="#二、程序" class="headerlink" title="二、程序"></a>二、程序</h2><h3 id="Ⅰ、算法程序"><a href="#Ⅰ、算法程序" class="headerlink" title="Ⅰ、算法程序"></a>Ⅰ、算法程序</h3><h4 id="1-插入排序算法（Insert-Sort-Algorithm）-1"><a href="#1-插入排序算法（Insert-Sort-Algorithm）-1" class="headerlink" title="1.插入排序算法（Insert Sort Algorithm）"></a>1.插入排序算法（Insert Sort Algorithm）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Insertion Sorting*/</span></span><br><span class="line"><span class="comment">/*每次从无序的队列中选择一个插入，</span></span><br><span class="line"><span class="comment"> *直到所有元素都排序完成。*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSortUp</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> swap = A[i];</span><br><span class="line">		<span class="type">int</span> j;</span><br><span class="line">		<span class="keyword">for</span> (j = i<span class="number">-1</span> ; A[j] &gt; swap &amp;&amp; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">			A[j+<span class="number">1</span>] = A[j];</span><br><span class="line">		A[j+<span class="number">1</span>] = swap;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-归并排序算法（Merge-Sort-Algorithm）-1"><a href="#2-归并排序算法（Merge-Sort-Algorithm）-1" class="headerlink" title="2.归并排序算法（Merge Sort Algorithm）"></a>2.归并排序算法（Merge Sort Algorithm）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*MergeSort*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//创造左右两个数组L、R，将已经排好的两部分放进去 </span></span><br><span class="line">	<span class="type">int</span> n1 = q - p + <span class="number">1</span>, n2 = r - q;</span><br><span class="line">	<span class="type">int</span> L[n1], R[n2];</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">		L[i] = A[p + i];</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n2; j++)</span><br><span class="line">		R[j] = A[q + <span class="number">1</span> + j];</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	//开始对两个数组进行归并 </span><br><span class="line">	i = 0; j = 0;</span><br><span class="line">	for (int k = p; k &lt;= r; k++) &#123;</span><br><span class="line">		if(i == n1)&#123;//如果左边数组已经全放进去 </span><br><span class="line">			while(j &lt; n2)	A[k++] = R[j++];</span><br><span class="line">		&#125; else if ( j == n2)&#123;//如果右边数组已经全放进去 </span><br><span class="line">			while(i &lt; n1)	A[k++] = L[i++];</span><br><span class="line">		&#125; else&#123;//比较两个数组，把小的数放进A数组，指针后移 </span><br><span class="line">			if (L[i] &lt;= R[j]) &#123;</span><br><span class="line">				A[k] = L[i];</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				A[k] = R[j];</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void MergeSortUp(int A[], int p,int r)</span><br><span class="line">&#123;</span><br><span class="line">	if (p &lt; r) &#123;</span><br><span class="line">		int q = (p + r) / 2;</span><br><span class="line">		MergeSortUp(A, p, q);</span><br><span class="line">		MergeSortUp(A, q + 1, r);</span><br><span class="line">		Merge(A, p, q, r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-快速排序算法（Quick-Sort-Algorithm）-1"><a href="#3-快速排序算法（Quick-Sort-Algorithm）-1" class="headerlink" title="3.快速排序算法（Quick Sort Algorithm）"></a>3.快速排序算法（Quick Sort Algorithm）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*QuickSort*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x = A[i];</span><br><span class="line">	A[i] = A[j];</span><br><span class="line">	A[j] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> p, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x = A[p];</span><br><span class="line">	<span class="type">int</span> i = p;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = p + <span class="number">1</span>; j &lt;= r; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (A[j] &lt; x) &#123;</span><br><span class="line">			i = i + <span class="number">1</span>;</span><br><span class="line">			swap(A, i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(A, p, i);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void QuickSortUp(int A[], int p, int r)</span><br><span class="line">&#123;</span><br><span class="line">	if (p &lt; r) &#123;</span><br><span class="line">		int q = partition(A, p, r);</span><br><span class="line">		QuickSortUp(A, p, q - 1);</span><br><span class="line">		QuickSortUp(A, q + 1, r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Ⅱ、测试程序"><a href="#Ⅱ、测试程序" class="headerlink" title="Ⅱ、测试程序"></a>Ⅱ、测试程序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Test*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> size 10000 <span class="comment">//size为数据规模</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;InsertSort.cpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MergeSort.cpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;QuickSort.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[size];</span><br><span class="line"><span class="type">clock_t</span> start,finish;</span><br><span class="line"><span class="type">double</span> runtime_insert,runtime_merge,runtime_quick;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*Generating test data set*/</span><br><span class="line">void tstdata(int n)</span><br><span class="line">&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	if((fp = fopen(&quot;tstdata.txt&quot;,&quot;w+&quot;))== NULL)</span><br><span class="line">		printf(&quot;cant open the file.\n&quot;);</span><br><span class="line">	else&#123;</span><br><span class="line">		srand(time(NULL));</span><br><span class="line">		for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">			if(i!=n) fprintf(fp,&quot;%d &quot;,rand());</span><br><span class="line">	      else fprintf(fp,&quot;%d\n&quot;,rand());</span><br><span class="line">		&#125;</span><br><span class="line">		fclose(fp);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*output function*/</span><br><span class="line">int output(char *filename,int A[])</span><br><span class="line">&#123;</span><br><span class="line">    FILE * fp;</span><br><span class="line">    if((fp = fopen(filename,&quot;w+&quot;))==NULL)&#123;</span><br><span class="line">      printf(&quot;cant open the file.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">	   for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">		   if(i!=size-1) fprintf(fp,&quot;%d &quot;,A[i]);</span><br><span class="line">		   else fprintf(fp,&quot;%d\n&quot;,A[i]);</span><br><span class="line">	   &#125;</span><br><span class="line">	   fclose(fp);</span><br><span class="line">	 &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	int i=0;</span><br><span class="line">	</span><br><span class="line">	/*generating test data*/</span><br><span class="line">	/*tstdata(size);</span><br><span class="line">	printf(&quot;Data set has been created.\n&quot;);*/</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	/*get the test data*/</span><br><span class="line">	FILE *fp;</span><br><span class="line">	if((fp = fopen(&quot;tstdata.txt&quot;,&quot;r&quot;))==NULL)&#123;</span><br><span class="line">		printf(&quot;cant open the file.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">	while(fscanf(fp, &quot;%d&quot;, &amp;A[i]) != EOF) </span><br><span class="line">        i++;</span><br><span class="line">   fclose(fp);</span><br><span class="line">	 for(i=0;i&lt;size;i++)&#123;</span><br><span class="line">	 	printf(&quot;%d &quot;,A[i]);</span><br><span class="line">	 &#125; </span><br><span class="line">	 printf(&quot;\n&quot;);</span><br><span class="line">	 printf(&quot;Array has been created.\n&quot;);</span><br><span class="line">	   </span><br><span class="line">	    </span><br><span class="line">	/*copy the test data set*/</span><br><span class="line">	int A1[size],A2[size],A3[size];</span><br><span class="line">	for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">		A1[i]=A[i];</span><br><span class="line">		A2[i]=A[i];</span><br><span class="line">		A3[i]=A[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    /*Insert Sorting*/</span><br><span class="line">	printf(&quot;Insert Sorting...\n&quot;);</span><br><span class="line">	</span><br><span class="line">	start = clock();</span><br><span class="line">	InsertSortUp(A1,size);</span><br><span class="line">	finish = clock();</span><br><span class="line">	</span><br><span class="line">	output(&quot;InsertSortUp.txt&quot;,A1);</span><br><span class="line">	runtime_insert = (double)(finish - start)/CLOCKS_PER_SEC;</span><br><span class="line">	printf(&quot;Insert Sort has been finished.\nTime Cost:%lf\n&quot;,runtime_insert);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    /*Merge Sorting*/</span><br><span class="line">	printf(&quot;Merge Sorting...\n&quot;);</span><br><span class="line">	</span><br><span class="line">	start = clock();</span><br><span class="line">	MergeSortUp(A2,0,size-1);</span><br><span class="line">	finish = clock();</span><br><span class="line">	</span><br><span class="line">	output(&quot;MergeSortUp.txt&quot;,A2);</span><br><span class="line">	runtime_merge = (double)(finish-start)/CLOCKS_PER_SEC;</span><br><span class="line">	printf(&quot;Merge Sort has been finished.\nTime Cost:%lf\n&quot;,runtime_merge);</span><br><span class="line"></span><br><span class="line">    /*Quick Sorting*/</span><br><span class="line">	printf(&quot;Quick Sorting...\n&quot;);</span><br><span class="line">	</span><br><span class="line">	start = clock();</span><br><span class="line">	QuickSortUp(A3,0,size-1);</span><br><span class="line">	finish = clock();</span><br><span class="line">	</span><br><span class="line">	output(&quot;QuickSortUp.txt&quot;,A3);</span><br><span class="line">	runtime_quick = (double)(finish-start)/CLOCKS_PER_SEC;</span><br><span class="line">	printf(&quot;Quick Sort has been finished.\nTime Cost:%lf\n&quot;,runtime_quick);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、测试数据集生成及测试"><a href="#三、测试数据集生成及测试" class="headerlink" title="三、测试数据集生成及测试"></a>三、测试数据集生成及测试</h2><ul>
<li><strong>我为算法的测试准备了12个测试数据集，其中数据量分别为10,000\50,000\100,000</strong>  </li>
<li><strong>每个数据量下有==随机生成数据集（用于测试平均复杂度）==和==逆序数据集（用于测试最坏情况）==</strong>  </li>
<li><strong>为了减小误差，每个类型的数据集都准备了两个，这样便生成了3x2x2=12个数据集</strong></li>
<li><strong>算法的正确性测试在数据量很小的时候进行了手动验证，所以这里我们仅着重比较时间复杂度</strong></li>
</ul>
<h3 id="Ⅰ、测试数据集生成"><a href="#Ⅰ、测试数据集生成" class="headerlink" title="Ⅰ、测试数据集生成"></a>Ⅰ、测试数据集生成</h3><p>通过main函数中的/<em>generating test data</em>/部分生成“随机生成测试集”，详细测试数据见附件。<br>通过快速排序算法生成相应的“逆序数据集”进行排序算法的时间复杂度测试，详细数据见附件。</p>
<h3 id="Ⅱ、测试过程"><a href="#Ⅱ、测试过程" class="headerlink" title="Ⅱ、测试过程"></a>Ⅱ、测试过程</h3><p>测试结果如下表：（详见附件）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>data set</th>
<th>Insert Sort(s)</th>
<th>Merge Sort(s)</th>
<th>Quick Sort(s) </th>
</tr>
</thead>
<tbody>
<tr>
<td>S1:10,000\rand array(average condition)</td>
<td>0.082</td>
<td>0.001</td>
<td>0.002</td>
</tr>
<tr>
<td>S2:10,000\rand array(average condition)</td>
<td>0.069</td>
<td>0.002</td>
<td>0.001</td>
</tr>
<tr>
<td>S3:10,000\reserve array(worst condition)</td>
<td>0.469</td>
<td>0.003</td>
<td>0.554</td>
</tr>
<tr>
<td>S4:10,000\reserve array(worst condition)</td>
<td>0.463</td>
<td>0.003</td>
<td>0.546</td>
</tr>
<tr>
<td>S5:50,000\rand array(average condition)</td>
<td>1.718</td>
<td>0.009</td>
<td>0.009</td>
</tr>
<tr>
<td>S6:50,000\rand array(average condition)</td>
<td>1.881</td>
<td>0.01</td>
<td>0.009</td>
</tr>
<tr>
<td>S7:50,000\reserve array(worst condition)</td>
<td>8.54</td>
<td>0.015</td>
<td>/</td>
</tr>
<tr>
<td>S8:50,000\reserve array(worst condition)</td>
<td>7.956</td>
<td>0.015</td>
<td>/</td>
</tr>
<tr>
<td>S9:100,000\rand array(average condition)</td>
<td>7.023</td>
<td>0.022</td>
<td>0.017</td>
</tr>
<tr>
<td>S10:100,000\rand array(average condition)</td>
<td>6.86</td>
<td>0.02</td>
<td>0.018</td>
</tr>
<tr>
<td>S11:100,000\reserve array(worst condition)</td>
<td>31.549</td>
<td>0.027</td>
<td>/</td>
</tr>
<tr>
<td>S12:100,000\reserve array(worst condition)</td>
<td>30.989</td>
<td>0.029</td>
<td>/</td>
</tr>
</tbody>
</table>
</div>
<p><em>注：50,000和100,000数据量下，最坏情况下快速排序算法程序没法完成排序</em></p>
<h2 id="四、算法复杂度分析"><a href="#四、算法复杂度分析" class="headerlink" title="四、算法复杂度分析"></a>四、算法复杂度分析</h2><h4 id="1-插入排序算法（Insert-Sort-Algorithm）-2"><a href="#1-插入排序算法（Insert-Sort-Algorithm）-2" class="headerlink" title="1.插入排序算法（Insert Sort Algorithm）"></a>1.插入排序算法（Insert Sort Algorithm）</h4><ul>
<li>最优情况：<br>最少比较一次，移动两次。<br>Cmin = n-1；Mmin=（n-1）×2；</li>
<li>最坏情况：<br>最多比较i次，移动i＋2次（逆序）（i=1，2，…，n-1）<br>Cmax=1+2+…+（n-1）=（n2-n）/2<br>M max=3+4+…+（n+1）=（n2+3n-4）/2<br>Cave=（n2+n-2）/4<br>M ave=（n2+7n-8）/4</li>
<li>故直接插入排序的时间复杂度为O（n2），它的时间复杂度和待排序列的顺序有关。</li>
</ul>
<h4 id="2-归并排序算法（Merge-Sort-Algorithm）-2"><a href="#2-归并排序算法（Merge-Sort-Algorithm）-2" class="headerlink" title="2.归并排序算法（Merge Sort Algorithm）"></a>2.归并排序算法（Merge Sort Algorithm）</h4><p>通过迭代作图法可知，归并算法的算法复杂度为O(nlogn)，它的时间复杂度和待排序列的顺序无关。</p>
<h4 id="3-快速排序算法（Quick-Sort-Algorithm）-2"><a href="#3-快速排序算法（Quick-Sort-Algorithm）-2" class="headerlink" title="3.快速排序算法（Quick Sort Algorithm）"></a>3.快速排序算法（Quick Sort Algorithm）</h4><ul>
<li>最坏情况：<br>顺序或逆序时，一次partition只能解决一个元素的位置 排列，所以最坏情况下的时间复杂度为O(n^2)</li>
<li>平均情况：<br>O(logn),枢轴元素两边的待排序列分的越平均，时间复杂度越小。</li>
</ul>
<h2 id="五、算法优化"><a href="#五、算法优化" class="headerlink" title="五、算法优化"></a>五、算法优化</h2><h3 id="1-归并排序的“哨兵”"><a href="#1-归并排序的“哨兵”" class="headerlink" title="1.归并排序的“哨兵”"></a>1.归并排序的“哨兵”</h3><p>在归并排序中，将两个已经排号的序列整合在一起时，之前我们是这样做的：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(i == n1)&#123;//如果左边数组已经全放进去 </span><br><span class="line">			while(j &lt; n2)	A[k++] = R[j++];</span><br><span class="line">		&#125; else if ( j == n2)&#123;//如果右边数组已经全放进去 </span><br><span class="line">			while(i &lt; n1)	A[k++] = L[i++];</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure><br>如果在待排的两个序列的最右端添加一个==哨兵==，即最大值MAX，就不用判断有序列已经选完了的问题，能够有效的减少判断的次数。</p>
<h3 id="2-快速排序枢轴元素pivot的选取"><a href="#2-快速排序枢轴元素pivot的选取" class="headerlink" title="2.快速排序枢轴元素pivot的选取"></a>2.快速排序枢轴元素pivot的选取</h3><p>pivot的选择对于快速排序时间复杂度的影响十分的大。从上面的“逆序测试数据”可知，如果每次选择的pivot都是最大/最小值，快速排序的复杂度可能会达到O(n^2)。<br>每次运行过程中，随机选取pivot, 通常能得到比较好的结果。<br>我采用了一种==三者取中==的方法，即选取第一个、最后一个以及中间的元素的中位数作为pivot，这样能够有效的避免“worst condition”的出现。<br>代码如下：(摘自csdn博客)<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//median-of-three pivot rule</span><br><span class="line">private static int choosePivotMedianOfThree(int[] a, int l, int r) &#123;	</span><br><span class="line">	int mid = 0;</span><br><span class="line">	if ((r-l+1) % 2 == 0) &#123;</span><br><span class="line">		mid = l + (r-l+1)/2 - 1;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		mid = l + (r-l+1)/2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//只需要找出中位数即可，不需要交换</span><br><span class="line">    //有的版本也可以进行交换</span><br><span class="line">	if (((a[l]-a[mid]) * (a[l]-a[r])) &lt;= 0) &#123;</span><br><span class="line">		return l;</span><br><span class="line">	&#125; else if (((a[mid]-a[l]) * (a[mid]-a[r])) &lt;= 0) 	&#123;</span><br><span class="line">		return mid;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------- </span><br><span class="line">/*作者：xinyuexy </span><br><span class="line"> *来源：CSDN </span><br><span class="line"> *原文：https://blog.csdn.net/qq_31903733/article/details/82945605 </span><br><span class="line"> *版权声明：本文为博主原创文章，转载请附上博文链接！*/</span><br></pre></td></tr></table></figure><br>再将选取的pivot与队列第一个元素交换即可。</p>
<h3 id="3-快速排序稳定性的改善"><a href="#3-快速排序稳定性的改善" class="headerlink" title="3.快速排序稳定性的改善"></a>3.快速排序稳定性的改善</h3><p>快速排序是“不稳定”的原因在于，partition的最后一步，pivot和指针i位置的元素交换。<br>举例：</p>
<ul>
<li>3  1  3’  5   2   6  1’(大小相同的元素用’区分)</li>
<li>3  1  2   5   3’  6  1’</li>
<li>3  1  2   1’  3’  6  5<br>(这时候还没问题)</li>
<li>1’ 1  2   3   3’  6  5<br>(最后一步1’和1的顺序发生变化)</li>
</ul>
<p>解决方法：每次partition的最后一步时，遍历待排数组A[i]之前的部分，将与A[i]大小相同的元素整体后移。</p>
<h2 id="六、实验心得"><a href="#六、实验心得" class="headerlink" title="六、实验心得"></a>六、实验心得</h2><ul>
<li>本次实验我学习了三种重要算法：插入排序算法、归并排序算法和快速排序算法，了解了它们的原理和适用的情景。</li>
<li>我认为相对于快速排序，归并排序更具有健壮性，它不会因为序列的顺序影响时间复杂度，而且它是一个稳定的排序。可能由于数据集不够大，我还没能充分体会到快速排序在时间上的优势。</li>
<li>最坏情况下的时间复杂度和平均时间复杂度相差非常大，在以后分析算法时要兼顾两者。</li>
</ul>
<h2 id="七、附录大纲"><a href="#七、附录大纲" class="headerlink" title="七、附录大纲"></a>七、附录大纲</h2><ul>
<li>Test.cpp<br>测试程序，包括数据集生成，待排序列输出等等。</li>
<li>InsertSort.cpp<br>插入排序算法</li>
<li>MergeSort.cpp<br>归并排序算法</li>
<li>QuickSort.cpp<br>快速排序算法</li>
<li>12个测试数据集txt</li>
<li>12个测试结果的截图</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>插入排序</tag>
        <tag>归并排序</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>30天自制操作系统（14）</title>
    <url>/201903/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8814%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY14-高分辨率及键盘输入"><a href="#DAY14-高分辨率及键盘输入" class="headerlink" title="DAY14_高分辨率及键盘输入"></a>DAY14_高分辨率及键盘输入</h1><h2 id="1-继续测试性能"><a href="#1-继续测试性能" class="headerlink" title="1. 继续测试性能"></a>1. 继续测试性能</h2><ul>
<li>之前我们通过“消除位移处理”缩短时间，对于很多“位移”情况，改进才能看到效果。所以我们使用大量的定时器，然后对性能进行比较。</li>
</ul>
<h2 id="2-提高分辨率（1）"><a href="#2-提高分辨率（1）" class="headerlink" title="2.提高分辨率（1）"></a>2.提高分辨率（1）</h2><ul>
<li>由于画面切换中我们要使用BIOS，所以就需要改写asmhead.nas的“画面模式设定”部分了。</li>
</ul>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 设定画面模式</span><br><span class="line">     MOV BX,0x4101 ; VBE的640x480x8bi彩色</span><br><span class="line">     MOV AX,0x4f02 </span><br><span class="line">     INT 0x10 </span><br><span class="line">     MOV BYTE [VMODE],8 ; 记下画面模式（参考C语言）</span><br><span class="line">     MOV WORD [SCRNX],640 </span><br><span class="line">     MOV WORD [SCRNY],480 </span><br><span class="line">     MOV DWORD [VRAM],0xe0000000 </span><br></pre></td></tr></table></figure>
<h2 id="3-提高分辨率（2）"><a href="#3-提高分辨率（2）" class="headerlink" title="3.提高分辨率（2）"></a>3.提高分辨率（2）</h2><ul>
<li>将程序改写，使在真机上运行</li>
</ul>
<h2 id="4-键盘输入（1）"><a href="#4-键盘输入（1）" class="headerlink" title="4.键盘输入（1）"></a>4.键盘输入（1）</h2><ul>
<li>按照下表，在键盘按键的基础上加上0x80就可以得到键弹起时的数值<br><img src="https://s2.ax1x.com/2019/03/31/ArbywT.jpg" alt="14.1"></li>
</ul>
<h2 id="5-键盘输入（2）"><a href="#5-键盘输入（2）" class="headerlink" title="5.键盘输入（2）"></a>5.键盘输入（2）</h2><ul>
<li>问题：每一个按键都需要一个if，程序会变长，我们进行修改：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static char keytable[0x54] = &#123; </span><br><span class="line">     0, 0, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;0&#x27;, &#x27;-&#x27;, &#x27;^&#x27;, 0, 0, </span><br><span class="line">     &#x27;Q&#x27;, &#x27;W&#x27;, &#x27;E&#x27;, &#x27;R&#x27;, &#x27;T&#x27;, &#x27;Y&#x27;, &#x27;U&#x27;, &#x27;I&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;@&#x27;, &#x27;[&#x27;, 0, 0, &#x27;A&#x27;, &#x27;S&#x27;, </span><br><span class="line">     &#x27;D&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;;&#x27;, &#x27;:&#x27;, 0, 0, &#x27;]&#x27;, &#x27;Z&#x27;, &#x27;X&#x27;, &#x27;C&#x27;, &#x27;V&#x27;, </span><br><span class="line">     &#x27;B&#x27;, &#x27;N&#x27;, &#x27;M&#x27;, &#x27;,&#x27;, &#x27;.&#x27;, &#x27;/&#x27;, 0, &#x27;*&#x27;, 0, &#x27; &#x27;, 0, 0, 0, 0, 0, 0, </span><br><span class="line">     0, 0, 0, 0, 0, 0, 0, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;-&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;+&#x27;, &#x27;1&#x27;, </span><br><span class="line">     &#x27;2&#x27;, &#x27;3&#x27;, &#x27;0&#x27;, &#x27;.&#x27; </span><br><span class="line">     &#125;; </span><br><span class="line"> if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /* 键盘数据 */ </span><br><span class="line">     sprintf(s, &quot;%02X&quot;, i - 256); </span><br><span class="line">     putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2); </span><br><span class="line">         if (i &lt; 256 + 0x54) &#123; </span><br><span class="line">             if (keytable[i - 256] != 0) &#123; </span><br><span class="line">             s[0] = keytable[i - 256]; </span><br><span class="line">             s[1] = 0; </span><br><span class="line">             putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, s, 1); </span><br><span class="line">             &#125; </span><br><span class="line">        &#125; </span><br><span class="line"> &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; /* 鼠标数据 */ </span><br></pre></td></tr></table></figure>
<h2 id="6-追记内容（1）"><a href="#6-追记内容（1）" class="headerlink" title="6.追记内容（1）"></a>6.追记内容（1）</h2><p>==在窗口中添加一些画，改变鼠标和字符的显示位置以及颜色。按下BackSpace，还可以改写已经输入的字符==</p>
<h2 id="7-追记内容（2）"><a href="#7-追记内容（2）" class="headerlink" title="7.追记内容（2）"></a>7.追记内容（2）</h2><p>==使用鼠标移动窗口==<br>添加的程序<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ((mdec.btn &amp; 0x01) != 0) &#123; </span><br><span class="line"> /* 按下左键、移动sht_win */</span><br><span class="line"> sheet_slide(sht_win, mx - 80, my - 8); </span><br><span class="line">/* 到这里结束！ */ &#125; </span><br></pre></td></tr></table></figure></p>
<ul>
<li>即使窗口跑到了画面外，也没有问题。因为我们已经针对鼠标指针提前采取了对策，这就如<br>同图层跑到了画面外面也可以动起来一样。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（13）</title>
    <url>/201903/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8813%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY13-定时器（2）"><a href="#DAY13-定时器（2）" class="headerlink" title="DAY13_定时器（2）"></a>DAY13_定时器（2）</h1><h2 id="1-简化字符串显示"><a href="#1-简化字符串显示" class="headerlink" title="1. 简化字符串显示"></a>1. 简化字符串显示</h2><ul>
<li>将“涂背景色、写字符、完成刷新”写进一个函数，更方便使用<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void putfonts8_asc_sht(struct SHEET *sht, int x, int y, int c, int b, char *s, int l) </span><br><span class="line">&#123; </span><br><span class="line">     boxfill8(sht-&gt;buf, sht-&gt;bxsize, b, x, y, x + l * 8 - 1, y + 15); </span><br><span class="line">     putfonts8_asc(sht-&gt;buf, sht-&gt;bxsize, x, y, c, s); </span><br><span class="line">     sheet_refresh(sht, x, y, x + l * 8, y + 16); </span><br><span class="line">     return; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x, y ...... 显示位置的坐标</span><br><span class="line">c ...... 字符颜色（color）</span><br><span class="line">b ...... 背景颜色（back color）</span><br><span class="line">s ...... 字符串（string）</span><br><span class="line">l ...... 字符串长度（length）</span><br></pre></td></tr></table></figure>
<h2 id="2-重新调整FIFO缓冲区（1）"><a href="#2-重新调整FIFO缓冲区（1）" class="headerlink" title="2.重新调整FIFO缓冲区（1）"></a>2.重新调整FIFO缓冲区（1）</h2><ul>
<li>将定时器用的多个FIFO缓冲区都集中成一个，往FIFO写入不同的数据，就能够正常地分辨出是哪个寄存器超时了。</li>
</ul>
<h2 id="3-测试性能"><a href="#3-测试性能" class="headerlink" title="3.测试性能"></a>3.测试性能</h2><ul>
<li>我们专注于定时器地改良，是因为在今后地开发中会经常使用定时器。</li>
<li>测试性能地方法：先对HariMain略加修改，恢复变量count，然后完全不显示计数，全力执行“count++；”语句。当到了10秒后超时的时候，再显示这个count值。</li>
</ul>
<h2 id="4-重新调整FIFO缓冲区（2）"><a href="#4-重新调整FIFO缓冲区（2）" class="headerlink" title="4.重新调整FIFO缓冲区（2）"></a>4.重新调整FIFO缓冲区（2）</h2><ul>
<li>把3个定时器全部归纳到一个FIFO缓冲区中，就可以把键盘和鼠标归纳起来，只用1个FIFO缓冲区。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0～ 1…………………光标闪烁用定时器</span><br><span class="line">3…………………3秒定时器</span><br><span class="line">10…………………10秒定时器</span><br><span class="line">256～ 511…………………键盘输入（从键盘控制器读入的值再加上256）</span><br><span class="line">512～ 767……鼠标输入（从键盘控制器读入的值再加上512）</span><br></pre></td></tr></table></figure>
<ul>
<li>此次我们改写最多的是HariMain。在HariMain里，执行“count++;”语句和查询FIFO缓冲区中是否有数据这两个操作，是多次交互进行的。这次修改以后，程序只需要看1个FIFO缓冲区就行了，而以前要看3个。也就是说，FIFO缓冲区的查询能够更快完成，从而使得“count++;”语句执行的次数更多。</li>
</ul>
<h2 id="5-加快中断处理（4）"><a href="#5-加快中断处理（4）" class="headerlink" title="5.加快中断处理（4）"></a>5.加快中断处理（4）</h2><ul>
<li>在FIFO里有一个取代移位处理的方法：读取一个数据以后不是让后面的数据向前靠齐，而是<br>改变下一次的数据读取地址。这是一个很巧妙的方法，但不适用于定时器。因为从timers[ ]中去除超时的中断时，这个方法虽然不错，但问题在于，用timer_settime登录中断时，后面的中断必须后移，在这一点上，以上方法不太好。</li>
<li><p>更好的方法：我们在结构体struct TIMER中加入next变量。这是个地址变量，用来存放下一个即将超时的定时器的地址。<br><img src="https://s2.ax1x.com/2019/03/31/ArHaKx.jpg" alt="13.1"></p>
</li>
<li><p>判断一下顺序，如果我们知道了插入的位置（即知道了在s和t中间插入的话），就可以像下图那样把数据重新连接起来。也就是仅仅改变s-&gt;next和timer-&gt;next的值就可以了。</p>
</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/03/31/ArHgxI.jpg" alt="13.2"></p>
<h2 id="6-使用“哨兵”简化程序"><a href="#6-使用“哨兵”简化程序" class="headerlink" title="6.使用“哨兵”简化程序"></a>6.使用“哨兵”简化程序</h2><ul>
<li>我们来看看具体的做法。在进行初始化的时候，将时刻0xffffffff的定时器连到最后一个定时器上。虽然我们偷了点懒没有设定fifo等，但不必担心。反正无论如何都不可能到达这个时刻（在到达之前会修改时刻），所以不可能发生超时问题。它一直处于后面，只是个附带物，是个留下来看家的留守者。这个留守者正是“哨兵“。</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（12）</title>
    <url>/201903/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8812%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY12-定时器（1）"><a href="#DAY12-定时器（1）" class="headerlink" title="DAY12_定时器（1）"></a>DAY12_定时器（1）</h1><h2 id="1-使用定时器"><a href="#1-使用定时器" class="headerlink" title="1.使用定时器"></a>1.使用定时器</h2><p><font color="FF0000">介绍定时器的作用，添加定时器实现中断。</font></p>
<ul>
<li>定时器（Timer）对于操作系统十分重要，每隔一段时间就发送一个中断信号给CPU。有了定时器，CPU就不用辛苦地计量时间。</li>
<li>没有定时器，我们就没法使用HLT指令，意味着要浪费很多电能。</li>
<li>有了定时器中断，程序只需要以自己的步调处理自己的问题就可以了。至于到底经过了多少时间，只要在中断处理程序中数一数定时器中断发生的次数就可以了。</li>
</ul>
<span id="more"></span>
<hr>
<ul>
<li>要在电脑中管理定时器，只需要对PIT（Programmable Interval Timer可编程的间隔型定时器）进行设定就可以了。通过设定PIT，让定时器每隔多少秒就产生一次中断。</li>
<li>在电脑中PIT连接着IRQ（interrupt request）的0号，所以只要设定了PIT就可以设定IRQ0的中断间隔。</li>
<li>我们不清楚其中的详细原理，只知道只要执行3次OUT指令设定就完成了。将中断周期设定为11932的话，中断频率好像就是100Hz，也就是说1秒钟会发生100次中断。</li>
<li>IRQ0发生时所调用的中断处理程序几乎和键盘的中断处理程序一样。</li>
</ul>
<h2 id="2-计量时间"><a href="#2-计量时间" class="headerlink" title="2.计量时间"></a>2.计量时间</h2><p>==加入计时器显示时间==</p>
<ul>
<li>让中断执行下面的程序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct TIMERCTL &#123; </span><br><span class="line">    unsigned int count; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<ul>
<li>实现方法<ul>
<li>定义struct TIMERCTL结构体，在结构体内定义一个计数变量。</li>
<li>初始化PIT时，计数变量为0，每次发生定时器中断时，计数变量就以1递增。</li>
<li>即计数变量在HariMain中不进行加算，每1s也会增加100.</li>
</ul>
</li>
</ul>
<h2 id="3-超时功能"><a href="#3-超时功能" class="headerlink" title="3.超时功能"></a>3.超时功能</h2><p>==超时功能的定义，添加超时功能==</p>
<ul>
<li>我们可以计量处理所花费的时间。具体做法：处理前看一下时间并把它存放到一个变量变量里，处理结束后再看一下时间，做差即可。根据这个可以编制==基准测试程序==</li>
<li>超时（timeout）：过了一段时间，定时器提示操作系统。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct TIMERCTL &#123; </span><br><span class="line">     unsigned int count; </span><br><span class="line">     unsigned int timeout; </span><br><span class="line">     struct FIFO8 *fifo; </span><br><span class="line">     unsigned char data; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>timeout用于记录离超时还有多长时间，当剩余时间到达0时，程序就往IFIFO缓冲区里发送数据。</p>
<h2 id="4-设定多个定时器"><a href="#4-设定多个定时器" class="headerlink" title="4.设定多个定时器"></a>4.设定多个定时器</h2><ul>
<li>在上一节做的超时功能，超时结束后如果再设定1000的话，那我们就可以让它每10秒显示一<br>次，或是让它一闪一灭地显示。</li>
<li>开发操作系统时，超时功能非常方便，所以在很多地方都可以使用它。比如可以让电子时钟<br>每隔1秒重新显示一次；演奏音乐时，可以用它计量音符的长短；也可以让它以0.1秒1次的频率来监视没有中断功能的装置；另外，还可以用它实现光标的闪烁功能。<br>为了简单地实现这些功能，我们要准备很多能够设定超时的定时器。</li>
</ul>
<h2 id="5-加快中断处理（1）"><a href="#5-加快中断处理（1）" class="headerlink" title="5.加快中断处理（1）"></a>5.加快中断处理（1）</h2><ul>
<li>问题：inthandler20中断花费了很长的时间</li>
<li>优化部分：现每次进行定时器中断处理的时候，都会对所有活动中的定时器进行“timerctl.timer[i].timeout—;”处理。也就是说，CPU要完成从内存中读取变量值，减去1，然后又往内存中写入的操作。</li>
<li>time[i].timeout不再是“所剩时间”而是“予定时刻”，将timerctl.count和timer[i].timeout进行比较，不用再经过内存计算。</li>
<li>问题：count设定成最大值，一段时间后需要重新启动操作系统。</li>
</ul>
<h2 id="6-加快中断处理（2）"><a href="#6-加快中断处理（2）" class="headerlink" title="6.加快中断处理（2）"></a>6.加快中断处理（2）</h2><p>==优化if语句==<br>解决方案：添加timerctl.next，让它记住下一个时刻</p>
<h2 id="7-加快中断处理（3）"><a href="#7-加快中断处理（3）" class="headerlink" title="7.加快中断处理（3）"></a>7.加快中断处理（3）</h2><ul>
<li>问题：到达next时刻和没到next时刻的定时器中断，它们的处理时间差别很大。<br>这样的程序结构不好。因为平常运行一直都很快的程序，会偶尔由于中断处理拖得太长，而搞得像是主程序要停了似的。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（11）</title>
    <url>/201903/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8811%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY11-制作窗口"><a href="#DAY11-制作窗口" class="headerlink" title="DAY11_制作窗口"></a>DAY11_制作窗口</h1><h2 id="1-鼠标显示问题"><a href="#1-鼠标显示问题" class="headerlink" title="1.鼠标显示问题"></a>1.鼠标显示问题</h2><ul>
<li>我们系统的鼠标不能够向右或向下移动到画面之外隐藏起来。为此我们修改HariMain</li>
</ul>
<span id="more"></span>
<p>将<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (mx &gt; binfo-&gt;scrnx - 16) &#123; </span><br><span class="line">    mx = binfo-&gt;scrnx - 16; </span><br><span class="line"> &#125; </span><br><span class="line"> if (my &gt; binfo-&gt;scrny - 16) &#123; </span><br><span class="line">    my = binfo-&gt;scrny - 16; </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><br>修改为<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (mx &gt; binfo-&gt;scrnx - 1) &#123; </span><br><span class="line">    mx = binfo-&gt;scrnx - 1; </span><br><span class="line"> &#125; </span><br><span class="line"> if (my &gt; binfo-&gt;scrny - 1) &#123; </span><br><span class="line">    my = binfo-&gt;scrny - 1; </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure></p>
<h2 id="2-实现画面外的支持"><a href="#2-实现画面外的支持" class="headerlink" title="2.实现画面外的支持"></a>2.实现画面外的支持</h2><h2 id="3-shtctl的指定省略"><a href="#3-shtctl的指定省略" class="headerlink" title="3.shtctl的指定省略"></a>3.shtctl的指定省略</h2><p>仅仅是上下移动图层就必须指定ctl太麻烦了。修改将sheet_refresh、sheet_slide、sheet_free等函数，让它们不再指定ctl</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sheet_refresh</span><span class="params">(<span class="keyword">struct</span> SHEET *sht, <span class="type">int</span> bx0, <span class="type">int</span> by0, <span class="type">int</span> bx1, <span class="type">int</span> by1)</span> </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">if</span> (sht-&gt;height &gt;= <span class="number">0</span>) &#123; <span class="comment">/* 如果正在显示，则按新图层的信息进行刷新*/</span> </span><br><span class="line"> sheet_refreshsub(sht-&gt;ctl, sht-&gt;vx0 + bx0, sht-&gt;vy0 + by0, sht-&gt;vx0 + bx1, sht-&gt;vy0 + by1); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">sheet_slide</span><span class="params">(<span class="keyword">struct</span> SHEET *sht, <span class="type">int</span> vx0, <span class="type">int</span> vy0)</span> </span><br><span class="line">&#123; </span><br><span class="line"> <span class="type">int</span> old_vx0 = sht-&gt;vx0, old_vy0 = sht-&gt;vy0; </span><br><span class="line"> sht-&gt;vx0 = vx0; </span><br><span class="line"> sht-&gt;vy0 = vy0; </span><br><span class="line"> <span class="keyword">if</span> (sht-&gt;height &gt;= <span class="number">0</span>) &#123; <span class="comment">/* 如果正在显示，则按新图层的信息进行刷新 */</span> </span><br><span class="line"> sheet_refreshsub(sht-&gt;ctl, old_vx0, old_vy0, old_vx0 + sht-&gt;bxsize, old_vy0 + </span><br><span class="line">sht-&gt;bysize); </span><br><span class="line"> sheet_refreshsub(sht-&gt;ctl, vx0, vy0, vx0 + sht-&gt;bxsize, vy0 + sht-&gt;bysize); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">sheet_free</span><span class="params">(<span class="keyword">struct</span> SHEET *sht)</span> </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">if</span> (sht-&gt;height &gt;= <span class="number">0</span>) &#123; </span><br><span class="line"> sheet_updown(sht, <span class="number">-1</span>); <span class="comment">/* 如果正在显示，则先设置为隐藏 */</span> </span><br><span class="line"> &#125; </span><br><span class="line"> sht-&gt;flags = <span class="number">0</span>; <span class="comment">/* 未使用标记 */</span> </span><br><span class="line"> <span class="keyword">return</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="4-显示窗口"><a href="#4-显示窗口" class="headerlink" title="4.显示窗口"></a>4.显示窗口</h2><ul>
<li>先准备一张图层，然后在图层缓冲区内描绘一个貌似窗口的图就可以了。</li>
</ul>
<p>只是对graph.c的init_screen8函数稍微进行修改。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void make_window8(unsigned char *buf, int xsize, int ysize, char *title) </span><br><span class="line">&#123; </span><br><span class="line">     static char closebtn[14][16] = &#123; </span><br><span class="line">     &quot;OOOOOOOOOOOOOOO@&quot;, </span><br><span class="line">     &quot;OQQQQQQQQQQQQQ$@&quot;, </span><br><span class="line">     &quot;OQQQQQQQQQQQQQ$@&quot;, </span><br><span class="line">     &quot;OQQQ@@QQQQ@@QQ$@&quot;, </span><br><span class="line">     &quot;OQQQQ@@QQ@@QQQ$@&quot;, </span><br><span class="line">     &quot;OQQQQQ@@@@QQQQ$@&quot;, </span><br><span class="line">     &quot;OQQQQQQ@@QQQQQ$@&quot;, </span><br><span class="line">     &quot;OQQQQQ@@@@QQQQ$@&quot;, </span><br><span class="line">     &quot;OQQQQ@@QQ@@QQQ$@&quot;, </span><br><span class="line">     &quot;OQQQ@@QQQQ@@QQ$@&quot;, </span><br><span class="line">     &quot;OQQQQQQQQQQQQQ$@&quot;, </span><br><span class="line">     &quot;OQQQQQQQQQQQQQ$@&quot;, </span><br><span class="line">     &quot;O$$$$$$$$$$$$$$@&quot;, </span><br><span class="line">     &quot;@@@@@@@@@@@@@@@@&quot; </span><br><span class="line">     &#125;; </span><br><span class="line">     int x, y; </span><br><span class="line">     char c; </span><br><span class="line">     boxfill8(buf, xsize, COL8_C6C6C6, 0, 0, xsize - 1, 0 ); </span><br><span class="line">     boxfill8(buf, xsize, COL8_FFFFFF, 1, 1, xsize - 2, 1 ); </span><br><span class="line">     boxfill8(buf, xsize, COL8_C6C6C6, 0, 0, 0, ysize - 1); </span><br><span class="line">     boxfill8(buf, xsize, COL8_FFFFFF, 1, 1, 1, ysize - 2); </span><br><span class="line">     boxfill8(buf, xsize, COL8_848484, xsize - 2, 1, xsize - 2, ysize - 2); </span><br><span class="line">     boxfill8(buf, xsize, COL8_000000, xsize - 1, 0, xsize - 1, ysize - 1); </span><br><span class="line">     boxfill8(buf, xsize, COL8_C6C6C6, 2, 2, xsize - 3, ysize - 3); </span><br><span class="line">     boxfill8(buf, xsize, COL8_000084, 3, 3, xsize - 4, 20 ); </span><br><span class="line">     boxfill8(buf, xsize, COL8_848484, 1, ysize - 2, xsize - 2, ysize - 2); </span><br><span class="line">     boxfill8(buf, xsize, COL8_000000, 0, ysize - 1, xsize - 1, ysize - 1); </span><br><span class="line">     putfonts8_asc(buf, xsize, 24, 4, COL8_FFFFFF, title); </span><br><span class="line">     for (y = 0; y &lt; 14; y++) &#123; </span><br><span class="line">        for (x = 0; x &lt; 16; x++) &#123; </span><br><span class="line">            c = closebtn[y][x]; </span><br><span class="line">            if (c == &#x27;@&#x27;) &#123; </span><br><span class="line">                c = COL8_000000; </span><br><span class="line">            &#125; else if (c == &#x27;$&#x27;) &#123; </span><br><span class="line">            c = COL8_848484; </span><br><span class="line">            &#125; else if (c == &#x27;Q&#x27;) &#123; </span><br><span class="line">            c = COL8_C6C6C6; </span><br><span class="line">            &#125; else &#123; </span><br><span class="line">            c = COL8_FFFFFF; </span><br><span class="line">            &#125; </span><br><span class="line">            buf[(5 + y) * xsize + (xsize - 21 + x)] = c; </span><br><span class="line">        &#125;   </span><br><span class="line">     &#125; </span><br><span class="line">     return; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<h2 id="5-小实验"><a href="#5-小实验" class="headerlink" title="5.小实验"></a>5.小实验</h2><p>HariMain中有设置图层高度的地方，如果像下面这样，把窗口图层放在最上面，光标图层放在其次，会变成什么样呢？<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sheet_updown(sht_back, 0); </span><br><span class="line">sheet_updown(sht_mouse, 1); </span><br><span class="line">sheet_updown(sht_win, 2); </span><br></pre></td></tr></table></figure><br>鼠标会跑到窗口图层的下面。</p>
<h2 id="6-高速计数器"><a href="#6-高速计数器" class="headerlink" title="6.高速计数器"></a>6.高速计数器</h2><ul>
<li>我们要做一个能够计数，并且能够把计数结果显示出来的窗口。</li>
<li>但是在刷新的时候，总是先刷新refresh范围内的背景图层，然后再刷新窗口图层，导致数字闪烁。</li>
</ul>
<h2 id="7-消除闪烁（1）"><a href="#7-消除闪烁（1）" class="headerlink" title="7.消除闪烁（1）"></a>7.消除闪烁（1）</h2><ul>
<li>窗口图层刷新是因为窗口的内容有变化，所以要在画面上显示变化后的新内容。基本上来讲，可以认为其他图层的内容没有变化（如果其他图层的内容也变了，那么应该会随后执行该图层的刷新）。<br>既然如此，图层内容没有变化也进行刷新的话就太浪费了。如果只是窗口变了，那背景就不<br>用刷新了。假如上面有鼠标，但鼠标的图层没有变化，我们也必须要刷新。窗口的刷新，可能会覆盖鼠标的一部分显示区域。</li>
<li>在sheet_slide函数里，图层的移动有时会导致下面的图层露出，所以要从最下面开始刷新。<br>另一方面，在移动目标处，比新移来的图层位置还要低的图层没有什么变化，而且只是隐藏起来了，所以只要刷新移动的图层和它上面的图层就可以了。</li>
<li>但是修改代码后，鼠标放在数字区的时候，鼠标又开始闪烁。</li>
</ul>
<h2 id="8-消除闪烁（2）"><a href="#8-消除闪烁（2）" class="headerlink" title="8.消除闪烁（2）"></a>8.消除闪烁（2）</h2><ul>
<li>闪烁现象是由于一会儿描绘一会儿消除造成的。所以说要想消除闪烁，就要在刷新窗口时避开鼠标所在的地方对VRAM进行写入处理。</li>
<li><p>方法：先开辟一块儿内存，大小和VRAM一样，这块内存用来表示画面上的点是哪个图层的像素，相当于图层的地图。<br><img src="https://s2.ax1x.com/2019/03/24/AYhJwF.png" alt="d11.1"></p>
</li>
<li><p>今后程序会对照map内容来向VRAM中写入，所以有时没必要从下面开始一直刷新到最上面<br>一层。</p>
</li>
<li>在sheet_slide函数里，首先重写map，分别对应移动前后的图层，然后调用sheet_refreshsub函数。在移动前的地方，只针对上层图层移走之后而露出的下层图层进行重绘就可以了。在移动目的地处仅重绘了一张移动过去的图层。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（10）</title>
    <url>/201903/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8810%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY10-叠加处理"><a href="#DAY10-叠加处理" class="headerlink" title="DAY10_叠加处理"></a>DAY10_叠加处理</h1><h2 id="1-内存管理（续）"><a href="#1-内存管理（续）" class="headerlink" title="1.内存管理（续）"></a>1.内存管理（续）</h2><span id="more"></span>
<ul>
<li>memory.c中增加了“向上舍入”的部分，即我们要编写一些总是以0x1000字节为单位进行内存分配和释放的函数，它们会把指定的内存大小按0x1000字节为单位向上舍入（ roundup）。</li>
<li>从向下舍入开始<br>要想把十六进制的某一位设置为0，同样只进行“与运算”就可以。</li>
<li>向上舍入：先向下舍入，再在它的结果上做个加法运算就可以了。（要先判断后几位是不是0）</li>
<li>更好的向上舍入的方法：i = (i + 0xfff) &amp; 0xfffff000; </li>
</ul>
<h2 id="2-叠加处理"><a href="#2-叠加处理" class="headerlink" title="2.叠加处理"></a>2.叠加处理</h2><ul>
<li>寻找一种方法，不仅适用于鼠标的叠加，还适用于窗口的叠加。</li>
<li>在程序中创建管理多重图层信息的结构SHTCTL</li>
<li>sheet_refresh函数：这个函数会从下到上描绘所有的图层。refresh是“刷新”的意思。电视屏幕就是在1秒内完成多帧的描绘才做出动画效果的，这个动作就被称为刷新。而这种对图层的刷新动作，与电视屏幕的动作有些相似，所以我们也给它起名字叫做刷新。</li>
<li>sheet_slide：不改变图层的高度而只上下左右移动图层的函数。</li>
<li>sheet_free释放已使用图层的内存的函数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct SHTCTL *shtctl_init(struct MEMMAN *memman, unsigned char *vram, int xsize, int ysize) </span><br><span class="line">&#123; </span><br><span class="line">     struct SHTCTL *ctl; </span><br><span class="line">     int i; </span><br><span class="line">     ctl = (struct SHTCTL *) memman_alloc_4k(memman, sizeof (struct SHTCTL)); </span><br><span class="line">     if (ctl == 0) &#123; </span><br><span class="line">     goto err; </span><br><span class="line">     &#125; </span><br><span class="line">         ctl-&gt;vram = vram; </span><br><span class="line">         ctl-&gt;xsize = xsize; </span><br><span class="line">         ctl-&gt;ysize = ysize; </span><br><span class="line">         ctl-&gt;top = -1; /*一个SHEET没都有 */ </span><br><span class="line">         for (i = 0; i &lt; MAX_SHEETS; i++) &#123; </span><br><span class="line">         ctl-&gt;sheets0[i].flags = 0; /* 标记为未使用 */ </span><br><span class="line">        &#125; </span><br><span class="line">    err: </span><br><span class="line">     return ctl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先使用memman_alloc_4k来分配用于记忆图层控制变量的内存空间，这时必须指定该变量所占空间的大小，不过我们可以使用sizeof（struct SHTCTL）这种写法，让C编译器自动计算。只要写sizeof（变量型），C编译器就会计算出该变量型所需的字节数。<br>接着，我们给控制变量赋值，给其下的所有图层变量都加上“未使用”标签。</p>
<h2 id="3-提高叠加处理速度（1）"><a href="#3-提高叠加处理速度（1）" class="headerlink" title="3.提高叠加处理速度（1）"></a>3.提高叠加处理速度（1）</h2><ul>
<li>只需要重新描绘鼠标移动相关的部分，也就是移动前后的部分就可以了，即256×2=512个像素。这只是64 000像素的0.8%而已，所以有望提速很多。现在我们根据这个思路写一下程序。</li>
<li>要在画面上显示坐标等信息，结果又执行了sheet_refresh程序。所以我们要解决图层内文字显示的问题。</li>
</ul>
<h2 id="4-提高叠加处理速度（2）"><a href="#4-提高叠加处理速度（2）" class="headerlink" title="4.提高叠加处理速度（2）"></a>4.提高叠加处理速度（2）</h2><ul>
<li>使不写入像素内容，也要多次执行if语句。我们最初就应该把for语句的范围限定在刷新范围之内。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1) </span><br><span class="line">&#123; </span><br><span class="line">     int h, bx, by, vx, vy, bx0, by0, bx1, by1; </span><br><span class="line">     unsigned char *buf, c, *vram = ctl-&gt;vram; </span><br><span class="line">     struct SHEET *sht; </span><br><span class="line">     for (h = 0; h &lt;= ctl-&gt;top; h++) &#123; </span><br><span class="line">     sht = ctl-&gt;sheets[h]; </span><br><span class="line">     buf = sht-&gt;buf; </span><br><span class="line">     /* 使用vx0～vy1，对bx0～by1进行倒推 */ </span><br><span class="line">     bx0 = vx0 - sht-&gt;vx0; </span><br><span class="line">     by0 = vy0 - sht-&gt;vy0; </span><br><span class="line">     bx1 = vx1 - sht-&gt;vx0; </span><br><span class="line">     by1 = vy1 - sht-&gt;vy0; </span><br><span class="line">     if (bx0 &lt; 0) &#123; bx0 = 0; &#125; /* 说明(1) */ </span><br><span class="line">     if (by0 &lt; 0) &#123; by0 = 0; &#125; </span><br><span class="line">     if (bx1 &gt; sht-&gt;bxsize) &#123; bx1 = sht-&gt;bxsize; &#125; /* 说明(2) */ </span><br><span class="line">     if (by1 &gt; sht-&gt;bysize) &#123; by1 = sht-&gt;bysize; &#125; </span><br><span class="line">     for (by = by0; by &lt; by1; by++) &#123; </span><br><span class="line">        vy = sht-&gt;vy0 + by; </span><br><span class="line">        for (bx = bx0; bx &lt; bx1; bx++) &#123; </span><br><span class="line">            vx = sht-&gt;vx0 + bx; </span><br><span class="line">            c = buf[by * sht-&gt;bxsize + bx]; </span><br><span class="line">            if (c != sht-&gt;col_inv) &#123; </span><br><span class="line">            vram[vy * ctl-&gt;xsize + vx] = c; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     &#125; </span><br><span class="line">     return; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统（9）</title>
    <url>/201903/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%889%EF%BC%89/</url>
    <content><![CDATA[<h1 id="DAY9-内存管理"><a href="#DAY9-内存管理" class="headerlink" title="DAY9_内存管理"></a>DAY9_内存管理</h1><h2 id="1-整理源文件"><a href="#1-整理源文件" class="headerlink" title="1.整理源文件"></a>1.整理源文件</h2><p><img src="https://s2.ax1x.com/2019/03/24/AYgbB4.md.png" alt="d9.1"></p>
<span id="more"></span>
<h2 id="2-内存容量检查"><a href="#2-内存容量检查" class="headerlink" title="2.内存容量检查"></a>2.内存容量检查</h2><ul>
<li>在最初启动时，BIOS肯定要检查内存容量，所以只要我们问一问BIOS，就能知道内存容量有多大。但是会很麻烦，我们选择自己动手检查内存。</li>
<li>做法：<ul>
<li>首先，暂时让486以后的CPU的高速缓存（cache）功能无效。<br>原理：内存检查时，要往内存里随便写入一个值，然后马上读取，来检查读取的值与写入的值是否相等。如果内存连接正常，则写入的值能够记在内存里。如果没连接上，则读出的值肯定是乱七八糟的。如果CPU里加上了缓存，写入和读出的不是内存，而是缓存。结果，所有的内存都“正常”，检查处理不能完成。<ul>
<li>通过HariMain识别3GB范围的内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-内存容量检查（2）"><a href="#3-内存容量检查（2）" class="headerlink" title="3.内存容量检查（2）"></a>3.内存容量检查（2）</h2><ul>
<li>编译器对程序进行了优化，无法识别内存，于是我们选择用汇编来写。</li>
</ul>
<h2 id="4-挑战内存管理"><a href="#4-挑战内存管理" class="headerlink" title="4.挑战内存管理"></a>4.挑战内存管理</h2><h3 id="内存管理是什么，为什么要进行内存管理？"><a href="#内存管理是什么，为什么要进行内存管理？" class="headerlink" title="内存管理是什么，为什么要进行内存管理？"></a>内存管理是什么，为什么要进行内存管理？</h3><p>操作系统在工作中，有时需要分配一定大小的内存，用完以后又不再需要，这种事会频繁发生。为了应付这些需求，必须恰当管理好哪些内存可以使用（哪些内存空闲），哪些内存不可以使用（正在使用），这就是内存管理。如果不进行管理，系统会变得一塌糊涂，要么知道哪里可用，要么多个应用程序使用同一地址的内存。</p>
<h3 id="内存管理的方法"><a href="#内存管理的方法" class="headerlink" title="内存管理的方法"></a>内存管理的方法</h3><ul>
<li>创建相应数量的区域，用1和0表示该区域是否被使用。但是这种方法的缺点就是，在内存区域很多的情况下，管理表很大。</li>
<li>列表管理的方法：从xxx号开始，yyy字节的空间是空着的。优点：占用内存小。大块内存的分配和释放都非常迅速。<br>缺点：程序管理变复杂了；当可用空间零散的时候，空间管理信息可能会被用完。  </li>
<li>我们的操作系统使用的方法是，当MEMMAN用完的时候，将小的内存区域舍弃，先不去管它。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
</search>
