[{"title":"2022年的书籍/影视/游戏/音乐总结","path":"/202212/2022年书影游音速评/","content":"书籍 11本, 电影/电视剧 26部. 电影/电视剧 想见你 ⭐⭐⭐⭐⭐ 进击的巨人S1-2 ⭐⭐⭐⭐⭐ 甄嬛传 ⭐⭐⭐⭐⭐ 寻梦环游记 ⭐⭐⭐⭐⭐- 逍遥法外 ⭐⭐⭐⭐+ 开端 ⭐⭐⭐⭐+ 怪奇物语S1-4 ⭐⭐⭐⭐ 死亡笔记 ⭐⭐⭐⭐ 鱿鱼游戏 ⭐⭐⭐⭐ 我们与恶的距离 ⭐⭐⭐⭐ 僵尸校园 ⭐⭐⭐⭐ 心灵奇旅 ⭐⭐⭐⭐ 爱在黎明破晓前 ⭐⭐⭐⭐ 顶楼S1-2 ⭐⭐⭐⭐ 回来的女儿 ⭐⭐⭐⭐- 命运航班 ⭐⭐⭐+ 信条 ⭐⭐⭐+ 还有明天 ⭐⭐⭐ 甜蜜家园 ⭐⭐+ 想见你影版 ⭐⭐+ 尸战朝鲜 ⭐⭐书籍哈利波特1-5 ⭐⭐⭐⭐⭐蛤蟆先生去看心理医生 ⭐⭐⭐⭐+拖延心理学 ⭐⭐⭐⭐被讨厌的勇气 ⭐⭐⭐⭐坏小孩 ⭐⭐⭐+计算广告 ⭐⭐⭐+阿德勒心理学 ⭐⭐⭐游戏明日方舟 ⭐⭐⭐⭐+塞尔达传说 ⭐⭐⭐⭐+凯娜精神之桥 ⭐⭐⭐⭐-原神 ⭐⭐⭐⭐-宝可梦传说 阿尔宙斯 ⭐⭐⭐第五人格 ⭐⭐音乐播放次数榜单Free Loop - Daniel PowterStay this way - fromis_9LOVE DIVE - IVEShoot! - POP!CORNTOMEBOY - (G)I-DLERunning Up That Hill - Kate BushHype Boy - NewJeansHoney - 王心凌LE VOYA9E - Kep1erDM - fromis_9 短评书影游哈利波特 1-5Status: FinishedStars: ⭐⭐⭐⭐⭐Review: 今年跟着喜马拉雅听书又重新听了一遍, 前四部依然非常上头. 感觉电影的情节真的安排得太赶了, 读原著会更爽一些. 阿德勒心理学Status: FinishedStars: ⭐⭐⭐Review: 在 PageOne 读的纸质书, 插画形式讲解阿德勒心理学. 已经读过「被讨厌的勇气」, 觉得这本书就像一本知识点总结. 被讨厌的勇气Status: FinishedStars: ⭐⭐⭐⭐Review: 用Kindle读的, 阿德勒心理学有可取之处, 这本书讲的也非常好. 其中最重要的「课题划分」概念对于当时的我来说意义非凡. 之后可能会重读一遍, 因为第一次读还有很多东西没有完全理解. 蛤蟆先生去看心理医生Status: FinishedStars: ⭐⭐⭐⭐+Review: 用Kindle读的, 虽然这本书的知识性不如上面一本, 但是这本书知识讲解得鞭辟入里, 代入感非常强 (又有柳林风声的背景). 其中「儿童, 成人, 家长」状态的概念对我的影响很大. 坏小孩Status: FinishedStars: ⭐⭐⭐+Review: 在喜马拉雅听的有声书. 不知道是不是因为我读书习惯越来越差了, 我觉得文字内容并没有那么有趣, 甚至有些无聊(相比改编的电视剧). 不过这本书写的孩子并不是传统意义的天真善良的刻板印象, 很有新意. 拖延心理学Status: OngoingStars: ⭐⭐⭐⭐Review: 在 PageOne 看了一会儿纸质书, 之后购入准备慢慢看. 书的内容对我非常有启发性, 特别是对于不在上班/上学的, 有大量空闲时间的我来说, 详尽地解释了拖延的原因和自我管理的方法, 我觉得这本书真的是大部分人的必读书. 计算广告Status: AbandonedStars: ⭐⭐⭐+Review: 可以速度一遍过一下基础概念. 这本书有点过时了, 不如去找网上的一些文档.开端Status: FinishedStars: ⭐⭐⭐⭐+Review: 无限流的影视佳作. 说实话我感觉白敬亭演的不好, 但是也没有太影响观感吧. (演员不要上综艺, 不然大家容易带入不进去.) 想见你Status: FinishedStars: ⭐⭐⭐⭐⭐Review: 值得五星的电视剧. 第三次刷了, 这一次是陪对象看的, 对象看的超级上头hhh. 想见你影版Status: FinishedStars: ⭐⭐+Review: 逻辑线很好, 剪辑稀烂. 我觉得主要是剧版太牛了吧, 影版想超越真的太难了. 进击的巨人S1-2Status: FinishedStars: ⭐⭐⭐⭐⭐Review: 和对象一起看的第三遍, 刚看完第二季, 说实话我真不觉得结局有那么烂(我感觉就是oc而已…) 怪奇物语S1-4Status: FinishedStars: ⭐⭐⭐⭐Review: 设定很赞, 每季主线流畅, 最后大家聚集在一起很热血. 最新一部 Run! Max 太牛了. 还有明天Status: AbandonedStars: ⭐⭐⭐Review: 开头还挺好看的,越往后就感觉情节越老套. 编剧没有好好打磨人物. 甄嬛传Status: FinishedStars: ⭐⭐⭐⭐⭐Review: 卓越的国产剧, 没有无意义的镜头. 死亡笔记Status: FinishedStars: ⭐⭐⭐⭐Review: 年初时候看的, 当时还担心这个动漫太压抑了. 开头太惊艳了, L 死后的故事有点赶. 是一部不能否认的好作品. Misamisa的恋爱脑还是让人有点不喜欢, 但是看到结局也接受了. 僵尸校园Status: FinishedStars: ⭐⭐⭐⭐Review: 和对象一起看的, 我觉得是合格的丧尸剧, 虽然爱情线有点莫名其妙了. 超级喜欢这种封闭空间逃难/逃杀的片. 尸战朝鲜Status: FinishedStars: ⭐⭐Review: 讲真有点无聊的. 主要是韩国的那个皇帝也太寒酸了. 甜蜜家园Status: AbandonedStars: ⭐⭐+Review: 看剧评感觉这部剧还是不错的, 但是我第一季快看完了, 仍然感觉没有进入主线, 剧情太拖沓了. 难以接受. 心灵奇旅Status: FinishedStars: ⭐⭐⭐⭐Review: 虽然讲述的道理没有那么深刻, 但是其他的一切真的很完美了. 生活本身就是生活的意义. 寻梦环游记Status: FinishedStars: ⭐⭐⭐⭐⭐-Review: 一部讨论了生与死的电影, 对我来说是很少接触的题材. 很喜欢. 命运航班Status: AbandonedStars: ⭐⭐⭐+Review: 设定太棒了, 但是剧情也太太太太拖沓了. 顶楼S1-2Status: FinishedStars: ⭐⭐⭐⭐-Review: 爽剧, 真的是够爽了. 逍遥法外Status: FinishedStars: ⭐⭐⭐⭐+Review: 年初又重刷了一遍. 对我来说是一部好剧, 也是我的美剧启蒙.很难得的是没有烂尾. 爱在黎明破晓前Status: FinishedStars: ⭐⭐⭐⭐Review: 年初和对象一起看的. 是我年轻三岁会喜欢的电影. 信条Status: FinishedStars: ⭐⭐⭐+Review: 我总感觉这个剧在故弄玄虚, 好像要讲一个很高深的设定但是又不想让观众搞明白的感觉. 仍记得当时我在电影院睡着的场景. 我在电影院一共就睡着两次, 一次是这一部另一次是柯南绀青之拳. 披荆斩棘的哥哥Status: FinishedStars: ⭐⭐⭐+Review: 综艺如果往艺术品的方向做就违背初衷了. 我觉得综艺最重要的是接地气, 能引发观众共鸣. 我们与恶的距离Status: OngoingStars: ⭐⭐⭐⭐Review: 设定就很棒了, 导演也很用心. 但是看剧时候的我太浮躁了, 总觉得看不下去. 鱿鱼游戏Status: FinishedStars: ⭐⭐⭐⭐Review: 套用爽剧模板但是很有趣. 回来的女儿Status: OngoingStars: ⭐⭐⭐⭐-Review: 我个人看悬疑剧更看重悬疑而不是逻辑, 这部剧还是挺好的踩到我的爽点上了. 无论是开头的孙悟空还是文文和妈妈睡觉的场景, 都让我感觉有爽到.凯娜精神之桥Status: FinishedStars: ⭐⭐⭐⭐-Review: 场景很赞, 但是感觉通关一遍就不想玩了. 我之后渐渐发觉自己还是喜欢社区属性强的游戏. 塞尔达传说Status: OngoingStars: ⭐⭐⭐⭐+Review: 把地图开完了, 水神兽打完. 最喜欢的设定是关于武器使用的设定.(投掷武器是真的爽) 神庙设计的也非常棒, 很喜欢. 宝可梦传说 阿尔宙斯Status: OngoingStars: ⭐⭐⭐Review: 说实话有点无聊. 一上来就给个图鉴然你去肝是怎样. 第五人格Status: AbandonedStars: ⭐⭐Review: 结合 LOL 最近说国服气氛不好, 我觉得PVP游戏国内的氛围真的 太差了, 也是因为大家的竞争观念, 想要赢的想法太强了吧. 没法好好享受游戏. 原神Status: OngoingStars: ⭐⭐⭐⭐-Review: 我一直觉得原神是一款很好的游戏. 但是对于老玩家来说, 玩法太单一了, 新出的卡牌也没什么意思. 今年从56级升到57级就也不想继续玩了. 如果原神再没有啥好玩的常驻新模式, 会渐渐没落的吧. 明日方舟Status: OngoingStars: ⭐⭐⭐⭐+Review: 下半年刚入坑. 塔防中的神中神. 这一年策划没有作妖, 社区氛围也非常好. 二创也都太有意思了. 肉鸽设计的真的很棒."},{"title":"回顾2021年的目标清单","path":"/202212/回顾2021年的目标清单/","content":"前几天写2022年展望的时候看了下自己2021年的目标清单核验, 感觉这两年目标的实现情况都比预期的要好, 但是年度目标并没有根据实际情况及时修订. 21年和22年的目标涉及的范围都很广, 深度不够. 23年的目标会在更细分的领域制定更详细的目标, 向着自己选定的几个方向去努力. 【核验】2021年目标清单 (核验日期: 2021.12.22)【100%】1、选择合适的平台，创建技术博客 是一个比较正确的目标了，督促自己学习和记录。2021年关于博客的想法我发生了许多改变，如果只是想记录的话用语雀就可以了，博客的主要作用还是分享和个人cv。在新的一年要好好记录、好好学习、好好总结。2022.4.3 - 后续准备用语雀来记博客；【cancelled】2、创建记录自己生活的博客，需要有视频床并没有完成这个。还是上面说的，如果只是需要记录，就不需要博客了。icity和微博目前能很好地满足我的需求了。这个东西和朋友圈有一点点类似的，只不过不像是朋友圈主动秀到别人眼前那样。但是现在的我对载体已经没有那么多的执念了，icity完全可以满足我的需求。记录应该是为自己记录的，而不是炫耀。 记录的载体可以更多样（录音、视频等等） 【85%】3、坚持健身，完善理论知识、规范动作标准2021年应该是已经算是坚持健身了，打卡了136天。理论知识并没有很完善，原本想着看《力量训练基础》的，但是处在现在这个变动的一年（升学），自己没有太多时间去看书。随着训练次数的增加，动作也越来越规范，发力感也越来越好。2022年对于健身的目标主要是“健康”，不要求肌肉量，更多要求尽量低的体脂和更健康的身体。把健身当成是一件享受的事情，想去就去，不要逼自己。 【0%】4、学会游泳没有学会，22年再看吧 【40%】5、顺利地完成毕设，不仅仅是糊弄，还需要真的去学东西其实也算是学到了东西，但是关于软件开发其实并没有学的很全面。这个东西，真的还是要去实习，才能学的更快更多、效率更高。 【0%】6、尽可能时间长地去实习，主动地多做一些事情，反思自己在实习中的收获被导师外派，再加上自己觉得困难的事情就没动力了，没有找到合适的技术岗or产品岗实习。现在已经有了小米的实习经验和持续两个月的找工作经验，自己应该更有自信地去找工作、找实习。【cancelled】7、抽时间总结美赛的经验和资料，形成一套可以盈利的培训方案【cancelled】8、花时间想想怎么在大四尽可能地经济独立，形成一套可以盈利的培训方案 【10%】9、坚持拍摄，成为一名光荣的vlogger去年就只有一个毕业旅行的vlog和一些很随意的cut。实习之后独居会有更多时间来拍视频。 【15%】10、阅读20本书3本，《变形记》、《霍乱时期的爱情》、《小狗钱钱》 【80%】11、观影20部16部，《你好李焕英》、《千与千寻》、《about time》、《the matrix》、《the matrix 2》、《天气之子》、《中国医生》、《哆啦A梦 伴我同行2》、《信号》、《鱿鱼游戏》、《逍遥法外》1-6 【60%】12、拍摄本科阶段的纪录片（和朋友们and微职only和朋友们，没有和wz，雅婷剪了一个wz毕业vlog，也很值得怀念了 【100%】13、毕业旅行值得怀念的旅行 烟台【cancelled】14、研究生阶段更加主动，push导师去做一些事情值得一提的是，通过这件事情我明白了，要多考虑考虑自己，不要被pua，没有任何人值得你这样的付出。在投入之前要进行收入评估，不要做亏本的买卖。 【0%】15、多参加kaggle的一些挑战赛【cancelled】16、接一些项目练手直接去实习 【0%】17、数据可视化大师（熟练掌握各种数据可视化的方法，可以做出各种惊艳的图【cancelled】18、关于学习路径图（它不仅是一个关于微职的内容，我想用它去帮助那些找不到自己职业方向的小伙伴们，每一个职业都值得尊敬，每一个职业的路径都是有迹可循的现在的我不想做这种公益性质的事情，现在的我只想为自己多考虑考虑。 【20%】19、英语口语emmm，怎么说呢，因为自己要准备新加坡那边的面试，自己的勇气增加了很多，但是口语的练习还非常缺乏。 【100%】20、icity注意记录日常，年末出一个2021年的年度总结书icity起到了它应有的作用，记录是为了反思和心情的排解、想法的抒发。不应该为了记录而记录。","tags":["项目管理"]},{"title":"2022年个人OKR核验","path":"/202212/2022年个人OKR核验/","content":"写于 2022.12.25. 现在的我正在中关村东路租的小房间里写下2022年的回顾与展望. 这个小房间刚搬进来的时候我还万分不满, 但现在住久了也渐渐习惯了, 书桌旁边就有一扇大窗户, 能够享受白天的阳光, 真的是一件很美好的事情. 我好像已经很久很久没有写过类似总结归纳的东西了, 很久没有在关心自己的状态. 过去一段时间的日程管理也仅仅是记录学习/工作上的事情. 好像我不敢写总结, 是因为害怕面对自己. 我突然想到, &lt;想见你&gt;里面黄雨萱跟陈思源讲的道理, “大人之所以是大人, 是因为他们知道什么事情比较重要.” 为了那件重要的事情, 就可以忽略其他不重要的事情. 在乎方方面面(维护一个完美的人设)是很累的, 找准最主要的事情然后针对它去努力就可以了, 其他的都可以不用在乎. 年度OKR核验12.26 (2022.4.30 修订版本)O: 【事业发展】对广告行业和NLP领域有深入的了解，能够独立负责项目。申请NUS或NTU博士并拿到offer. 申请PhD或Master项目并拿到Offer.Rv: 【90%】 了解计算广告行业的大框架, 在NLP领域有了很大的进步, 申请过程虽不是一帆风顺但自己也努力取得了成果. KR1: 了解广告行业知识和现状（看完《计算广告》和相关网文），对小米广告（浏览器和内容中心）内部框架有一个清晰的认知（看完小米商业平台部的文档）；每月复盘自己的工作内容，对工作负责。KR1: 了解NLP学术知识和企业应用现状，积累能写入简历的科研经历(以cv为导向), 发表论文一篇.Rv1: 【85%】 基本达成, EMNLP2022 Demo track非一作一篇. 没有一作的文章有点遗憾.KR2: 语言ielts &gt;= 6.5; GRE &gt;= 320 + 3.5 （英语成绩够用就好，有这个时间不如花在科研上）Rv2: 【100%】 ielts分数超出预期, GRE暂时不需要就没有考了.KR: 完成推荐信等, 联系导师套词, 争取拿到博士机会. 期间了解新加坡读博的各种政策, 整理.Rv3: 【100%】 Good Job. O: 【内心成长】追求心理健康和稳定，用理论框架梳理解释情绪和行为.Rv: 【99%】对自己过去一年内心的成长感到十分的钦佩. 勇敢面对自己和自己的选择, 没有丧失同理心.KR1: 定期看心理医生、按时吃药，争取减药or停药。Rv1: 【90%】 Good Job.KR2: 定期整理自己的情绪和领悟到的东西, 情绪以事业服务, 勇敢一些, 无需获得他人的认可. 看心理学方面的书籍并思考，记录关键笔记。如《被讨厌的勇气》、《蛤蟆先生去看心理医生》、《津巴多普通心理学》、《乌合之众》、《自卑与超越》、《社会性动物》。能够对生活中常见的问题或困扰自己的问题做出心理学角度的解释。Rv2: 【70%】 用理论框架梳理生活情绪, 能够站在比较高的位置观察自己的心态. O: 【身体健康】保持运动习惯，注重形象管理，身材变好，体脂降低。Rv: 【60%】勉强及格. 下半年做的不是太好, 虽然有客观原因, 但是仍然没有坚持健康管理.KR1: 个人护理。坚持好好洗脸和护肤，定期面膜护理，减糖。Rv1: 【75%】前三个季度都做的不错, 最后一个季度甜食吃的太多。KR2: 健康饮食。限制零食的购买和食用。不加餐，加餐只吃健康食品。Rv2: 【60%】前半年做的很好, 后半年由于身体原因和疫情原因属实是放纵了.KR: 运动。每周至少运动2三次，没有时间的话就只做有氧(游泳)。每周至少一次力量训练。Rv3: 【50%】学会了蛙泳. 5月之前做的很好, 后半年有少量有氧, 完全舍弃了力量运动. 疫情和身体原因都是借口. O: 【技艺才情】寻求多变Rv: 【75%】做的好. 能够达到75%真的超过我的预期了. 没想到自己这么棒.KR1: 视频制作/vlog。提高作品质量，不盲目追求投稿打卡。一年发布一条十分优质的视频内容。不以核心数据作为视频质量的评价指标.Rv1: 【75%】视频拍摄技巧/录音技巧/视频剪辑软件的使用(pr, 剪映, fcp) 都更加熟练, 技术方面取得了很大的进步. 但是有非常多的idea没有付诸现实. 原因: 没有考虑目标的可达成性, 没有合理制定目标和时间节点. 截至Dec. 26, 累计播放12.3万, 累计粉丝1472. 个人觉得最优秀的视频是拆花的视频, 最受欢迎的是化妆刷.KR2: 游泳。学会蛙泳和自由泳。Rv2: 【70%】Good Job. 学会了蛙泳. 一些感想回顾过去的2022, 它不像过去的年份那样平淡, 这一年里发生的事情都太激烈了, 每有一件新事情出现我的情绪就被震撼一次, 所以我对之前发生的事情记忆力就没有那么深刻. 留学 收到3份口头 Offer, 4份 Condition offer, 因为敏感背景被加澳 admission officer 拒2次, 被新加坡拒签1次, 收到小米和中科院的Offer, 雅思考出成绩. 这一年的情绪一直在被这些事情牵动着, 也没有想象中那么稳定. 在新的一年, 我希望自己能够坚定自己目标而不被这些事情的结果影响. 同时制定计划的时候也不应该把不能预料结果的事情算进去. 不能制定 “如果A那么我就做B” 这样的计划. 在同理心和钝感之间平衡, 不要过多得揣测别人话中莫须有的「深意」. 只有留给自己充分的休息时间, 才能更高效率的工作. 对话时降低语速, 注意表达时的眼神和神态控制, 去掉「然后」的口癖, 用停顿或动作来代替. 避免假性高效, 根据重要性等级为每件事情设置分数, 为自己创造深度工作的时间. 项目管理流程强化: 对交付信息- 主动汇报关键节点 - 复盘. 焦虑控制四象限. 焦虑原因: 想要证明成绩/获得认可.","tags":["项目管理"]},{"title":"雅思备考经验","path":"/202208/ielts/","content":"备考时间大约40天 (最后10天全职备考), 最后出分 6.5 (6.5), 记录一下自己的备考流程和经验. bg: 六级分数530 Listening Reading Writing Speaking 6.5 7.0 6.5 6.5 Overall备考用到的材料包括: 听力: 何琼网课, 王陆语料库 阅读: 刘洪波阅读真经 写作: Simon网课, Vince网课, 某宝的批改 口语: B站雅思口语9分安, 杨帅口语网课 真题: 剑 6, 13, 14, 16, 17 机考听阅抽到的题目难度比剑17稍微简单一点点, 但是出现了很多少见的题型. 听力出现了 no more than 2/3 words 的填空题, Section3和Section4的题目形式换了一下. 阅读出现了17道匹配题, 还有一个 no more than 3 words 的简答题. (这个题型在我刷到的剑雅里都没出现过) 写作大作文抽到了比例相对较小的 problem / solution 类似的题目. 问题是现有的商家用来促销的手段有哪些, 其中哪个最effective. 口语 Part1 抽到了 Advertisement, Part2 抽到了没准备的题目 Traffic Jam, Part3 问了七八个题目, 超时了好久. Listening 何琼听力网课 看了何琼听力网课的内容, 非常有用, 但是有些细节的做题方法有点旧了. 比如Section1填空题的答案不仅出现在对话的回答里, 而且也会出现在对话的问题中. 在剑17里填空题想要得到答案已经不能仅仅靠定位词了, 需要对对话情景比较了解. 需要准备一下何琼的场景词. 关于Section2和Section3的选择题, 我感觉何琼的方法已经不太好用了, 最好的方法还是做题然后精听或者听写. 剑17听力选择题的干扰项太变态了. 王陆语料库 因为自己的备考时间不太够, 所以最后没有用上, 但是备考时间充足的话我一定会老实用她的语料库听写. experience, february, journalism 都拼写错了, 0.5分就这样没了(哭). Reading没花太多时间在阅读上, 了解了刘洪波的做题方法后主要就是至少每两天一套题保持手感. 剑6 用来训练做题方法. 剑13 - 16的分数在7.5到8.5之间浮动, 剑17的分数差不多都是7.0 Tips: 剑17已经不再能通过简单的同义替换做题了, 需要理解文章内容. WritingSimon的小作文网课, 看完了之后把每节课的handout都完成, 写了六七篇的样子. Simon的大作文网课看完了, 但是最后没有采用, 还是用了B站Vince9120的写作逻辑. 写了两篇找某宝批改, 一篇6一篇5. Tips: 大作文的逻辑框架可以采用Simon的, 但是观点的展开一定要用Vince的三种方法. Simon的 Listing 的展开方式也被某宝批改的两位老师声讨了, 所以练习的两篇文章分数都比较低. 考场上时间不够的话不要再展开新观点了. 我最后半分钟的时候想到了一个很好的exemplify It is the good taste rather than low price makes CocaCola one of the best beverages.但是没有展开, 那一段的逻辑最后都没顺明白. Speaking考前把 Part1 和 Part2 的题目都串了一遍, 我用的杨帅整理的题库. 但是考试还是抽到新题了(悲). 没有准备过的新题, 我都没想到我能说够两分钟还被考官打断. (考官是一位白叔, 口语很舒服. 为了让我听清楚, 问问题的时候 key words 都是0.1倍速在讲) 推荐B站雅思口语9分安的公开课, 他讲的扩充的方法非常有用, 让 Part2 比较容易能讲到 2min . 避雷杨帅整理的题库, 还是要在雅思哥上看本季的题目. 考试的时候不要怯场讲话就会流利很多. 杨帅的 filler words 和每日练三句都是好的备考素材.","tags":["雅思"],"categories":["英语"]},{"title":"2022年2月产品实习面经","path":"/202202/pm面经/","content":"一共面了6个部门的产品实习 (字节Pico, 字节飞书, 滴滴地图事业部, Momenta, 小米互部, 小冰算法), 拿到两个offer最后选择了小米. Job Positions Enterprise Final Result VR和AR产品经理实习生 字节Pico 一面挂 地图点产品经理实习生 滴滴地图事业部 三面oc 产品架构实习生 Momenta 一面挂 商业平台产品经理实习生 小米互联网业务部 二面oc 算法产品经理实习生 红棉小冰 一面挂 测试产品经理实习生 字节飞书 一面挂 面试中简历挖掘和业务问题基本是五五开，简历挖掘部分不再赘述. 字节Pico方向：vr and ar2月9日投递简历，安排在2月11日一面。一共1h40min，给我面麻了 一面1、自我介绍2、来聊一聊你曾经的项目，你想先聊哪一个？（选择了小猴启蒙的用户增长运营，因为和产品岗位更加相关。）3、向我介绍一下这段实习你做了什么？（共分成了三点进行描述，微信平台数据跟踪、裂变活动策划、其他渠道向微信引流）4、详细介绍你在其中做了什么事情？（在裂变活动策划中，ab test 制定新的微信推送sop，制定了稳定时间频率的；在微信平台数据跟踪中，通过漏斗分析数据，中间还提问了各种细节）5、介绍一下区块链项目你在其中做的内容？（介绍）你觉得如果不用区块链能够解决这个问题吗？（可，把农民工的工资让开发方质押在银行）你觉得你的这个想法为什么没有人实施呢？（我这个问题说不出个所以然，减分点）6、你的职业规划是什么？（想来体验一下产品，再决定自己未来的职业道路规划）7、你对ar/mr有了解吗？（整个由两部分组成：硬件和内容。介绍了我体验过的两个产品，但是忘记爱奇艺那个产品的名字了，是一个挺大的减分点吧）8、你对未来ar、mr的畅想？（ar野生动物园导览）9、现场做一个产品调研，调研一下arkit，向我介绍一下它？（这个问题说的太笼统了，在我看网页的过程中面试官给我细化了一些sdk，我看了一下哪些sdk然后向面试官进行介绍，面试官也给我讲了很多相关的技术介绍）10、你平时玩游戏吗？（玩，巫师三 凯娜精神之桥）你觉得游戏中哪些最吸引你？（我最后选了“双人成行”，我觉得他比较牛逼的地方是两个人的游戏交互形式非常的多）如果你自己要做一个游戏，你该怎么借鉴双人成行呢？（我说的非常的不清楚）11、关于实习的时间12、反问环节，我问了pico的具体业务（ 总结：其实整个过程还是聊的很愉快的，但是后续我觉得自己其实是非常缺少“产品逻辑”，整个面试过程中聊的都是自己的直观体验，而没有从产品的角度去看待问题。这就是自己的不足。应该更多的了解产品岗位的视角是怎样的，从更专业的角度去剖析各种产品。 业务反馈被挂原因：对ar和vr的了解不够。 滴滴地图事业部主要方向：地图点共三面, oc，每一面都有30min，2.16一面；2.17二面；2.18三面 一面1、简历项目挖掘，关于学而思小猴的那一段用户增长运营经历2、如果你的mentor让你去给她买一杯咖啡，你会怎么做？（用pm项目管理的思路去答）3、在学校里最让你有成就感的一件事（3rd人工智能论坛）项目如何推进（项目管理），如果遇到不同意见如何说服？（pm沟通）4、如何快速估计出北京的公交车站点数（开放问题，采样思路随便说说） 面试官是一个非常和蔼的姐姐，面完当场告诉我通过了，准备二面 二面1、简历挖掘，关于区块链的项目，如何从pm的角度思考产品的可行性2、竞品分析：滴滴和高德打车流程的异同。（1）都是自动推荐周围上车点，没有给用户提示（2）下车点的选择大同小异（滴滴 添加途经点， 高德可以对调出发和到达）（3）打车界面（高德有价格筛选、应答率、多平台支持） 应答速度还是滴滴更快我还讲了一下关于高德的助老打车，无论是app还是小程序，用户路径都比滴滴的要好。 二面面试官觉得问题不大，说三面不出差错就没大问题。 三面1、对上车点和下车点的异同分析2、为什么打车软件从高德换到了滴滴3、高德和滴滴的分析（问的好笼统）最后向我介绍了地图事业部的业务 momenta 产品架构方向：产品系统架构 一面挂明显地感觉出来对面不想说话 kpi面 互相介绍了一下就没了 小米 商业平台方向：adpm一共两面，oc 一面简历挖掘；关于广告的兴趣；职业规划 二面广告计费方式的考察；简历挖掘；然后就是leader向我介绍工作内容了最后问了广告的一些算法（我懵了，还好没瞎编，后来知道leader也是cs出身的） 小冰方向：算法pm（听说小冰的pm数量比rd多很多，，）一面挂. 因为当时已经拿了滴滴offer，小米的offer也觉得停稳，小冰和字节飞书就面着玩儿了 一面 1、简历挖掘2、nlp的算法问我了解多少（3、在一个充满机器人的群聊（只有用户一个真人），发现这个用户非常喜欢说晚安，该如何构建用户场景？（用户画像建立-群聊场景-功能性建立） 字节飞书我之前真的超想去飞书，在字节做校园大使的时候就觉得飞书真的好用，大三的时候投简历被挂了。今年飞书toB业务开展比较缺人，，然而我面试的时候懈怠了，又是一面挂。 方向：测试软件的pm简历挖掘 + 问了些软工课程里的东西，关于测试的内容。如何测试微信朋友圈发送图片的功能 其实这个方向离我的预想差的太远了，我以为是toC体验的方向","tags":["产品","面经"],"categories":["产品"]},{"title":"博客内容归档和英文博客","path":"/202111/博客内容归档和英文博客/","content":"从2019年开始尝试搭建自己的博客，到现在已经本科毕业。这三年的时间虽然没有坚持更新博客，但是一直在坚持记录。无论是理论知识的学习、Debug的记录，还是读书健身笔记和感慨万千时的随笔，他们都散落在各种在线笔记软件和手机的备忘录中。 随着时间的推移，我对博客的认识也发生了很多变化。“记录”对我来说仍然具有非常大的意义，但是“博客”最重要的价值不应该是“记录”，而是“分享”——传递有价值的信息。我把平时的日常生活和学习经历记录在各种笔记中，过一段时间再去回顾和整理，选取其中有价值的东西去分享。 过去的一年再次参加了美赛，加入了几个和区块链有关的项目，也完成了不少专利和论文。更多的时间忙于运用知识，以需求为导向迫使自己进行广泛而不深刻的学习。对我来说真正有价值的输入变少了，输出和表达的欲望也降低了很多。 我在原先的博客域名之下又建立了一个英文博客BLOG-EN，旨在整理自己过去一年经历的各种项目。同时也将原博客中的内容进行整理归档，便于自己和访客的查阅。 课程设计与实验 Linux文本处理作业 &emsp;&emsp; 《30天自制操作系统》实验合辑 &emsp;&emsp; 学生宿舍管理系统Python开发 &emsp;&emsp; KNN和朴素贝叶斯的代码实现 &emsp;&emsp; 商品价格预测挑战 &emsp;&emsp; Fisher算法 &amp; SVM &amp; K-Means的实现和优化 &emsp;&emsp; FINDS算法和ID3算法 &emsp;&emsp; 算法设计之排序 &emsp;&emsp; 算法设计之循环赛赛程安排 &emsp;&emsp; 展示和汇报 基于链接内容的社区发现（一） &emsp;&emsp; 基于链接内容的社区发现（二） &emsp;&emsp; 学习笔记 《迁移学习简明手册》学习笔记 &emsp;&emsp; 用户对齐（实验室搬砖纪实） &emsp;&emsp; 读书笔记 《苏东坡传》 &emsp;&emsp; 《祭亡妻程氏文》 &emsp;&emsp;"},{"title":"《苏东坡传》摘录","path":"/202005/《苏东坡传》摘录/","content":"今年五月份读完的这本书，暑假开始的时候决定把读书笔记和读后感整理放在博客上。关于《苏东坡传》的文章一共有两篇，这是第一篇，内容为读书时的摘录。第二篇如下： 人生到处知何似， 应似飞鸿踏雪泥， 泥上偶然留指爪， 鸿飞那复计东西。 拿西洋作家为例，李白可以媲美雪莱或拜伦，是一个燃烧自己展现出瞬间壮景的文学彗星。杜甫就象米尔顿，是一个热心的哲学家和老好人，以贴切、渊博的古典比喻写出了丰富的作品。苏东坡永远年轻。他性格比较象萨克莱，政治和诗词的盛名则象雨果，同时又具有约翰生博士那份动人的本质。不知怎么约翰生博士的痛风病直到今天还叫我们感动，米尔顿的瞎眼却不尽然。如果约翰生同时又兼有甘斯伯劳的特色，而且象波普用诗词批评政治，又象史维夫特吃过那么多苦而没有史维夫特的尖酸味儿，我们就能找出一个英国的类比了。苏东坡的道精神由于遭受许多困难而更醇美，却没有变酸。今天我们爱他，只因为他吃苦吃得太多了。 苏东坡在面对痛苦时展现出了超常的淡然，他像是一个已经预知了自己一生的人。我最爱他的地方是他面对所有事情的坦诚。 今年五月份读完的这本书，暑假开始的时候决定把读书笔记和读后感整理放在博客上。关于《苏东坡传》的文章一共有两篇，这是第一篇，内容为读书时的摘录。第二篇如下： 我们可以检视一幕幕已经终了的情节，眼见许多事情因外在事变和内在性格的必然性而自然发展。 王安石热衷社会改革，自然觉得任何手段都没有错，甚至不惜清除异己。神圣的目标向来是最危险的。一旦目标神圣化，实行的手段必然日渐卑鄙。这种发展趋势逃不过苏东坡敏锐的心灵，甚至有点违背他的幽默感。他的行径和王安石不合；彼此的冲突决定了他一生的经历，也决定了宋朝的命运。 “文章如精金美玉”，苏东坡写信给谢民师说，“市有定价，非人所能以口舌贵贱也”。 构成永恒特质的“真诚性”究竟是什么呢？苏东坡清清楚楚表达了他对写作和文体的意见。“大略如行云流水。初无定质。但常行于所当行，常止于不可不止。文理自然，姿态横生。孔子曰，言之不文，行之不远。又曰，词达而已矣，夫言止于达意，则疑若不文，是大不然。求物之妙，如系风捕影，能使是物了然于心者，盖千万人而不一遇也。而况能使了然于口与手乎。是之谓词达。词至于能达，则文不可胜用矣。杨雄好为艰深之词。以文浅易之说，若正言之，则人人知之矣。此正所谓雕虫篆刻者。”苏东坡为文体下定义，正好贴切地描述了他自己写文章的过程，动笔收笔都象“行云流水”，揭露出文章和修辞的一切奥秘。什么时候进行，什么时候结束都没有一定的规矩。如果作家的思绪很美，只要他能忠实、诚恳、妥当表达，魅力和美感自然存在。这些不是硬放人作品的东西，词达而造成的单纯、自然和某一种自由感正是好文章的秘诀。这些特质具备了，文体不虚浮空洞，就可以写出真诚的文学作品。 “生平最快乐的时刻”，有一天苏东坡对他的朋友说，“就是写作时笔端能表达一切思想的脉络。我自忖道‘人间自乐莫过于此’”。 他曾一度坚称，给人快慰的力量便是文学本身的报酬。 当时有一位作家说，文士不怕刑罚，不爱晋升，也不贪生怕死，只怕欧阳修的意见。欧阳修对一位同事说，“读苏东坡的信，我全身喜极流汗。我应当退隐，使这个青年出人头地。”想想这句话对苏东坡有多大的影响! 日月何促促， 尘世苦局束。 我简直想说，苏东坡的精神代表“火”，他一生和水灾、旱灾奋斗，每到一地就忙着修建供水系统、水运系统和水井。火的象征很恰当，因为他活力充沛；换句话说，他的脾气和一生都象烈焰，到处给人生机和温暖，也一路烧毁了某些东西。 我没有懂作者这里说的烧毁的是什么东西 人生到处知何似， 应似飞鸿踏雪泥， 泥上偶然留指爪， 鸿飞那复计东西。 这是东坡的佳作之一，飞鸿象征人类的精神。事实上这本书所写的苏东坡生来事略只是一个伟大心灵偶尔留下的足迹，真正的苏东坡是一个幻鸟般的灵魂，说不定今天还在星宿间梦游呢。 她要他当心那些表现太露骨的泛泛之交，以及他根据“世间无恶人”理论而交上的朋友。他的麻烦就出在这儿；他无法看出别人的错处。他太太对他说：“当心那些朋友。太快建立的友情不会长久的。”东坡承认，她的话总是应验，我想她这方面的智慧是来自中国“君子之交淡如水”的古训——没有令人兴奋的味道，却永远不会生厌。诚挚的友情从来不表现太多。真正的好友不常写信，因为全心信任彼此的友谊，根本不必写。分别几年又重逢，友情依然如故。 坑上架着一个小木板桥，百英尺下有激流飞过，四周是直立的峡谷。章惇自己很勇敢，对苏轼一鞠躬，他走过木板桥，在对面峭壁上留几个字。苏东坡拒绝了，章惇独自过桥，泰然自若。他拢拢长袍，抓住一根吊索，沿峭壁到溪流对岸写了六个字：“苏轼章惇来游”。然后若无其事走回来。苏东坡拍拍朋友的背说，“有一天你会杀人。” “为什么？”章惇问道。 苏东坡答道，“能将自己性命玩弄于股掌之上，也就能杀人。”苏东坡的预言到底对不对，我们以后就知道了。 这不是中国第一次试行国家资本主义，却是最后的一次。在中国四千年的历史中，曾四度试行极权主义、国家资本主义、社会主义，以及剧烈的社会革命，每一次都惨败而终。最成功的是法家商鞍的右派极权主义，他的理论由兴建长城的秦始皇（公元前三世纪）有效推行。早期法家理论最重要的两大原则就是教战与重农。两者其实是同一回事，因为商鞍相信农夫是最好的军人，所有中产阶级的商人和贸易家都该尽量受到压制。大家都知道，根据这一教条而建立发展的强大军事系统使秦国统一了全中国；但是此一政治理论刚遍行全国，不到几年就完全崩溃。 王安石的怪习惯是不是伪装，我们无法断定；不过一个人的行为如果太过份，大家难免怀疑他有自我宣传的意味。 王安石说，他宁愿谈谈尧舜的贤臣。“在上等人才眼中，诸葛亮根本不值得一提。” 诸葛亮的政治天才在于一步步走向既定的目标，这位急功自信的财政鬼才觉得很不对胃口。 好官知道这些贷款对人民不利，确定他们付不出本利会下狱坐牢。他们遵守政府的明文规定，宣布贷款完全出于“自愿”，心中打算有一天会因“阻碍新政”而丢官。 王安石认为，控制文人的思想更属必要。他和古代的王莽，近代的希特勒一样，具有“一个国家、一个信仰、一个领袖”的信念〔他像希特勒，遭到反对就大发雷霆；现代精神病学家可以把他列为妄想狂。 无论古今中外，人民爱不爱某一政权唯有等这个专制政府失势才能判断。 郑侠终日站在宫门边，看到成群难民由东北逃来，挤满京师的街道。郑侠知道图画比言辞更有力，就把这些可怜的农民画下来，献给皇上。有一张画描写难民饥寒交迫，在大风雨中流浪。另一张描写半裸的男女正在吃草根树皮，还有人拴着铁链搬砖负柴来缴税。皇帝看到这些图画，不禁掉下泪来，精采的献图——我们以后会谈到——加上一颗彗星出现。圣山发生土崩，皇帝终于废除了许多“新法”。 司马光学问和品德都冠绝当代，从头到尾为原则而争。他和王安石代表相反的政策立场。 过了两个月老相富弼辞职，临行警告说，治斗争总是好人输，奸小一定会爬到高位。因为好人争原则，坏人争权利，最后双方都各得其所，好人去职，坏人留下来。他预言这样下去国家不久就会陷入纷乱。 苏东坡的九千字“上皇帝书”非常重要，可以代表他的政治哲学，也显出他个人的脾气和文风，充满机智、学问和大无畏的勇气。义愤的争论夹着冷静、简明的推理。有时候沮丧、严苛、挑剔、直爽无比；有时候却徐徐辩论，引经（孔孟）据典，引史例来支持他的理论。内容巧妙、诚挚、有力，对世事满怀激动和悲哀。 苏东坡认为，好政府要靠异议的健全作用来维持。民主就根据各党异议的原则而存在。我相信苏东坡若生在现代，一定反对联合国安理会的否决权，认为不民主。他知道盘古开天以来，没有两个人看法完全一样，除了民主就是专制。我从来没有发现一个反对民主的人在家、在国、在世界政局上不是暴君。 若使言无不同，意无不合，更唱迭和，何者非贤。 孔子曾说，人应该“驱郑声，远佞人”。有一天王安石和惠卿谈话，他弟弟安国在外面吹笛子。宰相对弟弟大叫说，“你能不能驱郑声？”他弟弟回答说，“你能不能远佞人？” 两兄弟政治观点始终相同，立场也一致，但是性格却完全不一样。子由性安稳，实事求是，保守，不爱多说话；东坡性豪放，开朗，多嘴多舌，天真而不计一切后果。朋友同伴都觉得子由很可靠，东坡开朗的天才，他的嘲弄和恶作剧却常常使人害怕。 苏东坡最大的缺点就是喜欢在宾客面前或者作品中坦白说出他的想法，十分不利。子由十分了解他的哥哥。子由把手放在他的嘴上，叫他从此沉默些，后来东坡出狱，子由也曾做过同样的暗示。 风中飞蓬正是苏东坡一生最好的象征，从此他就成为政治风暴中的海燕，直到老死从未在一个地方住过三年以上。 这里是他的第二故乡，不只因为此地有美丽的山丘、森林、湖泊、大海、热闹的市街和壮观的寺庙，也因为当地人民都很喜欢他，他度过了这一生中最幸福的日子。居民有南方人快乐的天性，有诗歌有美人，他们敬爱这位年轻的名诗人，欣赏他冲动、热情和无忧无虑的个性。美景启发了他的灵感，此外柔婉的魅力更抚慰了他的心灵。杭州赢得他的青睐，他也赢得杭州人民的爱戴。他担任杭州通判（助理官员），没有机会为人民多尽力，但是诗人的身份已经足够了；他被捕的时候，杭州人纷纷在街上设龛拜祭，替他解灾。他走了以后，南国的美景和温情一直令他魂牵梦系。他知道他会回来，十八年后他再度回来当太守，对本城建树极多，在杭州人心目中留下了不朽的回忆，大家都说他是杭州人。在他死后千年的今天。你走上西湖，登上孤山岛或凤山，或者在湖滨的一家饭店喝茶，你会听到杭州本籍的店主一再提到“苏东坡——苏东坡。”你若点明东坡是四川人，他可不高兴。咦，他认为苏东坡生在那儿，除了京师从来没到过别的地方哩! 苏东坡几乎相信他前生曾住在这儿。他自己的诗词和同代人的杂记都有记载。有一天他拜访寿星院，一进大门就觉得景物很熟悉。他告诉同伴，他知道有九十二级石阶通向忏堂。结果完全正确。他还向同伴描述后殿的建筑、庭院和木石。我们不必相信这些转生的故事，不过社会若相信神鬼和轮回，总有很多这一类的说法，就象鬼故事，没有人能证明是真是假。 游这些山往往要一整天，他常在傍晚回来，街灯都亮了。穿过灯火通明、人潮汹涌的小河塘夜市，他往往半醉才回家，想起一些诗句然后又忘掉一些： 睡眼忽惊矍， 繁灯闹河塘。 市人拍手笑， 状如失林莺。 始悟山野姿， 异趣难自强。 人生安为笑， 吾策殊未良。 这些家船都精雕细琢，船头有笕嘴。湖上还有其它船只专卖食品给游客。有人卖栗子、瓜子、莲藕、甜食、炸鸡和海鲜。有人专供茶水。有些船上载着艺人，照例贴近游客的小船，为大家表演歌唱、杂耍，并供应吊索和其他射猎的游戏。他们身边就是澄蓝的湖水，周长十英里左右。远处白云栖在山顶上，山峰若隐若现。云霞使山峰千变万化，多采多姿，山峰给云霞一个栖息的所在。有时候天冷欲雪，雾气盖满山脚。隔着雾气，游人可以看见零零落落的的亭台楼阁，瞥见远山模糊的棱线。睛天湖水清爽极了，水中鱼儿历历可数，苏东坡曾以两行愉快的诗句描写船夫的黄头巾与青山的背景相映照，画面十分动人： 映山黄帽螭头舫， 夹道青烟鹊尾炉。 他常常借一张和尚的躺椅，搬到附近竹林中；完全卸下官吏的尊严，脱下衣衫，赤身露体睡午觉。小和尚用敬畏的眼光偷看这位大学者，看到了别人无权一窥的场向。他看见——也许是自以为看见——苏东坡背上有七粒黑痣，排列的方位很象北斗七星。老和尚说，可见他是天廷派下来的神灵，暂时在人间作客而已 苏东坡眼中感官的生活和灵性的生活是同一回事，以诗意哲学化的人生观看来并没有什么冲突。有了诗，他热爱今生，不可能变成禁欲的和尚。有了哲学，他十分明智，也不会沉沦在“魔鬼”手中。他不会弃绝青山绿水，也不会弃绝美人、诗歌和酒肉。但是他有深度，不可能披上纨绔子弟肤浅、愤世嫉俗的外衣。 苏东坡身为通判，有一次曾裁决一件与和尚有关的案子。灵隐寺有一位和尚名叫了然，常到红灯区走动，爱上一个名叫秀奴的少女。后来他床头金尽，衣衫槛楼，秀奴就不肯见他了。有一天晚上他喝醉酒又去找那个女孩，吃了闭门羹，就强闯进去，将她打死。于是他被控杀人。官吏审问他，发现他臂上刺了两行诗：“但愿生同极乐国，免教今世苦相思。”调查完毕，证物送到苏东坡手中。苏东坡忍不住写下这一首词： 这个秃奴，修行忒煞，云山顶上空持戒。只因迷恋玉楼人，鹑衣百结浑无奈。 毒手伤心，花容粉碎，色空空色今安在，臂间刺道苦相思，这回还了相思债。 和尚被送到刑场处决。 苏太太聪明贤慧，不想用错方法，把丈夫逼到妓女怀中。此外她知道她丈夫是一个妻子或皇帝都无法阻挡的人，她采取明智的作风——充分信任他。 苏东坡个性复杂多变，很难了解。他是大哲学家，不可能变成清教徒，但他又是儒家子弟，不可能变成酒鬼。他了解生命，珍惜生命，不会把时光完全浪费在醇酒美人身上。他是自然诗人，怀有特殊健全的神秘人生观，往往和自然的了解密切融合。我相信任何一个人和自然、四季、雨、雪、山、谷那么接近，接受它的治疗，一定不会心思闭塞，具有封闭的人生观。 这是苏东坡最沮丧的时期，说也奇怪，诗人最悲哀的时候却写出了最好的作品。照中国的标准，他在这段期间达到诗词的成熟期。愤怒与尖酸都过去了，只留下满心安详与去意。 韩琦和欧阳修已逝。富弼和范镇辞官归隐。司马光潜心著作。张方平沉迷酒杯，东坡的弟弟明哲保身，一句话也不说。东坡不够圆滑。一个人亲眼看到百性受苦，这只是该不该忘掉一切后果表达心中感慨的问题。也许他从来没有考虑过。 现在苏东坡很受欢迎，不仅因为他对抗洪水成功，也因为他亲身关切狱囚的健康和利益，当时很少太守这么做。他亲自去看犯人，第一次派狱医照顾病患。苏东坡指出，法律虽禁止地方官鞭死囚犯，对囚犯病死或失于照顾而死，却没有明文规定。囚犯也是百姓。他遂赢得囚犯亲友的感激。 每一个人都是平等的。 套一句苏东坡自己的话，他始终如蝇在食，吐之乃已，到目前为止还平安无事。但是他“吐”一百次，终于被捉了。 苏东坡笑着对他们说了一个故事： 真宗时代，皇帝四处探访隐居的大学者，有人推荐杨朴。杨朴不愿入京，却被押到朝中见皇帝。 “听说你会写诗”皇帝说。 “不，我不会。”杨朴想掩饰自己的才华，不愿从政。 “朋友们送你出来，有没有人写诗给你？”皇帝又问。 “没有，”杨朴说，“只有臣妻写了一首。” “请问诗中写什么？”陛下问他。 于是杨朴把妻子送行的诗念给皇帝听。全诗如下： 更休落魄贪酒杯， 且莫猖狂爱咏诗。 今日捉将官里去， 这回断送老头皮。 苏太太听到这个故事，热泪盈眶，却忍不住笑出来。这个故事出现在东坡的笔记中，不知道是不是他临时杜撰的。 幽默 外在的工作与责任隐藏了一个人的本性。去掉这些时势和传统的陷阱，真我就出现了。苏东坡回到百姓群中，有如水里的海豹；在陆地上摇鳍摆尾的海豹只是半只海豹而已。 解放的生活使他的心灵产生蜕变，又反映到作品中。刻薄的讽刺、尖锐的笔锋、一切激情与愤怒都过去了，代之而起的是光辉、温暖、亲切、宽容的幽默感，绝对醇美，完全成熟。哲学的价值就是教人笑自己。就我所知，动物只有猩猩会笑，但是我相信只有人才会笑自己。不知道这能不能称为神祗的笑容。希腊诸神充满人性的错误和缺点，他们一定常常有机会自嘲一番；但是基督教的上帝或天使太完美了，不可能这样做。把这种自嘲的特色称为堕落人类独一的美德，该算是一大恭维吧。 任何情况下，幸福都是一种秘密。但是研究苏东坡的作品，就不难探出他幸福的奥秘了。 这位慷慨的天才对世人的贡献远超过他从世上收取的一切，他到处捕捉诗意的片刻，化为永恒，使我们大家都充实不少。 归去来兮，吾归何处……人生底事，来往如梭，待闲看秋风，洛水清波，好在堂前细柳，应念我莫剪柔柯。仍传语江南父老，时与晒鱼蓑。 到了南京，苏东坡去看王安石，后者现在已是疲惫的病老头了。他们一起谈诗论佛。双方都是大诗人，佛家弟子，有不少话可说。传说有一次两人比诗，同韵同题，苏东坡赢了。王安石中途放弃。谈话中苏东坡不免责备王安石招来战祸，迫害学者。 事实上，奢华的日子和简朴的日子在幸福方面倒没有什么差别。只有不配作高官的人才羡慕高官的荣宠。通常不想作官的人为当局一心争取，想作官的人却又不够资格。一旦“官愿”满足了，做大官的乐趣不见得胜过成功的铁匠。 乐事可慕，苦事可畏，皆是未至时心尔。及苦乐既至，以身履之。求畏慕者初不可得况，既过之后复有何物。 当时的知识分子只有两条路可走，不是做官就是自甘淡泊——淡泊通常代表贫穷。当然人可以以潜心学术，得到永远的声名；但是对许多人来说，不朽的声名就算有把握，也只是空腹的自我安慰罢了。 这些年来苏东坡不断在策论中说，“独立思考”和“公正无私”是好大臣的重要条件。但是独立思考和意见公正却是党人最讨厌的。 诗、书、画最主要的材料就是两种液体：酒和墨；他们有上好美酒，上好名墨，还有最好的毛笔和最珍贵的纸张。 把中国书法当做一种抽象画，也许最能解释其中的特性。中国书法和抽象画的问题其实非常相似。判断中国书法的好坏，批评家完全不管文字的意思，只把它视为抽象的构图。它是抽象画，因为它并不描绘任何可辨的物体，与一般绘画不同。中国字是由线条所构成，线条组合千变万化，书法就是把这些字完美凑出来，而且要和同一行、同一页的其它字体相配合。中国字是由最复杂的成份所构成，不免呈现一切构图的问题，包括轴线、轮廓、组织、对比、平衡、比例等等，尤其注重整体的统一概念。 一切艺术的问题都是节奏的问题，无论绘画、雕刻或音乐都是一样。既然美感就是动感，每一种形式都有隐含的韵律。就连建筑方面亦然，哥德式的教堂仿佛在沉思。美学上甚至可以用“冲”、“扫”、“粗鲁”等人格的形容词，这些都是韵律的观念。 这种动作的韵律美观念改变了一切技术家对线条、质量、表面、构图和材料的看法。若属于力学而非静态的美，一切全是平衡的直线画，像工程师的蓝图一般，那就不值得考虑了。相反的艺术家必须寻找扭曲不平的树枝线条，只因为弯曲扭转才能显出生命和运动。这种不平均的线条我们很容易看出生命和动作，其中敏感的压力、休止和扫动以及树枝偶然的哗啦声都仔细保存下来。国画和书法可以说有一项基本原则，除非必要——譬如画书桌和茶几——千万别用均衡的线条。构图的概念也变了。中国艺术家绝不以静态的安排、线面的对比为满足，因为这些线面都是死的。画家因此强调活线条，这是国画技巧和其它绘画的一大差别。 为了培养活线条的基础，书法家便回头观察大自然。自然的线条总让人想起动作，变化永无止尽。善跑的灵堤猎犬结实光滑，自有一种美姿；而爱尔兰小诜多毛矮胖，又另是一番风味。我们可以欣赏小鹿的灵巧，同时又爱慕狮掌强大的肌力。小鹿身材优美，不仅因为轮廓匀称，也因为它让人想起跳跃的动作，狮掌优美则因为让人想起飞扑，就是这种飞扑和跳跃的功能使线条具有活生生的协调感。若追求这种韵律美，我们可以欣赏大象庞然的身躯，小蛇扭曲的张力，甚至长颈鹿枯瘦笨拙的动作。所以自然的韵律永远充满机能，只因为线条和轮廓都是生长过程的结果，具有一定的作用。借自然丰富的韵律，才能极度锻炼我们的鉴赏眼光。中国书法家挥笔时想模仿的就是这种自然的律动，也只有最敏感的画笔才能模摹出来。有些笔触稳定而圆熟，令人想起狮掌的威力；有些令人想起马足的肌力，节骨分明。有些想表现明快的清爽感，字体有肩、有腰、有支架，正如完美的女性，或者像中国批评家所说的“如美人鬓带鲜花”。有些想效法枯藤难摹的雅姿，末端形成温文安定的小卷，用几片细叶加以平衡。别忘枯藤的平衡最完美，因为末端弯曲的角度和形状要看藤蔓整个的重量——茎株的支持点和残叶在哪一边而定。 在八大山人的鱼鸟或石涛的兰花中也许更能看出印象派艺术的极端例证。无论画鱼画鸡画鸟，八大山人的画可以说是用最少线条、最少墨汁来表现最多的韵味。大艺术家只花几分钟，迅速泼墨完成一张鱼、马或人像图；不是成功就是失败，万一失败他就把纸条揉成一团，丢入字纸篓中，从头来起。 我前面已说过，在位党和反对党也没有明确的权责。多数党统治的机能并不存在。于是政治游戏便成为个人之间的斗争，比西方更剧烈。但是东西方的政治规则完全一样：爬到顶端的一定是庸才。 第一，好政客要会说一大堆话，却不透露任何消息。好官决不肯定什么，只用否定。只要学会“无可奉告”、“你说得对”等至理名言，好官就可以无往而不利。第二、他应该施惠于朋友。第三、他应该小心不得罪人。一个人如果不随便说话，爱用文雅、细柔、愉快的低语，又很喜欢施小惠给人家，他就算不位极人臣，也不会失势。他到死都有官做。 苏东坡逃避政治，政治却在追逐他。他和司马光政见不合——独立的心灵永远不会完全一致——但是他到京师半年，司马光就去世了。苏东坡陷入显赫遭忌的地位。 他维护意见不一的原则。信中指出，“若上之所可，不问其是非，下亦可之。上之所否，不问其曲直，下亦否之”，对国家并没有好处。君主和大臣应该互相提供意见，如果百官唯唯诺诺，就变成孔子所谓“足以丧邦”的跟屁虫了。 当时政府最大的间题——中国每一朝代都是如此——就是冗官充斥。文人太多，官位太少，在“学而优则仕”的中国社会成为经常存在的弊端。除非现在能改变此一观念，否则教育普及就能把国家拖垮。我们要如何提供四亿五千万知识分子的官位呢？如果公职制度严格遵行，用人惟才，则考中的人数自然有限，素质也会提高。但是苏东坡时代已盛行亲族主义。 事实上他已决心离开朝廷。他说君子如麟凤难求，小人“易进如蛆蝇，腥膻所聚，瞬息千万”。 “聚蚊成雷，积羽成舟，寡不胜众也”。 苏东坡对于这种零碎、没有组织的救病工作并不满意，他由政府基金拨出两千缗，自己又捐了五十两金子，在城中心众安桥建了一座公立医院。就我所知，这个“安乐坊”是中国最早的公立医院。三年内曾医过一千个病人，主管医院的道士由政府赠以紫袍和金钱。后来医院搬到湖边，改名“安济坊”，苏东坡离开后还继续看病。 太后死前十天，范纯仁和苏子由等六位大臣进去看她。 “我大概无法复原了，”太后说，“不能长期看着你们。你们要尽力侍候小皇帝。” 大臣即将告退，太后指名要范纯仁留下来。于是哲宗叫别人退开，只剩范纯仁和吕大防。 朝中传闻太后谋反，要立自己的儿子为帝，太后问道，“皇上年幼，神宗托老身治国。九年里你们可曾看我特别照顾高家？” “没有，”吕大防说，“太后未曾厚待娘家，一切以邦国为重。” “正是如此，”太后含泪说，“所以老身临死才见不到自己的儿子和女儿。”她并没有派儿子在京师做官。 “太后必能康复，”吕大防说，“请听医生的劝告。您现在不该说这些事情。” “不，”太后说，“今天当你们的面，我要对皇上说几句话。我知道我死后很多大臣会愚弄他。孙子，你该当心。”她转向吕大防和范纯仁说：“我觉得老身死后，你们还是辞官归隐吧，小皇帝会用新人。” 她问侍从宫中有没有请大臣吃饭，她对吕大防和范纯仁说：“现在去用餐吧。明年此日，请记得老身。” 一个王朝的悲剧在于皇后们有必要接连生出善良、聪明、能干的儿子、孙子和曾孙，皇室才能长保权位——这是生物学上人类从来没有听过的不保险假设。天才不生天才，迟早贤明的君主会生出邪恶、昏庸的后代。 中国历史上若有一个时期可以称得上残暴与混乱的时代，那就是蔡京手下的政府了。他替皇帝建设精美的乐园，在中国历史中写下最可怕的一页，因为皇家乐园也用不着国人付出那么多悲惨的代价呀。园中每一块异石，每一朵奇花都曾牺牲几条人命。读到徽宗和大臣们赞美这个花园、假山、清溪、异石的诗句，我们不禁脊骨发冷，感受到中国文学史上从未有过的悲剧。悲剧在于作者并不知道这些。 章惇劝皇帝挖司马光的坟墓，打烂棺材，鞭尸示众，以警告所有不忠的臣民。在小皇帝心目中，司马光变成元祐时代奸诈、不忠、邪恶的象征。上朝的时候大家都表示赞成，只有许将不说话。小皇帝打量他，退朝后叫他留下来。 他转念一想：“此间有什么歇不得处。由是心若挂钩之鱼忽得解脱。若人悟此，当恁么时也不妨熟歇。” 他又恢复了自然的本性。他在广州曾买了一些檀香，现在他常关门静坐，享受奇特的异香，反省自己以往的错误。有时午后小睡一回，凉爽的江风吹进窗口，房顶的鸟鸦打断他的幽梦，他突然觉得自己卸下一切责任。他看到大江的光影射入他房中。真美，他暗自说，美得像清空的明月。他不懂为什么有人喜欢云中的翳月。他觉得晴空是光明磊落的象征。 苏东坡写过一篇酒颂。就是不解杯中乐趣的人读到他描写半痴半醉的幸福状态也会为之入迷： “浊醪有妙理赋 酒勿嫌浊，人当取醇。失忧心于昨梦，信妙理之疑神……仔人之生，以酒为命。常因既醉之适，人识此心之正。稻米无知，岂解穷理。麴栗有毒，安能发性，乃知神物之自然，盖与天工而相并。得时行道，我则师齐相之饮醇。远害全身，我则学徐公之中圣。湛若秋露，穆如春风。疑宿云之解驳，漏朝日之暾红。初体栗之失去，旋眼花之扫空……兀尔坐忘，浩然天纵。如如不动而体无碍，了了常知而心不用。座中客满。惟忧百種之空。身后名轻，但觉一杯之重。今夫明月之珠，不可以襦，夜光之璧，不可以哺。刍肉饱我而不我觉，布帛袄我而不我娱。惟此君独游万物之表，盖天下不可一日而无。在醉常醒，孰是狂人之乐。得意忘味，始知至道之腴。” 她是虔诚的佛教徒，临死还念着《金刚经》的一道偈/jié/语： 一切有为法， 如梦幻泡影。 如露亦如电， 应作如是观。 根据她的遗嘱，苏东坡将她安葬在城西丰湖边的山脚上，靠近一座亭台和几间佛寺。墓后有山溪瀑布流入湖中。 玉骨那愁瘴雾，冰肌自有仙风。海仙时遣探花丛，倒挂绿毛么凤。 素面常嫌粉污，洗妆不退唇红。高情已逐晓云空，不与梨花同梦。 苏东坡自以为晚年可以定居惠州，没想到突然被贬到海外。新居落成两个月，移居海南岛的命令就来了。有人记载说，他写了两行诗描述他在春风中小睡，聆听屋后庙院钟声的情景。章惇读到这段诗，就说：“原来苏东坡那么惬意。”于是颁布了移居的命令。 但是他不屈的灵魂和人生观不容许他失去生活的乐趣：“尚有此身付与造物者，听其运转流行坎止无不可者。故人知之，免忧热。”他写信给一位朋友说。 “吾始至南海，环视天水无际，凄然伤之曰‘何时得出此岛也’。已而思之：天地在积水中，九洲在大浪海中，中国在少海中。有生孰不在岛者。譬如注水于地，小草浮其上，一蚁抱草叶求活，已而水干，遇他蚁而泣日‘不意尚能相见尔’。小蚁岂知瞬间竟得全哉？思及此事甚妙。与诸友人小饮后记之。” 苏东坡也许是倔强，也许是真的掌握了自己。至少他从未失去幽默感。 苏东坡曾经对他弟弟说：“我上可以陪玉皇大帝，下可陪卑田院乞儿。在我眼中天下没有一个不是好人。”现在他和默默无闻的穷学者、农夫农妇交往。他和这些纯朴小民谈话不必有戒心，自由自在，最能表现自己。家里一天没有客人他就不自在，别人不来他就出去拜访邻居。和黄州时期一样，他与高官、平民、学者、农夫杂处。聊天总是他发言；他天生爱说话。但是他也希望别人开口。他带着海南种的大犬“乌嘴”到处闲逛。他和村民坐在槟榔树下，想畅谈一番。无知的穷农夫能对他说什么呢？农夫对这位大学者敬畏万分，“我们不知道要谈什么。”苏东坡说：“那就谈鬼吧，说几个鬼故事来听听。”对方会说他们没听过什么好的鬼故事，他说：“没关系，就谈你们听过的好了。”后来苏过告诉朋友，他父亲如果一天没看到客人，就好像有什么不对劲似的。 小屋完成后的两年半期间，苏东坡过着无忧无虑却十分贫穷的生活。他有两位妙友，一个是替他转信的广州道士何德顺，另一位是四处游荡，送他食物、药物、米、泡菜、书本的小学者（吴复古）。 他写了不少有关药草的笔记，我要特别谈谈荨麻治风湿的办法，荨麻含有荨麻素和黄体素，像毒藤似的，碰到皮肤就会肿痛。照他的说法，把荨麻敷在风湿起始的肿痛关节上，全身各处的酸痛都会停止。他还热烈信仰苍耳。苍耳到处都有，对人无害，不管吃多久怎么吃都可以（含有脂肪，少量树胶、维他命C1和耳醣）。他写下苍耳白粉碾制的办法，把叶灰用温火烧二十四小时就成了。白粉吃下去据说可以美化皮肤，“满肌如玉’。有些笔记谈到蔓菁、芦菔和苦荠，苏东坡称为‘葛天氏之遗民”的美食，价值高，味道又好吃。 他请子由写序，在一封信中说：“然吾于渊明，岂独好其诗也哉。如其为人，实有感焉。”很多崇拜苏东坡的人也会这样说。 徽宗继位时，国家的命脉已经腐蚀削弱。有个性、有才华、有正义感的君子是文明社会的珍贵产物，需要长时间培养茁壮。司马光、欧阳修、范纯仁、吕公著的时代过去了，那一代的人已经分别下狱、流放、病死、老死或被杀。独立批评，勇敢思考写作的气氛已经僵化，整个政治生命都污染了。苏东坡师徒因言论而受罪，不愿意再入政坛，何况政风又对他们不利。皇帝一声命令，不可能马上有一群正直、博学、大无畏的学者出现朝中。己尝了八年权力滋味的大批政客更不可能放弃权位。 显然神宗皇后和她婆婆一样，善于感受国家的利益，她们具有单纯的女性本能，会判断好人坏人。批评家和历史家迷恋优美的文辞和抽象的特征，善于研究某一时期深奥的问题和政策，却忘记我们看人最后总逃不过“好”、“坏”这两个形容词。总括一个人的事迹和个性，“好人”就是最高的赞美。苏东坡服侍的太后们似乎从来不管政府领袖的问题和政策。当然章惇是一个坚强果断的人。惠卿是雄辩家。蔡京生气勃勃、精明能干。但太后一概把他们归类成坏人。 他本来想等福建大船，苦等不来，就随吴复古、苏过和爱犬（乌嘴）渡海，一行人到雷州去找秦观。吴复古又失去踪影。苏东坡和吴复古一生游遍全中国，不同的是苏东坡被别人的命令赶来赶去，吴复古却是自愿飘泊。追忆往事，苏东坡似乎恨不能和他的朋友交换际遇。那样一定快乐得多，也自由得多。 他在广州受到热诚的招待。他到海南岛第二年，有人传说他死了。有一位朋友在宴席上开玩笑说： “我以为你死了。” 苏东坡说：“不错，我死了，在地府半路上碰到章惇，我又决定折回来。” 大家庭有不少小孩和年轻的妇女，他们就乘船到南雄。没走多远，吴复古和一群和尚追上他们，陪老苏畅游了几天。然后吴复古突然病倒去世，一切都那么简单。苏东坡问他临终有什么交代。吴复古笑笑合上了眼睛。 苏东坡最初和最终的乐趣都是写作。他把自己在南方所写的诗文拿给钱世雄看，眼睛闪闪发光，似乎忘记了一切。有时候他还能写短简和题跋，其中包括一篇桂酒颂，他知道好友会仔细珍藏，就把这篇文章送给钱世雄。 苏东坡缓缓低语：“西天也许存在，不过设法到那儿也没有用。”钱世雄站在旁边，就对他说：“尤其这个时候，你一定要试试看。”苏东坡最后一句话是“试就不对了”。那就是他的道家哲学，解脱在于自然而不自觉的善行。 由尘世的标准来说，苏东坡的一生相当坎坷不幸。有一次孔子的门生问起两个为信念而饿死的古圣人。门生问孔子，伯夷叔齐死前有没有悔意。孔子说：“他们求仁而得仁，为什么要后悔呢？” 苏东坡今生的“浩然之气”己经用光。人生不过是性灵的生活，而性灵是控制人类事迹和个性的力量，与生俱来，只能靠生命和际遇和环境来表现。正如苏东坡的描写：“浩然之气不依形而立，不恃力而行，不待生而存，不随生而亡矣。故在天为星辰，在地为河岳，幽则为鬼神，而明则复为人。此理之常，无足怪者。” 读到苏东坡的生平，我们等于追察人类心智和性灵暂时显现在地球上的生命。苏东坡死了，他的名字只是一段回忆，但是他却为我们留下了他灵魂的欢欣和心智的乐趣，这些都是不可磨灭的宝藏。","tags":["苏东坡"],"categories":["阅读"]},{"title":"《祭亡妻程氏文》 苏洵","path":"/202002/祭亡妻程氏文/","content":"与子相好，相期百年。不知中道，弃我而先。 东坡刚考中准备做官的时候，他的母亲去世了，她临死还没有听到京师的好消息。《苏东坡传》中林语堂先生引了苏洵的《祭亡妻程氏文》的一段话：“我归旧庐，无不改移。魂兮未泯，不日来归。” 昨晚读到这里的时候有被触动。今天去找来了原文查词典把文章理顺了。 呜呼！与子相好，相期百年，不知中道，弃我而先。 我徂京师，不远当还；嗟子之去，曾不须臾。子去不返，我怀永哀。反复求思，意子复回。 人亦有言，死生短长，苟皆不欲，尔避谁当，我独悲子。 生逢百殃，有子六人，今谁在堂？唯轼与辙，仅存不亡。咻呴抚摩，既冠既昏，教以学问，畏其无闻。昼夜孜孜，孰知子勤？ 提携东去，出门迟迟。今往不捷，后何以归？二子告我，母氏劳苦，今不汲汲，奈后将悔。大寒酷热，崎岖在外。亦既荐名，试于南宫。文字炜炜，叹惊群公。二子喜跃，我知母心，非官实好，要以文称。 我今西归，有以藉口。故乡千里，期母寿考。归来空堂，哭不见人。伤心故物，感涕殷勤。 嗟予老矣，四海一身。自子之逝，内失良朋。孤居终日，有过谁箴？ 昔予少年，游荡不学，子虽不言，耿耿不乐。我知子心，忧我泯没，感叹折节，以至今日！ 呜呼死矣！不可再得。 安镇之乡，里名可龙，隶武阳县，在州北东。有蟠其丘，惟子之坟。凿为二室，期与子同。骨肉归土，魂无不之。我归旧庐，无不改移。魂兮未泯，不日来归。","categories":["阅读"]},{"title":"《极简欧洲史》读书笔记","path":"/202002/极简欧洲史读书笔记/","content":"从2019年年底到2020年年初我一直在读的这本书——《极简欧洲史》，我应该不会向身边的人推荐这本书，因为这是一本比较枯燥的历史课本。唯一能让我对历史提起兴趣的描写性语言少之又少。在我读到大概三分之二的时候就想放弃，然而最后还是因为微职的读书小组坚持读下来了。这本书越往后节奏越快，到后面快要变成了流水账。不过通过这本书我也做了非常多的思考：像我这样对历史毫无兴趣的理科生还需不需要读历史？有没有更舒服的、更有趣地了解历史的方式？ 本书的内容原本是授课用的讲义，目的是让澳大利亚的大学生对欧洲历史有个初步的认识。但身为老师的我并不是从最前面开始，按部就班讲到最后。我的做法是先为学生很快地做个概论，再回头补充细节。——《极简欧洲史》引言 既然整本书都只是知识性的，那这本书的读书笔记应该是一份复习提纲。然而我并没有按照书的逻辑做摘录，而是仅仅把其中触动我的一些文字摘录了出来。现在回去看，这些摘录并不是关于“历史”的，而是关于“人”的。 在雅典，死刑通常都是立刻执行，这次却往后推迟了，因为宗教庆典的关系。苏格拉底大可趁机潜逃，说不定那些官员还暗自希望他逃之夭夭，但他却拒绝逃跑。他问：“既然我不能永远活着，那又何必苟且偷生？活着不是目的，好好活着才是。我曾在雅典的法治下过着很好的生活，如今我已准备好接受惩罚。”直到最后一刻，他还是充满了哲学思辨。直到他的镣铐被取下，他还在发表高论，说痛苦和享乐只是一线之隔。他被判处服毒芹汁自绝，必须在一日将尽时服下毒药，他的弟子求他晚点再喝，现在太阳还没下山呢！苏格拉底回复道，要是他这样偷生，自己看了都觉得荒谬，他平静地接过毒药一饮而尽，全无半点神伤，很快就药效发作而亡。 “他该受到什么报应，”鲁克丽丝说，“我交由你们决定。至于我，虽然失节非我之过，但我要接受自己的惩罚。失贞的女人应该得到什么报应，我绝不会首开避脱的先例。”话声甫落，她便从衣袍中掏出一把刀刺入心脏，应声倒下，就此香销玉殒。她的父亲和丈夫哀恸欲绝。两人只能呆立着无助地哭泣，但布鲁图斯拔出鲁克丽丝胸前染血的刀，举着它高喊：“我要对这位烈女的血发誓：在她被暴君蹧蹋之前，没有人比她更为贞洁，我也对上帝发誓，我要借助刀剑、烈火以及所有能让我更强大的东西，追捕骄傲者塔克文、邪恶的王后及其所有的子女，绝不让他们任何人再登上罗马的王座。” 拿破仑是启蒙运动之子，深信革命所揭橥的诸多原则，却不相信人民有权统治自己。自1789年之后，法国在这个志业上可说是节节落败，拿破仑的政见因此非常吸引人。他是独裁者中最有魅力的一个，他不准任何团体享有特权，所有国民一律得到平等对待，国家提供所有孩童受教育的机会，所有职务都要公开选才。他延揽各方人才进入政府，无论是保王派还是共和派，雅各宾恐怖政权的支持者还是反对者，完全不计较他们过去在革命中扮演的角色。他只交给他们一个使命：创立一个有理性、有秩序的政府体制。 你一定会喜欢这些平民百姓。他们很脏很臭，看来很不讨喜，因为他们一年到头无分寒暑地日夜操劳，形容憔悴、伤痕累累、营养不良、疾病缠身。那为什么你还会喜欢他们？因为他们的命运很容易追踪；百年复百年，他们做的都是同样的事，几乎所有的人都在耕种。 历史是枯燥的，但历史河流中的每个人都是鲜活的。我们可以通过面对死亡时平淡和毅然的苏格拉底去了解雅典的法庭；通过坚贞的鲁克莉丝了解罗马共和政体的开启；通过飒爽的拿破仑了解法国的革命。当我们从人的角度切入历史的时候，我们可以收获更多的共鸣。《中国的历史精神》里说“历史便即是人生”，因为历史确实是由无数的人生构成的。历史本身就是我们人生整个过往的经验。 当我发现人物对于历史的重要性之后，也明确了自己想要了解历史的一个更好的途径应该是人物传记。所以也从自己最喜欢的苏轼开始读《苏东坡传》，上一周的读书时间也比较开心，不仅仅是因为苏轼本身就是一个很有意思的人，林语堂的文风也比较轻松诙谐。苏轼身上的纯真相当感染人，也对我自己面对选择的态度有挺大的触动。希望这周能把《苏东坡传》读完吧。 以古为鉴，可知兴替；以人为鉴，可正德身。 ——唐太宗","tags":["极简欧洲史","历史"],"categories":["阅读"]},{"title":"Price Suggestion Chanllenge","path":"/201911/Price_Suggestion_Chanllenge/","content":"实验题目题目背景考虑到网上销售的产品数量，产品定价在规模上变得更加困难。服装有很强的季节性定价趋势，受品牌影响很大，而电子产品价格根据产品规格波动。如何根据以往信息进行合理定价，有效地帮助商家进行商品的销售是一个有意义的问题。 分析目标通过给出的商品描述、商品类别和品牌信息，并结合训练数据中的商品价格来给新商品定价格。Eg ： 显然 Versace 的衣服价格上应该远高于美特斯邦威的衣服，并且在商品描述中，可以发现两者描述有细微差别。 本 project 旨在对文本信息进行分析，提取文本信息中重要信息，推导出和价格之间的潜在关系 数据字段分析 数据集 train.csv 训练集 （含price） test.csv 测试集 (不含price) ; label_test.csv 测试集 中对应的 price f_test.csv 最终的评价数据集 （不含 price ） 评价指标评价的使用的是 Mean Squared Logarithmic Error: 计算的方式如下 MSLE = \\cfrac{1}{n}\\sum_{i=1}^n(log(p_i+1)-log(\\alpha_i+1))^2其中$n$代表测试集的样本数；$p_i$代表的是预测的商品价格值；$\\alpha_i$代表实际的销售价格。 作业要求提交的最后文件内容为： 最终代码文件（请写清楚使用了那些库，以及相应库的版本，可使用 pip list 命令查看版本，确保能顺利运行） 在 f_test.csv数据集上的结果 分析文档请不要是简单的代码粘贴，加入分析过程将你对于数据的理解记录下来，简单来说，缺失值处理这种基本操作写出你的尝试的各种方法，为了解决rank太低的情况下分数太低写一份同学负责哪一部分代码，每一部分没有区别，主要是为了给代码风格打分。 提交结果文件格式 结果文件名为 提交格式 第一行为 test_id \\t price 的表头 接下来的每行为id \\t predict_price 实验过程这次实验难度很大，我们所有参考资料均在实验报告的末尾注明 一、样例代码的学习首先尝试了给出的样例代码，了解了解决这个问题的大致思路。解决这个价格预测问题的主要过程是：导入数据和数据探索、数据预处理、模型构建、价格预测和测评。 导入数据和数据探索导入数据和初步了解数据train_data = pd.read_csv(&#x27;../data/4/train.csv&#x27;, sep=&quot;\\t&quot;)test_data = pd.read_csv(&#x27;../data/4/test.csv&#x27;,sep=&#x27;\\t&#x27;)train_data.info()&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;RangeIndex: 300000 entries, 0 to 299999Data columns (total 8 columns):train_id 300000 non-null int64name 300000 non-null objectitem_condition_id 300000 non-null int64category_name 298719 non-null objectbrand_name 171929 non-null objectprice 300000 non-null float64shipping 300000 non-null int64item_description 300000 non-null objectdtypes: float64(1), int64(3), object(4)memory usage: 18.3+ MB 数据预处理首先处理属性，训练数据首先要删去price，再去掉没有用处的 train_id 或者 test_id。通过观察上面的数据属性可知 category_name 和 brand_name有数据缺失，样例代码直接用 missing填充。def featureProcessing(df): # delete the data that will not be used df = df.drop([&#x27;price&#x27;, &#x27;test_id&#x27;, &#x27;train_id&#x27;], axis=1) # deal with the missing value with a default value df[&#x27;category_name&#x27;] = df[&#x27;category_name&#x27;].fillna(&#x27;missing&#x27;).astype(str) df[&#x27;brand_name&#x27;] = df[&#x27;brand_name&#x27;].fillna(&#x27;missing&#x27;).astype(str) df[&#x27;item_description&#x27;] = df[&#x27;item_description&#x27;].fillna(&#x27;No&#x27;) # convert the data : int -&gt; str df[&#x27;shipping&#x27;] = df[&#x27;shipping&#x27;].astype(str) df[&#x27;item_condition_id&#x27;] = df[&#x27;item_condition_id&#x27;].astype(str) return df 模型构建首先做模型的输入，通过CountVectorizer 和 TfidfVectorizer生成词频的矩阵， Tfidf 的效果更优，因为考虑了各词在所有字段钟出现的次数，生成的词频矩阵是带有权重的。 vectorizer = FeatureUnion([ (&#x27;name&#x27;, CountVectorizer(ngram_range=(1, 2), max_features=50000, preprocessor=build_preprocessor_1(&#x27;name&#x27;))), (&#x27;category_name&#x27;, CountVectorizer(token_pattern=&#x27;.+&#x27;, preprocessor=build_preprocessor_1(&#x27;category_name&#x27;))), (&#x27;brand_name&#x27;, CountVectorizer(token_pattern=&#x27;.+&#x27;, preprocessor=build_preprocessor_1(&#x27;brand_name&#x27;))), (&#x27;shipping&#x27;, CountVectorizer(token_pattern=&#x27;\\d+&#x27;, preprocessor=build_preprocessor_1(&#x27;shipping&#x27;))), (&#x27;item_condition_id&#x27;, CountVectorizer(token_pattern=&#x27;\\d+&#x27;, preprocessor=build_preprocessor_1(&#x27;item_condition_id&#x27;))), (&#x27;item_description&#x27;, TfidfVectorizer(ngram_range=(1, 3),max_features=100000, preprocessor=build_preprocessor_1(&#x27;item_description&#x27;))),]) 利用岭回归，实现价格预测。def ridgeClassify(train_data, train_label): ridgeClf = Ridge( solver=&#x27;auto&#x27;, fit_intercept=True, alpha=0.5, max_iter=500, normalize=False, tol=0.05) # 训练 ridgeClf.fit(train_data, train_label) return ridgeClf通过对数据集的了解和对样例代码的学习，我们了解到优化这个问题的答案有三个角度可以入手： 数据预处理：怎样处理缺失值？数据该怎样结合？ 形成词频矩阵时进行优化：调整 CountVectorizer 和 TfidfVectorizer 的参数 模型的选择和优化：尝试岭回归之外的模型、调整模型参数。 二、尝试更多的模型在上面的样例代码中，利用岭回归模型得到的结果是3.01左右。经过之前课上的提示和网上的资料查找，我们准备再去尝试一下 MLP模型和 Lgmb模型。在粗略的尝试了两个模型之后我们决定进一步利用 MLP 进行下一步的优化。 MLPMLP 模型的结果如下： LGBMLgbm 模型的结果如下： MLP 和 LGBM 结合 特征处理 导入数据集 # 读文件 train = pd.read_csv(&#x27;data/train.csv&#x27;, sep=&#x27;\\t&#x27;) test = pd.read_csv(&#x27;data/test.csv&#x27;, sep=&#x27;\\t&#x27;) # 训练数据和测试数据一起处理 df = pd.concat([train, test], axis=0) 缺失值处理 #对缺失值进行处理 df[&#x27;category_name&#x27;] = df[&#x27;category_name&#x27;].fillna(&#x27;MISS&#x27;).astype(str) df[&#x27;brand_name&#x27;] = df[&#x27;brand_name&#x27;].fillna(&#x27;missing&#x27;).astype(str) df[&#x27;item_description&#x27;] = df[&#x27;item_description&#x27;].fillna(&#x27;No&#x27;) #数据类型处理 df[&#x27;shipping&#x27;] = df[&#x27;shipping&#x27;].astype(str) df[&#x27;item_condition_id&#x27;] = df[&#x27;item_condition_id&#x27;].astype(str) 特征向量化 使用 sklearn 库中的 CountVectorizer 类将文本特征进行向量化处理，并使用 FeatureUnion 进行特征联合 vectorizer = FeatureUnion([ (&#x27;name&#x27;, CountVectorizer( ngram_range=(1, 2), max_features=100000, preprocessor=build_preprocessor(&#x27;name&#x27;))), (&#x27;category_name&#x27;, CountVectorizer( token_pattern=&#x27;.+&#x27;, preprocessor=build_preprocessor(&#x27;category_name&#x27;))), (&#x27;brand_name&#x27;, CountVectorizer( token_pattern=&#x27;.+&#x27;, preprocessor=build_preprocessor(&#x27;brand_name&#x27;))), (&#x27;shipping&#x27;, CountVectorizer( token_pattern=&#x27;\\d+&#x27;, preprocessor=build_preprocessor(&#x27;shipping&#x27;))), (&#x27;item_condition_id&#x27;, CountVectorizer( token_pattern=&#x27;\\d+&#x27;, preprocessor=build_preprocessor(&#x27;item_condition_id&#x27;))), (&#x27;item_description&#x27;, TfidfVectorizer( ngram_range=(1, 3), max_features=200000, preprocessor=build_preprocessor(&#x27;item_description&#x27;), stop_words=&#x27;english&#x27;)), ]) 模型构建 对特征分别使用岭回归模型，Lgbm 模型和 mlp 模型进行训练，在本地测试得到的解分别为3.01，3.00，0.26 岭回归模型 def ridge_classify(train_data,train_label): #模型 model = Ridge( solver=&#x27;auto&#x27;, fit_intercept=True, alpha=0.4, max_iter=100, normalize=False, tol=0.05) #训练 model.fit(train_data, train_label) return model lgbm模型 def lgbm_classify(train_data,train_label): params = &#123; &#x27;learning_rate&#x27;: 0.75, &#x27;application&#x27;: &#x27;regression&#x27;, &#x27;max_depth&#x27;: 3, &#x27;num_leaves&#x27;: 100, &#x27;verbosity&#x27;: -1, &#x27;metric&#x27;: &#x27;RMSE&#x27;, &#125; train_X, valid_X, train_y, valid_y = train_test_split(train_data, train_label, test_size=0.1, random_state=144) d_train = lgb.Dataset(train_X, label=train_y) d_valid = lgb.Dataset(valid_X, label=valid_y) watchlist = [d_train, d_valid] model = lgb.train(params, train_set=d_train, num_boost_round=2200, valid_sets=watchlist, \\ early_stopping_rounds=50, verbose_eval=100) return model mlp 模型 MLP 模型由两个全连接层和一个dropout层组成，本质上就是一个多隐藏层的网络 def mlp_model(train_data,train_label,row_train): model = Sequential() # 全连接层 model.add(Dense(64, input_shape=(row_train,), activation=&#x27;relu&#x27;)) # DropOut层 model.add(Dropout(0.4)) # 全连接层+分类器 model.add(Dense(1, activation=&#x27;relu&#x27;)) model.compile(loss=&#x27;mean_squared_logarithmic_error&#x27;, optimizer=&#x27;adam&#x27;, metrics=[&#x27;accuracy&#x27;] ) model.fit(train_data, train_label, batch_size=300, epochs=1, ) return model.predict(X_test) 三、形成词频矩阵时进行优化在样例代码中我们尝试了将所有 CountVectorizer 替换为 TdidfVectorizer，然后利用岭模型进行预测，但是结果并没有优化很多，仅仅到2.9而已。在后面利用 MLP时完全舍弃了 CountVectorizer 只利用 TdidfVectorizer。 四、优化数据预处理过程我们对上面基本已经完善的 MLP 进行优化的方式是尝试不同特征的组合。 数据属性分析（详见Price Suggestion Challenge1.ipynb）首先对属性进行分析：item_condition_id 300000 non-null int64shipping 300000 non-null int64name 300000 non-null objectcategory_name 298719 non-null objectbrand_name 171929 non-null objectitem_description 300000 non-null objectitem_condition_id 和 shipping 直接作为输入考虑，而 name, category_name, brand_name, item_description 考虑不同的组合进行尝试。 在此之前，我们找到了一个数据可视化的实例教程，对数据的属性进行分析。通过详细观察数据得到最优的输入组合：train.head() price通过数据可视化后的观察我们得知为什么要对 price 做 log1p 处理，这样使 price 分布更优。 category_name尝试对该属性进行拆分，分成各种子类并查看相应数据。 item_description 不同的输入组合 在样例代码中只是简单地将各个属性结合在一起进行文本分析，即name + item_condition_id + category_name + brand_name + shipping + item_description（6个输入） 尝试name, item_condition_id, shipping,category_name + item_description, brand_name（5个输入） 尝试name, item_condition_id, shipping, category_name + brand_name + item_description（4个输入） 尝试name, item_condition_id, shipping, name + category_name + brand_name + item_description （4个输入） 四种组合作为输入的结果非常相近，除了组合1MSLE在0.4左右，组合2和3 在0.21 左右，组合4最终能跑到0.17左右。组合4实际上加大了name的权重，让最终结果更好。 最终源码及实验结果 数据预处理 # 数据处理# 属性共有8个，删去price，train_id对结果没有影响。def data_preprocess(df): df[&#x27;name&#x27;] = df[&#x27;name&#x27;].fillna(&#x27;&#x27;) + &#x27; &#x27; + df[&#x27;brand_name&#x27;].fillna(&#x27;&#x27;) df[&#x27;text&#x27;] = (df[&#x27;item_description&#x27;].fillna(&#x27;&#x27;) + &#x27; &#x27; + df[&#x27;name&#x27;] + &#x27; &#x27; + df[&#x27;category_name&#x27;].fillna(&#x27;&#x27;)) return df[[&#x27;name&#x27;, &#x27;text&#x27;, &#x27;shipping&#x27;, &#x27;item_condition_id&#x27;]] 构建模型 def fit_predict(xs, y_train): X_train, X_test = xs # 配置tf.Session的运算方式，比如gpu运算或者cpu运算 config = tf.ConfigProto( # 设置多个操作并行运算的线程数 intra_op_parallelism_threads=1, use_per_session_threads=1, inter_op_parallelism_threads=1) # Session提供了Operation执行和Tensor求值的环境。 with tf.Session(graph=tf.Graph(), config=config) as sess, timer(&#x27;fit_predict&#x27;): ks.backend.set_session(sess) model_in = ks.Input(shape=(X_train.shape[1],), dtype=&#x27;float32&#x27;, sparse=True) # ks.layers.Dense 表示输出空间的维度 # Dense全连接层，相当于直接添加一层 # activation 是按逐个元素计算的激活函数 out = ks.layers.Dense(192, activation=&#x27;relu&#x27;)(model_in) out = ks.layers.Dense(64, activation=&#x27;relu&#x27;)(out) out = ks.layers.Dense(64, activation=&#x27;relu&#x27;)(out) out = ks.layers.Dense(1)(out) model = ks.Model(model_in, out) model.compile(loss=&#x27;mean_squared_error&#x27;, optimizer=ks.optimizers.Adam(lr=3e-3)) for i in range(3): with timer(f&#x27;epoch &#123;i + 1&#125;&#x27;): model.fit(x=X_train, y=y_train, batch_size=2 ** (11 + i), epochs=1, verbose=0) return model.predict(X_test)[:, 0] 训练模型并预测结果 def main(): vectorizer = make_union(# 把所有的transformers组装成一个FeatureUnion. n_jobs表示可以同时进行 # FunctionTransformer 实现自定义转换，validate=False 时没有输入验证 # TfidfVectorizer函数，仅考虑按照词频排列前max_feature位的词，token_pattern=&#x27;\\w+&#x27;至少匹配一位的词 make_pipeline(FunctionTransformer(itemgetter(&#x27;name&#x27;), validate=False), TfidfVectorizer(max_features=100000, token_pattern=&#x27;\\w+&#x27;)), make_pipeline(FunctionTransformer(itemgetter(&#x27;text&#x27;), validate=False), TfidfVectorizer(max_features=100000, token_pattern=&#x27;\\w+&#x27;)), make_pipeline(FunctionTransformer(itemgetter([&#x27;shipping&#x27;, &#x27;item_condition_id&#x27;]), validate=False), FunctionTransformer(to_records, validate=False), DictVectorizer()), n_jobs=4) # StandardScaler()进行数据标准化。保存训练集中的参数（均值、方差）直接使用其对象转换测试集数据。 y_scaler = StandardScaler() # with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。 with timer(&#x27;process train&#x27;): train = pd.read_csv(&#x27;train.csv&#x27;, sep=&#x27;\\t&#x27;) test = pd.read_csv(&#x27;test.csv&#x27;, sep=&#x27;\\t&#x27;) # 删去&#x27;price&#x27;属性 train = train[train[&#x27;price&#x27;] &gt; 0].reset_index(drop=True) # 将price数据进行标准化 y_train = y_scaler.fit_transform(np.log1p(train[&#x27;price&#x27;].values.reshape(-1, 1))) X_train = vectorizer.fit_transform(data_preprocess(train)).astype(np.float32) print(f&#x27;X_train: &#123;X_train.shape&#125; of &#123;X_train.dtype&#125;&#x27;) with timer(&#x27;process valid&#x27;): X_test = vectorizer.transform(data_preprocess(test)).astype(np.float32) with ThreadPool(processes=4) as pool: Xb_train, Xb_test = [x.astype(np.bool).astype(np.float32) for x in [X_train, X_test]] xs = [[Xb_train, Xb_test], [X_train, X_test]] * 2 # 预测模型 y_pred = np.mean(pool.map(partial(fit_predict, y_train=y_train), xs), axis=0) y_pred = np.expm1(y_scaler.inverse_transform(y_pred.reshape(-1, 1))[:, 0]) # print(type(y_pred)) # 输出预测结果到csv test_id = np.array(range(0, len(y_pred))) dataframe = pd.DataFrame(&#123;&#x27;test_id&#x27;: test_id, &#x27;price&#x27;: y_pred&#125;) dataframe.to_csv(&quot;res.csv&quot;, index=False, sep=&#x27;\\t&#x27;) # print(&#x27;Valid MSLE: &#123;:.4f&#125;&#x27;.format(mean_squared_log_error(valid[&#x27;price&#x27;], y_pred))) 最终实验结果达到了0.179。 在MLP模型下的其他优化方向 可以观察到在item_desciption 的词云中，有诸如shipping 和free等词，这些词可能代表着免运费等含义，与shipping属性有一定的重复，将它作为特征词训练模型会造成干扰。 单个关键词可能包含的信息不全面，关键词之间可能有很大的关联。 在最终的模型中MLP采用了四层感知机，感知机的层数和每层的输入规模还可以做进一步调参。 实验心得这次实验的难度非常大，不知道从何入手。 在仔细研究了课程中给的样例代码和数据可视化分析的内容之后，对数据集和预测的方法都有了初步的了解。 因为对MLP，Lightgbm等模型非常不熟悉，所以从输入的角度入手，在不同属性的组合之处进行尝试，得到了最终的较为优秀的结果。 在之后的学习中应该更加深入地学习和了解模型，尽量能够自己独立完成创建模型，而不是修改其他已经写好的模型。 参考资料[1].https://ahmedbesbes.com/how-to-mine-newsfeed-data-and-extract-interactive-insights-in-python.html [2]. https://github.com/pjankiewicz/mercari-solution [3].https://www.kaggle.com/thykhuely/mercari-interactive-eda-topic-modelling [4].https://wklchris.github.io/Py3-pandas.html#%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AFdfdescribe-svalue_counts—unique [5].https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E5%99%A8 [6].https://blog.csdn.net/weixin_39807102/article/details/81912566 [7].https://github.com/maiwen/NLP [8]. https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F [9].https://blog.csdn.net/u012609509/article/details/72911564 [10]. https://www.kaggle.com/tunguz/more-effective-ridge-lgbm-script-lb-0-44823 [11]. https://qiita.com/kazuhirokomoda/items/1e9b7ebcacf264b2d814 [12]. https://www.jianshu.com/p/c532424541ad [13]. https://www.jiqizhixin.com/articles/2017-11-13-7","tags":["NLP"],"categories":["数据科学导论"]},{"title":"Linux开发环境及应用作业1","path":"/201911/Linux开发环境及应用作业 20191031/","content":"作业要求从因特网上搜索相关Web网页，处理网页html数据，从中提取出当前时间点北京各监测站的 PM2.5浓度，输出格式如下。要求：写出各个处 理步骤，并给出解释。2018-03-15 13:00:00,海淀区万柳,732018-03-15 13:00:00,昌平镇,672018-03-15 13:00:00,奥体中心,662018-03-15 14:00:00,海淀区万柳,732018-03-15 14:00:00,昌平镇,732018-03-15 14:00:00,奥体中心,75 实验过程数据搜集北京各监测站的PM2.5指数的数据来源网站：http://www.86pm25.com/city/beijing.html 数据整理及汇总先展示实现该操作的指令和最后的结果： 下面详细解释指令： 首先利用标签把数据分成单独的行，sed -e &#39;s/&lt;tr/ &lt;tr/g&#39; 其次删掉html文件中的所有标签-e &#39;s/&lt;[^&lt;&gt;]*&gt;/ /g，把所有标签都换成了空格。 我先在html文件中寻找日期和时间，发现时间的那一行有“更新”的字样，于是建立awk文件，此时发现“更新”后面中文的冒号紧跟着日期，没发把日期分离开，于是先在中文冒号后面添加空格。顺便把日期和时间的格式改成标准的输出的格式。-e &#39;s/：/： /g&#39; -e &#39;s/[年月]/-/g&#39; -e &#39;s/日//g -e &#39;s/时/:00:00/g&#39; 此时可以把时间和日期抽离出来了。在建立的awk文件中输入/更新/ &#123;data = $2; time = $3&#125; 得到日期和时间 之后，我们去找监测站和pm2.5指数，发现在这些数据最后都有$m^3$单位在，于是在awk文件中添加/m3/&#123;printf(&quot;%s %s,%s,%s &quot;,date, time, $1, $3);&#125; 最后把单位删掉，并输出到csv文件中即可。awk -f flow.awk | sed -e &#39;s/[ug/m3]//g&#39; &gt; flow.csv","tags":["文本处理"],"categories":["Linux"]},{"title":"神经网络前向传播和反向传播算法推导","path":"/201911/神经网络作业报告/","content":"一、目标 推导具有单隐层的神经网络的前向传播和反向传播算法，并进行编程（可以使用sklearn中的神经网络）。 探讨10，30，100，300，1000，不同隐藏节点数对网络性能的影响。 探讨不同学习率和迭代次数对网络性能的影响。 改变数据的标准化方法，探讨对训练的影响。 查阅资料说明什么是Hebb学习规则 二、推导单隐层神经网络的前向传播和反向传播算法参考资料：https://blog.csdn.net/Lucky_Go/article/details/89738286 三、算法实现参考资料：https://blog.csdn.net/zsx17/article/details/89342506 因为网上神经网络的代码基本都是用tensorflow实现的，这里是直接调库。在完成了作业的基本要求之后我也尝试了自己实现单隐层神经网络的代码（在实验报告的后部分）。 1. 载入数据# 1、载入数据import numpy as npimport tensorflow as tfimport tensorflow.examples.tutorials.mnist.input_data as input_data# 读取mnist数据mnist = input_data.read_data_sets(&#x27;MNIST_data/&#x27;, one_hot=True) 2. 建立模型# 2.建立模型# 2.1 构建输入层x = tf.placeholder(tf.float32, [None, 784], name=&#x27;X&#x27;)y = tf.placeholder(tf.float32, [None, 10], name=&#x27;Y&#x27;)# 2.2 构建隐藏层# 隐藏层神经元数量(随意设置）H1_NN = 256# 权重W1 = tf.Variable(tf.random_normal([784, H1_NN]))# 偏置项b1 = tf.Variable(tf.zeros([H1_NN]))Y1 = tf.nn.relu(tf.matmul(x, W1) + b1)# 2.3 构建输出层W2 = tf.Variable(tf.random_normal([H1_NN, 10]))b2 = tf.Variable(tf.zeros([10]))forward = tf.matmul(Y1, W2) + b2pred = tf.nn.softmax(forward) 3. 训练模型# 3.训练模型# 3.1 定义损失函数# tensorflow提供了下面的函数，用于避免log(0)值为Nan造成数据不稳定loss_function = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=forward, labels=y))# # 交叉熵损失函数# loss_function = tf.reduce_mean(-tf.reduce_sum(y*tf.log(pred), reduction_indices=1))# 3.2 设置训练参数train_epochs = 40 # 训练轮数batch_size = 50 # 单次训练样本数(批次大小)# 一轮训练的批次数total_batch = int(mnist.train.num_examples / batch_size)display_step = 1 # 显示粒数learning_rate = 0.01 # 学习率# 3.2 选择优化器optimizer = tf.train.AdamOptimizer(learning_rate).minimize(loss_function)# 3.3定义准确率correct_prediction = tf.equal(tf.argmax(y, 1), tf.argmax(pred, 1))accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))# 3.4 模型的训练# 记录训练开始的时间from time import timestartTime = time()sess = tf.Session()sess.run(tf.global_variables_initializer())for epoch in range(train_epochs): for batch in range(total_batch): # 读取批次训练数据 xs, ys = mnist.train.next_batch(batch_size) # 执行批次训练 sess.run(optimizer, feed_dict=&#123;x: xs, y: ys&#125;) # 在total_batch批次数据训练完成后，使用验证数据计算误差和准确率，验证集不分批 loss, acc = sess.run([loss_function, accuracy], feed_dict=&#123;x: mnist.validation.images, y: mnist.validation.labels&#125;) # 打印训练过程中的详细信息 if (epoch + 1) % display_step == 0: print(&#x27;训练轮次：&#x27;, &#x27;%02d&#x27; % (epoch + 1), &#x27;损失：&#x27;, &#x27;&#123;:.9f&#125;&#x27;.format(loss), &#x27;准确率：&#x27;, &#x27;&#123;:.4f&#125;&#x27;.format(acc))print(&#x27;训练结束&#x27;)# 显示总运行时间duration = time() - startTimeprint(&quot;总运行时间为：&quot;, &quot;&#123;:.2f&#125;&quot;.format(duration)) 4. 模型评估# 4.评估模型accu_test = sess.run(accuracy, feed_dict=&#123;x: mnist.test.images, y: mnist.test.labels&#125;)print(&#x27;测试集准确率：&#x27;, accu_test) 5. 应用模型# 5.应用模型prediction_result = sess.run(tf.argmax(pred, 1), feed_dict=&#123;x: mnist.test.images&#125;)# 查看预测结果的前10项print(&quot;前10项的结果：&quot;, prediction_result[0:10])# 5.1找出预测错误的样本compare_lists = prediction_result == np.argmax(mnist.test.labels, 1)print(compare_lists)err_lists = [i for i in range(len(compare_lists)) if compare_lists[i] == False]print(&#x27;预测错误的图片：&#x27;, err_lists)print(&#x27;预测错误图片的总数：&#x27;, len(err_lists))# 定义一个输出错误分类的函数import numpy as npdef print_predict_errs(labels, # 标签列表 prediction): # 预测值列表 count = 0 compare_lists = (prediction == np.argmax(labels, 1)) err_lists = [i for i in range(len(compare_lists)) if compare_lists[i] == False] for x in err_lists: print(&#x27;index=&#x27; + str(x) + &#x27;标签值=&#x27;, np.argmax(labels[x]), &#x27;预测值=&#x27;, prediction[x]) count = count + 1 print(&quot;总计：&quot; + str(count))print_predict_errs(labels=mnist.test.labels, prediction=prediction_result)# 可视化import matplotlib.pyplot as pltdef plot_images_labels_prediction(images, # 图像列表 labels, # 标签列表 predication, # 预测值列表 index, # 从第index个开始显示 num=10): # 缺省一次显示10幅 fig = plt.gcf() # 获取当前图表，get current figure fig.set_size_inches(10, 12) # 设为英寸，1英寸=2.53厘米 if num &gt; 25: num = 25 # 最多显示25个子图 for i in range(0, num): ax = plt.subplot(5, 5, i + 1) # 获取当前要处理的子图 # 显示第index图像 ax.imshow(np.reshape(images[index], (28, 28)), cmap=&#x27;binary&#x27;) # 构建该图上显示的title title = &#x27;label=&#x27; + str(np.argmax(labels[index])) if len(predication) &gt; 0: title += &quot;,predict=&quot; + str(predication[index]) # 显示图上的title信息 ax.set_title(title, fontsize=10) ax.set_xticks([]) # 不显示坐标轴 ax.set_yticks([]) index += 1 plt.show()plot_images_labels_prediction(mnist.test.images, mnist.test.labels, prediction_result, 10, 25)plot_images_labels_prediction(mnist.test.images, mnist.test.labels, prediction_result, 610, 20) 6. 结果展示上面的代码中隐层节点个数为256个，学习率为0.01，迭代次数为40次。训练结果如下： 部分分类图像如下所示： 四、算法调优在上面的模型中隐层结点数为256，学习率为0.01，迭代次数为40次。 下面分别从隐层节点数、学习率和迭代次数三个角度进行调优。 1. 隐层节点数将隐层节点数设为10，得到的结果如下图所示： 将隐层节点设为30，100，300，1000的效果不再具体展示，效果如下所示： 隐层节点个数 总运行时间/s 预测错误的图片数 准确率 10 46.29 736 0.9264 30 43.46 528 0.9472 100 59.06 343 0.9657 256 84.48 249 0.9751 300 76.64 269 0.9731 1000 302.27 240 0.976 由表可知，准确率随着隐层节点个数的增加而增加，增加速率逐步减少。 2. 学习率学习率分别为0.005，0.01， 0.02， 0.1，隐层节点数选择256，迭代次数选择40。分类结果如下： 学习率 总运行时间/s 预测错误的图片数 准确率 0.005 78.81 231 0.9769 0.01 84.48 249 0.9751 0.02 69.72 446 0.9554 0.1 73.87 2561 0.7439 由表可知，准确率随着学习率的增加而降低。在学习率低于0.01时，图片分类的准确率提升的速率较小。 3. 迭代次数迭代次数分别为20，40，100，隐层节点数选择256，学习率选择0.01。分类结果如下： 迭代次数 总运行时间/s 预测错误的图片数 准确率 20 37.12 307 0.9693 40 84.48 249 0.9751 100 184.39 239 0.9761 由表可知，迭代次数对总运行时间的影响率很大，准确率随着迭代次数的增加而增加，但对准确率起决定因素的还是隐层的节点个数以及学习率。 4. 改变数据标准化方法最大-最小规范化Z-score规范化五、Hebb学习规则参考资料：https://baike.baidu.com/item/Hebb%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%99/3061563?fr=aladdin Hebb学习规则是一个无监督学习规则，这种学习的结果是使网络能够提取训练集的统计特性，从而把输入信息按照它们的相似性程度划分为若干类。这一点与人类观察和认识世界的过程非常吻合，人类观察和认识世界在相当程度上就是在根据事物的统计特征进行分类。Hebb学习规则只根据神经元连接间的激活水平改变权值，因此这种方法又称为相关学习或并联学习。 无监督学习规则 唐纳德·赫布（1904-1985）是加拿大著名生理心理学家。Hebb学习规则与“条件反射”机理一致，并且已经得到了神经细胞学说的证实。 巴甫洛夫的条件反射实验：每次给狗喂食前都先响铃，时间一长，狗就会将铃声和食物联系起来。以后如果响铃但是不给食物，狗也会流口水。 受该实验的启发，Hebb的理论认为在同一时间被激发的神经元间的联系会被强化。比如，铃声响时一个神经元被激发，在同一时间食物的出现会激发附近的另一个神经元，那么这两个神经元间的联系就会强化，从而记住这两个事物之间存在着联系。相反，如果两个神经元总是不能同步激发，那么它们间的联系将会越来越弱。 Hebb学习律可表示为：$W{ij}(t+1)=W{ij}(t)+a⋅yi⋅y_j$$W{ij}(t+1)=W_{ij}(t)+a⋅y_i⋅y_j$ 其中$W{ij}$表示神经元$j$到神经元$i$的连接权，$y_i$与$y_j$表示两个神经元的输出，$a$是表示学习速率的常数，如果$y_i$与$y_j$同时被激活，即$y_i$与$y_j$同时为正，那么$W{ij}$将增大。如果$yi$被激活，而$y_j$处于抑制状态，即$y_i$为正$y_j$为负，那么$W{ij}$将变小。 六、 自己实现单隐层神经网络参考资料：https://blog.csdn.net/hellozhxy/article/details/81055391 网络结构的函数定义： def layer_sizes(X, Y): n_x = X.shape[0] # size of input layer n_h = 4 # size of hidden layer n_y = Y.shape[0] # size of output layer return (n_x, n_h, n_y) 参数初始化函数： def initialize_parameters(n_x, n_h, n_y): W1 = np.random.randn(n_h, n_x)*0.01 b1 = np.zeros((n_h, 1)) W2 = np.random.randn(n_y, n_h)*0.01 b2 = np.zeros((n_y, 1)) assert (W1.shape == (n_h, n_x)) assert (b1.shape == (n_h, 1)) assert (W2.shape == (n_y, n_h)) assert (b2.shape == (n_y, 1)) parameters = &#123;&quot;W1&quot;: W1, &quot;b1&quot;: b1, &quot;W2&quot;: W2, &quot;b2&quot;: b2&#125; return parameters 前向传播计算函数： def forward_propagation(X, parameters): # Retrieve each parameter from the dictionary &quot;parameters&quot; W1 = parameters[&#x27;W1&#x27;] b1 = parameters[&#x27;b1&#x27;] W2 = parameters[&#x27;W2&#x27;] b2 = parameters[&#x27;b2&#x27;] # Implement Forward Propagation to calculate A2 (probabilities) Z1 = np.dot(W1, X) + b1 A1 = np.tanh(Z1) Z2 = np.dot(W2, Z1) + b2 A2 = sigmoid(Z2) assert(A2.shape == (1, X.shape[1])) cache = &#123;&quot;Z1&quot;: Z1, &quot;A1&quot;: A1, &quot;Z2&quot;: Z2, &quot;A2&quot;: A2&#125; return A2, cache 计算损失函数： def compute_cost(A2, Y, parameters): m = Y.shape[1] # number of example # Compute the cross-entropy cost logprobs = np.multiply(np.log(A2),Y) + np.multiply(np.log(1-A2), 1-Y) cost = -1/m * np.sum(logprobs) cost = np.squeeze(cost) # makes sure cost is the dimension we expect. assert(isinstance(cost, float)) return cost 反向传播函数： def backward_propagation(parameters, cache, X, Y): m = X.shape[1] # First, retrieve W1 and W2 from the dictionary &quot;parameters&quot;. W1 = parameters[&#x27;W1&#x27;] W2 = parameters[&#x27;W2&#x27;] # Retrieve also A1 and A2 from dictionary &quot;cache&quot;. A1 = cache[&#x27;A1&#x27;] A2 = cache[&#x27;A2&#x27;] # Backward propagation: calculate dW1, db1, dW2, db2. dZ2 = A2-Y dW2 = 1/m * np.dot(dZ2, A1.T) db2 = 1/m * np.sum(dZ2, axis=1, keepdims=True) dZ1 = np.dot(W2.T, dZ2)*(1-np.power(A1, 2)) dW1 = 1/m * np.dot(dZ1, X.T) db1 = 1/m * np.sum(dZ1, axis=1, keepdims=True) grads = &#123;&quot;dW1&quot;: dW1, &quot;db1&quot;: db1, &quot;dW2&quot;: dW2, &quot;db2&quot;: db2&#125; return grads 权值更新函数： def update_parameters(parameters, grads, learning_rate = 1.2): # Retrieve each parameter from the dictionary &quot;parameters&quot; W1 = parameters[&#x27;W1&#x27;] b1 = parameters[&#x27;b1&#x27;] W2 = parameters[&#x27;W2&#x27;] b2 = parameters[&#x27;b2&#x27;] # Retrieve each gradient from the dictionary &quot;grads&quot; dW1 = grads[&#x27;dW1&#x27;] db1 = grads[&#x27;db1&#x27;] dW2 = grads[&#x27;dW2&#x27;] db2 = grads[&#x27;db2&#x27;] # Update rule for each parameter W1 -= dW1 * learning_rate b1 -= db1 * learning_rate W2 -= dW2 * learning_rate b2 -= db2 * learning_rate parameters = &#123;&quot;W1&quot;: W1, &quot;b1&quot;: b1, &quot;W2&quot;: W2, &quot;b2&quot;: b2&#125; return parameters 最终的神经网络模型： def nn_model(X, Y, n_h, num_iterations = 10000, print_cost=False): np.random.seed(3) n_x = layer_sizes(X, Y)[0] n_y = layer_sizes(X, Y)[2] # Initialize parameters, then retrieve W1, b1, W2, b2. Inputs: &quot;n_x, n_h, n_y&quot;. Outputs = &quot;W1, b1, W2, b2, parameters&quot;. parameters = initialize_parameters(n_x, n_h, n_y) W1 = parameters[&#x27;W1&#x27;] b1 = parameters[&#x27;b1&#x27;] W2 = parameters[&#x27;W2&#x27;] b2 = parameters[&#x27;b2&#x27;] # Loop (gradient descent) for i in range(0, num_iterations): # Forward propagation. Inputs: &quot;X, parameters&quot;. Outputs: &quot;A2, cache&quot;. A2, cache = forward_propagation(X, parameters) # Cost function. Inputs: &quot;A2, Y, parameters&quot;. Outputs: &quot;cost&quot;. cost = compute_cost(A2, Y, parameters) # Backpropagation. Inputs: &quot;parameters, cache, X, Y&quot;. Outputs: &quot;grads&quot;. grads = backward_propagation(parameters, cache, X, Y) # Gradient descent parameter update. Inputs: &quot;parameters, grads&quot;. Outputs: &quot;parameters&quot;. parameters = update_parameters(parameters, grads, learning_rate=1.2) # Print the cost every 1000 iterations if print_cost and i % 1000 == 0: print (&quot;Cost after iteration %i: %f&quot; %(i, cost)) return parameters","tags":["神经网络"],"categories":["机器学习"]},{"title":"Finds算法和ID3算法","path":"/201910/FINDS算法和ID3算法/","content":"作业要求 实现FINDS算法 实现ID3算法 不要调库自己写。如果有能力可以继续用课件里的数据集测试两个算法（用天气的4条记录测试FINDS，用贷款的15条记录测试ID3）给出训练误差测试误差等； 再有能力可以使用更大的数据集测试算法。 算法实现FINDS算法 目标：寻找极大特殊假设。 从假设集合H中最特殊的假设开始。在该假设不能正确地划分一个正例的时候将其进行一般化。算法如下： FINDS算法是一种利用more-general-than的偏序结构来搜索假设空间的方法，这一搜索沿着偏序链，从较特殊的假设逐渐演变为较一般的假设。 算法Python实现： &quot;&quot;&quot; -*- coding: utf-8 -*- Created on 2019/10/21 21:02 FINDS @Author : Zhouy @Blog : www.crocodilezs.top&quot;&quot;&quot;# create datasetdef CreateDataset(): dataset = [[&#x27;Sunny&#x27;, &#x27;Warm&#x27;, &#x27;Normal&#x27;, &#x27;Strong&#x27;, &#x27;Warm&#x27;, &#x27;Same&#x27;, &#x27;Yes&#x27;], [&#x27;Sunny&#x27;, &#x27;Warm&#x27;, &#x27;High&#x27;, &#x27;Strong&#x27;, &#x27;Warm&#x27;, &#x27;Same&#x27;, &#x27;Yes&#x27;], [&#x27;Rainy&#x27;, &#x27;Cold&#x27;, &#x27;High&#x27;, &#x27;Strong&#x27;, &#x27;Warm&#x27;, &#x27;Change&#x27;, &#x27;No&#x27;], [&#x27;Sunny&#x27;, &#x27;Warm&#x27;, &#x27;High&#x27;, &#x27;Strong&#x27;, &#x27;Cold&#x27;, &#x27;Change&#x27;, &#x27;Yes&#x27;]] labels = [&#x27;Sky&#x27;, &#x27;Temp&#x27;, &#x27;Humidity&#x27;, &#x27;Wind&#x27;, &#x27;Water&#x27;, &#x27;Forest&#x27;, &#x27;OutdoorSport&#x27;] return dataset, labels# Find one version space by using FINDS# &#x27;/&#x27; means null, and &#x27;*&#x27; means generalizationdef FINDS(dataset): constraint = [&#x27;/&#x27;, &#x27;/&#x27;, &#x27;/&#x27;, &#x27;/&#x27;, &#x27;/&#x27;, &#x27;/&#x27;] for item in dataset: if item[-1] == &#x27;Yes&#x27;: # only go through positive instances for i in range(len(item)-1): if(item[i] != constraint[i] and constraint[i] != &#x27;*&#x27;): if(constraint[i] == &#x27;/&#x27;): constraint[i] = item[i] else: constraint[i] = &#x27;*&#x27; return constraintdef main(): dataset, labels = CreateDataset() constraint = FINDS(dataset) print(constraint)if __name__ == &quot;__main__&quot;: main() ID3算法 决策树：决策树是一种常用的分类与回归方法。决策树的模型为树形结构，在针对分类问题时，实际上就是针对输入数据的各个特征对实例进行分类的过程，即通过树形结构的模型，在每一层级上对特征值进行判断，进而到达决策树叶子节点，即完成分类过程。决策树的本质是概念学习。 信息熵（香浓熵）、条件熵和信息增益的概念 信息量：一件事发生的概率越小，我们说它所蕴含的信息量越大。 信息熵：信息熵就是所有可能发生的事件的信息量的期望 条件熵：表示在X给定条件下，Y的条件概率分布的熵对X的数学期望。![条件熵(https://s2.ax1x.com/2019/10/22/K36FBj.jpg) 信息增益：当我们用另一个变量X对原变量Y分类后，原变量Y的不确定性就会减小了(即熵值减小)。而熵就是不确定性，不确定程度减少了多少其实就是信息增益。这就是信息增益的由来，所以信息增益定义如下： 算法’python’实现:(用课件上的贷款数据集一直没法成功分类，于是参考了csdn博客的另一个数据集合代码) myTrees.py &quot;&quot;&quot; -*- coding: utf-8 -*- Created on 2019/10/22 11:59 myTrees @Author : Zhouy @Blog : www.crocodilezs.top&quot;&quot;&quot;from math import logimport operator# 原始数据def createDataSet(): dataSet = [[1, 1, &#x27;yes&#x27;], [1, 1, &#x27;yes&#x27;], [1, 0, &#x27;no&#x27;], [0, 1, &#x27;no&#x27;], [0, 1, &#x27;no&#x27;]] labels = [&#x27;no surfacing&#x27;,&#x27;flippers&#x27;] return dataSet, labels# 多数表决器# 列中相同值数量最多为结果def majorityCnt(classList): classCounts = &#123;&#125; for value in classList: if (value not in classCounts.keys()): classCounts[value] = 0 classCounts[value] += 1 sortedClassCount = sorted(classCounts.iteritems(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0]# 划分数据集# dataSet:原始数据集# axis:进行分割的指定列索引# value:指定列中的值def splitDataSet(dataSet, axis, value): retDataSet = [] for featDataVal in dataSet: if featDataVal[axis] == value: # 下面两行去除某一项指定列的值，很巧妙有没有 reducedFeatVal = featDataVal[:axis] reducedFeatVal.extend(featDataVal[axis + 1:]) retDataSet.append(reducedFeatVal) return retDataSet# 计算香农熵def calcShannonEnt(dataSet): # 数据集总项数 numEntries = len(dataSet) # 标签计数对象初始化 labelCounts = &#123;&#125; for featDataVal in dataSet: # 获取数据集每一项的最后一列的标签值 currentLabel = featDataVal[-1] # 如果当前标签不在标签存储对象里，则初始化，然后计数 if currentLabel not in labelCounts.keys(): labelCounts[currentLabel] = 0 labelCounts[currentLabel] += 1 # 熵初始化 shannonEnt = 0.0 # 遍历标签对象，求概率，计算熵 for key in labelCounts.keys(): prop = labelCounts[key] / float(numEntries) shannonEnt -= prop * log(prop, 2) return shannonEnt# 选出最优特征列索引def chooseBestFeatureToSplit(dataSet): # 计算特征个数，dataSet最后一列是标签属性，不是特征量 numFeatures = len(dataSet[0]) - 1 # 计算初始数据香农熵 baseEntropy = calcShannonEnt(dataSet) # 初始化信息增益，最优划分特征列索引 bestInfoGain = 0.0 bestFeatureIndex = -1 for i in range(numFeatures): # 获取每一列数据 featList = [example[i] for example in dataSet] # 将每一列数据去重 uniqueVals = set(featList) newEntropy = 0.0 for value in uniqueVals: subDataSet = splitDataSet(dataSet, i, value) # 计算条件概率 prob = len(subDataSet) / float(len(dataSet)) # 计算条件熵 newEntropy += prob * calcShannonEnt(subDataSet) # 计算信息增益 infoGain = baseEntropy - newEntropy if (infoGain &gt; bestInfoGain): bestInfoGain = infoGain bestFeatureIndex = i return bestFeatureIndex# 决策树创建def createTree(dataSet, labels): # 获取标签属性，dataSet最后一列，区别于labels标签名称 classList = [example[-1] for example in dataSet] # 树极端终止条件判断 # 标签属性值全部相同，返回标签属性第一项值 if classList.count(classList[0]) == len(classList): return classList[0] # 只有一个特征（1列） if len(dataSet[0]) == 1: return majorityCnt(classList) # 获取最优特征列索引 bestFeatureIndex = chooseBestFeatureToSplit(dataSet) # 获取最优索引对应的标签名称 bestFeatureLabel = labels[bestFeatureIndex] # 创建根节点 myTree = &#123;bestFeatureLabel: &#123;&#125;&#125; # 去除最优索引对应的标签名，使labels标签能正确遍历 del (labels[bestFeatureIndex]) # 获取最优列 bestFeature = [example[bestFeatureIndex] for example in dataSet] uniquesVals = set(bestFeature) for value in uniquesVals: # 子标签名称集合 subLabels = labels[:] # 递归 myTree[bestFeatureLabel][value] = createTree(splitDataSet(dataSet, bestFeatureIndex, value), subLabels) return myTree# 获取分类结果# inputTree:决策树字典# featLabels:标签列表# testVec:测试向量 例如：简单实例下某一路径 [1,1] =&gt; yes（树干值组合，从根结点到叶子节点）def classify(inputTree, featLabels, testVec): # 获取根结点名称，将dict转化为list firstSide = list(inputTree.keys()) # 根结点名称String类型 firstStr = firstSide[0] # 获取根结点对应的子节点 secondDict = inputTree[firstStr] # 获取根结点名称在标签列表中对应的索引 featIndex = featLabels.index(firstStr) # 由索引获取向量表中的对应值 key = testVec[featIndex] # 获取树干向量后的对象 valueOfFeat = secondDict[key] # 判断是子结点还是叶子节点：子结点就回调分类函数，叶子结点就是分类结果 # if type(valueOfFeat).__name__==&#x27;dict&#x27;: 等价 if isinstance(valueOfFeat, dict): if isinstance(valueOfFeat, dict): classLabel = classify(valueOfFeat, featLabels, testVec) else: classLabel = valueOfFeat return classLabel# 将决策树分类器存储在磁盘中，filename一般保存为txt格式def storeTree(inputTree, filename): import pickle fw = open(filename, &#x27;wb+&#x27;) pickle.dump(inputTree, fw) fw.close()# 将瓷盘中的对象加载出来，这里的filename就是上面函数中的txt文件def grabTree(filename): import pickle fr = open(filename, &#x27;rb&#x27;) return pickle.load(fr) treePlotter.py &quot;&quot;&quot; -*- coding: utf-8 -*- Created on 2019/10/22 12:00 treePlotter @Author : Zhouy @Blog : www.crocodilezs.top&quot;&quot;&quot;import matplotlib.pyplot as pltdecisionNode = dict(boxstyle=&quot;sawtooth&quot;, fc=&quot;0.8&quot;)leafNode = dict(boxstyle=&quot;round4&quot;, fc=&quot;0.8&quot;)arrow_args = dict(arrowstyle=&quot;&lt;-&quot;)# 获取树的叶子节点def getNumLeafs(myTree): numLeafs = 0 # dict转化为list firstSides = list(myTree.keys()) firstStr = firstSides[0] secondDict = myTree[firstStr] for key in secondDict.keys(): # 判断是否是叶子节点（通过类型判断，子类不存在，则类型为str；子类存在，则为dict） if type(secondDict[ key]).__name__ == &#x27;dict&#x27;: # test to see if the nodes are dictonaires, if not they are leaf nodes numLeafs += getNumLeafs(secondDict[key]) else: numLeafs += 1 return numLeafs# 获取树的层数def getTreeDepth(myTree): maxDepth = 0 # dict转化为list firstSides = list(myTree.keys()) firstStr = firstSides[0] secondDict = myTree[firstStr] for key in secondDict.keys(): if type(secondDict[ key]).__name__ == &#x27;dict&#x27;: # test to see if the nodes are dictonaires, if not they are leaf nodes thisDepth = 1 + getTreeDepth(secondDict[key]) else: thisDepth = 1 if thisDepth &gt; maxDepth: maxDepth = thisDepth return maxDepthdef plotNode(nodeTxt, centerPt, parentPt, nodeType): createPlot.ax1.annotate(nodeTxt, xy=parentPt, xycoords=&#x27;axes fraction&#x27;, xytext=centerPt, textcoords=&#x27;axes fraction&#x27;, va=&quot;center&quot;, ha=&quot;center&quot;, bbox=nodeType, arrowprops=arrow_args)def plotMidText(cntrPt, parentPt, txtString): xMid = (parentPt[0] - cntrPt[0]) / 2.0 + cntrPt[0] yMid = (parentPt[1] - cntrPt[1]) / 2.0 + cntrPt[1] createPlot.ax1.text(xMid, yMid, txtString, va=&quot;center&quot;, ha=&quot;center&quot;, rotation=30)def plotTree(myTree, parentPt, nodeTxt): # if the first key tells you what feat was split on numLeafs = getNumLeafs(myTree) # this determines the x width of this tree depth = getTreeDepth(myTree) firstSides = list(myTree.keys()) firstStr = firstSides[0] # the text label for this node should be this cntrPt = (plotTree.xOff + (1.0 + float(numLeafs)) / 2.0 / plotTree.totalW, plotTree.yOff) plotMidText(cntrPt, parentPt, nodeTxt) plotNode(firstStr, cntrPt, parentPt, decisionNode) secondDict = myTree[firstStr] plotTree.yOff = plotTree.yOff - 1.0 / plotTree.totalD for key in secondDict.keys(): if type(secondDict[ key]).__name__ == &#x27;dict&#x27;: # test to see if the nodes are dictonaires, if not they are leaf nodes plotTree(secondDict[key], cntrPt, str(key)) # recursion else: # it&#x27;s a leaf node print the leaf node plotTree.xOff = plotTree.xOff + 1.0 / plotTree.totalW plotNode(secondDict[key], (plotTree.xOff, plotTree.yOff), cntrPt, leafNode) plotMidText((plotTree.xOff, plotTree.yOff), cntrPt, str(key)) plotTree.yOff = plotTree.yOff + 1.0 / plotTree.totalD# if you do get a dictonary you know it&#x27;s a tree, and the first element will be another dict# 绘制决策树def createPlot(inTree): fig = plt.figure(1, facecolor=&#x27;white&#x27;) fig.clf() axprops = dict(xticks=[], yticks=[]) createPlot.ax1 = plt.subplot(111, frameon=False, **axprops) # no ticks # createPlot.ax1 = plt.subplot(111, frameon=False) #ticks for demo puropses plotTree.totalW = float(getNumLeafs(inTree)) plotTree.totalD = float(getTreeDepth(inTree)) plotTree.xOff = -0.5 / plotTree.totalW plotTree.yOff = 1.0 plotTree(inTree, (0.5, 1.0), &#x27;&#x27;) plt.show()# 绘制树的根节点和叶子节点（根节点形状：长方形，叶子节点：椭圆形）# def createPlot():# fig = plt.figure(1, facecolor=&#x27;white&#x27;)# fig.clf()# createPlot.ax1 = plt.subplot(111, frameon=False) #ticks for demo puropses# plotNode(&#x27;a decision node&#x27;, (0.5, 0.1), (0.1, 0.5), decisionNode)# plotNode(&#x27;a leaf node&#x27;, (0.8, 0.1), (0.3, 0.8), leafNode)# plt.show()def retrieveTree(i): listOfTrees = [&#123;&#x27;no surfacing&#x27;: &#123;0: &#x27;no&#x27;, 1: &#123;&#x27;flippers&#x27;: &#123;0: &#x27;no&#x27;, 1: &#x27;yes&#x27;&#125;&#125;&#125;&#125;, &#123;&#x27;no surfacing&#x27;: &#123;0: &#x27;no&#x27;, 1: &#123;&#x27;flippers&#x27;: &#123;0: &#123;&#x27;head&#x27;: &#123;0: &#x27;no&#x27;, 1: &#x27;yes&#x27;&#125;&#125;, 1: &#x27;no&#x27;&#125;&#125;&#125;&#125; ] return listOfTrees[i]# thisTree = retrieveTree(0)# createPlot(thisTree)# createPlot()# myTree = retrieveTree(0)# numLeafs =getNumLeafs(myTree)# treeDepth =getTreeDepth(myTree)# print(u&quot;叶子节点数目：%d&quot;% numLeafs)# print(u&quot;树深度：%d&quot;%treeDepth) testTrees_3.py &quot;&quot;&quot; -*- coding: utf-8 -*- Created on 2019/10/22 12:00 testTrees_3 @Author : Zhouy @Blog : www.crocodilezs.top&quot;&quot;&quot;import myTrees as mtimport treePlotter as tp#测试dataSet, labels = mt.createDataSet()#copy函数：新开辟一块内存，然后将list的所有值复制到新开辟的内存中labels1 = labels.copy()#createTree函数中将labels1的值改变了，所以在分类测试时不能用labels1myTree = mt.createTree(dataSet,labels1)#保存树到本地mt.storeTree(myTree,&#x27;myTree.txt&#x27;)#在本地磁盘获取树myTree = mt.grabTree(&#x27;myTree.txt&#x27;)print (u&quot;决策树结构：%s&quot;%myTree)#绘制决策树print(u&quot;绘制决策树：&quot;)tp.createPlot(myTree)numLeafs =tp.getNumLeafs(myTree)treeDepth =tp.getTreeDepth(myTree)print(u&quot;叶子节点数目：%d&quot;% numLeafs)print(u&quot;树深度：%d&quot;%treeDepth)#测试分类 简单样本数据3列labelResult =mt.classify(myTree,labels,[1,1])print(u&quot;[1,1] 测试结果为：%s&quot;%labelResult)labelResult =mt.classify(myTree,labels,[1,0])print(u&quot;[1,0] 测试结果为：%s&quot;%labelResult)","tags":["FindS","ID3"],"categories":["机器学习"]},{"title":"计算机系统基础实验一、Linux环境和GCC工具链","path":"/201910/计算机系统基础实验一/","content":"Linux操作系统概述和实验环境介绍操作系统概念OS是管理和控制计算机硬件与软件资源的计算机程序，是直接在“裸机”上的最基本的系统软件。 Linux的应用 服务器端：Linux非常稳定，特别适合大型企业生产环境。 作为网络平台的后端服务器被使用。 作为应用服务器、数据库服务器被使用：解决海量数据、高并发的问题； 作为嵌入式操作系统被使用：智能控制、自动化、物联网等领域。 Linux历史追溯到UNIX简单地说，Linux是对UNIX的重新实现。世界各地的Linux开发人员借鉴了UNIX的技术和用户界面，并且融入了很多独创的技术。Linux不属于BSD和AT&amp;T风格的UNIX中的任何一种。因此，严格来说，Linux是有别于UNIX的另一种操作系统。 Linux简介Linux发现行版本举例：Ubuntu、redhat 操作系统的三个部分内核操作系统五大管理功能一般都由操作系统内核负责。 外壳 外壳程序负责接收用户操作，提供与 用户的交互界面。 一般操作系统提供给用户的界面主要有两种：文本界面、GUI图形界面。管理工具和附属软件 操作系统的功能 CPU的控制与管理：处理器管理 内存的分配与管理：存储器管理 外部设备的控制与管理：设备管理 文件管理 作业管理和控制：用户接口 Shell 外壳程序对用户的输入命令进行解释，为用户提供一种通过操作系统使用计算机的操作环境。 Windows的图形界面，由一个成为Explorer的模块解释用户的输入。 如DOS的命令行界面，Command.com是对命令输入进行解释的外壳程序(Linux的Shell) Shell命令：从命令行输入语句，每输入一次就能得到一次响应，这些语句就是shell命令。 Shell程序：又称Shell脚本。（把一系列的shell命令，按照一定的语法规则和控制结构，组织在一个文件中，然后由内核来一条接一条地解释和执行这些命令，这个文件就是shell程序，类似DOS/Winsows中的。bat批处理文件。） [username@computername ~]$user name为当前用户名，computername 为当前计算机名 ，$表示当前用户是一般用户。 ssh secure shell把Linux终端搬到Windows下，连接到BUPT1.Shell常用命令目录操作命令目录操作命令能够对当前的目录进行查看、创建、删除，以及显示当前工作目录和改变当前目录等操作。 1. /etc - 系统所需的重要配置和管理文件 2. /dev - 存放device file（装置文件） 3. /boot - 存放系统激活的相关文件，不可任意删除。 4. /home - 登陆用户的主目录 5. /lib - 存放系统激活时需要的系统函数库 6. /usr/lib - 存放一些应用程序的共享函数库 7. /mnt - 系统默认的挂载点(mount point) 8. /proc - 虚拟文件系统，不占用硬盘空间，目录下的文件均放置于内存中 9. /root - 系统管理用户root的主目录 10. /bin - 存放一些系统启动时所需的普通程序和系统程序 11. /tmp - 存放临时文件 12. /var - 存放被系统修改过的数据。 常用的目录操作命令包括： pwd 打印当前工作目录 cd 改变当前所在目录 ls 查看当前目录下的内容 dir 类似ls命令 mkdir 创建目录 rmdir 删除空目录 文件操作命令 在命令行环境下对文件进行操作将比在图形环境下操作文件更加快捷和高效 文件操作主要包括：搜索文件、复制和移动文件、删除文件以及合并文件内容 常用文件操作命令： cat more less head tail cp mv rm find touch ln 使用帮助命令 man 命令名 whatis 命令名 help 命令名：适用于部分命令 Vi编辑器Vi简介 Vi编辑器是Visual interface的简称，它可以执行输出、删除、查找、替换、块操作等众多文本操作 Vi不是一个排版程序，只是一个文本编辑程序。 是全屏幕文本编辑器，没有菜单，只有命令。 Vi的基本概念 命令行模式（command mode）控制屏幕光标的移动、字符、字或行的删除、移动复制某区段及进入Insert mode下，或者到last line mode。 插入模式（Insert mode）只有在Insert mode下，才可以做文字输入，按ESC键可回到命令行模式。 底行模式(last line mode)将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号。 $ vi test.txt 即可进入vi（打开或新建文件） 操作： 命令行模式 —-&gt;(i) 插入模式 插入模式 —-&gt;（ESC） 命令行模式 如果处于「插入模式」，就只能一直输入文字，如果发现输错了字想用光标往回移动将该字删除，就得先回到「命令行模式」 在「命令行模式」下，按下：进入底行模式: w filename: wq: q! GCC工具链简介 GCC编译器能将C和C++语言源程序、汇编程序编译、链接成可执行文件。 使用GCC编译器时，编译过程可以被细分为四个阶段： 预处理(Pre-Processing) 编译(Compiling) 汇编(Assembling) 链接(Linking) GDB的概述GDB是一款GNU开发组织并发布的UNIX/Linux下的程序调试工具。它使你能够在程序运行时观察程序的内部结构和内存的使用情况。以下是GDB提供的一些功能： 监视程序中变量的值 设置断点以使程序在指定的代码行上停止运行 能逐行执行代码 Objdump简介Objdump是以一种可阅读的格式让你更多地了解二进制文件可能带有地附加信息。对于想进一步了解系统地程序员，这个命令没有没有更多意义，对于想进一步了解系统的程序员，应该掌握这种工具，至少你可以自己写写shellcode了，或者看看人家给的exploit中的shellcode是什么东西。把C语言源代码编译链接生成的可执行程序反汇编后得到对应的汇编代码，可以帮助我们理解C语言和汇编语言之间的对应关系。非常有助于深入理解C语言 至此，已经完成了计算机系统基础第一次实验的理论部分，其中有太多的东西还需要自己去实践、接下来开始实验！","categories":["计算机系统基础"]},{"title":"KNN与Naive_Bayes代码实现","path":"/201911/KNN与Naive_Bayes代码实现/","content":"任务要求采用Python实现分类算法： 不得借助现成的工具包调库，例如SKlearn 至少实现k-近邻，朴素贝叶斯，逻辑回归，决策树与支持向量机中的其中一个算法。k-临近，朴素贝叶斯相对较简单，逻辑回归，决策树与支持向量机相对较难。 对breast cancer数据集调用编写的函数进行分类演示。 能力强的可以多实现几种算法 算法实现——kNN利用breast_cancer中的数据，实现kNN算法。 导入数据集，并分为训练集和测试集 实现kNN算法 对每一个测试集中的实例，计算它距离训练集中的点的距离 根据选定的k值，选择距离最近的k个点数量更多的“标签” 算法效果测试，测试算法的精确度，和SKlearn提供的kNN算法进行比较。 源码导入数据# 导入数据集from sklearn import datasetsfrom sklearn.model_selection import train_test_splitfrom sklearn import neighborsdatasets = datasets.load_breast_cancer()X = datasets.data;y = datasets.target;X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.3, random_state = 0)k = 5# print(datasets.DESCR)# malignant - 0, benign - 1y_predict = [] kNN算法实现def knn(X_train, y_train, X_test, y_predict): &#x27;&#x27;&#x27; 对测试集的数据进行预测，得到的结果与y_test比较。用欧式距离进行计算。 &#x27;&#x27;&#x27; for test_data in X_test: first_k_instance = [] for i in range(len(X_train)): distance = 0; for attributes_no in range(len(X_train[0])): distance += (test_data[attributes_no] - X_train[i][attributes_no]) ** 2 Euclid_distance = distance ** 0.5 #print(Euclid_distance) if i &lt; k: first_k_instance.append((i, Euclid_distance)) elif Euclid_distance &lt; first_k_instance[k-1][1]: first_k_instance[k-1] = (i, Euclid_distance) first_k_instance = sorted(first_k_instance, key = lambda x:x[1]) #print(first_k_instance) # 现在得到了距离测试点最近的k个点，用多数表决器来判断测试点是良性还是恶性 benign = 0 malignant = 0 for instance in first_k_instance: if y_train[instance[0]] == 0: malignant += 1 else: benign += 1 if malignant &gt;= benign: y_predict.append(0) else: y_predict.append(1) 精确度计算函数def accuracy(y_predict, y_test): correct = 0 for i in range(len(y_predict)): if y_predict[i] == y_test[i]: correct += 1 accuracy_rate = correct / len(y_predict) return correct, accuracy_rate 主函数def main(): knn(X_train, y_train, X_test, y_predict) correct, accuracy_rate = accuracy(y_predict, y_test) print(y_predict) print(&quot;kNN模型测试集预测的准确率为：%.3f&quot; % accuracy_rate); KNN = neighbors.KNeighborsClassifier(n_neighbors = 5) KNN.fit(X_train, y_train) print(&quot;sklearn库中kNN模型预测的准确率为：%.3f&quot; % KNN.score(X_test, y_test)); if __name__ == &#x27;__main__&#x27;: main() [0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1] kNN模型测试集预测的准确率为：0.947 sklearn库中kNN模型预测的准确率为：0.947 通过实验结果可以发现，我们实现的kNN与SKlearn中提供的kNN效果一致。我们可以通过设置k的值和转换寻找相似样本的策略（将欧式距离替换为匹配系数或Jaccard等），进一步优化精确度。 算法实现——Naive_Bayes利用breast_cancer中的数据，实现Naive_Bayes算法。 导入数据集，并分为训练集和测试集 实现Naive Bayes算法 把连续的属性划分区间，计算正例和反例落在每个属性的每个区间的个数 计算概率值，预测测试集的标签 算法效果测试，测试算法的精确度，和SKlearn提供的Naive Bayes算法进行比较。 源码导入数据# load datasetsfrom sklearn import datasetsfrom sklearn.model_selection import train_test_splitfrom sklearn import naive_bayesdatasets = datasets.load_breast_cancer()X = datasets.data;y = datasets.target;X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.3, random_state = 0)#print(datasets.DESCR)#malignant - 0, benign - 1y_predict = [] 由于30个属性全部都是连续值，我们使用朴素贝叶斯的时候需要将属性的值的范围分为几个区间，计算实例落在该区间的概率。这里每个属性我都以平均值作为间隔来划分区间。 对每个连续的属性划分区间并统计个数def distribution(X_train, y_train): &#x27;&#x27;&#x27; 先把区间分好，然后再计算概率。 &#x27;&#x27;&#x27; #===============区间划分====================# attributes_max_min_mean = [] # 记录所有属性的最大值、最小值和平均值 for i in range(len(X_train[0])): #属性循环 #section = [max, min, mean] section = [X_train[0][i], X_train[0][i], 0] for instance in X_train: #训练样例循环 if instance[i] &gt; section[0]: section[0] = instance[i] if instance[i] &lt; section[1]: section[1] = instance[i] section[2] += instance[i] section[2] /= len(X_train) attributes_max_min_mean.append(section) #=========计算每个属性落在每个区间的样例个数=========# instance_distribution = [] for i in range(len(X_train[0])): #属性循环 smaller_benign = 0 larger_benign = 0 smaller_malignant = 0 larger_malignant = 0 for j in range(len(X_train)): #训练样例循环 if X_train[j][i] &gt; attributes_max_min_mean[i][2]: if y_train[j] == 1: larger_benign += 1 else: larger_malignant +=1 elif y_train[j] == 1: smaller_benign += 1 else: smaller_malignant += 1 instance_distribution.append([smaller_benign, larger_benign, smaller_malignant, larger_malignant]) return instance_distribution, attributes_max_min_mean 实现朴素贝叶斯def Naive_Bayes(X_test, y_predict, instance_distribution,attributes_max_min_mean): for test_data in X_test: #测试样例循环 #训练集中良性和恶性肿瘤的数量 malignant = instance_distribution[0][2] + instance_distribution[0][3] benign = instance_distribution[0][0] + instance_distribution[0][1] #概率初始化，下面计算每个属性的概率 p_xc0 = 1 p_xc1 = 1 for i in range(len(X_train[0])): # 属性循环 if test_data[i] &gt; attributes_max_min_mean[i][2]: p_xc0 *= instance_distribution[i][3] / malignant p_xc1 *= instance_distribution[i][1] / benign else: p_xc0 *= instance_distribution[i][2] / malignant p_xc1 *= instance_distribution[i][0] / benign p0 = p_xc0 * malignant / (malignant + benign) p1 = p_xc1 * benign / (malignant + benign) if p0 &gt; p1: y_predict.append(0) else: y_predict.append(1) 计算精确度def accuracy(y_predict, y_test): correct = 0 for i in range(len(y_predict)): if y_predict[i] == y_test[i]: correct += 1 accuracy_rate = correct / len(y_predict) return correct, accuracy_rate 主函数def main(): instance_distribution, attributes_max_min_mean = distribution(X_train, y_train) Naive_Bayes(X_test, y_predict, instance_distribution, attributes_max_min_mean) correct, accuracy_rate = accuracy(y_predict, y_test) print(y_predict) print(&quot;Naive Bayes模型测试集预测的准确率为：%.3f&quot; % accuracy_rate); bayes = naive_bayes.GaussianNB() bayes.fit(X_train, y_train) print(&quot;sklearn库中Naive Bayes模型预测的准确率为：%.3f&quot; % bayes.score(X_test, y_test)); if __name__ == &#x27;__main__&#x27;: main() [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1] Naive Bayes模型测试集预测的准确率为：0.930 sklearn库中Naive Bayes模型预测的准确率为：0.924 通过实验结果可以发现，我们实现的朴素贝叶斯比SKlearn提供的朴素贝叶斯效果更好。我们可以通过尝试各属性不同的区间划分，进一步优化精确度。而SKlearn提供的朴素贝叶斯效果不好的原因可能就是将连续值转换为离散值的区间划分没有做好。","categories":["数据科学导论"]},{"title":"Fisher算法&SVM&K-Means及其优化","path":"/201911/Fisher算法&SVM&K-Means及其优化/","content":"fisher算法及其实现 请实现fisher算法，并采用自己随机生成2类数据（每类100个）的方式，验证自己的算法。参考资料:https://blog.csdn.net/pengjian444/article/details/71138003 数据生成from sklearn.datasets import make_multilabel_classificationimport numpy as npx, y = make_multilabel_classification(n_samples=200, n_features=2, n_labels=1, n_classes=1, random_state=2)# 根据类别分类index1 = np.array([index for (index, value) in enumerate(y) if value == 0]) # 获取类别1的indexsindex2 = np.array([index for (index, value) in enumerate(y) if value == 1]) # 获取类别2的indexsc_1 = x[index1] # 类别1的所有数据(x1, x2) in X_1c_2 = x[index2] # 类别2的所有数据(x1, x2) in X_2 make_multilabel_classification方法参数说明n_samples:样本的数量。n_features：样本的特征，这里是在二维平面中的点，所以为2.n_labels：每个实例的平均标签数。n_classes：分类问题的分类数。random_state：设置随机数种子，保证每次产生相同的数据。 enumerate()函数说明enumerate()函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 fisher算法实现def cal_cov_and_avg(samples): u1 = np.mean(samples, axis=0) cov_m = np.zeros((samples.shape[1], samples.shape[1])) for s in samples: t = s - u1 cov_m += t * t.reshape(2, 1) return cov_m, u1def fisher(c_1, c_2): cov_1, u1 = cal_cov_and_avg(c_1) cov_2, u2 = cal_cov_and_avg(c_2) s_w = cov_1 + cov_2 u, s, v = np.linalg.svd(s_w) # 奇异值分解 s_w_inv = np.dot(np.dot(v.T, np.linalg.inv(np.diag(s))), u.T) return np.dot(s_w_inv, u1 - u2) np.mean：计算制定轴上的平均值。np.zeros：给定形状和类型确定的数组，并用0填充。 判定类别def judge(sample, w, c_1, c_2): u1 = np.mean(c_1, axis=0) u2 = np.mean(c_2, axis=0) center_1 = np.dot(w.T, u1) center_2 = np.dot(w.T, u2) pos = np.dot(w.T, sample) return abs(pos - center_1) &lt; abs(pos - center_2)w = fisher(c_1, c_2) # 调用函数，得到参数wout = judge(c_1[1], w, c_1, c_2) # 判断所属的类别# print(out) 绘图import matplotlib.pyplot as pltplt.scatter(c_1[:, 0], c_1[:, 1], c=&#x27;#99CC99&#x27;)plt.scatter(c_2[:, 0], c_2[:, 1], c=&#x27;#FFCC00&#x27;)line_x = np.arange(min(np.min(c_1[:, 0]), np.min(c_2[:, 0])), max(np.max(c_1[:, 0]), np.max(c_2[:, 0])), step=1)line_y = - (w[0] * line_x) / w[1]plt.plot(line_x, line_y)plt.show() &lt;Figure size 640x480 with 1 Axes&gt; SVM优化对偶问题的详细推导过程 请给出SVM优化对偶问题的详细推导过程；并给出只有2维特征情况下的，对偶问题的优化求解过程（可以采用lagrange方法，也可以采用其他方法。）参考资料：https://zhuanlan.zhihu.com/p/49331510 SVM算法的实现 请实现SVM算法；并采用自己随机生成2类线性可分数据（每类100个）的方式验证自己的算法。参考资料：https://www.jb51.net/article/131580.htm from sklearn import svm import numpy as np import matplotlib.pyplot as plt np.random.seed(0) x = np.r_[np.random.randn(100,2)-[2,2],np.random.randn(100,2)+[2,2]] #正态分布来产生数字,20行2列*2 y = [0]*100+[1]*100 #100个class0，100个class1 clf = svm.SVC(kernel=&#x27;linear&#x27;) clf.fit(x,y) w = clf.coef_[0] #获取w a = -w[0]/w[1] #斜率 #画图划线 xx = np.linspace(-5,5) #(-5,5)之间x的值 yy = a*xx-(clf.intercept_[0])/w[1] #xx带入y，截距 #画出与点相切的线 b = clf.support_vectors_[0] yy_down = a*xx+(b[1]-a*b[0]) b = clf.support_vectors_[-1] yy_up = a*xx+(b[1]-a*b[0]) print(&quot;W:&quot;,w) print(&quot;a:&quot;,a) print(&quot;support_vectors_:&quot;,clf.support_vectors_) print(&quot;clf.coef_:&quot;,clf.coef_) plt.figure(figsize=(8,4)) plt.plot(xx,yy) plt.plot(xx,yy_down) plt.plot(xx,yy_up) plt.scatter(clf.support_vectors_[:,0],clf.support_vectors_[:,1],s=80) plt.scatter(x[:,0],x[:,1],c=y,cmap=plt.cm.Paired) #[:，0]列切片，第0列 plt.axis(&#x27;tight&#x27;) plt.show() W: [0.95070185 1.15607502] a: -0.8223530762163854 support_vectors_: [[-0.51174781 -0.10411082] [ 0.16323595 -0.66347205] [ 2.39904635 -0.77259276] [ 0.66574153 0.65328249] [-0.25556423 0.97749316]] clf.coef_: [[0.95070185 1.15607502]] k-means算法的实现 请实现k-means的算法；并采用自己随机生成3类数据（每类100个）的方式，验证自己的算法。参考资料1:https://cloud.tencent.com/developer/article/1465020参考资料2:https://blog.csdn.net/weixin_42029738/article/details/81978038 &#x27;&#x27;&#x27; K-Means clustering algorithms&#x27;&#x27;&#x27;print(__doc__)import timeimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.cluster import MiniBatchKMeans, KMeansfrom sklearn.metrics.pairwise import pairwise_distances_argminfrom sklearn.datasets.samples_generator import make_blobs# ############################################################################## Generate sample datanp.random.seed(0)batch_size = 45centers = [[1, 1], [-1, -1], [1, -1]] # 初始化3个中心n_clusters = len(centers) # 聚类的数目为3# 产生10000组二维数据，以上面三个点为中心，以(-10,10)为边界，数据集的标准差是0.7X, labels_true = make_blobs(n_samples=10000, centers=centers, cluster_std=0.7)# ############################################################################## Compute clustering with Meansk_means = KMeans(init=&#x27;k-means++&#x27;, n_clusters=3, n_init=10)t0 = time.time()k_means.fit(X)# 使用k-means对300组数据集训练算法的时间消耗t_batch = time.time() - t0# ############################################################################## Plot resultfig = plt.figure(figsize=(8, 3))fig.subplots_adjust(left=0.02, right=0.98, bottom=0.05, top=0.9)colors = [&#x27;#4EACC5&#x27;, &#x27;#FF9C34&#x27;, &#x27;#4E9A06&#x27;]# We want to have the same colors for the same cluster from the# MiniBatchKMeans and the KMeans algorithm. Let&#x27;s pair the cluster centers per# closest one.k_means_cluster_centers = np.sort(k_means.cluster_centers_, axis=0)k_means_labels = pairwise_distances_argmin(X, k_means_cluster_centers)# KMeansax = fig.add_subplot(1, 3, 1)for k, col in zip(range(n_clusters), colors): my_members = k_means_labels == k cluster_center = k_means_cluster_centers[k] ax.plot(X[my_members, 0], X[my_members, 1], &#x27;w&#x27;, markerfacecolor=col, marker=&#x27;.&#x27;) ax.plot(cluster_center[0], cluster_center[1], &#x27;o&#x27;, markerfacecolor=col, markeredgecolor=&#x27;k&#x27;, markersize=6)ax.set_title(&#x27;KMeans&#x27;)ax.set_xticks(())ax.set_yticks(())plt.text(-3.5, 1.8, &#x27;train time: %.2fs inertia: %f&#x27; % ( t_batch, k_means.inertia_))plt.show() K-Means clustering algorithms k-means算法的改进 请给出三种k-means算法在大数据量时的改进方法，并分析改进的结果。改进方法包括： k-means++（改变中心点的选取方法） elkan K-Means（减少不必要的距离计算） ISODATA算法（在运行过程中根据实际情况调整聚类中心数k） Mini Batch k-means算法（采用部分样本，舍弃一些精确度大大加快收敛速度） 其中1和4改进方法给出了源码和对比。 k-means++（改变中心点的选择方法）参考资料1:https://blog.csdn.net/github_39261590/article/details/76910689参考资料2:https://www.cnblogs.com/yszd/p/9672885.htmlk-means++算法选择初始seeds的基本思想就是：初始的聚类中心之间的相互距离要尽可能的远。 算法步骤： 从输入的数据点集合中随机选择一个点作为第一个聚类中心 对于数据集中的每一个点x，计算它与最近聚类中心(指已选择的聚类中心)的距离D(x) 选择一个新的数据点作为新的聚类中心，选择的原则是：D(x)较大的点，被选取作为聚类中心的概率较大 重复2和3直到k个聚类中心被选出来 利用这k个初始的聚类中心来运行标准的k-means算法 import numpy as npimport matplotlib.pyplot as pltimport sklearn.datasets as dsimport matplotlib.colorsfrom sklearn.cluster import KMeansfrom sklearn.cluster import MiniBatchKMeansdef expand(a, b): d = (b - a) * 0.1 return a-b, b+dif __name__ == &quot;__main__&quot;: N = 400 centers = 4 data, y = ds.make_blobs(N, n_features=2, centers=centers, random_state=2) data2, y2 = ds.make_blobs(N, n_features=2, centers=centers, cluster_std=(1, 2.5, 0.5, 2), random_state=2) # 按行拼接numpy数组 data3 = np.vstack((data[y == 0][:], data[y == 1][:50], data[y == 2][:20], data[y == 3][:5])) y3 = np.array([0] * 100 + [1] * 50 + [2] * 20 + [3] * 5) cls = KMeans(n_clusters=4, init=&#x27;k-means++&#x27;) y_hat = cls.fit_predict(data) y2_hat = cls.fit_predict(data2) y3_hat = cls.fit_predict(data3) m = np.array(((1, 1),(1, 3))) data_r = data.dot(m) y_r_hat = cls.fit_predict(data_r) matplotlib.rcParams[&#x27;font.sans-serif&#x27;] = [u&#x27;SimHei&#x27;] matplotlib.rcParams[&#x27;axes.unicode_minus&#x27;] = False cm = matplotlib.colors.ListedColormap(list(&#x27;rgbm&#x27;)) plt.figure(figsize=(9, 10), facecolor=&#x27;w&#x27;) plt.subplot(421) plt.title(u&#x27;原始数据&#x27;) plt.scatter(data[:, 0], data[:, 1], c=y, s=30, cmap=cm, edgecolors=&#x27;none&#x27;) x1_min, x2_min = np.min(data, axis=0) x1_max, x2_max = np.max(data, axis=0) x1_min, x1_max = expand(x1_min, x1_max) x2_min, x2_max = expand(x2_min, x2_max) plt.xlim((x1_min, x1_max)) plt.ylim((x2_min, x2_max)) plt.grid(True) plt.subplot(422) plt.title(u&#x27;KMeans++聚类&#x27;) plt.scatter(data[:, 0], data[:, 1], c=y_hat, s=30, cmap=cm, edgecolors=&#x27;none&#x27;) plt.xlim((x1_min, x1_max)) plt.ylim((x2_min, x2_max)) plt.grid(True) elkan k-means算法参考资料:https://blog.csdn.net/u014465639/article/details/71342072elkan K-Means利用了两边之和大于等于第三边,以及两边之差小于第三边的三角形性质，来减少距离的计算。第一种规律是对于一个样本点和两个质心。如果我们预先计算出了这两个质心之间的距离，则如果计算发现,我们立即就可以知道。此时我们不需要再计算,也就是说省了一步距离计算。第二种规律是对于一个样本点和两个质心。我们可以得到。这个从三角形的性质也很容易得到。利用上边的两个规律，elkan K-Means比起传统的K-Means迭代速度有很大的提高。但是如果我们的样本的特征是稀疏的，有缺失值的话，这个方法就不使用了，此时某些距离无法计算，则不能使用该算法。 ISODATA算法参考资料1:https://blog.csdn.net/houston11235/article/details/8511379参考资料2:https://www.cnblogs.com/huadongw/p/4101422.htmlk-means 的一个缺点就是必须指定聚类的个数，这个有些时候并不太行得通。于是就要求最好这个类别的个数也可以改变，这就形成了 isodata 方法，通过设定一些类别分裂和合并的条件，在聚类的过程中自动增减类别的数目。当然这也带来了一个问题，就是这个条件有时候并不那么好给出。当然 isodata 在很多情况下还是可以得到比较靠谱的结果。 Mini Batch k-means（用一部分样本做传统的k-means，舍弃一部分精确度大大提高收敛速度）参考资料1:https://cloud.tencent.com/developer/article/1465020Mini Batch KMeans算法是一种能尽量保持聚类准确性下但能大幅度降低计算时间的聚类模型，采用小批量的数据子集减少计算时间，同时仍试图优化目标函数，这里所谓的Mini Batch是指每次训练算法时随机抽取的数据子集，采用这些随机选取的数据进行训练，大大的减少了计算的时间，减少的KMeans算法的收敛时间，但要比标准算法略差一点，建议当样本量大于一万做聚类时，就需要考虑选用Mini Batch KMeans算法。 &#x27;&#x27;&#x27; Comparison of the K-Means and MiniBatchKMeans clustering algorithms&#x27;&#x27;&#x27;print(__doc__)import timeimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.cluster import MiniBatchKMeans, KMeansfrom sklearn.metrics.pairwise import pairwise_distances_argminfrom sklearn.datasets.samples_generator import make_blobs# ############################################################################## Generate sample datanp.random.seed(0)batch_size = 45centers = [[1, 1], [-1, -1], [1, -1]] # 初始化3个中心n_clusters = len(centers) # 聚类的数目为3# 产生10000组二维数据，以上面三个点为中心，以(-10,10)为边界，数据集的标准差是0.7X, labels_true = make_blobs(n_samples=10000, centers=centers, cluster_std=0.7)# ############################################################################## Compute clustering with Meansk_means = KMeans(init=&#x27;k-means++&#x27;, n_clusters=3, n_init=10)t0 = time.time()k_means.fit(X)# 使用k-means对300组数据集训练算法的时间消耗t_batch = time.time() - t0# ############################################################################## Compute clustering with MiniBatchKMeansmbk = MiniBatchKMeans(init=&#x27;k-means++&#x27;, n_clusters=3, batch_size=batch_size, n_init=10, max_no_improvement=10, verbose=0)t0 = time.time()mbk.fit(X)# 使用MiniBatchKMeans对300组数据集训练算法的时间消耗t_mini_batch = time.time() - t0# ############################################################################## Plot resultfig = plt.figure(figsize=(8, 3))fig.subplots_adjust(left=0.02, right=0.98, bottom=0.05, top=0.9)colors = [&#x27;#4EACC5&#x27;, &#x27;#FF9C34&#x27;, &#x27;#4E9A06&#x27;]# We want to have the same colors for the same cluster from the# MiniBatchKMeans and the KMeans algorithm. Let&#x27;s pair the cluster centers per# closest one.k_means_cluster_centers = np.sort(k_means.cluster_centers_, axis=0)mbk_means_cluster_centers = np.sort(mbk.cluster_centers_, axis=0)k_means_labels = pairwise_distances_argmin(X, k_means_cluster_centers)mbk_means_labels = pairwise_distances_argmin(X, mbk_means_cluster_centers)order = pairwise_distances_argmin(k_means_cluster_centers, mbk_means_cluster_centers)# KMeansax = fig.add_subplot(1, 3, 1)for k, col in zip(range(n_clusters), colors): my_members = k_means_labels == k cluster_center = k_means_cluster_centers[k] ax.plot(X[my_members, 0], X[my_members, 1], &#x27;w&#x27;, markerfacecolor=col, marker=&#x27;.&#x27;) ax.plot(cluster_center[0], cluster_center[1], &#x27;o&#x27;, markerfacecolor=col, markeredgecolor=&#x27;k&#x27;, markersize=6)ax.set_title(&#x27;KMeans&#x27;)ax.set_xticks(())ax.set_yticks(())plt.text(-3.5, 1.8, &#x27;train time: %.2fs inertia: %f&#x27; % ( t_batch, k_means.inertia_))# MiniBatchKMeansax = fig.add_subplot(1, 3, 2)for k, col in zip(range(n_clusters), colors): my_members = mbk_means_labels == order[k] cluster_center = mbk_means_cluster_centers[order[k]] ax.plot(X[my_members, 0], X[my_members, 1], &#x27;w&#x27;, markerfacecolor=col, marker=&#x27;.&#x27;) ax.plot(cluster_center[0], cluster_center[1], &#x27;o&#x27;, markerfacecolor=col, markeredgecolor=&#x27;k&#x27;, markersize=6)ax.set_title(&#x27;MiniBatchKMeans&#x27;)ax.set_xticks(())ax.set_yticks(())plt.text(-3.5, 1.8, &#x27;train time: %.2fs inertia: %f&#x27; % (t_mini_batch, mbk.inertia_))# Initialise the different array to all Falsedifferent = (mbk_means_labels == 4)ax = fig.add_subplot(1, 3, 3)for k in range(n_clusters): different += ((k_means_labels == k) != (mbk_means_labels == order[k]))identic = np.logical_not(different)ax.plot(X[identic, 0], X[identic, 1], &#x27;w&#x27;, markerfacecolor=&#x27;#bbbbbb&#x27;, marker=&#x27;.&#x27;)ax.plot(X[different, 0], X[different, 1], &#x27;w&#x27;, markerfacecolor=&#x27;m&#x27;, marker=&#x27;.&#x27;)ax.set_title(&#x27;Difference&#x27;)ax.set_xticks(())ax.set_yticks(())plt.show() Comparison of the K-Means and MiniBatchKMeans clustering algorithms","tags":["Fisher","SVM","K-Means"],"categories":["机器学习"]},{"title":"写于10月15日——博客正式对外开放之际","path":"/201909/写于博客正式对外开放之际/","content":"If you can quite, then quite. If you can't quite, you're a writer. ——R.A.Salvatore 经过四个月的磨叽，新的博客基本已经完善。鳄鱼先生的水族馆本来想着把原先wordpress博客的文章慢慢搬过来再向大家开放博客，但是仔细看看自己原来的那些文章，要么是没什么深度的书评和影评，要么是平淡的流水账。 但是讲真话，看到自己以前的文字觉得很有成就感，因为那些文章的信息量虽然没那么高、有很多无意义的情绪宣泄，但是里面都有很有意思的闪光点，自己大一大二还真是一个有些自负的天马行空少年。如果这个学期还有时间，就把自己曾经的一些想法整理一下发到博客上来。 下面就记录一下自己接触博客这个圈子以来的一些感触。 我为什么要写博客？表达自己的方式有太多了，微信朋友圈、微信公众平台、QQ空间、微博、知乎、百度贴吧…但是我逐渐发现两个非常严重的问题，其一、这些社交平台上的原创信息都太多了，把自己的想法和感触发布出去真的就是石沉大海，少有人能注意到自己的想法，即使看到了，能让大家留下印象真的非常困难（微信公众平台最明显，随着微信公众平台的门槛降低，“写的比看的多”真的成为了现实）这是消息爆炸的必然结果，随着时间的累积，互联网上文字的平均价值一定会逐渐减少。其二、即使在自己很有存在感的朋友圈和空间，发布的内容也只是自己即时的感慨和供大家取乐的段子，这些东西能够极大地满足我的虚荣心，也记录下了自己很多美好的瞬间。但是在这些平台发布一些长篇大论，就少有人阅读也很难引发深刻的共鸣。 自己的文字越来越浮躁、信息量越来越低，最终在2017年12月，我开始接触博客。 博客对于我来说就像是信息海洋里属于自己的象牙舟——任缘分流，最后还回港口。 老狼就是一个不会被时间改变的人，你应该庆幸身边有这样的人。我是那种随时跟着时代改变的，但是如果你身边都是这样的人，大家都是弄潮儿，最后就不知道随波逐流到哪儿去了。那你身边有这么一个人呢，你在哪儿弄潮也好，还是劈波斩浪也好，你老能看见他。你会知道，“哦，这个地方是我们出发的地方，这个地方是我们还要回去的地方。” ——高晓松 搭建博客的历史大一的时候根本不懂任何技术，经知乎大佬们安利最终决定自己买服务器用wordpress进行傻瓜操作。买域名主机一气呵成，按照教程搭建好了自己的博客。wordpress也确实对小白很友好了，但是它有一个很严重的问题——慢，还有一个致命的问题——莫名其妙地自己的博客就会打不开。wordpress有很棒的地方比如说操作简单、文章可以带密码（有些文章只开放给特定人群），当然缺点就是可定制性太低了，博文内部的插件很少很少，不想现在的’hexo’NeXT主题非常灵活。最终，在我又一次打不开自己博客的时候，我选择了放弃wordpress，放弃自己买的主机，准备转战其他的地方。 博客中国、博客大巴这些老牌BSP（Blog Service Provider）已经半死不活了。博客园、CSDN的博客技术性又太强了。当时的我始终逃避自己码代码，虽然对hexo早有耳闻，但是总感觉技术性太强一直不愿尝试。最后找到了一个发布轻博文的地方——网易lofter，然而lofter现在的用户流量也大不如前。无奈，我最终还是选择了hexo+github。现在真的可以说是真香了。 搭建的过程真的非常非常艰辛，从六月份一直到现在，花了不知道多少时间和多少精力，从git的使用到前端的学习，从markdown进阶到next博文内嵌的插件，每一项都学的我要疯掉。最困难的就是next主题更新的速度太快，根本找不到什么新版本的指导教程，只能自己一点一点摸索，借鉴别人的博客。最终才把自己的主题写好。期间受到过很多大佬的博客的启发： 内容方面陈素封的博客：陈素封老师是我搭建博客期间最佩服的博主，他的文章信息量极大，让我获益匪浅。 技术方面Sanarous的博客：最好看的主题没有之一，我的博客的博文字体和配色基本都是借鉴这位大佬的。他的博客搭建系列对我的技术和审美的提升都非常大。他的博客也是我见过的最优秀的博客。 下面的博客各有可取之处，在搭建的过程中也给了我莫大的帮助： 李瑞豪的博客asdfv1929’s blog贤柳阁Felix：这个主题真的让人眼前一亮YouForeverLinchao’s Blog 我的生活博客搭建的具体过程已经忘得差不多了，也不想再费尽心思地回想和记录。目前自己博客的定位当然不会是一个单纯的技术博客，平时也会post自己的学习笔记、健身记录、书影观后感、游记、摄影和随笔。可以说这是自己的一个个人品牌吧，在接下来的日子里要不断地完善。陈素封老师在自己地一篇文章中提到过写博客的意义： 提供持续学习的动力 积累更多的知识 提高将事情讲清楚的能力 分享带来的连锁反应 帮你找到志同道合的人 记录成长 培养持续做一件事的能力 讨论反思 搜寻你意想不到的东西 一个人在做一件属于自己的事 互联网的身份识别 以上意义对我来说，最重要的应该是1、5、10、11，还有就是让自己沉淀下来，能够去把信息碎片整合、归纳、扩展，形成自己独树一帜的观点。这些是博客对于我的意义。 我现在的日程轨迹自己也非常地满意： 晚上十一点开始清理滴答清单的每日Checklist，然后为第二天安排任务。滴答清单的具体使用方法参考了课程《跟邹小强学用滴答清单》，课程在网易云课堂上应该有。滴答清单我用了快半年了，这是我目前接触的最完美的时间管理类app，我需要的功能它全部都有，而且有产品自己的对时间管理的一些想法。“收集箱”的存在对我有很大的帮助。 下面是我每晚的checklist： 1. 信息门户 2. 北邮人论坛十大 3. 清理阅读清单 4. qq官方通知群 5. 清理滴答清单 6. 整理知识碎片 7. 计算机院公众号 每日的打卡清单包括： 1. 查看今天花了多少钱 2. 健身（z1.2.3.5.6） 3. 坚持记录 4. 阅读 5. 不发脾气 6. 背单词 7. 吃早餐 8. 喝水 每日的咨询获得包括：36氪、澎湃新闻、部分微信公众号、网易云课堂、北邮人论坛收集的app：pocket（很优秀的app！）晚上记录的app：卡片日记（记录app里界面我最喜欢的了，每天记录的时候心情最重要，所以日记软件的颜值要求应该是最高的~）然后有时间的时候再根据卡片日记里的想法形成长篇大论发到博客。&lt;/div&gt; 然而、然而、最近课程真的太忙了啊！专业分流就跟转专业了一样，前两年学的东西和现在的专业都脱轨了啊！这几天累的不行，也好久都没写博客了。 今天写的这一篇的内容一定还有太多不完善的地方，日后再慢慢细化吧。","tags":["博客"],"categories":["参省乎己"]},{"title":"关于细节","path":"/201909/2019-09-24-关于细节/","content":"最近的生活中“细节”这个词出现了很多次。我们从小就被大人们叮嘱要“注意细节”，随着年龄的增长这个词很少再被人提起。这两天发生的一系列事情都让我回过头来重新关注这个词。 近期让我重新注意到这个词的时候是在发给合伙人中秋茶话会的问卷时，标题后面“【复制】”两个字没有删掉，凤民学姐一句“要细心呐”让我突然楞了一下。上次听到这种提醒应该是在小学了。那个时候做错了自己本应该做对的题，会收到老师这样的提醒。 我突然意识到自己在浮躁地做很多事情，这种做事的状态应该调整过来。自己想要做的事情太多，但是行动力没有预期的那么高，所以很多事情都没有做到百分百的完美。对于一个思想活跃的大学生来说，产生新鲜的想法是一件最廉价的事情，真正重要的是做事的行动力。现在的自己应该是有“做减法”的需求，一些事情要么就不做，要么就做到自己的百分之百。尤其是无法逃避的课程作业和课程设计，这些事情理应做到自己的最完美。 在和李京老师的面谈中也提到了关于细节的一些问题。李京老师讲到的关于面试比赛的策划，项目组给出了106页的策划书——不管策划到底怎样，仅仅从策划书的量来看，就知道做这件事的人已经做到尽善尽美了。当我们在职场中或者在平时的学习生活中，我们不可能一上来就拥有很优越的机会，也不可能一下子就做出惊为天人的事情。那么我们的能力和出众点就体现在细节上，在细节上做到无可挑剔同样能给人留下很深的印象。“做好细节”能够让我们“被人注意到”。 认真雕刻细节能够让我们给人留下很好的第一印象。今天欧老师在上课的时候提到免试研究生的复试，单单从一个学生的简历就能发现很多事情——那些认认真真琢磨简历的人至少说明他们把这件事情“放在心上”，这说明他们愿意把之后的时间投入到实验室，愿意和身边的同学交流等等。一份认真的简历能够表达很多东西。老师提醒我们，一定要注意细节，特别是在第一印象中的细节十分重要。 今天在线上和一位快手的学长交流，他着重强调了“亮点”这个词，它可以是学历、专业、论文或者实践等等，重要的是我们要留意开始打造“个人品牌”。 大厂不缺好学校的学生，比如快手一度清北比例高达40%，组里一半以上的清北中科院，但是永远缺乏岗位极度匹配的人。原因并非是大学的专业和研究方向不对口，也并非是高校的教育和职场脱节，而是我们一直是从大学的培养方案出发，去适应不同公司的需求；而非从岗位需求出发，面向岗位技能在大学中学习。这种培养方法是一把双刃剑，它虽然保证了对岗位的高度适应，但是也削弱了人的全面的能力，在社会飞速发展中，可能会随着职业的没落，这种培训方式的偏颇也就显现出来。 我们也应该去尝试构建一种结果导向的培养方案，按照未来的需求在大学阶段集成能力，尤其是在大学专业划分模糊且行业发展迅速的时代。 今天：肝数据科学导论作业到3点，玩手机到4点。九点二十起床，马马虎虎听了课 （大数据技术基础），中午完了一会游戏，美美地吃了一顿，宿舍睡了一会儿，就去上课，没怎么认真听（数据科学导论）在研究博客地SEO。晚上看了好久的乐队的夏天。然后忙于各种琐事，一边学习一边聊天。 效率好低啊，明天还要写作业呢。","categories":["参省乎己"]},{"title":"「学生宿舍管理系统」实验报告","path":"/201909/「学生宿舍管理系统」实验报告/","content":"问题描述使用Python语言，设计一个小型的学生宿舍管理系统，系统用户为宿舍管理员。 功能要求 学生信息：学号、姓名、性别（男/女）、宿舍房间号、联系电话。 系统功能 可按学号查找某一位学生的具体信息 可以录入新的学生信息 可以显示现有的所有学生信息 程序要求 使用函数、列表、字典、字符串、条件循环等解决问题； 程序规模在80~200行左右。 任务分析实现宿舍管理程序的三个功能。添加的功能包括：可以利用学生的姓名进行查找。错误处理：在功能选择、输入学号、姓名、性别、宿舍房间号、联系电话时都有可能出现数据格式不正确的情况，需要请求用户重新输入。在查找失败时，需要向用户提供查找失败信息。 模块划分共有一个主函数和三个模块函数： search_stu可按照学号查找某一位学生的具体信息。（这里做了一个功能拓展，可以通过学生姓名来进行查找，如果有重名的同学都会查找出来） add_stu模块录入新的学生信息 show_all_students显示现有的所有学生信息 main函数进行功能选择 数据结构和关键算法 导入prettytable模块，使输出结果更为美观。 stu_info是一个$n * 5$ 的数组，其中$n$为学生数量 程序代码search_stu函数def search_stu(): &quot;按照学号或姓名查找某一位学生的具体信息&quot; find = -1 t = PrettyTable([&quot;学号&quot;,&quot;姓名&quot;,&quot;性别&quot;,&quot;宿舍房间号&quot;,&quot;联系电话&quot;]) sea = input(&quot;请输入要搜索的学号或姓名： &quot;) if sea.isdigit() == True: for i in range(len(stu_info)): if stu_info[i][0] == sea: find = i t.add_row(stu_info[i]) if sea.isalpha() == True: count = 0 for i in range(len(stu_info)): if stu_info[i][1] == sea: find = i t.add_row(stu_info[i]) if find == -1: print(&quot;抱歉，未查找到该学生。&quot;) else: print(t) add_stu函数def add_stu(): &quot;录入新的学生信息&quot; print(&quot;-&quot;*50) print(&quot;新增学生&quot;) num = input(&quot;请输入学号： &quot;) while num.isdigit() != True: num = input(&quot;输入错误，请重新输入： &quot;) name = input(&quot;请输入姓名： &quot;) while name.isalpha() != True: name = input(&quot;输入错误，请重新输入： &quot;) sex = input(&quot;请输入性别：（男/女） &quot;) while sex != &quot;男&quot; and sex != &quot;女&quot;: sex = input(&quot;输入错误，请重新输入： &quot;) room_no = input(&quot;请输入房间号： &quot;) while room_no.isdigit() != True: room_no = input(&quot;输入错误，请重新输入： &quot;) tel = input(&quot;请输入电话：&quot;) while tel.isdigit() != True: tel = input(&quot;输入错误，请重新输入： &quot;) stu = [num, name, sex, room_no, tel] stu_info.append(stu) print(&quot;添加&quot;+num+&quot;成功&quot;) show_all_students函数def show_all_students(): for i in range(len(stu_info)): table.add_row(stu_info[i]) print(table) 主函数def main(): while True: print(&quot;*&quot;*50) print(&quot;欢迎使用【宿舍管理系统】&quot;) print(&quot;1.查找学生&quot;) print(&quot;2.新增学生&quot;) print(&quot;3.显示全部&quot;) print(&quot;0.退出系统&quot;) print(&quot;*&quot;*50) print() instruct = input(&quot;请选择希望执行的操作：&quot;) if instruct == &quot;1&quot;: search_stu() elif instruct == &quot;2&quot;: add_stu() elif instruct == &quot;3&quot;: show_all_students() elif instruct == &quot;0&quot;: print(&quot;欢迎再次使用【宿舍管理系统】&quot;) break else: print(&quot;输入错误，请重新输入指令！&quot;) 执行结果功能2. 录入学生信息 功能3.显示所有学生信息 功能1. 根据学号或姓名进行查找 根据学号查找 根据姓名查找 可见，重名的学生被查找出来 功能0. 退出系统 错误处理","tags":["Python"],"categories":["数据科学导论"]},{"title":"实验室苦逼搬砖暑假生活纪实","path":"/201909/实验室苦逼搬砖暑假生活纪实/","content":"记录一下自己暑假在实验室做的一些事情和收获吧。 虽然进步很小很缓慢，但总归是有的。 7月13日 关于论文的主要内容，学长进行了讲解： 任务目标：通过迁移学习实现用户对齐问题，并将对齐结果与其他的用户对其方法进行比较：其中的方法包括“监督类型的”和“非监督类型的”，最终论文里要将我们的方法与其他至少三四种方法进行比较。 下面的时间应该做到： 0）熟悉各数据集，每个数据集经过哪个函数变成什么样子？ myspace文件夹中，.node文件前一个数字表示结点标号，后面的表示用户名。 .edges文件每一行的两个数字表示边连接的两个节点。 aminer.tar.gz,flicker.tar.gz,lastfm.tar.gz,linkedin.tar,gz,livejournal.tar.gz这五个压缩包都是上面形式的点和边 aminer-linkedin.map.raw文件，将aminer.tar.gz文件中的结点映射到linkedin上 1）DRNE（将图表示矩阵转化成向量） 转化成的向量是什么格式？它是怎样表示矩阵的？它的输入和输出是怎样的？ 2）wGAN的一个变种函数（生成相应的对齐结果） 它的输入和输出是怎样的？ 7月14日非常艰难的一天，DRNE作者的readme文档写错了，指令是错误的，我第一次接触这个看不懂debug信息，学长也没发现。最后发邮件问原作者才知道readme中把\\打成了/🤬这一件事情花了我三天的时间，一开始以为自己的环境没搭建好，安装了各种库，利用anaconda创造了许多环境测试，我哭了。 关于安装tensorflow的方法： 莫凡Python ling’s bolg 安装时遇到的问题 上面这些乱七八糟的都不如直接pip install，觉得慢的话换成清华镜像资源清华大学开源软件镜像站 pypi镜像使用帮助 7月15日 学长又分配了两个任务，第一个是判断图是否为连通图。 其实要是只有几个点倒简单，但是仅仅接触了一点`Python`就要写个几千点判断连通图的程序，我想到的第一点是效率会非常低。。。最后这个代码学长亲自写了。 这里顺带复习了一下数据结构的东西 邻接矩阵与邻接表 邻接矩阵 边表 边集表，图的储存结构之一。边表由表头结点和表结点两部分组成，图中每个顶点均对应一个存储在数组中的表头结点。 边表存储了以点为起点的边的信息，邻接表存储了以点为出发点的点的信息。 edgelist边表中每行有两个数，表示这两个结点之间有边 python nx.has_path(G, source, target)用来判断是否为连通图 networkx库查阅资料：network资料NetworkX是一个用Python语言开发的图论与复杂网络建模工具，内置了常用的图与复杂网络分析算法，可以方便的进行复杂网络数据分析、仿真建模等工作。networkx支持创建简单无向图、有向图和多重图（multigraph）；内置许多标准的图论算法，节点可为任意数据；支持任意的边值维度，功能丰富，简单易用。network官方文档 发现文档里举的例子都是自己输入的个别的点，我可以先研究一下DRNE的代码，从里面得到一些有用的内容。 代码看不懂的地方，首先就是embedding：关于embedding 7月16日 CONSNET数据集： deepwalk-master先不用，做对比算法的 DRNE-master 用来做embedding的 GAN用来生成模型 关于anaconda的使用： Anaconda是一个方便的python包管理和环境管理软件，一般用来配置不同的项目环境。 我们常常会遇到这样的情况，正在做的项目A和项目B分别基于python2和python3，而第电脑只能安装一个环境，这个时候Anaconda就派上了用场，它可以创建多个互不干扰的环境，分别运行不同版本的软件包，以达到兼容的目的。 Anaconda通过管理工具包、开发环境、Python版本，大大简化了你的工作流程。不仅可以方便地安装、更新、卸载工具包，而且安装时能自动安装相应的依赖包，同时还能使用不同的虚拟环境隔离不同要求的项目。 Anaconda入门 7月17日 conda有一点好处是，如果你需要安装一个包，系统将自动检查这个包需要的前置包并且安装，比如你要安装TensorFlow，而TensorFlow会用到很多像前置包像pandas、matiplot等，如果你在单纯的python下没有安装pandas等包就直接安装TensorFlow，那么和有可能无法使用，而使用conda安装TensorFlow将会询问你并自动帮你把缺少的前置包安装好 使用anaconda先创建一个用于drne的环境 安装以上环境 其中添加的资源库都没有tensorflow == 1.2.0 按照提示 To search for alternate channels that may provide the conda package you’re looking for, navigate to https://anaconda.org and use the search bar at the top of the page. 去官网搜索资源即可下载 环境安装完成 anaconda跑不出来，先学习anaconda的使用方法： anaconda1 anaconda2 anaconda3 7月19日继续研究network库 7月21日研读networkx的文档，在后面处理相关问题的时候会简单很多。在学习图的过程中，遇到的问题： 最后一行输出，我记得莫凡python里有讲这个，关于迭代器的东西，然后搜索了一下，继续进行学习：Python迭代器 任务：写一个可以将ground truth抽样的函数，给定一个列表，例如[0.3， 0.5， 0.7]，0.3表示在groundtruth里面随机抽样30%，并生成名为new-gt-0.3.txt的文件，列表长度为多少，就生成多少个这样的文件。 7月22日readme文档中AcrossNetworkEmbeddingData文件夹里的文件和实际文件夹里的不一样，是否有问题？ anchor users 定位用户 7月23日读学长写的： 连通图代码numpy.zeroshttps://blog.csdn.net/qq_28618765/article/details/78085457 抽样代码自己完成：数据转换代码python open函数的参数https://www.runoob.com/python/python-func-open.html if __name__ == &quot;__main__&quot;: main() https://blog.csdn.net/qq_33254870/article/details/81668297 https://cloud.tencent.com/developer/ask/172682 一定要系统地学一下python！要不然什么都不会，写起来效率太低了！！ 怎样用csvreader读入用tab分隔的文件——直接用\\t https://www.runoob.com/python/att-list-len.html for while if后面都要有冒号 python的‘和’符号是 and 关于newline参数 7月24日 把trans_result打成了tranns_result，出现问题，，，，， python也没有报错，还好自己发现了 i = 0\twhile(i &lt; len(trans_result)): # print(&quot;Delete process...&quot;) if(trans_result[i][0] == 0 or trans_result[i][1] == 0): trans_result = np.delete(trans_result, i, axis = 0) else:#！！！！注意这里的else！！！否则会出错 i = i + 1 ❤️ 🧡 💛 💚 💙 💜 中间几天帮张老师查项目资料来着——关于“认知计算”和“意图推理” 7月31日如何调出eclipse左边文件栏 anaconda prompt 切换到e盘： drne配适自己的代码：activate for_drnee: 8月4日coursera视频无法播放https://blog.csdn.net/qq_39521554/article/details/79039548 欧式距离 https://www.cnblogs.com/kimkat/p/9938475.html 测试程序（把程序拆成几小部分） np.linalg.norm(vec1 - vec2) 读入部分，怎样读出来两个向量 python cookbook 真的能学到很多东西！！挺有用！ https://zhidao.baidu.com/question/115008008.html https://www.cnblogs.com/bakari/p/4807847.html 8月5日 查数据类型：https://www.cnblogs.com/carlber/p/9362584.html 列表最后有一个逗号，就会多出来一个空元素https://www.cnblogs.com/lostme/articles/8857083.html operands could not be broadcast together with shapes (2,) (250,)https://blog.csdn.net/Odyssues_lee/article/details/85244735 运行map（）后，报：map object at 0x02629E50解决方法与原因分析​​​​​​​https://blog.csdn.net/weixin_40807247/article/details/82797378 https://www.cnblogs.com/hwd9654/p/5707920.html 从字符串中提取数字：https://www.cnblogs.com/dancesir/p/11021829.html python中，“”是什么意思？怎么解决？https://zhidao.baidu.com/question/329317296.html 数据格式要求很严格：3 25 47 69 7tab和x个空格不一样 输出百分比：https://blog.csdn.net/u013553529/article/details/78567696 8月7日博客搭建https://blog.csdn.net/fangquan1980/article/details/80648171 https://blog.csdn.net/zyupupup/article/details/85098366 https://blog.csdn.net/weixin_42419856/article/details/81141546 https://blog.csdn.net/lvsehaiyang1993/article/details/80881433 http://zhangchunlei.com/blog/2014/12/01/modify-a-record-of-my-website-dns/ On a Windows machine, you&#x27;ll want to run nslookup your-domain.com and ensure that the output does not include any of the deprecated IP addresses (207.97.227.XXX, 204.232.175.XX, or 199.27.73.XXX).If you&#x27;re on a Mac or Linux machine, simply paste this command into a terminal window, replacing your-domain.com with, your site&#x27;s domain. dig your-domain.com | grep -E &#x27;(207.97.227.245|204.232.175.78|199.27.73.133)&#x27; || echo &quot;OK&quot;. If you see the word &quot;OK&quot;, you&#x27;re all set. https://blog.csdn.net/a1023182899/article/details/77461567 8月8日https://www.v2ex.com/amp/t/465570 LINE（PALE中）GAN画圈 8月11日xlrd模块：https://www.cnblogs.com/insane-Mr-Li/p/9092619.html 8月13日 random.choiceshttps://blog.csdn.net/lcqin111/article/details/83504029 Cannot feed value of shape (256, 255) for Tensor ‘Placeholder:0’, which has shape ‘(?, 256)’http://www.mamicode.com/info-detail-2346029.html for i in range(4000): print(&quot;--------------training---------DDDDDD----------EPOCH：&quot; + str(i) + &quot;-----------------------&quot;) for j in range(5): mm = np.reshape(random.choices(f_d, f_g, k=256)) nn = np.reshape(random.choices(t_d, t_g, k=256)) rms_train1, loss1 = sess.run([model.rms_train_op1, model.loss_d], feed_dict=&#123;model.s: np.array(random.choices(f_d, f_g, k=256)), model.t: np.array(random.choices(t_d, t_g, k=256))&#125;) for every in model.clip: sess.run(every) 总结7.13了解任务详情 7.14装相应的环境，跑DRNE，发现了文档的错误DRNE在命令行窗口运行。输入：edgelist输出：.npy（需要再写程序转换为embedding） 7.15想要完成任务：判断是否为连通图结果就是不行，， 7.16还在为DRNE的无脑错误 debug 7.17学习了anaconda的使用，还在跑DRNE，， 7.18DRNE，， 7.19完成一个可以将ground truth抽样的函数，例如[0.3, 0.5, 0.7] 7.21学习关于图的内容，不敢下手自己写代码 7.22开始跑IONE（java） 7.23数据转换代码，将cosnet数据集中的用户名转换成结点号 7.24删去edges里面没有在groundtruth中出现的记录，以此来缩小数据集 7.25用学长改过的代码跑ione 7.31用anaconda环境跑DRNE 8.4写计算距离，画圈的代码 8.5计算距离的代码，注意数据格式 8.7博客搭建 8.8跑PALE中的LINE，尝试WGAN 8.11跑学长改过的WGAN 8.11跑学长改过的WGAN完成，DRNE结果的npy转成txt","tags":["迁移学习","Anaconda","DRNE","IONE","WGAN","PALE"],"categories":["机器学习"]},{"title":"30天自制操作系统（27）","path":"/201905/30天自制操作系统（27）/","content":"DAY27_LDT与库1. 先来修复bugbug：用nsct命令运行的应用程序，无论是按Shift+F1还是点击窗口的”x”按钮狗没有反应。task_run(task, -1, 0); 2. 应用程序运行时关闭命令行窗口 目标：在应用程序运行的时候无法关闭所对应的命令行窗口。 修改：1.让系统在按下”x”按钮的时候暂且将命令行窗口从画面上隐藏起来。（因为关闭命令行窗口会有延迟） 当FIFO接收到从console.c发送的“关闭窗口”请求数据时所进行的处理，主要是释放指定的图层。 3. 保护应用程序(1)破坏程序：[FORMAT &quot;WCOFF&quot;] [INSTRSET &quot;i486p&quot;] [BITS 32] [FILE &quot;crack7.nas&quot;] GLOBAL _HariMain [SECTION .text] _HariMain: MOV AX,1005*8 MOV DS,AX CMP DWORD [DS:0x0004],&#x27;Hari&#x27; JNE fin ; 不是应用程序，因此不执行任何操作 MOV ECX,[DS:0x0000] ; 读取该应用程序数据段的大小 MOV AX,2005*8 MOV DS,AX crackloop: ; 整个用123填充 ADD ECX,-1 MOV BYTE [DS:ECX],123 CMP ECX,0 JNE crackloop fin: ; 结束 MOV EDX,4 INT 0x40 4. 保护应用程序(2)CPU为我们提供了解决方案，那就是LDT。GDT: global descriptor tableLDT: local descriptor table其中GDT中的段设置是供所有任务通用的，而LDT中的段设置只对某个应用程序有效。 5. 优化应用程序的大小那么我们该怎么办呢？我们可以将这些函数做成不同的.obj文件，将_api_putchar等需要用到的函数和_api_openwin等不需要用到的函数分离开。 6. 库如果像上一节那样，把函数拆分开来，并用连接器来进行连接的话，我们需要创建很多很多个.obj文件。当然，如果不拆分函数，而是做成一个大的.obj文件也可以（如同a_nask.obj），但这样的话应用程序没有引用的函数也会被包含进去，生成的应用程序文件就会像之前那样无端增大很多。库：将很多个.obj文件打包成一个文件。要创建一个库，我们首先需要.obj文件作为原材料，除此之外，我们还需要一个叫做库管理器的程序。GOLIB = $(TOOLPATH)golib00.exe apilib.lib : Makefile $(OBJS_API) $(GOLIB) $(OBJS_API) out:apilib.liba.bim : a.obj apilib.lib Makefile $(OBJ2BIM) @$(RULEFILE) out:a.bim map:a.map a.obj apilib.lib void api_putchar(int c); void api_putstr0(char *s); void api_putstr1(char *s, int l); void api_end(void); int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title); void api_putstrwin(int win, int x, int y, int col, int len, char *str); void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col); void api_initmalloc(void); char *api_malloc(int size); void api_free(char *addr, int size); void api_point(int win, int x, int y, int col); void api_refreshwin(int win, int x0, int y0, int x1, int y1);void api_linewin(int win, int x0, int y0, int x1, int y1, int col); void api_closewin(int win); int api_getkey(int mode); int api_alloctimer(void); void api_inittimer(int timer, int data); void api_settimer(int timer, int time); void api_freetimer(int timer); void api_beep(int tone); #include &quot;apilib.h&quot; 7. 整理make环境整理操作系统、库、应用程序的文件和代码。","categories":["操作系统"]},{"title":"30天自制操作系统（26）","path":"/201904/30天自制操作系统（26）/","content":"DAY26_为窗口移动提速1. 提高窗口的移动速度(1)导致窗口移动速度慢的原因有很多，其中之一就是sheet_refreshmap的速度太慢。这个函数在sheet_slide中被调用了两次，如果能提高它的速度效果应该会很明显。 2. 提高窗口的移动速度(2) sheet_refreshmap中有这样一句map[vy * ctl-&gt;xsize + vx] = sid; 在汇编语言中，如果我们用16位寄存器代替8位寄存器来执行MOV指令的话，相邻的地址中也会同时写入数据，而如果用32位寄存器，仅1条指令就可以同时向相邻的4个地址写入值了。更重要的是，即便是同时写入4个字节的值，只要指定地址是4的整数倍，指令的执行速度就和1个字节的MOV是相同的。也就是说，速度说不定能提高到原来的4倍！ 3.提高窗口移动速度(3)于是我们首先想到了sheet_refreshsub，窗口移动的时候也调用了这个函数，因此通过修改它可以提高窗口移动的速度，此外其他一些地方也会调用这个函数。 4.提高窗口移动速度(4)为什么明明已经放开了鼠标键，窗口却还在挪动呢？这是因为伴随图层移动所进行的绘图操作非常消耗时间，导致系统来不及处理FIFO中的鼠标移动数据。那么我们可以在接收到鼠标移动数据后不立即进行绘图操作，但如果一直不绘图的话鼠标和窗口就静止不动了，那不就没意义了吗？我们可以等FIFO为空时再进行绘图操作嘛。 5.启动时只打开一个命令行窗口一般都是先打开一个命令行窗口，然后根据需要增加。下面我们就将启动时显示的命令行窗口数量改为一个，并且实现可以随意启动新命令行窗口的功能吧。 在Windows中，即便不在命令行中输入命令，只通过鼠标的操作也可以打开新的命令行窗口。不过鼠标点击开始菜单这种方式实现起来太难，我们还是做快捷键吧。 6.增加更多的命令行窗口7. 关闭命令行窗口(1)在Windows的命令行窗口中，输入“exit”命令就可以关闭当前窗口.在关闭一个命令行窗口时系统需要做些什么事呢？首先需要将创建该窗口时所占用的内存空间全部释放出来，然后还需要释放窗口的图层和任务结构。咦，问题来了，在创建任务时我们为命令行窗口准备了专用的栈，却没有将这个栈的地址保存起来，这样的话就无法执行释放操作了。怎么办呢？我们可以在TASK结构中添加一个cons_stack成员，用来保存栈的地址。 8. 关闭命令行窗口(2)实现用鼠标关闭命令行窗口的功能。当鼠标点击窗口上的“×”按钮时，向命令行窗口任务发送4这个数据，命令行窗口接收到这个数据后则开始执行exit命令的程序。 9.start命令Windows的命令行窗口里有一个start命令，它的功能是可以打开一个新的命令行窗口并运行指定的应用程序。void cmd_start(struct CONSOLE *cons, char *cmdline, int memtotal) &#123; struct SHTCTL *shtctl = (struct SHTCTL *) *((int *) 0x0fe4); struct SHEET *sht = open_console(shtctl, memtotal); struct FIFO32 *fifo = &amp;sht-&gt;task-&gt;fifo; int i; sheet_slide(sht, 32, 4); sheet_updown(sht, shtctl-&gt;top); /*将命令行输入的字符串逐字复制到新的命令行窗口中*/ for (i = 6; cmdline[i] != 0; i++) &#123; fifo32_put(fifo, cmdline[i] + 256); &#125; fifo32_put(fifo, 10 + 256); /*回车键*/ cons_newline(cons); return; &#125; 10. ncst命令用start命令启动应用程序看起来很不错，但如果运行color这样的程序的话，我们并不希望真的新开一个命令行窗口出来，反倒是没有这个多余的窗口比较好。那么下面我们就来做一个不打开新命令行窗口的start命令吧，给它起个名字，叫做“no console start”，简称ncst命令。","categories":["操作系统"]},{"title":"30天自制操作系统（25）","path":"/201904/30天自制操作系统（25）/","content":"DAY25_增加命令行窗口1.蜂鸣器发声蜂鸣器发声EDX=20 EAX=声音频率（单位是mHz，即毫赫兹）例如当EAX=4400000时，则发出440Hz的声音频率设为0则表示停止发声 int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax) &#123; （中略） &#125; else if (edx == 20) &#123; if (eax == 0) &#123; i = io_in8(0x61); io_out8(0x61, i &amp; 0x0d); &#125; else &#123; i = 1193180000 / eax; io_out8(0x43, 0xb6); io_out8(0x42, i &amp; 0xff); io_out8(0x42, i &gt;&gt; 8); i = io_in8(0x61); io_out8(0x61, (i | 0x03) &amp; 0x0f); &#125; &#125; return 0; &#125; 2.增加更多的颜色(1)修改graphic.cvoid init_palette(void) &#123; static unsigned char table_rgb[16 * 3] = &#123; （中略） &#125;; unsigned char table2[216 * 3]; int r, g, b; set_palette(0, 15, table_rgb); for (b = 0; b &lt; 6; b++) &#123; for (g = 0; g &lt; 6; g++) &#123; for (r = 0; r &lt; 6; r++) &#123; table2[(r + g * 6 + b * 36) * 3 + 0] = r * 51; table2[(r + g * 6 + b * 36) * 3 + 1] = g * 51; table2[(r + g * 6 + b * 36) * 3 + 2] = b * 51; &#125; &#125; &#125; set_palette(16, 231, table2); return; &#125; 3.增加更多的颜色(2)我们可以用两种颜色交替排列，看上去就像这两种颜色混合在一起一样，这就是要点。颜色的混合方式我们考虑了下面3种（算上完全不混合的情况，一共有5种）。 4. 窗口初始位置因此我们希望让窗口总是显示在画面的中央，而且显示窗口时的图层高度也不能总是固定为3，而是要判断当前画面中窗口的数量并自动显示在最上面。 5. 增加命令行窗口(1)于是，我们这次只修改bootpack.c，将命令行窗口的相关变量（buf_cons、sht_cons、task_cons和cons）各准备2个，分别分给命令行1和命令行2。 6.增加命令行窗口(2)struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec); 这里的cons变量是用来判断“要向哪个命令行窗口输出字符”的关键。该变量的值是从内存地址0x0fec读取出来的，而无论从哪个任务读取这个内存地址中的值，得到的肯定都是同一个值，因此不管在哪个窗口中运行a.hrb，都只能在固定的其中一个窗口中显示字符。 7. 增加命令行窗口(3)问题出在cmd_app身上set_segmdesc(gdt + 1003, finfo-&gt;size - 1, (int) p, AR_CODE32_ER + 0x60); set_segmdesc(gdt + 1004, segsiz - 1, (int) q, AR_DATA32_RW + 0x60); （中略） start_app(0x1b, 1003 * 8, esp, 1004 * 8, &amp;(task-&gt;tss.esp0)); 首先，color.hrb在某个窗口中被运行，启动程序一切顺利，然后显示窗口并绘图，接下来等待键盘输入并进入休眠状态。到这里为止没有任何问题。然后我们在另外一个窗口中运行color.hrb，程序也顺利启动了，显示窗口并绘图，随后进入休眠状态。然而在这个时候，问题其实已经发生了。这是怎么回事呢？因为我们为color.hrb准备的1003号代码段和1004号数据段，被color2.hrb所用的段给覆盖掉了。因此，当按下回车键唤醒color.hrb时，就会发生异常情况——明明应该去运行color.hrb的，结果却错误地运行了color2.hrb，这样当然会出错了。 8.增加命令行窗口(4)这次的修改也很简单，首先将原来task_cons[0]的地方改为key_wintask和shttask，这样一来，用键盘强制结束时会以当前输入窗口为对象，而用鼠标点击“×”按钮时会以被点击的窗口为对象。 9.变得更像真正的操作系统(1)10.变得更像真正的操作系统(2)这样肯定不行，因为命令行窗口任务的优先级比较低，只有当bootpack.c的HariMain休眠之后才会运行命令行窗口任务，而如果不运行这个任务的话，FIFO缓冲区就不会被初始化，这就相当于我们在向一个还没初始化的FIFO强行发送数据，于是造成fifo32_put混乱而导致重启。","categories":["操作系统"]},{"title":"30天自制操作系统（24）","path":"/201904/30天自制操作系统（24）/","content":"DAY24_窗口操作1.窗口切换(1) 目标：实现切换窗口顺序得功能。 先实现按下F11时，将最下面得那个窗口放到最上面。 修改bootpack.cif (i == 256 + 0x57 &amp;&amp; shtctl-&gt;top &gt; 2) &#123; /* F11 */ sheet_updown(shtctl-&gt;sheets[1], shtctl-&gt;top - 1); &#125; 2. 窗口切换(2)我们需要按照从上到下得顺序，判断鼠标得位置落在哪个图层得范围内，并且还需要确保该位置不是透明色区域。for (j = shtctl-&gt;top - 1; j &gt; 0; j--) &#123; sht = shtctl-&gt;sheets[j]; x = mx - sht-&gt;vx0; y = my - sht-&gt;vy0; if (0 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; sht-&gt;bysize) &#123; if (sht-&gt;buf[y * sht-&gt;bxsize + x] != sht-&gt;col_inv) &#123; sheet_updown(sht, shtctl-&gt;top - 1); break; &#125; &#125; &#125; 3.移动窗口当鼠标左键点击窗口时，如果点击位置位于窗口的标题栏区域，则进入“窗口移动模式”，使窗口的位置追随鼠标指针的移动，当放开鼠标左键时，退出“窗口移动模式”，返回通常模式。if (mmx &lt; 0) &#123; /*如果处于通常模式*/ /*按照从上到下的顺序寻找鼠标所指向的图层*/ for (j = shtctl-&gt;top - 1; j &gt; 0; j--) &#123; sht = shtctl-&gt;sheets[j]; x = mx - sht-&gt;vx0; y = my - sht-&gt;vy0; if (0 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; sht-&gt;bysize) &#123; if (sht-&gt;buf[y * sht-&gt;bxsize + x] != sht-&gt;col_inv) &#123; sheet_updown(sht, shtctl-&gt;top - 1); if (3 &lt;= x &amp;&amp; x &lt; sht-&gt;bxsize - 3 &amp;&amp; 3 &lt;= y &amp;&amp; y &lt; 21) &#123; mmx = mx; /*进入窗口移动模式*/ mmy = my; &#125; break; &#125; &#125; &#125; &#125; else &#123; /*如果处于窗口移动模式*/ x = mx - mmx; /*计算鼠标的移动距离*/ y = my - mmy; sheet_slide(sht, sht-&gt;vx0 + x, sht-&gt;vy0 + y); mmx = mx; /*更新为移动后的坐标*/ mmy = my; &#125; &#125; else &#123; /*没有按下左键*/ mmx = -1; /*返回通常模式*/&#125; 4.用鼠标关闭窗口5.将输入切换到应用程序窗口按下Tab键时将键盘输入切换到当前输入窗口下面一层的窗口中，若当前窗口为最下层，则切换到最上层窗口。 if (key_win == sht_win) &#123; /*发送至任务A */ if (cursor_x &lt; 128) &#123; /*显示一个字符并将光标后移一位*/ s[1] = 0; putfonts8_asc_sht(sht_win, cursor_x, 28, COL8_000000, COL8_FFFFFF, s, 1); cursor_x += 8; &#125; &#125; else &#123; /*发送至命令行窗口*/ fifo32_put(&amp;key_win-&gt;task-&gt;fifo, s[0] + 256); &#125; &#125; if (i == 256 + 0x0e) &#123; /*退格键*/ if (key_win == sht_win) &#123; /*发送至任务A */ if (cursor_x &gt; 8) &#123; /*用空格擦除光标后将光标前移一位*/ putfonts8_asc_sht(sht_win, cursor_x, 28, COL8_000000, COL8_FFFFFF, &quot; &quot;, 1); cursor_x -= 8; &#125; &#125; else &#123; /*发送至命令行窗口*/ fifo32_put(&amp;key_win-&gt;task-&gt;fifo, 8 + 256); &#125; &#125; if (i == 256 + 0x1c) &#123; /*回车键*/ if (key_win != sht_win) &#123; /*发送至命令行窗口*/ fifo32_put(&amp;key_win-&gt;task-&gt;fifo, 10 + 256); &#125; &#125; if (i == 256 + 0x0f) &#123; /* Tab键*/ cursor_c = keywin_off(key_win, sht_win, cursor_c, cursor_x); j = key_win-&gt;height - 1; if (j == 0) &#123; j = shtctl-&gt;top - 1; &#125; key_win = shtctl-&gt;sheets[j]; /*到此结束*/ cursor_c = keywin_on(key_win, sht_win, cursor_c); &#125; 6.用鼠标切换输入窗口目标：让操作系统可以通过简单的点击就能完成输入切换。 7.定时器API获取定时器（alloc）EDX=16 EAX=定时器句柄（由操作系统返回）设置定时器的发送数据（init）EDX=17 EBX=定时器句柄EAX=数据定时器时间设定（set）EDX=18 EBX=定时器句柄EAX=时间释放定时器（free）EDX=19 EBX=定时器句柄 8.取消定时器问题：应用程序设置了一个1秒的定时器，当定时器到达指定时间时会产生超时，并向任务发送事先设置的数据。问题是，如果这时应用程序已经结束了，定时器的数据就会被发送到命令行窗口，而命令行窗口肯定是一头雾水。","categories":["操作系统"]},{"title":"「迁移学习简明手册」学习笔记（1）","path":"/201908/「迁移学习简明手册」学习笔记（1）/","content":"1.迁移学习的基本概念1.2 迁移学习基本概念 核心问题：找到新问题和原问题之间的相似性，才可以顺利地实现知识的迁移。 定义：迁移学习，是指利用数据、任务、或模型之间的相似性，将在旧领域学习过的模型，应用在新领域的一种学习过程。 1.3 为什么要迁移学习这个表格包括了1.3的所有内容，可以只看这个表格： 1.大数据与少标注之间的矛盾 2.大数据与弱计算之间的矛盾 3.普适化模型与个性化需求之间的矛盾机器学习的目标是构建一个尽可能通用的模型，而人们的个性化需求五花八门，短期内根本无法用一个通用的模型去满足。 4.特定应用的需求推荐系统的冷启动问题：一个新的推荐系统，没有足够的用户数据，如何进行精准的推荐；一个崭新的图片标注系统，没有足够的标签，如何进行精准的服务？ 针对以上问题，迁移学习是如何解决的呢？ 1.迁移数据标注 2.模型迁移（将那些大公司在大数据上训练好的模型，迁移到我们的任务中） 3.自适应学习（对普适化模型进行灵活的调整，以便完成我们的任务） 4.相似领域知识迁移 1.4 与已有概念的区别和联系1.迁移学习和机器学习迁移学习属于机器学习的一类 2.迁移学习和多任务学习多任务学习指多个相关的任务一起协同学习。 3.迁移学习和终身学习终身学习是在已经学习好若干个任务之后，面对新的任务可以继续学习而不遗忘之前学习的任务。 4.迁移学习和领域自适应5.迁移学习和增量学习增量学习侧重解决数据不断到来，模型不断更新的问题。 6.迁移学习和自我学习自我学习指的是模型不断地从自身处进行更新 7.迁移学习和协方差漂移协方差漂移指数据地边缘概率分布发生变化 1.5 负迁移（“东施效颦”）如果两个领域之间不存在相似性，或者基本不相似，那么就会大大损害迁移学习地效果。这时候，我们可以说出现了==负迁移(Negative Transfer)== 定义：在源域上学习到的知识，对于目标域上的学习产生负面作用。 产生负迁移的原因： 数据问题 方法问题：源域和目标域是相似的，但是迁移学习的方法不够好。 传递迁移学习：传统迁移学习好比是踩着一块石头过河，传递迁移学习就是踩着连续的两块石头。当两个领域不相似时，传递迁移学习却可以利用处于这两个领域之间的若干领域，将知识传递式的完成迁移。 2.迁移学习的研究领域机器学习可分为有监督、半监督和无监督的机器学习三大类。迁移学习也可以进行这样的分类。 分类的四个准则：按目标域有无标签分、按学习方法分、按特征分、按在线形式分 2.1 按目标域标签分 1.监督迁移学习 Supervised Transfer Learning 2.半监督迁移学习 Semi-Supervised Transfer Learning 3.无监督迁移学习 Unsupervised Transfer Learning 显然，少标签或无标签的问题（半监督和无监督迁移学习），是研究的热点和难点。 2.2 按学习方法分类 1.基于样本的迁移学习方法(Instance based Transfer Learning)通过权重重用，对源域和目标域的样例进行迁移 2.基于==特征==的迁移学习方法(Feature based Transfer Leaning)意思是说，假设源域和目标域的特征原来不在一个空间，或者说它们在原来那个空间上不相似，那我们就想办法把它们变换到一个空间里面，那这些特征不就相似了？ 3.基于==模型==的迁移学习方法(Model based Transfer Leaning)构建参数共享的模型 4.基于关系的迁移学习方法(Relation based Transfer Learning)挖掘和利用关系进行类比迁移 2.3 按特征分类 1.同构迁移学习(Homogeneous Transfer Learning) 2.异构迁移学习(Heterogeneous Transfer Learning)如果特征语义和维度都相同，那么就是同构；反之，如果特征完全不相同，那么就是异构。举个例子来说，不同图片的迁移，就可以认为是同构；而图片到文本的迁移，则是异构的。 2.4 按离线与在线形式分 1.离线迁移学习(Offline Transfer Learning) 2.在线迁移学习(Online Transfer Learning) 目前，绝大多数的迁移学习方法，都采用了离线方式。即，源域和目标域均是给定的，迁移一次即可。这种方式的缺点是显而易见的：算法无法对新加入的数据进行学习，模型也无法得到更新。与之相对的，是在线的方式。即随着数据的动态加入，迁移学习算法也可以不断地更新。 3.迁移学习的应用计算机视觉、文本分类、行为识别、自然语言处理、室内定位、视频监控、舆情分析、人机交互 3.1 计算机视觉同一类图片，不同的拍摄角度、不同光照、不同背景，都会造成特征分布发生改变。因此，使用迁移学习构建跨领域的鲁棒分类器是十分重要的。 3.2 文本分类由于文本数据有其领域特殊性，因此，在一个领域上训练的分类器，不能直接拿来作用到另一个领域上。这就需要用到迁移学习。例如，在电影评论文本数据集上训练好的分类器，不能直接用于图书评论的预测。这就需要进行迁移学习。 3.3 时间序列行为识别 (Activity Recognition) 主要通过佩戴在用户身体上的传感器，研究用户的行为。行为数据是一种时间序列数据。不同用户、不同环境、不同位置、不同设备，都会导致时间序列数据的分布发生变化。 3.4 医疗健康医疗领域研究的难点问题是，无法获取足够有效的医疗数据。 4.基础知识4.1迁移学习的问题形式化4.1.1 领域领域(Domain)是进行学习的主体。领域主要由两部分构成：数据和生成这些数据的概率分布。源领域：有知识、有大量数据标注的领域；目标域：我们最终要赋予知识、赋予标注的对象。 4.1.2 任务任务(Task)：学习的目标。由两部分组成：标签和标签对应的函数。 4.1.3 迁移学习领域自适应(Domain Adaptation) 4.2 总体思路开发算法来最大限度地利用有标注地领域地知识，来辅助目标领域的知识获取和学习。找到相似性 (不变量)，是进行迁移学习的核心。度量工作的目标有两点： 一是很好地度量两个领域的相似性，不仅定性地告诉我们它们是否相似，更定量地给出相似程度。 二是以度量为准则，通过我们所要采用的学习手段，增大两个领域之间的相似性，从而完成迁移学习。 一句话总结： ==相似性是核心，度量准则是重要手段。== 4.3 度量准则核心：衡量两个数据域的差异。 4.3.1 常见的几种距离 1.欧式距离 2.闵科夫斯基距离 3.马氏距离 4.3.2 相似度 1.余弦相似度 2.互信息 3.皮尔逊相关系数 4.Jaccard相关系数 4.3.3 KL散度与JS距离4.3.4 最大均值差异MMD(Maximun mean discrepancy)4.3.5 Principle Angle4.3.6 A-distance4.3.7 Hilbert-Schmidt Independence Criterion4.3.8 Wasserstein Distance4.4 迁移学习的理论保证这一部分有些难度。当自己提出的算法需要理论证明时，可以借鉴这一部分。 5.迁移学习的基本方法四种基本方法：基于样本的迁移，基于模型的迁移，基于特征的迁移，以及基于关系的迁移。 5.1 基于样本的迁移学习方法(Instance based Transfer Learning)如图，在迁移时，为了最大限度地和目标域相似，我们可以人为地提高源域中属于狗这个类别地样本权重。优缺点：虽然实例权重法具有较好的理论支撑、容易推导泛化误差上界，但这类方法通常只在领域间分布差异较小时有效，因此对自然语言处理、计算机视觉等任务效果并不理想。 5.2 基于特征迁移通过特征变换的方式互相迁移，来减少源域和目标域之间地差距；或者将源域和目标域的数据特征变换到统一特征空间中，然后利用传统的机器学习方法进行分类识别。根据特征的同构和异构性，又可以分为同构和异构迁移学习。这类方法通常假设源域和目标域间有一些交叉的特征。 5.3 基于模型学习基于模型的迁移方法 (Parameter/Model based Transfer Learning) 是指从源域和目标域中找到他们之间共享的参数信息，以实现迁移的方法。这种迁移方式要求的假设条件是：源域中的数据与目标域中的数据可以共享一些模型的参数。 5.4 基于关系迁移这种方法比较关注源域和目标域的样本之间的关系。这些文章都借助于马尔科夫逻辑网络 (Markov Logic Net)来挖掘不同领域之间的关系相似性。我们将重点讨论基于特征和基于模型的迁移学习方法，这也是目前绝大多数研究工作的热点。","tags":["迁移学习"],"categories":["机器学习"]},{"title":"30天自制操作系统（23）","path":"/201904/30天自制操作系统（23）/","content":"DAY23_图形处理相关1.编写malloc如果api_malloc只是调用操作系统中的memman_alloc，并将分配到的内存空间地址返回给应用程序的话，是行不通的，因为通过memman_alloc所获得的内存空间并不位于应用程序的数据段范围内，应用程序是无法进行读写操作的。如果应用程序在不知情的情况下执行了读写操作，将会产生异常并强制结束。 memman初始化EDX=8 EBX=memman的地址EAX=memman所管理的内存空间的起始地址ECX=memman所管理的内存空间的字节数mallocEDX=9 EBX=memman的地址ECX=需要请求的字节数EAX=分配到的内存空间地址freeEDX=10 EBX=memman的地址EAX=需要释放的内存空间地址ECX=需要释放的字节数 2.画点在窗口中画点EDX =11 EBX =窗口句柄ESI =显示位置的x坐标EDI =显示位置的y坐标EAX =色号 画星星int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title); void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col); void api_initmalloc(void); char *api_malloc(int size); void api_point(int win, int x, int y, int col); void api_end(void); int rand(void); /*产生0～32767之间的随机数*/ void HariMain(void) &#123; char *buf; int win, i, x, y; api_initmalloc(); buf = api_malloc(150 * 100); win = api_openwin(buf, 150, 100, -1, &quot;stars&quot;); api_boxfilwin(win, 6, 26, 143, 93, 0 /*黑色*/); for (i = 0; i &lt; 50; i++) &#123; x = (rand() % 137) + 6; y = (rand() % 67) + 26; api_point(win, x, y, 3 /*黄色*/); &#125; api_end(); &#125; 3.刷新窗口在所有的窗口绘图命令中设置一个“不自动刷新”的选项，然后再编写一个仅用来刷新的API刷新窗口EDX = 12 EBX = 窗口句柄EAX = x0 ECX = y0 ESI = x1 EDI = y1 4.画直线for (i = 0; i &lt; len; i++) &#123; api_point(win, x, y, col); x += dx; y += dy; &#125; 5.关闭窗口关闭窗口EDX=14 EBX=窗口句柄 6.键盘输入API键盘输入EDX = 15 EAX = 0……没有键盘输入时返回1，不休眠 = 1……休眠直到发生键盘输入EAX = 输入的字符编码 8.强制结束并关闭窗口问题：在运行walk.hrb和lines.hrb时，如果不按回车键结束，而是按Shift+F1强制结束程序的话，窗口就会残留在画面上。解决方法：在struct SHEET中添加一个用来存放task的成员，当应用程序结束时，查询所有的图层，如果图层的task为将要结束的应用程序任务，则关闭该图层。","categories":["操作系统"]},{"title":"30天自制操作系统（22）","path":"/201904/30天自制操作系统（22）/","content":"DAY22_用C语言编写应用程序1.保护操作系统（5）问题：在定时器上做手脚，光标闪烁变得异常缓慢，任务切换的速度也会变得缓慢。[INSTRSET &quot;i486p&quot;] [BITS 32] MOV AL,0x34 OUT 0x43,AL MOV AL,0xff OUT 0x40,AL MOV AL,0xff OUT 0x40,AL ; 上述代码的功能与下面代码相当; io_out8(PIT_CTRL, 0x34); ; io_out8(PIT_CNT0, 0xff); ; io_out8(PIT_CNT0, 0xff); MOV EDX,4 INT 0x40 执行CLI然后再HLT。由于不再产生定时器中断，任务切换也会停止，键盘和鼠标中断也停止响应。 2.帮助发现bugCPU的异常处理功能，除了可以保护操作系统免遭应用程序的破坏，还可以帮助我们在编写应用程序时及早发现bug。 对栈异常的处理：要想让它发现bug，最好能知道引发异常的指令的地址。 int *inthandler0c(int *esp) &#123; struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec); struct TASK *task = task_now(); char s[30]; /*这里！*/ cons_putstr0(cons, &quot; INT 0C : Stack Exception. &quot;); sprintf(s, &quot;EIP = %08X &quot;, esp[11]); /*这里！*/ cons_putstr0(cons, s); /*这里！*/ return &amp;(task-&gt;tss.esp0); /*强制结束程序*/ &#125; int *inthandler0d(int *esp) &#123; struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec); struct TASK *task = task_now(); char s[30]; /*这里！*/ cons_putstr0(cons, &quot; INT 0D : General Protected Exception. &quot;); sprintf(s, &quot;EIP = %08X &quot;, esp[11]); /*这里！*/ cons_putstr0(cons, s); /*这里！*/ return &amp;(task-&gt;tss.esp0); /*强制结束程序*/ &#125; 3.强制结束应用程序 如何实现？将某一个键设定为强制结束键，按一下就可以结束程序。把强制结束处理写在其他的任务中，bootpack.c 4.用C语言显示字符串（1）已经做好了用来显示字符串的API，却没做可供C语言调用该API的函数。 5.用C语言显示字符串（2）连接了.obj文件的bim2hrb认为“hello, world”这个字符串就应该存放在0x400这个地址中。由bim2hrb生成的.hrb文件其实是由两个部分构成的。 代码部分 数据部分 修改console.c： 文件中找不到“Hari”标志则报错。 数据段的大小根据.hrb文件中指定的值进行分配。 将.hrb文件中的数据部分先复制到数据段后再启动程序。 6.显示窗口编写一个用来显示窗口的APIEDX = 5 EBX = 窗口缓冲区ESI = 窗口在x轴方向上的大小（即窗口宽度）EDI = 窗口在y轴方向上的大小（即窗口高度）EAX = 透明色ECX = 窗口名称 7.在窗口中描绘字符和方显示字符的API：EDX = 6 EBX = 窗口句柄ESI = 显示位置的x坐标EDI = 显示位置的y坐标EAX = 色号ECX = 字符串长度EBP = 字符串 描绘方块的API：EDX = 7 EBX = 窗口句柄EAX = x0 ECX = y0 ESI = x1 EDI = y1 EBP = 色号","categories":["操作系统"]},{"title":"30天自制操作系统（21）","path":"/201904/30天自制操作系统（21）/","content":"DAY21_保护操作系统1.攻克难题——字符串显示API 我们需要在API中做个改动，使其能够将应用程序传递的地址解释为代码段内地址。 2.用C语言编写应用程序要实现C语言编写应用程序，需要在应用程序方面创建一个api_putchar函数。注意，这个函数不是创建在操作系统中。api_putchar函数需要用C语言来调用，功能是向EDX和AL赋值，并调用INT 0x40。 [FORMAT &quot;WCOFF&quot;] ; 生成对象文件的模式[INSTRSET &quot;i486p&quot;] ; 表示使用486兼容指令集[BITS 32] ; 生成32位模式机器语言[FILE &quot;a_nask.nas&quot;] ; 源文件名信息 GLOBAL _api_putchar [SECTION .text] _api_putchar: ; void api_putchar(int c); MOV EDX,1 MOV AL,[ESP+4] ; c INT 0x40 RET 这里的api_putchar需要与a.c的编译结果进行连接，因此我们使用对象文件模式 3.保护操作系统（1）操作系统需要运行各种应用程序，而这些应用程序有可能是操作系统开发者编写的，也有可能是用户、别的软件开发商或者是某个自由软件作者出于善意编写的。所谓对操作系统的破坏，严重程度也不同，比如擅自删除重要文件、使其他任务的运行产生异常，或者造成操作系统死机而不得不重新启动等等。 4.保护操作系统（2）我们需要为应用程序提供专用的内存空间，并且禁止别的应用程序访问。要做到这一点，我们可以创建应用程序专用的数据段，并在应用程序运行期间，将DS和SS指向该段地址。这次我们还使用了以句点（.）开头的标签名，这是一种被称为本地标签的特殊标签。它基本上和普通的标签功能一样，区别在于即使标签名和其他函数中的标签重复，系统也能将它们区分开来。 5.对异常的支持接下来我们要实现强制结束程序的功能。要想强制结束程序，只要在中断号0x0d中注册一个函数即可。这是因为在x86架构规范中，当应用程序试图破坏操作系统，或者试图违背操作系统的设置时，就会自动产生0x0d中断，因此该中断也被称为“异常”。 6.保护操作系统（3）可能出现的问题：操作系统会指定应用程序的DS，因此破坏行为会发生异常，那么如果忽略操作系统指定的DS，而是用汇编语言直接将操作系统用的段地址存入DS的话，就又可以干坏事了。 7.保护操作系统（4） 想法：让应用程序无法使用操作系统的段地址。 具体做法：x86架构有这样的功能。在段定义的地方，如果将访问权限加上0x60的话，就可以将段设置为应用程序用。当CS中的段地址为应用程序用段地址时，CPU会认为“当前正在运行应用程序”，这时如果存入操作系统用的段地址就会产生异常。 在启动应用程序的时候我们需要让“操作系统向应用程序的段执行far-CALL”解决方案：可以使用RETF","categories":["操作系统"]},{"title":"基于链接内容的社区发现算法（一）","path":"/201904/基于链接内容的社区发现（一）/","content":"Robust Detection of Link Communities in Large Social Network by Exploiting Link SemanticsRobust Detection of Link Communities in Large Social Network by Exploiting Link Semantics 这篇论文是我加入张老师实验室读的第一篇论文，寒假里草草读了一遍，感叹了自己垃圾的英文水平，上周除了上课和作业基本没做什么，一直在研读这篇论文。很幸运的是上周关于这篇论文的汇报我做的非常精彩，也不枉自己上周那么辛苦的肝了。 这篇博客用来记录自己研读时候的思考和整理。 整个论文的整体内容我将从四个方面介绍。分别是社区发现算法的背景和现存的方法、论文提出的模型和方法、试验和结论与讨论。 1. Background 1.1 社交网络的发展 社交对于世界各地各领域的人们来讲都越来越重要。随着社交网络的发展，越来越多的信息开始在互联网中聚集。 对于这些大数据的分析能够让我们更加熟悉网络的深层结构、了解用户行为和未来趋势。 社交网络中的一个重要的问题便是社区发现，通过社区发现我们能够为用户提供个性化推荐和异常行为的识别。 所谓的“社区发现”，就是将出现在社交网络中的用户节点划分成不同的组别。每个组的用户结点都有着某些相同的特征。 1.2 现存的方法 我们通常用一个图来表示社交网络。其中的点表示用户结点，其中的边表示用户之间的联系。 最初人们社区发现的算法是根据网络的拓扑结构，即让我们划分后的各个社区间的边的数量最少，社区内部点之间的边尽可能的多 之后，社区发现的算法得到改进，我们通过节点内容进行社区划分，即使得同一个社区内的结点内容尽可能多的相似。通过结点内容进行社区发现能够大大提升我们社区发现的效率。 同时我们发现，用户之间的链接，即图中的边也含有大量的信息。 这张图形象的表示了我们的方法和其他方法的区别。其中右边的图是基于结点内容进行社区发现的算法示意图，左边的图是我们基于链接内容进行社区发现的图。我们可以看出现有的其他方法的问题： 1.只考虑了节点内容。考虑节点内容进行社区发现在有些时候有很高的效率。以微博用户的社区发现为例，当我们提供的内容是用户简介时，基于节点内容进行社区发现是很可以的。但是当我们提供的内容是用户之间发送的消息时，这其实是一种“链接内容”，我们需要将链接内容转换成节点内容，比如用户A发送的所有消息算成用户A的节点内容。这时候势必导致社区划分的不准确。 2.假设网络拓扑社区和结点内容社区的用户结点是一样的。两个用户间联系紧密，构成一个拓扑社区，但是他们聊天的内容可能是很五花八门的，两个人可能被分到不同的节点内容社区中去，这个时候现有的方法社区发现的效率就会下降。 3.每个社区仅仅有一个话题。比如右边的图把Music和Movies混在一起当作一个话题，而我们的方法（左边）含有两个话题。 4.仅仅用单个词汇进行社区标签。有时候我们可能会不知所云。而我们的方法用句子进行标签，便于理解。 2.The Model and Method2.1综述详见图片 2.2 详细分析我们先来看看我们进行社区发现需要考虑哪一些因素： 拓扑角度：结点、链接 内容角度：单词、句子、话题 社区和话题群聚(topic cluster) 变量介绍详见图片(难理解的内容都已经用中文进行注释) 所有变量的详细关系如下图所示 为了便于理解，我自己又画了一个图。 图左半部分就是根据拓扑结构进行社区发现，右半部分是根据节点内容进行社区发现。 现在，我们的模型已经建立起来了，我们的目标为以下三点： 具体算法我们算法的整体思想是这样的：首先我们根据某标准把网络中的所有节点划分到不同的社区中（E-step），然后我们将提取每个社区中的关键词，来进行社区标注。（M-step）我们再根据标注进行有监督的学习，对社区进行更精准的划分，以此来一遍遍迭代。 下面我们运用了极大似然的思想进行EM算法。E-step： 我们进行期望化的变量是p，p代表着链接被分配到哪个社区中。现在p的取值是Jensen不等式的取等条件。 M-step： 下面我们要求式(3)的最大值，tau、 omega_ri、 y_rj都是可以通过直接求导求出来的。剩下的psai和fai的最大值我们再一次通过EM算法来求。引入变量p和h，运用JENSEN公式，p和h在取等条件时式子取到最大值。 下面我们给出整个算法的伪代码，看懂这个图整个算法的思路就差不多了。","tags":["社区发现"],"categories":["社区发现"]},{"title":"基于链接内容的社区发现算法（二）","path":"/201904/基于链接内容的社区发现（二）/","content":"Robust Detection of Link Communities in Large Social Network by Exploiting Link Semantics这一部分没什么难点，ppt里写的都很清楚了。。 三、试验1.数据集我们选择了两个数据集，包括美国安然能源公司内部的邮件内容（安然公司丑闻，加州能源危机）和Reddit新闻网站三天的的三个论坛的内容。如果用户A对用户B的帖子进行评论，就产生了一条从A到B的链接，链接内容为评论的内容。 那么如何判断我们社区发现的结果是正确的呢？对于第一个数据集，伯克利大学的学生已经将这些用户节点分成了11个用户社区，我们可以直接将社区发现的结果与这十一个社区比对。对于第二个数据集，我们可以直接将发现的社区和三个论坛内容相比较。 2.对比的方法我们采取了8种最先进的社区发现算法，包括利用拓扑结构的、利用结点内容的、利用链接内容的、可重叠的、不可重叠的（可重叠的意思就是可以将一个用户结点放进多个社区里）等，如图： 3.测评参数F-score和Jaccard similarity，用于测评相似度的两个参数，结果两个参数越大，说明社区发现的结果越好。 4.结果 5.个例研究我们选择了Reddit网站2012年8月27号的数据集进行分析，与我们的方法对比的是SCI SCI方法的结果如下： 我们的方法： 我们的方法还有一个好处，就是可以通过fai和Y找到社区的词云： 我们方法的应用建议： 四、结论 这是文章的标题，下面我们对标题的关键词进行讨论和总结。Robust:健壮性。在传统的方法中，当网络拓朴和话题群聚不重合的时候，方法的效率就会变得很低，而我们的方法将网络拓朴和话题群聚分开来讨论，具有一定的健壮性。 Detection of Link Communities：本论文的主要内容——社区发现。 Exploiting Link Semantics: 基于链接语义。","tags":["社区发现"],"categories":["社区发现"]},{"title":"30天自制操作系统（20）","path":"/201904/30天自制操作系统（20）/","content":"DAY20_API1.程序整理目标：实现由应用程序对操作系统功能的调用（即API，也叫系统调用）。 2.显示单个字符的API(1)目标：显示单个字符的API。 首先我们做一个测试用的应用程序，将要显示的字符编码存入AL寄存器，然后调用操作系统的函数，字符就显示出来了。[BITS 32] MOV AL,&#x27;A&#x27; CALL （cons_putchar的地址）fin: HLT JMP fin bootpack.map文件这是一个文本文件，用文本编辑器打开即可，其中应该可以找到这样一行：0x00000BE3 : _asm_cons_putchar这就是_asm_cons_putchar的地址了，因此，我们将地址填在应用程序中. [BITS 32] MOV AL,&#x27;A&#x27; CALL 0xbe3 fin: HLT JMP fin 3.显示单个字符的API(2) 应用程序对API执行CALL的时候，千万不能忘记加上段号。 4.结束应用程序 C语言中没有用来执行far-CALL的命令，我们只好来创建一个farcall函数_farcall: ; void farcall(int eip, int cs); CALL FAR [ESP+4] ; eip, cs RET 5.不随操作系统版本而改变的 API6.为应用程序自由命名 目标：让系统支持其他应用程序名void cons_runcmd(char *cmdline, struct CONSOLE *cons, int *fat, unsigned int memtotal) &#123; if (strcmp(cmdline, &quot;mem&quot;) == 0) &#123; cmd_mem(cons, memtotal); &#125; else if (strcmp(cmdline, &quot;cls&quot;) == 0) &#123; cmd_cls(cons); &#125; else if (strcmp(cmdline, &quot;dir&quot;) == 0) &#123; cmd_dir(cons); &#125; else if (strncmp(cmdline, &quot;type &quot;, 5) == 0) &#123; cmd_type(cons, fat, cmdline); &#125; else if (cmdline[0] != 0) &#123; /*从此开始*/ if (cmd_app(cons, fat, cmdline) == 0) &#123; /*不是命令，不是应用程序，也不是空行*/ putfonts8_asc_sht(cons-&gt;sht, 8, cons-&gt;cur_y, COL8_FFFFFF, COL8_000000, &quot;Bad command.&quot;, 12); cons_newline(cons); cons_newline(cons); &#125; &#125; /*到此结束 */ return; &#125; 7.当心寄存器 命名只显示一个h 给_asm_cons_putchar添上2行代码，就是PUSHAD和POPAD。 8.用API显示字符 从实际的应用程序开发角度来说，能显示字符串的API远比只能显示单个字符的API要来的方便，因为一次显示一串字符的情况比一次只显示一个字符的情况多得多。 一般有两种方式： 种是显示一串字符，遇到字符编码0则结束； 先指定好要显示的字符串的长度再显示。 功能号 1……显示单个字符（AL = 字符编码）功能号 2……显示字符串 0（EBX = 字符串地址）功能号 3……显示字符串 1（EBX = 字符串地址，ECX = 字符串长度） 将_asm_cons_putchar改写成一个新的函数。_asm_hrb_api: STI PUSHAD; PUSHAD; CALL _hrb_api ADD ESP,32 POPAD IRETD","categories":["操作系统"]},{"title":"30天自制操作系统（19）","path":"/201904/30天自制操作系统（19）/","content":"DAY19_应用程序1.type命令 在Windows的命令行中，有一个叫做type的命令，输入“type 文件名”就会显示出文件的内容。 磁盘映像中的地址 = clustno * 512 + 0x003e00 将s[0～10]这11个字节用空格的字符编码填充，然后读取cmdline[5～]并复制到s[0～]，在复制的同时，将其中的小写字母转换为大写字母。随后，当遇到句点时，则可以断定接下来的部分为扩展名，于是将复制的目标改为s[8～]。经过这样的转换，我们就得到了和磁盘内格式相同的文件名。 “寻找文件”这一段中，我们在磁盘中寻找与所输入的文件名相符的文件。如果成功找到指定文件，则用break跳出for循环；如果找不到，则会在x到达224或者finfo[x].name[0]为0x00时结束循环。 /* type命令*/ /*准备文件名*/ for (y = 0; y &lt; 11; y++) &#123; s[y] = &#x27; &#x27;; &#125; y = 0; for (x = 5; y &lt; 11 &amp;&amp; cmdline[x] != 0; x++) &#123; if (cmdline[x] == &#x27;.&#x27; &amp;&amp; y &lt;= 8) &#123; y = 8; &#125; else &#123; s[y] = cmdline[x]; if (&#x27;a&#x27; &lt;= s[y] &amp;&amp; s[y] &lt;= &#x27;z&#x27;) &#123; /*将小写字母转换成大写字母 */ s[y] -= 0x20; &#125; y++; &#125; &#125; /*寻找文件*/ for (x = 0; x &lt; 224; ) &#123; if (finfo[x].name[0] == 0x00) &#123; break; &#125; if ((finfo[x].type &amp; 0x18) == 0) &#123; for (y = 0; y &lt; 11; y++) &#123; if (finfo[x].name[y] != s[y]) &#123; goto type_next_file; &#125; &#125; break; /*找到文件*/ &#125; type_next_file: x++; &#125; if (x &lt; 224 &amp;&amp; finfo[x].name[0] != 0x00) &#123; /*找到文件的情况*/ y = finfo[x].size; p = (char *) (finfo[x].clustno * 512 + 0x003e00 + ADR_DISKIMG); cursor_x = 8; for (x = 0; x &lt; y; x++) &#123; /*逐字输出*/ s[0] = p[x]; s[1] = 0; putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, s, 1); cursor_x += 8; if (cursor_x == 8 + 240) &#123; /*到达最右端后换行*/ cursor_x = 8; cursor_y = cons_newline(cursor_y, sheet); &#125; &#125; &#125; else &#123; /*没有找到文件的情况*/ putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, &quot;File not found.&quot;, 15); cursor_y = cons_newline(cursor_y, sheet); &#125; 2.type命令改良 目标：实现对换行的支持。 0x09……制表符：显示空格直到 x 被 4 整除为止0x0a……换行符：换行0x0d……回车符：忽略 我们这里所说的制表符也称为水平制表符（horizonal tab），因为对齐字符位置是在水平方向上移动。相对的，还有一种垂直制表符（vertical tab） 在Windows中换行的字符编码为“0x0d 0x0a”两个字节，而Linux中只有“0x0a”一个字节。 字符编码0x0a原本代表折行（line feed）的意思，即只是移动到下一行。 0x0d，也就是回车符的文字编码，代表“让打印头（或者打字机的辊筒）回到行首”的意思，因此才被称为“回车”（carriage return）。 3.对FAT的支持 现在的type命令，肯定可以正确显示文件开头的512个字节的内容，但是如果遇到大于512个字节的文件，中间可能就会突然显示出其他文件的内容。 对于文件的下一段存放在哪里，在磁盘中是有记录的，我们只要分析这个记录，就可以正确读取文件内容了。 它位于从0柱面、0磁头、2扇区开始的9个扇区中，在磁盘映像中相当于0x000200～0x0013ff。这个记录被称为FAT，是“file allocation table”的缩写，翻译过来叫作“文件分配表”（即记录文件在磁盘中存放位置的表）。 4.代码整理 窗口相关函数 → window.c 命令行窗口相关函数 → console.c 文件相关函数 → file.c 5.第一个应用程序[BITS 32] fin: HLT JMP fin 像type命令一样，我们用file_loadfile将文件的内容读到内存中 应用程序不知道自己被读到哪个内存地址，这里暂且由ORG0来生成。因此，为了应用程序能够顺利运行，我们需要为其创建一个内存段。 段创建好之后，接下来只要goto到该段中的程序，程序应该就会开始运行了。要goto到其他的内存段，在汇编语言中用farjmp指令。for (y = 0; y &lt; 11; y++) &#123; s[y] = &#x27; &#x27;; &#125; s[0] = &#x27;H&#x27;; s[1] = &#x27;L&#x27;; s[2] = &#x27;T&#x27;; s[8] = &#x27;H&#x27;; s[9] = &#x27;R&#x27;; s[10] = &#x27;B&#x27;; for (x = 0; x &lt; 224; ) &#123; if (finfo[x].name[0] == 0x00) &#123; break; &#125; if ((finfo[x].type &amp; 0x18) == 0) &#123; for (y = 0; y &lt; 11; y++) &#123; if (finfo[x].name[y] != s[y]) &#123; goto hlt_next_file; &#125; &#125; break; /*找到文件*/ &#125; hlt_next_file: x++; &#125; if (x &lt; 224 &amp;&amp; finfo[x].name[0] != 0x00) &#123; /*找到文件的情况*/ p = (char *) memman_alloc_4k(memman, finfo[x].size); file_loadfile(finfo[x].clustno, finfo[x].size, p, fat, (char *) (ADR_DISKIMG + 0x003e00)); set_segmdesc(gdt + 1003, finfo[x].size - 1, (int) p, AR_CODE32_ER); farjmp(0, 1003 * 8); memman_free_4k(memman, (int) p, finfo[x].size); &#125; else &#123; /*没有找到文件的情况*/ putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, &quot;File not found.&quot;, 15); cursor_y = cons_newline(cursor_y, sheet); &#125; /*到此结束*/","categories":["操作系统"]},{"title":"循环赛赛程安排","path":"/201904/循环赛赛程安排/","content":"一、问题重述设有n个运动员要进行网球循环赛。设计一个满足下列条件的比赛日程表： 每个选手必须与其他n-1个选手各赛一次； 每个选手一天只能赛一次； 当n是偶数时，循环赛进行n-1天。 当n是奇数时，循环赛进行n天。 二、问题分析1.当n是2的次幂时 $ n=2^k,k=1,2,3,4… $时，此时问题比较简单。按照==分治==的策略，可将所有参赛的选手分为两部分，$ n＝2k $个选手的比赛日程表可以通过为 $ n/2＝2k-1 $ 个选手设计的比赛日程表来决定。递归地执行这种分割，直到只剩下 2 个选手时，比赛日程表的制定就变得很简单：只要让这 2 个选手进行比赛就可以了。再逐步合并子问题的解即可得到原问题的解。 示意图如下： 此时的分治算法如下所示:void tourna(int n) //基本的分治算法&#123; if(n==1)&#123;a[0][0]=1;return;&#125; tourna(n/2); //分治 copy(n); //合并&#125;void copy(int n)&#123; int m=n/2; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;m;j++)&#123; //由左上角小块的值算出对应的右上角小块的值 a[i][j+m]=a[i][j]+m; //由右上角小块的值算出对应的左下角小块的值 a[i+m][j]=a[i][j+m]; //由左上角小块的值算出对应的右下角小块的值 a[i+m][j+m]=a[i][j]; &#125;&#125;我们用a[i][j]表示第i支队伍在第j天遇到的对手。 2.当n不是2的次幂时下面讨论当n不是2的次幂时的情况。我们发现当n为奇数时，每天必定有一支队伍轮空。此时我们==假定还有一只不存在的队伍与轮空的队伍比赛==，将我们的奇偶数情况的模型统一。此时n的赛程表与偶数n+1时的赛程表是相似的。比如，当n=4时| 0 | 1 | 2 | 3 ||—-|—-|—-|—-|| 1 | 0 | 3 | 2 || 2 | 3 | 0 | 1 || 3 | 2 | 1 | 0 | 当n=3时| 0 | 1 | 2 | / ||—-|—-|—-|—-|| 1 | 0 | / | 2 || 2 | / | 0 | 1 || / | 2 | 1 | 0 | (删去最后一行)其中“/”表示轮空。 综上，当遇到n为奇数的情况，我们便可以转化为偶数来考虑。 接下来我们遇到问题的难点==矩阵的合并==当n/2为偶数时，合并比较容易，就像$ n=2^k $那样。下面我们来考虑n/2为奇数的情况。此时合并的过程我参考了猪一戒的博客 我们考虑当n=6时的情况。我们先将6个人分成2组，每组3个人（[0，1,2],[3,4,5]），然后发现3是个奇数，然后在每组中+1个虚拟人：X和Y；这样，每组就变成了4个人，然后将这4个人在除以2，我们就得到了一个两两组合的小的组。 首先来看[0，1]; [2,x] 0 1 1 0 2 x x 2 将这两组合起来： 0 1 2 x 1 0 x 2 2 x 0 1 x 2 1 0 这里要得到3个选手的比赛安排，所以，我们将假想的X去掉，并将它的位置以/代替： 0 1 2 / 1 0 / 2 2 / 0 1 然后我们也按照这个规律，安排[3,4,5]的日程，得到表格| 3 | 4 | 5 | / ||—-|—-|—-|—-|| 4 | 3 | / | 5 || 5 | / | 3 | 4 | 我们得到了两个3x4的矩阵（其中第一列表示每个队伍，实际上只有三天），我们最终想得到6*6（其中第一列表示每个队伍，实际上只有五天）的矩阵。 我们先将上面两个矩阵合并 0 1 2 / 1 0 / 2 2 / 0 1 3 4 5 / 4 3 / 5 5 / 3 4 前三天的比赛已经基本排完了，我们只需要在斜杠/的地方填上相应的比赛。很显然可以让每天轮空的两支队伍比赛。（在程序中没有斜杠表示，还是假想的队伍，方便进行监测） 0 1 2 3 1 0 4 2 2 5 0 1 3 4 5 0 4 3 1 5 5 2 3 4 上面的矩阵中[0,1,2]和[3,4,5]组内已经比完了，组间比了一次，剩下的只需要轮换两次即可得到后两天的比赛情况。 0 1 2 3 4 5 1 0 4 2 5 3 2 5 0 1 3 4 3 4 5 0 2 1 4 3 1 5 0 2 5 2 3 4 1 0 于是我们便可以得到两个奇数矩阵的合并情况。 在程序中，我们的思路不是严格意义上的所谓的“合并”，而是“扩展”。比如对于“合并2个3x4的矩阵”，我们是“将1个3x4的矩阵扩展为6x6的矩阵”（因为这两个3x4的矩阵规格相同，排序顺序一样，所以只需要做一遍） 三、代码展示（代码里有一些打印行号的printf语句，不知道为啥一去掉就过不了编译，所以没有删掉。。）#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&quot;Check.cpp&quot;void copy(int n, int **a)//偶数情况&#123;\t//printf(&quot;当前行号%05d &quot;,__LINE__);\tint m=n/2;\tfor(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;m;j++)&#123; //由左上角小块的值算出对应的右上角小块的值 a[i][j+m]=a[i][j]+m; //由右上角小块的值算出对应的左下角小块的值 a[i+m][j]=a[i][j+m]; //由左上角小块的值算出对应的右下角小块的值 a[i+m][j+m]=a[i][j]; &#125; &#125;&#125;void copyodd(int n, int **a) // n/2 为奇数时的合并算法&#123;\tprintf(&quot;当前行号%05d &quot;,__LINE__);\tint m=n/2;\tint b[m];\tfor(int i=0;i&lt;m;i++)&#123; b[i]=m+i; b[m+i]=b[i];\t&#125;\tfor(int i=0;i&lt;m;i++)&#123; //由左上角小块的值算出相应的左下角小块的值 for(int j=0;j&lt;m+1;j++)&#123; if(a[i][j]&gt;=m)&#123; a[i][j]=b[i]; a[m+i][j]=(b[i]+m)%n; &#125;\telse a[m+i][j]=a[i][j]+m; &#125; //由左上角小块的值算出相应的右上角和右下角小块的值 for(int j=1;j&lt;m;j++)&#123; a[i][m+j]=b[i+j]; a[b[i+j]][m+j]=i; &#125;\t&#125;&#125;void merge(int n, int **a) //合并算法&#123;\tif((n/2)&gt;1 &amp;&amp; (n/2)%2 == 1) copyodd(n,a); //n/2 为奇数时,注意是 (n/2)%2 == 1，n别忘了/2 else copy(n,a);&#125;void tournament(int n, int **a) //循环赛算法&#123;\tprintf(&quot;当前行号%05d &quot;,__LINE__);\tif(n==1)&#123;a[0][0]=0;return;&#125;\tif(n%2 == 1)\t&#123;tournament(n+1,a);return;&#125; //n为奇数，分治\ttournament(n/2,a); //n为偶数，分治\tmerge(n,a); //合并&#125;main()&#123;\tint n;\tscanf(&quot;%d&quot;,&amp;n); //创建数组\tint **a;\ta = (int**)malloc(sizeof(int*)*n); if(n%2==1)&#123; for(int i=0; i&lt;n+1; i++)\ta[i] = (int*)malloc(sizeof(int)*(n+1));\t&#125; else &#123; for(int i=0; i&lt;n; i++)\ta[i] = (int*)malloc(sizeof(int)*n);\t&#125; //生成循坏赛矩阵\ttournament(n,a); //打印\tprintf(&quot;当前行号:%05d &quot;,__LINE__);\tfor(int i=0; i&lt;n; i++)&#123; for(int j=1; j&lt;(n%2 == 1 ? n+1 : n); j++)&#123; if(a[i][j]&lt;n)\tprintf(&quot;%d &quot;,a[i][j]); else printf(&quot;x &quot;); &#125; printf(&quot; &quot;);\t&#125; //检验程序\tif(Check(a,n)==1) printf(&quot;This gametable is availuable. &quot;);\telse printf(&quot;This gametable is unavailuable. &quot;);\tif(n%2 ==1)&#123; for(int i=0; i&lt;n; i++)\tfree(a[i]);\t&#125; else &#123; for(int i=0; i&lt;n+1; i++)\tfree(a[i]);\t&#125;\tfree(a);&#125; 四、测试程序测试程序对我们生成的矩阵进行检验。从两个角度进行。 每个队伍都要和其他队伍进行一场比赛 每个队伍每天仅进行一场比赛 测试程序代码如下int Check(int **a, int n)&#123;\tint column;\tif(n%2==1) column=n+1;\telse column=n;\tint flag=0;\tint check=1;//check为0说明不符合条件，停止检验。 //检验每个队伍都与其他队伍比赛 for(int i=0; i&lt;n&amp;&amp;check==1; i++)&#123; for(int k=0; k&lt;n&amp;&amp;check==1; k++)&#123; flag=0; for(int j=0;j&lt;column&amp;&amp;flag==0;j++)&#123; if(a[i][j] == k) flag=1; &#125; if(flag==0) check=0; &#125;\t&#125;\t//检验某天是否有队伍重复比赛\tint times[n];\tfor(int j=1; j&lt;column&amp;&amp;check==1; j++)&#123; for(int w=0; w&lt;n; w++) times[w]=0; for(int i=0; i&lt;n&amp;&amp;check==1; i++)&#123; times[a[i][j]]++; if(times[a[i][j]]&gt;=2) check==0; &#125;\t&#125; if(check==1) return 1;\telse return 0;&#125; 五、实验结果 当n=6时 当n=9时 测试结果均正确。 参考文献[1]王民川,田永轩.分治法在循环赛日程表设计中的应用[J].光盘技术,2009(05):45-46.","tags":["分治法"],"categories":["算法"]},{"title":"30天自制操作系统（18）","path":"/201904/30天自制操作系统（18）/","content":"DAY18_dir命令1.控制光标闪烁(1) 在Windows中，只有可以接受键盘输入的窗口有光标闪烁，而其他的窗口中是不显示光标的。 对HariMain进行改写 /*从此开始*/ if (cursor_c &gt;= 0) &#123; boxfill8(sht_win-&gt;buf, sht_win-&gt;bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43); /*到此结束*/ &#125; sheet_refresh(sht_win, cursor_x, 28, cursor_x + 8, 44); &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; /*鼠标数据*/ （中略） &#125; else if (i &lt;= 1) &#123; /*光标用定时器*/ /*从此开始*/ if (i != 0) &#123; timer_init(timer, &amp;fifo, 0); /*下次置0 */ if (cursor_c &gt;= 0) &#123; cursor_c = COL8_000000; &#125; &#125; else &#123; timer_init(timer, &amp;fifo, 1); /*下次置1 */ if (cursor_c &gt;= 0) &#123; cursor_c = COL8_FFFFFF; &#125; &#125; timer_settime(timer, 50); if (cursor_c &gt;= 0) &#123; boxfill8(sht_win-&gt;buf, sht_win-&gt;bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43); sheet_refresh(sht_win, cursor_x, 28, cursor_x + 8, 44); /*到此结束*/ &#125; &#125; &#125; &#125; &#125; 2.控制光标闪烁(2) 实现命令行窗口中光标闪烁的控制。 像传递按键编码一样，我们可以使用FIFO来实现。 我们先将光标开始闪烁定义为2，停止闪烁定义为3。 3.对回车键的支持 应该对输入的字符进行判断，然后执行相应的命令 /*从此开始*/ if (i == 256 + 0x1c) &#123; /*回车键*/ if (key_to != 0) &#123; /*发送至命令行窗口*/ fifo32_put(&amp;task_cons-&gt;fifo, 10 + 256); &#125; /*到此结束*/ &#125; 4.对窗口滚动的支持void console_task(struct SHEET *sheet) &#123; （中略） int x, y; （中略） for (;;) &#123; io_cli(); if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; （中略） &#125; else &#123; （中略） if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /*键盘数据（通过任务A） */ if (i == 8 + 256) &#123; /*退格键*/ （中略） &#125; else if (i == 10 + 256) &#123; /* Enter */ /*用空格将光标擦除*/ putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, &quot; &quot;, 1); /*从此开始 */ if (cursor_y &lt; 28 + 112) &#123; cursor_y += 16; /*换行*/ &#125; else &#123; /*滚动*/ for (y = 28; y &lt; 28 + 112; y++) &#123; for (x = 8; x &lt; 8 + 240; x++) &#123; sheet-&gt;buf[x + y * sheet-&gt;bxsize] = sheet-&gt;buf[x + (y + 16) * sheet-&gt;bxsize]; &#125; &#125; for (y = 28 + 112; y &lt; 28 + 128; y++) &#123; for (x = 8; x &lt; 8 + 240; x++) &#123; sheet-&gt;buf[x + y * sheet-&gt;bxsize] = COL8_000000; &#125; &#125; sheet_refresh(sheet, 8, 28, 8 + 240, 28 + 128); &#125; /*显示提示符*/ putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, &quot;&gt;&quot;, 1); /*到此为止*/ cursor_x = 16; &#125; else &#123; /*一般字符*/ （中略） &#125; &#125; （中略） &#125; &#125; &#125; 5.mem命令我们已经实现了屏幕滚动，现在该是到了让它执行命令的时候了。mem命令就是memeory的缩写，也就是用来显示内存使用情况的命令。 介绍一下重点。首先我们添加了memtotal和memman两个变量，它们是执行mem命令所必需的。关于memtotal，我们采用和sheet相同的方法从HariMain传递过来，因此我们还要改写一下HariMain。 我们还添加了一个cmdline变量，也就是“命令行”（command line）的缩写。这个变量用来记录通过键盘输入的内容，在“键盘数据”处理的“一般字符”部分，将输入的内容顺次累积起来。 6.cls命令 这个命令的作用是清除屏幕上的内容，也就是“clear screen”（清屏）的缩写。顺便补充个小知识，在Linux中清屏命令是“clear”。代码精简：if (c[0] == &#x27;m&#x27; &amp;&amp; c[1] == &#x27;e&#x27; &amp;&amp; c[2] == &#x27;m&#x27; &amp;&amp; c[3] == 0) &#123; 改成：if (strcmp(cmdline, &quot;mem&quot;) == 0) &#123; strcmp这个函数，只要声明#include即可使用，因此在bootpack.c中我们也要用它。 7. dir命令 我们的目标是制作可执行文件（比如.exe）来让它运行。 过在此之前，我们先来制作一个显示磁盘内文件名称的命令吧。 dir指令除了会显示文件名，还会显示文件的日期和大小。","categories":["操作系统"]},{"title":"30天自制操作系统（17）","path":"/201904/30天自制操作系统（17）/","content":"DAY17_命令行窗口1.闲置任务 即使不改写程序，也能自动在适当的LEVEL运行适当的任务，这样的操作系统才是优秀的操作系统 因此，一般情况下可以让任务休眠，但当所有LEVEL中都没有任务存在的时候，就需要HTL了。接下来我们就按照这个要求来改写mtask.c。 如果“所有LEVEL中都没有任务”就会出问题，那我们只要避免这种情况发生不就可以了吗？这类似于我们写定时器的时候所采用的“卫兵”的思路。 void task_idle(void) &#123; for (;;) &#123; io_hlt(); &#125; &#125; 综上所述，我们完全不需要对task_sleep等代码进行任何改动，只需在task_init中将这个闲置任务放在最下层LEVEL中就可以了。 2.创建命令行窗口3.切换输入窗口 目标：我们要让系统在按下“Tab”键的时候，将输入窗口切换到命令行窗口上去。 我们先改变窗口标题栏的颜色。 4.实现字符输入 要实现字符的输入，只要在键盘被按下的时候向console_task的FIFO发送数据即可。 我们还是把struct FIFO放到struct TASK里面去吧。基本上没有什么任务是完全用不到FIFO的，因此我们把它们绑定起来 在向命令行窗口发送键盘数据的时候，并不是直接发送从键盘接收到的原始数据，而是发送经过keytable[]转换后的值。究其原因，是由于这样做可以省去在命令行窗口任务中将按键编码转换成字符编码的步骤void console_task(struct SHEET *sheet) &#123; struct TIMER *timer; struct TASK *task = task_now(); int i, fifobuf[128], cursor_x = 16, cursor_c = COL8_000000; char s[2]; fifo32_init(&amp;task-&gt;fifo, 128, fifobuf, task); timer = timer_alloc(); timer_init(timer, &amp;task-&gt;fifo, 1); timer_settime(timer, 50); /*显示提示符*/ putfonts8_asc_sht(sheet, 8, 28, COL8_FFFFFF, COL8_000000, &quot;&gt;&quot;, 1); for (;;) &#123; io_cli(); if (fifo32_status(&amp;task-&gt;fifo) == 0) &#123; task_sleep(task); io_sti(); &#125; else &#123; i = fifo32_get(&amp;task-&gt;fifo); io_sti(); if (i &lt;= 1) &#123; /*光标用定时器*/ if (i != 0) &#123; timer_init(timer, &amp;task-&gt;fifo, 0); /*接下来置0 */ cursor_c = COL8_FFFFFF; &#125; else &#123; timer_init(timer, &amp;task-&gt;fifo, 1); /*接下来置1 */ cursor_c = COL8_000000; &#125; timer_settime(timer, 50); &#125; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /*键盘数据（通过任务A） */ if (i == 8 + 256) &#123; /*退格键*/ if (cursor_x &gt; 16) &#123; /*用空白擦除光标后将光标前移一位*/ putfonts8_asc_sht(sheet, cursor_x, 28, COL8_FFFFFF, COL8_000000, &quot; &quot;, 1); cursor_x -= 8; &#125; &#125; else &#123; /*一般字符*/ if (cursor_x &lt; 240) &#123; /*显示一个字符之后将光标后移一位 */ s[0] = i - 256; s[1] = 0; putfonts8_asc_sht(sheet, cursor_x, 28, COL8_FFFFFF, COL8_000000, s, 1); cursor_x += 8; &#125; &#125; &#125; /*重新显示光标*/ boxfill8(sheet-&gt;buf, sheet-&gt;bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43); sheet_refresh(sheet, cursor_x, 28, cursor_x + 8, 44); &#125; &#125; &#125; 5.符号的输入 目标：实现！和%的输入 我们必须要处理shift键 6.大写字母和小写字母 我们必须同时判断Shift键的状态和CapsLock的状态 CapsLock 为 OFF &amp; Shift 键为 OFF → 小写英文字母 CapsLock 为 OFF &amp; Shift 键为 ON → 大写英文字母 CapsLock 为 ON &amp; Shift 键为 OFF → 大写英文字母 CapsLock 为 ON &amp; Shift 键为 ON → 小写英文字母 7.对各种锁定键的支持 点亮/熄灭键盘上指示灯的方法 原理： 对于NumLock和CapsLock等LED的控制，可采用下面的方法向键盘发送指令和数据。 读取状态寄存器，等待 bit 1 的值变为 0。 向数据输出（0060）写入要发送的 1 个字节数据。 等待键盘返回 1 个字节的信息，这和等待键盘输入所采用的方法相同（用 IRQ等待或者用轮询状态寄存器 bit 1 的值直到其变为 0 都可以）。 返回的信息如果为 0xfa，表明 1 个字节的数据已成功发送给键盘。如为 0xfe则表明发送失败，需要返回第 1 步重新发送。 要控制LED的状态，需要按上述方法执行两次，向键盘发送EDxx数据。其中，xx的bit 0代表ScrollLock，bit 1代表NumLock，bit2代表CapsLock（0表示熄灭，1表示点亮）。bit 3～7为保留位，置0即可。 #define KEYCMD_LED 0xed void HariMain(void) &#123; （中略） struct FIFO32 fifo, keycmd; int fifobuf[128], keycmd_buf[32]; （中略） int key_to = 0, key_shift = 0, key_leds = (binfo-&gt;leds &gt;&gt; 4) &amp; 7, keycmd_wait = -1; （中略） fifo32_init(&amp;keycmd, 32, keycmd_buf, 0); （中略） /*为了避免和键盘当前状态冲突，在一开始先进行设置*/ fifo32_put(&amp;keycmd, KEYCMD_LED); fifo32_put(&amp;keycmd, key_leds); for (;;) &#123; if (fifo32_status(&amp;keycmd) &gt; 0 &amp;&amp; keycmd_wait &lt; 0) &#123; /*从此开始*/ /*如果存在向键盘控制器发送的数据，则发送它 */ keycmd_wait = fifo32_get(&amp;keycmd); wait_KBC_sendready(); io_out8(PORT_KEYDAT, keycmd_wait); &#125; /*到此结束*/ io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; task_sleep(task_a); io_sti(); &#125; else &#123; i = fifo32_get(&amp;fifo); io_sti(); if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /* 键盘数据 */ （中略） /*从此开始*/ if (i == 256 + 0x3a) &#123; /* CapsLock */ key_leds ^= 4; fifo32_put(&amp;keycmd, KEYCMD_LED); fifo32_put(&amp;keycmd, key_leds); &#125; if (i == 256 + 0x45) &#123; /* NumLock */ key_leds ^= 2; fifo32_put(&amp;keycmd, KEYCMD_LED); fifo32_put(&amp;keycmd, key_leds); &#125; if (i == 256 + 0x46) &#123; /* ScrollLock */ key_leds ^= 1; fifo32_put(&amp;keycmd, KEYCMD_LED); fifo32_put(&amp;keycmd, key_leds); &#125; if (i == 256 + 0xfa) &#123; /*键盘成功接收到数据*/ keycmd_wait = -1; &#125; if (i == 256 + 0xfe) &#123; /*键盘没有成功接收到数据*/ wait_KBC_sendready(); io_out8(PORT_KEYDAT, keycmd_wait); /*到此结束*/ &#125; （中略） &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; /*鼠标数据*/ （中略） &#125; else if (i &lt;= 1) &#123; /*光标用定时器*/ （中略） &#125; &#125; &#125; &#125; 实现方法： 创建了一个叫keycmd的FIFO缓冲区，它不是用来接收中断请求的，而是用来管理由任务A向键盘控制器发送数据的顺序的。如果有数据要发送到键盘控制器，首先会在这个keycmd中累积起来。 keycmd_wait变量，用来表示向键盘控制器发送数据的状态。当keycmd_wait的值为-1时，表示键盘控制器处于通常状态，可以发送指令；当值不为-1时，表示键盘控制器正在等待发送的数据，这时要发送的数据被保存在keycmd_wait变量中。","categories":["操作系统"]},{"title":"30天自制操作系统（16）","path":"/201904/30天自制操作系统（16）/","content":"DAY16_多任务（2）1.任务管理自动化 充分做好多任务机制的基础上，再利用多任务逐步完善操作系统本身。 如果我们想要运行三个任务的话，就必须改写mt_taskswitch的代码。如果能像当初定时器和窗口背景的做法一样更好。 struct TASKCTL *taskctl; struct TIMER *task_timer; struct TASK *task_init(struct MEMMAN *memman) &#123; int i; struct TASK *task; struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT; taskctl = (struct TASKCTL *) memman_alloc_4k(memman, sizeof (struct TASKCTL)); for (i = 0; i &lt; MAX_TASKS; i++) &#123; taskctl-&gt;tasks0[i].flags = 0; taskctl-&gt;tasks0[i].sel = (TASK_GDT0 + i) * 8; set_segmdesc(gdt + TASK_GDT0 + i, 103, (int) &amp;taskctl-&gt;tasks0[i].tss, AR_TSS32); &#125; task = task_alloc(); task-&gt;flags = 2; /*活动中标志*/ taskctl-&gt;running = 1; taskctl-&gt;now = 0; taskctl-&gt;tasks[0] = task; load_tr(task-&gt;sel); task_timer = timer_alloc(); timer_settime(task_timer, 2); return task; &#125; 调用task_init，会返回一个内存地址，意思是==现在正在运行的这个程序，已经变成一个任务了==。可能大家不是很能理解这个说法，在调用init之后，所有程序的运行都会被当成任务来进行管理，而调用init的这个程序，我们也要让它所属于某个任务，这样一来，通过调用任务的设置函数，就可以对任务进行各种控制，比如说修改优先级等。 2.让任务休眠 给每个任务==分配不同的时间==——休眠+唤醒 休眠： void task_sleep(struct TASK *task) &#123; int i; char ts = 0; if (task-&gt;flags == 2) &#123; /*如果指定任务处于唤醒状态*/ if (task == taskctl-&gt;tasks[taskctl-&gt;now]) &#123; ts = 1; /*让自己休眠的话，稍后需要进行任务切换*/ &#125; /*寻找task所在的位置*/ for (i = 0; i &lt; taskctl-&gt;running; i++) &#123; if (taskctl-&gt;tasks[i] == task) &#123; /*在这里*/ break; &#125; &#125; taskctl-&gt;running--; if (i &lt; taskctl-&gt;now) &#123; taskctl-&gt;now--; /*需要移动成员，要相应地处理*/ &#125; /*移动成员*/ for (; i &lt; taskctl-&gt;running; i++) &#123; taskctl-&gt;tasks[i] = taskctl-&gt;tasks[i + 1]; &#125; task-&gt;flags = 1; /*不工作的状态*/ if (ts != 0) &#123; /*任务切换*/ if (taskctl-&gt;now &gt;= taskctl-&gt;running) &#123; /*如果now的值出现异常，则进行修正*/ taskctl-&gt;now = 0; &#125; farjmp(0, taskctl-&gt;tasks[taskctl-&gt;now]-&gt;sel); &#125; &#125; return; &#125; 唤醒： 在FIFO中添加用于记录要唤醒任务的信息的成员。struct FIFO32 &#123; int *buf; int p, q, size, free, flags; struct TASK *task; &#125;; 3.增加窗口数量 形成任务A、任务B0、任务B1和任务B2的格局。 任务B0～B2各自拥有自己的窗口，它们的功能都一样，即进行计数，这有点像在Windows中启动了一个应用程序及其2个副本的感觉。 4.设定任务优先级（1） 改写mtask.c、task_switchvoid task_switch(void) &#123; struct TASK *task; taskctl-&gt;now++; if (taskctl-&gt;now == taskctl-&gt;running) &#123; taskctl-&gt;now = 0; &#125; task = taskctl-&gt;tasks[taskctl-&gt;now]; timer_settime(task_timer, task-&gt;priority); if (taskctl-&gt;running &gt;= 2) &#123; farjmp(0, task-&gt;sel); &#125; return; &#125; 5.设定任务优先级（2） 在操作系统中有一些处理，即使牺牲其他任务的性能也必须要尽快完成，否则会引起用户的不满，就比如这次对鼠标的处理。对于这类任务，我们可以让它在处理结束后马上休眠，而优先级则可以设置得非常高。 我们需要设计一种架构，使得即便高优先级的任务同时运行，也能够区分哪个更加优先。 这种架构的工作原理是，最上层的LEVEL 0中只要存在哪怕一个任务，则完全忽略LEVEL 1和LEVEL 2中的任务，只在LEVEL 0的任务中进行任务切换。当LEVEL 0中的任务全部休眠，或者全部降到下层LEVEL，也就是当LEVEL 0中没有任何任务的时候，接下来开始轮到LEVEL 1中的任务进行任务切换。当LEVEL 0和LEVEL 1中都没有任务时，那就该轮到LEVEL2 出场了。在这种架构下，只要把音乐播放任务设置在LEVEL 0中，就可以保证获得比鼠标更高的优先级。 task_now 用于返回现在活动中的struct TASK的内存地址struct TASK *task_now(void) &#123; struct TASKLEVEL *tl = &amp;taskctl-&gt;level[taskctl-&gt;now_lv]; return tl-&gt;tasks[tl-&gt;now]; &#125; task_add，用来向struct TASKLEVEL中添加一个任务void task_add(struct TASK *task) &#123; struct TASKLEVEL *tl = &amp;taskctl-&gt;level[task-&gt;level]; tl-&gt;tasks[tl-&gt;running] = task; tl-&gt;running++; task-&gt;flags = 2; /*活动中*/ return; &#125; task_remove void task_remove(struct TASK *task) &#123; int i; struct TASKLEVEL *tl = &amp;taskctl-&gt;level[task-&gt;level]; /*寻找task所在的位置*/ for (i = 0; i &lt; tl-&gt;running; i++) &#123; if (tl-&gt;tasks[i] == task) &#123; /*在这里 */ break; &#125; &#125; tl-&gt;running--; if (i &lt; tl-&gt;now) &#123; tl-&gt;now--; /*需要移动成员，要相应地处理 */ &#125; if (tl-&gt;now &gt;= tl-&gt;running) &#123; /*如果now的值出现异常，则进行修正*/ tl-&gt;now = 0; &#125; task-&gt;flags = 1; /* 休眠中 */ /* 移动 */ for (; i &lt; tl-&gt;running; i++) &#123; tl-&gt;tasks[i] = tl-&gt;tasks[i + 1]; &#125; return; &#125; task_switchsub,用来在任务切换时决定接下来切换到哪个LEVEL void task_switchsub(void) &#123; int i; /*寻找最上层的LEVEL */ for (i = 0; i &lt; MAX_TASKLEVELS; i++) &#123; if (taskctl-&gt;level[i].running &gt; 0) &#123; break; /*找到了*/ &#125; &#125; taskctl-&gt;now_lv = i; taskctl-&gt;lv_change = 0; return; &#125;","categories":["操作系统"]},{"title":"30天自制操作系统（15）","path":"/201904/30天自制操作系统（15）/","content":"DAY15_多任务（1）1.挑战任务切换 多任务：多个应用程序同时运行的状态（也就是同时打开好几个窗口的状态）。 实际上这些程序==并没有在同时运行==，只是看上去好像是在同时运行一样。 在一般的操作系统中，这个切换的动作每0.01～0.03秒就会进行一次。当然，切换的速度越快，让人觉得程序是在同时运行的效果也就越好。不过，CPU进行程序切换（我们称为“任务切换”）这个动作本身就需要消耗一定的时间，这个时间大约为0.0001秒左右，不同的CPU及操作系统所需的时间也有所不同。 CPU处理方式：当你向CPU发出任务切换的指令时，CPU会先把寄存器中的值全部写入内存中，这样做是为了当以后切换回这个程序的时候，可以从中断的地方继续运行。接下来，为了运行下一个程序，CPU会把所有寄存器中的值从内存中读取出来（当然，这个读取的地址和刚刚写入的地址一定是不同的，不然就相当于什么都没变嘛），这样就完成了一次切换。我们前面所说的任务切换所需要的时间，正是对内存进行写入和读取操作所消耗的时间。 TSS 任务状态段 task status segment EIP 扩展指令指针寄存器 extended instruction pointer：CPU用来记录下一条需要执行的指令位于内存中哪个地址的寄存器，因此它才被称为“指令指针”。如果没有这个寄存器，记性不好的CPU就会忘记自己正在运行哪里的程序，于是程序就没办法正常运行了。每执行一条指令，EIP寄存器中的值就会自动累加，从而保证一直指向下一条指令所在的内存地址。 实际任务切换 创建两个TSSstruct TSS32 tss_a, tss_b; 向它们的Idtr和iomap分别存入合适的值tss_a.ldtr = 0; tss_a.iomap = 0x40000000; tss_b.ldtr = 0; tss_b.iomap = 0x40000000; 将它们两个在GDT中进行定义 struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT; set_segmdesc(gdt + 3, 103, (int) &amp;tss_a, AR_TSS32); set_segmdesc(gdt + 4, 103, (int) &amp;tss_b, AR_TSS32); 我们向TR寄存器存入3 * 8这个值，这是因为我们刚才把当前运行的任务定义为GDT的3号。 要进行任务切换，我们必须执行far模式的跳转指令 在eip中，我们需要定义在切换到这个任务的时候，要从哪里开始运行。 2.任务切换进阶 目标：从任务A切换到任务B，再切换回任务A 3.做个简单的多任务（1） 目标：实现更快速的，来回交替的任务切换。这样我们就可以告别光标停住、鼠标卡死、键盘打不了字的情况，让两个任务看上去好像在同时运行一样。 把taskswitch写成一个函数_farjmp: ; void farjmp(int eip, int cs); JMP FAR [ESP+4] ; eip, cs RET 4.做个简单的多任务（2）5.提高运行速度 因为我们的程序每计1个数就在画面上显示一次，但1秒钟之内刷新100次以上的话，人眼根本就分辨不出来，所以我们不需要计1个数就刷新一次，只要每隔0.01秒刷新一次就足够了。 6.测试运行速度向task_b_main添加代码测试运行速度void task_b_main(struct SHEET *sht_back) &#123; struct FIFO32 fifo; struct TIMER *timer_ts, *timer_put, *timer_1s; int i, fifobuf[128], count = 0, count0 = 0; char s[12]; （中略） timer_1s = timer_alloc(); timer_init(timer_1s, &amp;fifo, 100); timer_settime(timer_1s, 100); for (;;) &#123; count++; io_cli(); if (fifo32_status(&amp;fifo) == 0) &#123; io_sti(); &#125; else &#123; i = fifo32_get(&amp;fifo); io_sti(); if (i == 1) &#123; （中略） &#125; else if (i == 2) &#123; （中略） &#125; else if (i == 100) &#123; sprintf(s, &quot;%11d&quot;, count - count0); putfonts8_asc_sht(sht_back, 0, 128, COL8_FFFFFF, COL8_008484, s, 11); count0 = count; timer_settime(timer_1s, 100); &#125; &#125; &#125; &#125; 7.多任务进阶 真正的多任务，是要做到在程序本身不知道的情况下进行任务切换。 果使用这样的设计，即便在程序中不进行任务切换的处理（比如忘记写了，或者因为bug没能正常切换之类的），也一定会正常完成切换。之前那种多任务的话，如果任务B因为发生bug而无法进行切换，那么当切换到任务B以后，其他的任务就再也无法运行了，这样会造成无论是按键盘还是动鼠标都毫无反应的悲剧。","categories":["操作系统"]},{"title":"插入排序（Insert Sort）、归并排序（Merge Sort）和快速排序（Quick Sort）","path":"/201904/插入排序归并排序和快速排序/","content":"一、算法简介1.插入排序算法（Insert Sort Algorithm） 直接插入排序(Straight Insertion Sort)的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次==从无序表中取==出第一个元素，将它==插入到有序表中==的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。 我们需要做的工作只有两个： 取出无序区中的第1个数，并找出它在有序区对应的位置。 将无序区的数据插入到有序区；若有必要的话，则对有序区中的相关数据进行移位。 2.归并排序算法（Merge Sort Algorithm） 归并排序的操作：将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 归并排序的应用场景：速度仅次于快速排序，为稳定排序算法，一般用于==对总体无序，但是各子项相对有序的数列==3.快速排序算法（Quick Sort Algorithm） 快速排序的思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 适用场景：快速排序是==不稳定的==。它不需要额外的存储空间。它的应用场景是大规模的数据排序，并且实际性能要好于归并排序。 二、程序Ⅰ、算法程序1.插入排序算法（Insert Sort Algorithm）/*Insertion Sorting*//*每次从无序的队列中选择一个插入， *直到所有元素都排序完成。*/void InsertSortUp(int A[], int n)&#123;\tfor (int i = 1; i &lt; n; i++) &#123; int swap = A[i]; int j; for (j = i-1 ; A[j] &gt; swap &amp;&amp; j &gt;= 0; j--) A[j+1] = A[j]; A[j+1] = swap;\t&#125;&#125; 2.归并排序算法（Merge Sort Algorithm）/*MergeSort*/void Merge(int A[], int p, int q, int r)&#123;\t//创造左右两个数组L、R，将已经排好的两部分放进去 int n1 = q - p + 1, n2 = r - q;\tint L[n1], R[n2];\tint i,j;\tfor (i = 0; i &lt; n1; i++) L[i] = A[p + i];\tfor (j = 0; j &lt; n2; j++) R[j] = A[q + 1 + j]; //开始对两个数组进行归并 i = 0; j = 0;\tfor (int k = p; k &lt;= r; k++) &#123; if(i == n1)&#123;//如果左边数组已经全放进去 while(j &lt; n2)\tA[k++] = R[j++]; &#125; else if ( j == n2)&#123;//如果右边数组已经全放进去 while(i &lt; n1)\tA[k++] = L[i++]; &#125; else&#123;//比较两个数组，把小的数放进A数组，指针后移 if (L[i] &lt;= R[j]) &#123; A[k] = L[i]; i++; &#125; else &#123; A[k] = R[j]; j++; &#125; &#125; &#125;&#125; void MergeSortUp(int A[], int p,int r)&#123;\tif (p &lt; r) &#123; int q = (p + r) / 2; MergeSortUp(A, p, q); MergeSortUp(A, q + 1, r); Merge(A, p, q, r);\t&#125;&#125; 3.快速排序算法（Quick Sort Algorithm）/*QuickSort*/void swap(int A[], int i, int j)&#123;\tint x = A[i];\tA[i] = A[j];\tA[j] = x;&#125;int partition(int A[], int p, int r)&#123;\tint x = A[p];\tint i = p;\tfor (int j = p + 1; j &lt;= r; j++) &#123; if (A[j] &lt; x) &#123; i = i + 1; swap(A, i, j); &#125;\t&#125;\tswap(A, p, i);\treturn i;&#125; void QuickSortUp(int A[], int p, int r)&#123;\tif (p &lt; r) &#123; int q = partition(A, p, r); QuickSortUp(A, p, q - 1); QuickSortUp(A, q + 1, r);\t&#125;&#125; Ⅱ、测试程序/*Test*/#include&lt;ctime&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#define size 10000 //size为数据规模#include&quot;InsertSort.cpp&quot;#include&quot;MergeSort.cpp&quot;#include&quot;QuickSort.cpp&quot;int A[size];clock_t start,finish;double runtime_insert,runtime_merge,runtime_quick; /*Generating test data set*/void tstdata(int n)&#123;\tFILE *fp;\tif((fp = fopen(&quot;tstdata.txt&quot;,&quot;w+&quot;))== NULL) printf(&quot;cant open the file. &quot;);\telse&#123; srand(time(NULL)); for (int i = 1; i &lt;= n; i++) &#123; if(i!=n) fprintf(fp,&quot;%d &quot;,rand()); else fprintf(fp,&quot;%d &quot;,rand()); &#125; fclose(fp);\t&#125;\t&#125; /*output function*/int output(char *filename,int A[])&#123; FILE * fp; if((fp = fopen(filename,&quot;w+&quot;))==NULL)&#123; printf(&quot;cant open the file. &quot;); &#125; else&#123; for(int i=0;i&lt;size;i++)&#123; if(i!=size-1) fprintf(fp,&quot;%d &quot;,A[i]); else fprintf(fp,&quot;%d &quot;,A[i]); &#125; fclose(fp); &#125; return 0;&#125; main()&#123;\tint i=0; /*generating test data*/\t/*tstdata(size);\tprintf(&quot;Data set has been created. &quot;);*/ /*get the test data*/\tFILE *fp;\tif((fp = fopen(&quot;tstdata.txt&quot;,&quot;r&quot;))==NULL)&#123; printf(&quot;cant open the file. &quot;); &#125;\twhile(fscanf(fp, &quot;%d&quot;, &amp;A[i]) != EOF) i++; fclose(fp); for(i=0;i&lt;size;i++)&#123; printf(&quot;%d &quot;,A[i]); &#125; printf(&quot; &quot;); printf(&quot;Array has been created. &quot;); /*copy the test data set*/\tint A1[size],A2[size],A3[size];\tfor(int i=0;i&lt;size;i++)&#123; A1[i]=A[i]; A2[i]=A[i]; A3[i]=A[i];\t&#125; /*Insert Sorting*/\tprintf(&quot;Insert Sorting... &quot;); start = clock();\tInsertSortUp(A1,size);\tfinish = clock(); output(&quot;InsertSortUp.txt&quot;,A1);\truntime_insert = (double)(finish - start)/CLOCKS_PER_SEC;\tprintf(&quot;Insert Sort has been finished. Time Cost:%lf &quot;,runtime_insert); /*Merge Sorting*/\tprintf(&quot;Merge Sorting... &quot;); start = clock();\tMergeSortUp(A2,0,size-1);\tfinish = clock(); output(&quot;MergeSortUp.txt&quot;,A2);\truntime_merge = (double)(finish-start)/CLOCKS_PER_SEC;\tprintf(&quot;Merge Sort has been finished. Time Cost:%lf &quot;,runtime_merge); /*Quick Sorting*/\tprintf(&quot;Quick Sorting... &quot;); start = clock();\tQuickSortUp(A3,0,size-1);\tfinish = clock(); output(&quot;QuickSortUp.txt&quot;,A3);\truntime_quick = (double)(finish-start)/CLOCKS_PER_SEC;\tprintf(&quot;Quick Sort has been finished. Time Cost:%lf &quot;,runtime_quick);\t&#125; 三、测试数据集生成及测试 我为算法的测试准备了12个测试数据集，其中数据量分别为10,000\\50,000\\100,000 每个数据量下有==随机生成数据集（用于测试平均复杂度）==和==逆序数据集（用于测试最坏情况）== 为了减小误差，每个类型的数据集都准备了两个，这样便生成了3x2x2=12个数据集 算法的正确性测试在数据量很小的时候进行了手动验证，所以这里我们仅着重比较时间复杂度 Ⅰ、测试数据集生成通过main函数中的/generating test data/部分生成“随机生成测试集”，详细测试数据见附件。通过快速排序算法生成相应的“逆序数据集”进行排序算法的时间复杂度测试，详细数据见附件。 Ⅱ、测试过程测试结果如下表：（详见附件） data set Insert Sort(s) Merge Sort(s) Quick Sort(s) S1:10,000\\rand array(average condition) 0.082 0.001 0.002 S2:10,000\\rand array(average condition) 0.069 0.002 0.001 S3:10,000\\reserve array(worst condition) 0.469 0.003 0.554 S4:10,000\\reserve array(worst condition) 0.463 0.003 0.546 S5:50,000\\rand array(average condition) 1.718 0.009 0.009 S6:50,000\\rand array(average condition) 1.881 0.01 0.009 S7:50,000\\reserve array(worst condition) 8.54 0.015 / S8:50,000\\reserve array(worst condition) 7.956 0.015 / S9:100,000\\rand array(average condition) 7.023 0.022 0.017 S10:100,000\\rand array(average condition) 6.86 0.02 0.018 S11:100,000\\reserve array(worst condition) 31.549 0.027 / S12:100,000\\reserve array(worst condition) 30.989 0.029 / 注：50,000和100,000数据量下，最坏情况下快速排序算法程序没法完成排序 四、算法复杂度分析1.插入排序算法（Insert Sort Algorithm） 最优情况：最少比较一次，移动两次。Cmin = n-1；Mmin=（n-1）×2； 最坏情况：最多比较i次，移动i＋2次（逆序）（i=1，2，…，n-1）Cmax=1+2+…+（n-1）=（n2-n）/2M max=3+4+…+（n+1）=（n2+3n-4）/2Cave=（n2+n-2）/4M ave=（n2+7n-8）/4 故直接插入排序的时间复杂度为O（n2），它的时间复杂度和待排序列的顺序有关。 2.归并排序算法（Merge Sort Algorithm）通过迭代作图法可知，归并算法的算法复杂度为O(nlogn)，它的时间复杂度和待排序列的顺序无关。 3.快速排序算法（Quick Sort Algorithm） 最坏情况：顺序或逆序时，一次partition只能解决一个元素的位置 排列，所以最坏情况下的时间复杂度为O(n^2) 平均情况：O(logn),枢轴元素两边的待排序列分的越平均，时间复杂度越小。 五、算法优化1.归并排序的“哨兵”在归并排序中，将两个已经排号的序列整合在一起时，之前我们是这样做的：if(i == n1)&#123;//如果左边数组已经全放进去 while(j &lt; n2)\tA[k++] = R[j++]; &#125; else if ( j == n2)&#123;//如果右边数组已经全放进去 while(i &lt; n1)\tA[k++] = L[i++]; &#125;如果在待排的两个序列的最右端添加一个==哨兵==，即最大值MAX，就不用判断有序列已经选完了的问题，能够有效的减少判断的次数。 2.快速排序枢轴元素pivot的选取pivot的选择对于快速排序时间复杂度的影响十分的大。从上面的“逆序测试数据”可知，如果每次选择的pivot都是最大/最小值，快速排序的复杂度可能会达到O(n^2)。每次运行过程中，随机选取pivot, 通常能得到比较好的结果。我采用了一种==三者取中==的方法，即选取第一个、最后一个以及中间的元素的中位数作为pivot，这样能够有效的避免“worst condition”的出现。代码如下：(摘自csdn博客)//median-of-three pivot ruleprivate static int choosePivotMedianOfThree(int[] a, int l, int r) &#123; int mid = 0;\tif ((r-l+1) % 2 == 0) &#123; mid = l + (r-l+1)/2 - 1;\t&#125; else &#123; mid = l + (r-l+1)/2;\t&#125;\t//只需要找出中位数即可，不需要交换 //有的版本也可以进行交换\tif (((a[l]-a[mid]) * (a[l]-a[r])) &lt;= 0) &#123; return l;\t&#125; else if (((a[mid]-a[l]) * (a[mid]-a[r])) &lt;= 0) &#123; return mid;\t&#125; else &#123; return r;\t&#125;&#125;--------------------- /*作者：xinyuexy *来源：CSDN *原文：https://blog.csdn.net/qq_31903733/article/details/82945605 *版权声明：本文为博主原创文章，转载请附上博文链接！*/再将选取的pivot与队列第一个元素交换即可。 3.快速排序稳定性的改善快速排序是“不稳定”的原因在于，partition的最后一步，pivot和指针i位置的元素交换。举例： 3 1 3’ 5 2 6 1’(大小相同的元素用’区分) 3 1 2 5 3’ 6 1’ 3 1 2 1’ 3’ 6 5(这时候还没问题) 1’ 1 2 3 3’ 6 5(最后一步1’和1的顺序发生变化) 解决方法：每次partition的最后一步时，遍历待排数组A[i]之前的部分，将与A[i]大小相同的元素整体后移。 六、实验心得 本次实验我学习了三种重要算法：插入排序算法、归并排序算法和快速排序算法，了解了它们的原理和适用的情景。 我认为相对于快速排序，归并排序更具有健壮性，它不会因为序列的顺序影响时间复杂度，而且它是一个稳定的排序。可能由于数据集不够大，我还没能充分体会到快速排序在时间上的优势。 最坏情况下的时间复杂度和平均时间复杂度相差非常大，在以后分析算法时要兼顾两者。 七、附录大纲 Test.cpp测试程序，包括数据集生成，待排序列输出等等。 InsertSort.cpp插入排序算法 MergeSort.cpp归并排序算法 QuickSort.cpp快速排序算法 12个测试数据集txt 12个测试结果的截图","tags":["插入排序","归并排序","快速排序"],"categories":["算法"]},{"title":"30天自制操作系统（14）","path":"/201903/30天自制操作系统（14）/","content":"DAY14_高分辨率及键盘输入1. 继续测试性能 之前我们通过“消除位移处理”缩短时间，对于很多“位移”情况，改进才能看到效果。所以我们使用大量的定时器，然后对性能进行比较。 2.提高分辨率（1） 由于画面切换中我们要使用BIOS，所以就需要改写asmhead.nas的“画面模式设定”部分了。 ; 设定画面模式 MOV BX,0x4101 ; VBE的640x480x8bi彩色 MOV AX,0x4f02 INT 0x10 MOV BYTE [VMODE],8 ; 记下画面模式（参考C语言） MOV WORD [SCRNX],640 MOV WORD [SCRNY],480 MOV DWORD [VRAM],0xe0000000 3.提高分辨率（2） 将程序改写，使在真机上运行 4.键盘输入（1） 按照下表，在键盘按键的基础上加上0x80就可以得到键弹起时的数值 5.键盘输入（2） 问题：每一个按键都需要一个if，程序会变长，我们进行修改： static char keytable[0x54] = &#123; 0, 0, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;0&#x27;, &#x27;-&#x27;, &#x27;^&#x27;, 0, 0, &#x27;Q&#x27;, &#x27;W&#x27;, &#x27;E&#x27;, &#x27;R&#x27;, &#x27;T&#x27;, &#x27;Y&#x27;, &#x27;U&#x27;, &#x27;I&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;@&#x27;, &#x27;[&#x27;, 0, 0, &#x27;A&#x27;, &#x27;S&#x27;, &#x27;D&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;;&#x27;, &#x27;:&#x27;, 0, 0, &#x27;]&#x27;, &#x27;Z&#x27;, &#x27;X&#x27;, &#x27;C&#x27;, &#x27;V&#x27;, &#x27;B&#x27;, &#x27;N&#x27;, &#x27;M&#x27;, &#x27;,&#x27;, &#x27;.&#x27;, &#x27;/&#x27;, 0, &#x27;*&#x27;, 0, &#x27; &#x27;, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;-&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;+&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;0&#x27;, &#x27;.&#x27; &#125;; if (256 &lt;= i &amp;&amp; i &lt;= 511) &#123; /* 键盘数据 */ sprintf(s, &quot;%02X&quot;, i - 256); putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2); if (i &lt; 256 + 0x54) &#123; if (keytable[i - 256] != 0) &#123; s[0] = keytable[i - 256]; s[1] = 0; putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, s, 1); &#125; &#125; &#125; else if (512 &lt;= i &amp;&amp; i &lt;= 767) &#123; /* 鼠标数据 */ 6.追记内容（1）==在窗口中添加一些画，改变鼠标和字符的显示位置以及颜色。按下BackSpace，还可以改写已经输入的字符== 7.追记内容（2）==使用鼠标移动窗口==添加的程序if ((mdec.btn &amp; 0x01) != 0) &#123; /* 按下左键、移动sht_win */ sheet_slide(sht_win, mx - 80, my - 8); /* 到这里结束！ */ &#125; 即使窗口跑到了画面外，也没有问题。因为我们已经针对鼠标指针提前采取了对策，这就如同图层跑到了画面外面也可以动起来一样。","categories":["操作系统"]},{"title":"30天自制操作系统（13）","path":"/201903/30天自制操作系统（13）/","content":"DAY13_定时器（2）1. 简化字符串显示 将“涂背景色、写字符、完成刷新”写进一个函数，更方便使用void putfonts8_asc_sht(struct SHEET *sht, int x, int y, int c, int b, char *s, int l) &#123; boxfill8(sht-&gt;buf, sht-&gt;bxsize, b, x, y, x + l * 8 - 1, y + 15); putfonts8_asc(sht-&gt;buf, sht-&gt;bxsize, x, y, c, s); sheet_refresh(sht, x, y, x + l * 8, y + 16); return; &#125; x, y ...... 显示位置的坐标c ...... 字符颜色（color）b ...... 背景颜色（back color）s ...... 字符串（string）l ...... 字符串长度（length） 2.重新调整FIFO缓冲区（1） 将定时器用的多个FIFO缓冲区都集中成一个，往FIFO写入不同的数据，就能够正常地分辨出是哪个寄存器超时了。 3.测试性能 我们专注于定时器地改良，是因为在今后地开发中会经常使用定时器。 测试性能地方法：先对HariMain略加修改，恢复变量count，然后完全不显示计数，全力执行“count++；”语句。当到了10秒后超时的时候，再显示这个count值。 4.重新调整FIFO缓冲区（2） 把3个定时器全部归纳到一个FIFO缓冲区中，就可以把键盘和鼠标归纳起来，只用1个FIFO缓冲区。 0～ 1…………………光标闪烁用定时器3…………………3秒定时器10…………………10秒定时器256～ 511…………………键盘输入（从键盘控制器读入的值再加上256）512～ 767……鼠标输入（从键盘控制器读入的值再加上512） 此次我们改写最多的是HariMain。在HariMain里，执行“count++;”语句和查询FIFO缓冲区中是否有数据这两个操作，是多次交互进行的。这次修改以后，程序只需要看1个FIFO缓冲区就行了，而以前要看3个。也就是说，FIFO缓冲区的查询能够更快完成，从而使得“count++;”语句执行的次数更多。 5.加快中断处理（4） 在FIFO里有一个取代移位处理的方法：读取一个数据以后不是让后面的数据向前靠齐，而是改变下一次的数据读取地址。这是一个很巧妙的方法，但不适用于定时器。因为从timers[ ]中去除超时的中断时，这个方法虽然不错，但问题在于，用timer_settime登录中断时，后面的中断必须后移，在这一点上，以上方法不太好。 更好的方法：我们在结构体struct TIMER中加入next变量。这是个地址变量，用来存放下一个即将超时的定时器的地址。 判断一下顺序，如果我们知道了插入的位置（即知道了在s和t中间插入的话），就可以像下图那样把数据重新连接起来。也就是仅仅改变s-&gt;next和timer-&gt;next的值就可以了。 6.使用“哨兵”简化程序 我们来看看具体的做法。在进行初始化的时候，将时刻0xffffffff的定时器连到最后一个定时器上。虽然我们偷了点懒没有设定fifo等，但不必担心。反正无论如何都不可能到达这个时刻（在到达之前会修改时刻），所以不可能发生超时问题。它一直处于后面，只是个附带物，是个留下来看家的留守者。这个留守者正是“哨兵“。","categories":["操作系统"]},{"title":"30天自制操作系统（12）","path":"/201903/30天自制操作系统（12）/","content":"DAY12_定时器（1）1.使用定时器介绍定时器的作用，添加定时器实现中断。 定时器（Timer）对于操作系统十分重要，每隔一段时间就发送一个中断信号给CPU。有了定时器，CPU就不用辛苦地计量时间。 没有定时器，我们就没法使用HLT指令，意味着要浪费很多电能。 有了定时器中断，程序只需要以自己的步调处理自己的问题就可以了。至于到底经过了多少时间，只要在中断处理程序中数一数定时器中断发生的次数就可以了。 要在电脑中管理定时器，只需要对PIT（Programmable Interval Timer可编程的间隔型定时器）进行设定就可以了。通过设定PIT，让定时器每隔多少秒就产生一次中断。 在电脑中PIT连接着IRQ（interrupt request）的0号，所以只要设定了PIT就可以设定IRQ0的中断间隔。 我们不清楚其中的详细原理，只知道只要执行3次OUT指令设定就完成了。将中断周期设定为11932的话，中断频率好像就是100Hz，也就是说1秒钟会发生100次中断。 IRQ0发生时所调用的中断处理程序几乎和键盘的中断处理程序一样。 2.计量时间==加入计时器显示时间== 让中断执行下面的程序 struct TIMERCTL &#123; unsigned int count; &#125;; 实现方法 定义struct TIMERCTL结构体，在结构体内定义一个计数变量。 初始化PIT时，计数变量为0，每次发生定时器中断时，计数变量就以1递增。 即计数变量在HariMain中不进行加算，每1s也会增加100. 3.超时功能==超时功能的定义，添加超时功能== 我们可以计量处理所花费的时间。具体做法：处理前看一下时间并把它存放到一个变量变量里，处理结束后再看一下时间，做差即可。根据这个可以编制==基准测试程序== 超时（timeout）：过了一段时间，定时器提示操作系统。 struct TIMERCTL &#123; unsigned int count; unsigned int timeout; struct FIFO8 *fifo; unsigned char data; &#125;; timeout用于记录离超时还有多长时间，当剩余时间到达0时，程序就往IFIFO缓冲区里发送数据。 4.设定多个定时器 在上一节做的超时功能，超时结束后如果再设定1000的话，那我们就可以让它每10秒显示一次，或是让它一闪一灭地显示。 开发操作系统时，超时功能非常方便，所以在很多地方都可以使用它。比如可以让电子时钟每隔1秒重新显示一次；演奏音乐时，可以用它计量音符的长短；也可以让它以0.1秒1次的频率来监视没有中断功能的装置；另外，还可以用它实现光标的闪烁功能。为了简单地实现这些功能，我们要准备很多能够设定超时的定时器。 5.加快中断处理（1） 问题：inthandler20中断花费了很长的时间 优化部分：现每次进行定时器中断处理的时候，都会对所有活动中的定时器进行“timerctl.timer[i].timeout—;”处理。也就是说，CPU要完成从内存中读取变量值，减去1，然后又往内存中写入的操作。 time[i].timeout不再是“所剩时间”而是“予定时刻”，将timerctl.count和timer[i].timeout进行比较，不用再经过内存计算。 问题：count设定成最大值，一段时间后需要重新启动操作系统。 6.加快中断处理（2）==优化if语句==解决方案：添加timerctl.next，让它记住下一个时刻 7.加快中断处理（3） 问题：到达next时刻和没到next时刻的定时器中断，它们的处理时间差别很大。这样的程序结构不好。因为平常运行一直都很快的程序，会偶尔由于中断处理拖得太长，而搞得像是主程序要停了似的。","categories":["操作系统"]},{"title":"30天自制操作系统（11）","path":"/201903/30天自制操作系统（11）/","content":"DAY11_制作窗口1.鼠标显示问题 我们系统的鼠标不能够向右或向下移动到画面之外隐藏起来。为此我们修改HariMain 将if (mx &gt; binfo-&gt;scrnx - 16) &#123; mx = binfo-&gt;scrnx - 16; &#125; if (my &gt; binfo-&gt;scrny - 16) &#123; my = binfo-&gt;scrny - 16; &#125; 修改为if (mx &gt; binfo-&gt;scrnx - 1) &#123; mx = binfo-&gt;scrnx - 1; &#125; if (my &gt; binfo-&gt;scrny - 1) &#123; my = binfo-&gt;scrny - 1; &#125; 2.实现画面外的支持3.shtctl的指定省略仅仅是上下移动图层就必须指定ctl太麻烦了。修改将sheet_refresh、sheet_slide、sheet_free等函数，让它们不再指定ctl void sheet_refresh(struct SHEET *sht, int bx0, int by0, int bx1, int by1) &#123; if (sht-&gt;height &gt;= 0) &#123; /* 如果正在显示，则按新图层的信息进行刷新*/ sheet_refreshsub(sht-&gt;ctl, sht-&gt;vx0 + bx0, sht-&gt;vy0 + by0, sht-&gt;vx0 + bx1, sht-&gt;vy0 + by1); &#125; return; &#125; void sheet_slide(struct SHEET *sht, int vx0, int vy0) &#123; int old_vx0 = sht-&gt;vx0, old_vy0 = sht-&gt;vy0; sht-&gt;vx0 = vx0; sht-&gt;vy0 = vy0; if (sht-&gt;height &gt;= 0) &#123; /* 如果正在显示，则按新图层的信息进行刷新 */ sheet_refreshsub(sht-&gt;ctl, old_vx0, old_vy0, old_vx0 + sht-&gt;bxsize, old_vy0 + sht-&gt;bysize); sheet_refreshsub(sht-&gt;ctl, vx0, vy0, vx0 + sht-&gt;bxsize, vy0 + sht-&gt;bysize); &#125; return; &#125; void sheet_free(struct SHEET *sht) &#123; if (sht-&gt;height &gt;= 0) &#123; sheet_updown(sht, -1); /* 如果正在显示，则先设置为隐藏 */ &#125; sht-&gt;flags = 0; /* 未使用标记 */ return; &#125; 4.显示窗口 先准备一张图层，然后在图层缓冲区内描绘一个貌似窗口的图就可以了。 只是对graph.c的init_screen8函数稍微进行修改。void make_window8(unsigned char *buf, int xsize, int ysize, char *title) &#123; static char closebtn[14][16] = &#123; &quot;OOOOOOOOOOOOOOO@&quot;, &quot;OQQQQQQQQQQQQQ$@&quot;, &quot;OQQQQQQQQQQQQQ$@&quot;, &quot;OQQQ@@QQQQ@@QQ$@&quot;, &quot;OQQQQ@@QQ@@QQQ$@&quot;, &quot;OQQQQQ@@@@QQQQ$@&quot;, &quot;OQQQQQQ@@QQQQQ$@&quot;, &quot;OQQQQQ@@@@QQQQ$@&quot;, &quot;OQQQQ@@QQ@@QQQ$@&quot;, &quot;OQQQ@@QQQQ@@QQ$@&quot;, &quot;OQQQQQQQQQQQQQ$@&quot;, &quot;OQQQQQQQQQQQQQ$@&quot;, &quot;O$$$$$$$$$$$$$$@&quot;, &quot;@@@@@@@@@@@@@@@@&quot; &#125;; int x, y; char c; boxfill8(buf, xsize, COL8_C6C6C6, 0, 0, xsize - 1, 0 ); boxfill8(buf, xsize, COL8_FFFFFF, 1, 1, xsize - 2, 1 ); boxfill8(buf, xsize, COL8_C6C6C6, 0, 0, 0, ysize - 1); boxfill8(buf, xsize, COL8_FFFFFF, 1, 1, 1, ysize - 2); boxfill8(buf, xsize, COL8_848484, xsize - 2, 1, xsize - 2, ysize - 2); boxfill8(buf, xsize, COL8_000000, xsize - 1, 0, xsize - 1, ysize - 1); boxfill8(buf, xsize, COL8_C6C6C6, 2, 2, xsize - 3, ysize - 3); boxfill8(buf, xsize, COL8_000084, 3, 3, xsize - 4, 20 ); boxfill8(buf, xsize, COL8_848484, 1, ysize - 2, xsize - 2, ysize - 2); boxfill8(buf, xsize, COL8_000000, 0, ysize - 1, xsize - 1, ysize - 1); putfonts8_asc(buf, xsize, 24, 4, COL8_FFFFFF, title); for (y = 0; y &lt; 14; y++) &#123; for (x = 0; x &lt; 16; x++) &#123; c = closebtn[y][x]; if (c == &#x27;@&#x27;) &#123; c = COL8_000000; &#125; else if (c == &#x27;$&#x27;) &#123; c = COL8_848484; &#125; else if (c == &#x27;Q&#x27;) &#123; c = COL8_C6C6C6; &#125; else &#123; c = COL8_FFFFFF; &#125; buf[(5 + y) * xsize + (xsize - 21 + x)] = c; &#125; &#125; return; &#125; 5.小实验HariMain中有设置图层高度的地方，如果像下面这样，把窗口图层放在最上面，光标图层放在其次，会变成什么样呢？sheet_updown(sht_back, 0); sheet_updown(sht_mouse, 1); sheet_updown(sht_win, 2); 鼠标会跑到窗口图层的下面。 6.高速计数器 我们要做一个能够计数，并且能够把计数结果显示出来的窗口。 但是在刷新的时候，总是先刷新refresh范围内的背景图层，然后再刷新窗口图层，导致数字闪烁。 7.消除闪烁（1） 窗口图层刷新是因为窗口的内容有变化，所以要在画面上显示变化后的新内容。基本上来讲，可以认为其他图层的内容没有变化（如果其他图层的内容也变了，那么应该会随后执行该图层的刷新）。既然如此，图层内容没有变化也进行刷新的话就太浪费了。如果只是窗口变了，那背景就不用刷新了。假如上面有鼠标，但鼠标的图层没有变化，我们也必须要刷新。窗口的刷新，可能会覆盖鼠标的一部分显示区域。 在sheet_slide函数里，图层的移动有时会导致下面的图层露出，所以要从最下面开始刷新。另一方面，在移动目标处，比新移来的图层位置还要低的图层没有什么变化，而且只是隐藏起来了，所以只要刷新移动的图层和它上面的图层就可以了。 但是修改代码后，鼠标放在数字区的时候，鼠标又开始闪烁。 8.消除闪烁（2） 闪烁现象是由于一会儿描绘一会儿消除造成的。所以说要想消除闪烁，就要在刷新窗口时避开鼠标所在的地方对VRAM进行写入处理。 方法：先开辟一块儿内存，大小和VRAM一样，这块内存用来表示画面上的点是哪个图层的像素，相当于图层的地图。 今后程序会对照map内容来向VRAM中写入，所以有时没必要从下面开始一直刷新到最上面一层。 在sheet_slide函数里，首先重写map，分别对应移动前后的图层，然后调用sheet_refreshsub函数。在移动前的地方，只针对上层图层移走之后而露出的下层图层进行重绘就可以了。在移动目的地处仅重绘了一张移动过去的图层。","categories":["操作系统"]},{"title":"30天自制操作系统（10）","path":"/201903/30天自制操作系统（10）/","content":"DAY10_叠加处理1.内存管理（续） memory.c中增加了“向上舍入”的部分，即我们要编写一些总是以0x1000字节为单位进行内存分配和释放的函数，它们会把指定的内存大小按0x1000字节为单位向上舍入（ roundup）。 从向下舍入开始要想把十六进制的某一位设置为0，同样只进行“与运算”就可以。 向上舍入：先向下舍入，再在它的结果上做个加法运算就可以了。（要先判断后几位是不是0） 更好的向上舍入的方法：i = (i + 0xfff) &amp; 0xfffff000; 2.叠加处理 寻找一种方法，不仅适用于鼠标的叠加，还适用于窗口的叠加。 在程序中创建管理多重图层信息的结构SHTCTL sheet_refresh函数：这个函数会从下到上描绘所有的图层。refresh是“刷新”的意思。电视屏幕就是在1秒内完成多帧的描绘才做出动画效果的，这个动作就被称为刷新。而这种对图层的刷新动作，与电视屏幕的动作有些相似，所以我们也给它起名字叫做刷新。 sheet_slide：不改变图层的高度而只上下左右移动图层的函数。 sheet_free释放已使用图层的内存的函数。 struct SHTCTL *shtctl_init(struct MEMMAN *memman, unsigned char *vram, int xsize, int ysize) &#123; struct SHTCTL *ctl; int i; ctl = (struct SHTCTL *) memman_alloc_4k(memman, sizeof (struct SHTCTL)); if (ctl == 0) &#123; goto err; &#125; ctl-&gt;vram = vram; ctl-&gt;xsize = xsize; ctl-&gt;ysize = ysize; ctl-&gt;top = -1; /*一个SHEET没都有 */ for (i = 0; i &lt; MAX_SHEETS; i++) &#123; ctl-&gt;sheets0[i].flags = 0; /* 标记为未使用 */ &#125; err: return ctl; &#125; 首先使用memman_alloc_4k来分配用于记忆图层控制变量的内存空间，这时必须指定该变量所占空间的大小，不过我们可以使用sizeof（struct SHTCTL）这种写法，让C编译器自动计算。只要写sizeof（变量型），C编译器就会计算出该变量型所需的字节数。接着，我们给控制变量赋值，给其下的所有图层变量都加上“未使用”标签。 3.提高叠加处理速度（1） 只需要重新描绘鼠标移动相关的部分，也就是移动前后的部分就可以了，即256×2=512个像素。这只是64 000像素的0.8%而已，所以有望提速很多。现在我们根据这个思路写一下程序。 要在画面上显示坐标等信息，结果又执行了sheet_refresh程序。所以我们要解决图层内文字显示的问题。 4.提高叠加处理速度（2） 使不写入像素内容，也要多次执行if语句。我们最初就应该把for语句的范围限定在刷新范围之内。void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1) &#123; int h, bx, by, vx, vy, bx0, by0, bx1, by1; unsigned char *buf, c, *vram = ctl-&gt;vram; struct SHEET *sht; for (h = 0; h &lt;= ctl-&gt;top; h++) &#123; sht = ctl-&gt;sheets[h]; buf = sht-&gt;buf; /* 使用vx0～vy1，对bx0～by1进行倒推 */ bx0 = vx0 - sht-&gt;vx0; by0 = vy0 - sht-&gt;vy0; bx1 = vx1 - sht-&gt;vx0; by1 = vy1 - sht-&gt;vy0; if (bx0 &lt; 0) &#123; bx0 = 0; &#125; /* 说明(1) */ if (by0 &lt; 0) &#123; by0 = 0; &#125; if (bx1 &gt; sht-&gt;bxsize) &#123; bx1 = sht-&gt;bxsize; &#125; /* 说明(2) */ if (by1 &gt; sht-&gt;bysize) &#123; by1 = sht-&gt;bysize; &#125; for (by = by0; by &lt; by1; by++) &#123; vy = sht-&gt;vy0 + by; for (bx = bx0; bx &lt; bx1; bx++) &#123; vx = sht-&gt;vx0 + bx; c = buf[by * sht-&gt;bxsize + bx]; if (c != sht-&gt;col_inv) &#123; vram[vy * ctl-&gt;xsize + vx] = c; &#125; &#125; &#125; &#125; return; &#125;","categories":["操作系统"]},{"title":"30天自制操作系统（9）","path":"/201903/30天自制操作系统（9）/","content":"DAY9_内存管理1.整理源文件 2.内存容量检查 在最初启动时，BIOS肯定要检查内存容量，所以只要我们问一问BIOS，就能知道内存容量有多大。但是会很麻烦，我们选择自己动手检查内存。 做法： 首先，暂时让486以后的CPU的高速缓存（cache）功能无效。原理：内存检查时，要往内存里随便写入一个值，然后马上读取，来检查读取的值与写入的值是否相等。如果内存连接正常，则写入的值能够记在内存里。如果没连接上，则读出的值肯定是乱七八糟的。如果CPU里加上了缓存，写入和读出的不是内存，而是缓存。结果，所有的内存都“正常”，检查处理不能完成。 通过HariMain识别3GB范围的内存 3.内存容量检查（2） 编译器对程序进行了优化，无法识别内存，于是我们选择用汇编来写。 4.挑战内存管理内存管理是什么，为什么要进行内存管理？操作系统在工作中，有时需要分配一定大小的内存，用完以后又不再需要，这种事会频繁发生。为了应付这些需求，必须恰当管理好哪些内存可以使用（哪些内存空闲），哪些内存不可以使用（正在使用），这就是内存管理。如果不进行管理，系统会变得一塌糊涂，要么知道哪里可用，要么多个应用程序使用同一地址的内存。 内存管理的方法 创建相应数量的区域，用1和0表示该区域是否被使用。但是这种方法的缺点就是，在内存区域很多的情况下，管理表很大。 列表管理的方法：从xxx号开始，yyy字节的空间是空着的。优点：占用内存小。大块内存的分配和释放都非常迅速。缺点：程序管理变复杂了；当可用空间零散的时候，空间管理信息可能会被用完。 我们的操作系统使用的方法是，当MEMMAN用完的时候，将小的内存区域舍弃，先不去管它。","tags":["内存管理"],"categories":["操作系统"]},{"path":"/friends/index.html","content":"文章留言关于我朋友们时间线随记英文主页虫洞 Friends思维DixeranNekoMioAl0ha0e黑七的自留地 来自github的朋友 如何通过Github提交友链Step1: 新建 GitHub Issue, 按照模板填写并提交. 您提交的头像尺寸为96px, 可以通过 iloveimg 调整图片大小. 可以通过 thum 生成你的博客快照. Step2: 将本站添加到您的友链中, 如果您也使用 issue 作为友链源，只需要告知您的友链源仓库即可.&#123; &quot;title&quot;: &quot;鳄鱼Crc2H0U&quot;, &quot;url&quot;: &quot;https://blog.crocodilezs.top&quot;, &quot;avatar&quot;: &quot;https://bu.dusays.com/2022/05/24/628bb5874996a.jpg&quot;, &quot;screenshot&quot;: &quot;https://image.thum.io/get/maxAge/12/width/700/https://blog.crocodilezs.top/about&quot;, &quot;description&quot;: &quot;野生鳄鱼的自留地&quot;, &quot;keywords&quot;: &quot;&quot;&#125; Step3: 等待审核通过添加 active 标签, 您就可以在我的友链页面看到自己. Tips: 如果您需要更新自己的友链, 请直接修改 issue 内容. 如果无法修改, 可以重新创建一个."},{"path":"/chat/index.html","content":""},{"path":"/about/index.html","content":"文章留言关于我朋友们时间线动态英文主页虫洞 关于我Hello! 我是鳄鱼, 1998年生.ISTJ喜欢真诚可靠的人喜欢语言和声音, 是一名ASMR佛系UP.欢迎交换友链 关于本站这里是 建站时间线. 欢迎订阅RSS.我从大二开始萌生了建立自己博客的想法, 那个时候觉得自己建站是一件相当酷的事情, 博客的每一个角落都可以自定义, 设计自己喜欢的配件和发布自己想说的内容让人很兴奋. 于是从Wordpress开始, 我创建了自己的第一个博客. 我是一个喜欢记录的人, 大三大四的时候把自己的学习笔记, 书摘, 健身记录和感悟随笔都发到博客中来. 在博客里堆了很多杂乱的内容. 大四毕业之后我发现之前博客记录的内容知识密度很低, 文章都是自己写下来都不会再阅读的内容, 自己对于记录下来的内容也没有进一步地整理和思考. 升学之后由于各种原因自己也很久没有更新博客了, 再次开始写东西的时候发现自己的表达能力退化了. 22年5月, 我更换了自己修改的花里胡哨的NexT主题, 重新用Stellar主题翻修了博客, 删去了之前质量较低的文章. 希望自己博客之后的每一篇文章都是思考和雕琢之后的产出. 同时利用博客写作来敦促自己不断地学习, 提升自己的写作能力. 过往经历2022 年 6 月 至今中科院自动化研究所模式识别国家重点实验室实习. 自然语言处理方向.2022 年 3 月 至 2022 年 5 月小米互联网业务部商业平台产品经理实习. 负责浏览器信息流场景广告业务.2021 年 6 月 至 2021 年 10 月国网区块链公司参与国网第六届青创赛项目, 基于区块链的劳务人员工薪管理系统.2021 年 6 月北京邮电大学本科毕业, 数据科学与大数据技术专业.2020 年 10 月 至 2021 年 1 月好未来教育集团K12 用户增长运营实习. 负责微信平台用户增长, 裂变及拉活. 联系方式你可以通过博客留言或邮件的方式与我联系. Mail: yyzhou98 [AT] 163 [DOT] com"},{"path":"/timeline/index.html","content":"文章留言关于我朋友们时间线动态英文主页虫洞 Timeline2022 年 9 月英文blog更换域名, 更换Stellar主题.2022 年 5 月更换主题Stellar, 感谢 @Xaoxuu大佬.更新关于页面, 增加时间线页面.2021 年 11 月新建英文blog, 用来存放之前做过的(CV里的)项目, Hexo + GitHub Pages.2020 年 11 月使用二级域名blog.crocodilezs.top.2019 年 8 月Hexo框架 + GitHub Pages, 域名 crocodilezs.top.使用NexT主题, 感谢 @Sanarous大佬的个性化定制教程. 小范围宣传博客, 换了几个友链.2019 年 4 月首次搭建博客, Wordpress + 某主机服务商老x主机, 域名 crocodilezs.com."}]